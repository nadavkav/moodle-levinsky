From 39127129135e26f9866ac0226f1c7de85b943f5b Mon Sep 17 00:00:00 2001
From: Nadav Kavalerchik <nadavkav@gmail.com>
Date: Wed, 11 Oct 2017 21:25:16 +0300
Subject: [PATCH 41/95] lib/editor/atto/plugins/wordimport (new)

---
 lib/editor/atto/plugins/wordimport/.travis.yml     |   48 +
 lib/editor/atto/plugins/wordimport/CHANGES.txt     |   25 +
 lib/editor/atto/plugins/wordimport/README.md       |    9 +
 lib/editor/atto/plugins/wordimport/db/install.php  |   88 +
 .../atto/plugins/wordimport/db/uninstall.php       |   62 +
 lib/editor/atto/plugins/wordimport/environment.xml |    7 +
 lib/editor/atto/plugins/wordimport/import.php      |   83 +
 .../plugins/wordimport/lang/en/atto_wordimport.php |   38 +
 lib/editor/atto/plugins/wordimport/lib.php         |  326 ++
 lib/editor/atto/plugins/wordimport/omml2mml.xsl    | 2093 +++++++++
 lib/editor/atto/plugins/wordimport/pix/icon.png    |  Bin 0 -> 678 bytes
 .../atto/plugins/wordimport/pix/wordimport.png     |  Bin 0 -> 1120 bytes
 lib/editor/atto/plugins/wordimport/settings.php    |   46 +
 lib/editor/atto/plugins/wordimport/version.php     |   31 +
 .../atto/plugins/wordimport/wordml2xhtmlpass1.xsl  | 4928 ++++++++++++++++++++
 .../atto/plugins/wordimport/wordml2xhtmlpass2.xsl  |  699 +++
 .../atto/plugins/wordimport/xslemulatexslt.inc     |   95 +
 .../moodle-atto_wordimport-button-debug.js         |  Bin 0 -> 14199 bytes
 .../moodle-atto_wordimport-button-min.js           |  Bin 0 -> 4035 bytes
 .../moodle-atto_wordimport-button.js               |  Bin 0 -> 12841 bytes
 .../plugins/wordimport/yui/src/button/build.json   |   10 +
 .../plugins/wordimport/yui/src/button/js/button.js |  322 ++
 .../wordimport/yui/src/button/meta/button.json     |    7 +
 23 files changed, 8917 insertions(+)
 create mode 100644 lib/editor/atto/plugins/wordimport/.travis.yml
 create mode 100644 lib/editor/atto/plugins/wordimport/CHANGES.txt
 create mode 100644 lib/editor/atto/plugins/wordimport/README.md
 create mode 100644 lib/editor/atto/plugins/wordimport/db/install.php
 create mode 100644 lib/editor/atto/plugins/wordimport/db/uninstall.php
 create mode 100644 lib/editor/atto/plugins/wordimport/environment.xml
 create mode 100644 lib/editor/atto/plugins/wordimport/import.php
 create mode 100644 lib/editor/atto/plugins/wordimport/lang/en/atto_wordimport.php
 create mode 100644 lib/editor/atto/plugins/wordimport/lib.php
 create mode 100644 lib/editor/atto/plugins/wordimport/omml2mml.xsl
 create mode 100644 lib/editor/atto/plugins/wordimport/pix/icon.png
 create mode 100644 lib/editor/atto/plugins/wordimport/pix/wordimport.png
 create mode 100644 lib/editor/atto/plugins/wordimport/settings.php
 create mode 100644 lib/editor/atto/plugins/wordimport/version.php
 create mode 100644 lib/editor/atto/plugins/wordimport/wordml2xhtmlpass1.xsl
 create mode 100644 lib/editor/atto/plugins/wordimport/wordml2xhtmlpass2.xsl
 create mode 100644 lib/editor/atto/plugins/wordimport/xslemulatexslt.inc
 create mode 100644 lib/editor/atto/plugins/wordimport/yui/build/moodle-atto_wordimport-button/moodle-atto_wordimport-button-debug.js
 create mode 100644 lib/editor/atto/plugins/wordimport/yui/build/moodle-atto_wordimport-button/moodle-atto_wordimport-button-min.js
 create mode 100644 lib/editor/atto/plugins/wordimport/yui/build/moodle-atto_wordimport-button/moodle-atto_wordimport-button.js
 create mode 100644 lib/editor/atto/plugins/wordimport/yui/src/button/build.json
 create mode 100644 lib/editor/atto/plugins/wordimport/yui/src/button/js/button.js
 create mode 100644 lib/editor/atto/plugins/wordimport/yui/src/button/meta/button.json

diff --git a/lib/editor/atto/plugins/wordimport/.travis.yml b/lib/editor/atto/plugins/wordimport/.travis.yml
new file mode 100644
index 0000000..4c40e7e
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/.travis.yml
@@ -0,0 +1,48 @@
+language: php
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.composer/cache
+
+php:
+ # - 5.4
+ # - 5.5
+ - 5.6
+ - 7.0
+
+matrix:
+ allow_failures:
+  - php: 7.0
+
+env:
+ matrix:
+  # - DB=pgsql MOODLE_BRANCH=MOODLE_27_STABLE
+  # - DB=pgsql MOODLE_BRANCH=MOODLE_28_STABLE
+  # - DB=pgsql MOODLE_BRANCH=MOODLE_29_STABLE
+  # - DB=pgsql MOODLE_BRANCH=MOODLE_30_STABLE
+  # - DB=mysqli MOODLE_BRANCH=MOODLE_27_STABLE
+  # - DB=mysqli MOODLE_BRANCH=MOODLE_28_STABLE
+  - DB=mysqli MOODLE_BRANCH=MOODLE_29_STABLE
+  # - DB=mysqli MOODLE_BRANCH=MOODLE_30_STABLE
+
+before_install:
+  - cd ../..
+  - composer selfupdate
+  - composer create-project -n --no-dev moodlerooms/moodle-plugin-ci ci ^1
+  - export PATH="$(cd ci/bin; pwd):$(cd ci/vendor/bin; pwd):$PATH"
+
+install:
+  - moodle-plugin-ci install
+
+script:
+  - moodle-plugin-ci phplint
+  - moodle-plugin-ci phpcpd
+  - moodle-plugin-ci phpmd
+  - moodle-plugin-ci codechecker
+  # - moodle-plugin-ci csslint
+  - moodle-plugin-ci shifter
+  - moodle-plugin-ci jshint
+  # - moodle-plugin-ci phpunit
+  # - moodle-plugin-ci behat
\ No newline at end of file
diff --git a/lib/editor/atto/plugins/wordimport/CHANGES.txt b/lib/editor/atto/plugins/wordimport/CHANGES.txt
new file mode 100644
index 0000000..938a149
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/CHANGES.txt
@@ -0,0 +1,25 @@
+Release notes
+-------------
+
+Date          Version   Comment
+2017/09/11    1.3.5     Disable Word Import button if the editor field does not support filearea
+2017/08/25    1.3.4     Don't raise the memory limit for XSLT any more
+2017/08/14    1.3.3     Handle list item duplication bug inside adjacent table cells
+2017/08/07    1.3.2     Handle Bootstrap Alert components
+2017/04/23    1.3.1     Use Bootstrap panel class for textboxes, use canonical tempdir reference
+2017/02/12    1.3.0     Handle textboxes (convert from Word tables) and quotations
+2017/01/05    1.2.1     Fix error when handling empty table cells
+2016/12/13    1.2.0     Improve formatting of tables and figures, support RTL languages better
+2016/01/20    1.1.2     Clean up spans to omit default text colour, remove underline from links.
+2015/12/08    1.1.1     Fix code to pass codechecker, use POST instead of GET to upload Word file
+2015/12/08    1.1.0     Fix error importing some files, clean code to pass codechecker, upgrade maturity to stable
+2015/10/15    1.0.0     Make uninstall process safer, mark first officially approved release on Moodle plugins directory
+2015/10/14    0.9.5     Use Moodle exception class to flag errors, parameterize heading style to element map
+2015/10/12    0.9.4     Correct context ID handling to work on all platforms, improve error handling
+2015/09/28    0.9.3     Implement drag and drop support
+2015/09/25    0.9.2     Insert content whereever the cursor is, not at the end of the text area
+2015/09/24    0.9.1     Automate installation process so that icon is added to files group in editor
+2015/09/24    0.9.0     Add support for importing equations
+2015/09/21    0.0.9     Fix security issues when deleting imported Word file, other code cleanup
+2015/09/17    0.0.8     Ensure image names are always unique when importing multiple times
+2015/09/16    0.0.7     Clean up code to comply with Moodle guidelines and implement reviewer comments, import images
diff --git a/lib/editor/atto/plugins/wordimport/README.md b/lib/editor/atto/plugins/wordimport/README.md
new file mode 100644
index 0000000..c9a5cd4
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/README.md
@@ -0,0 +1,9 @@
+#An Atto plugin to import Word file content cleanly
+
+##Description
+The contents of the Word file are converted into clean well-formed HTML and pasted
+into the box. 
+
+##Requirements
+* The Word files must be in .docx (Word 2007/2010) format.
+* The XSL PHP extension must be installed on the Moodle server to enable the Word file conversion.
diff --git a/lib/editor/atto/plugins/wordimport/db/install.php b/lib/editor/atto/plugins/wordimport/db/install.php
new file mode 100644
index 0000000..40f184a
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/db/install.php
@@ -0,0 +1,88 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Atto text editor import Microsoft Word files - installation.
+ *
+ * @package    atto_wordimport
+ * @copyright  2015 Eoin Campbell
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ * @license    see original copyright notice below
+ */
+
+//
+// Copyright (c) 2011, Maths for More S.L. http://www.wiris.com
+// This file is part of WIRIS Plugin.
+//
+// WIRIS Plugin is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// any later version.
+//
+// WIRIS Plugin is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with WIRIS Plugin. If not, see <http://www.gnu.org/licenses/>.
+//
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * Enable Wordimport plugin button in the files group on installation
+ *
+ * @return void
+ */
+function xmldb_atto_wordimport_install() {
+    $toolbar = get_config('editor_atto', 'toolbar');
+    $found = false;
+    if (strpos($toolbar, 'files')) {
+        $groups = explode("\n", $toolbar);
+        foreach ($groups as $i => $group) {
+            $parts = explode('=', $group);
+            if (trim($parts[0]) == 'files') {
+                $groups[$i] = 'files = wordimport, ' . trim($parts[1]);
+                $found = true;
+            }
+        }
+    } else if (strpos($toolbar, 'insert')) {
+        // Otherwise put it in the other group.
+        foreach ($groups as $i => $group) {
+            $parts = explode('=', $group);
+            if (trim($parts[0]) == 'insert') {
+                $groups[$i] = 'insert = wordimport, ' . trim($parts[1]);
+                $found = true;
+            }
+        }
+    } else if (strpos($toolbar, 'other')) {
+        // Otherwise put it in the other group.
+        foreach ($groups as $i => $group) {
+            $parts = explode('=', $group);
+            if (trim($parts[0]) == 'other') {
+                $groups[$i] = 'other = wordimport, ' . trim($parts[1]);
+                $found = true;
+            }
+        }
+    }
+
+    // Update config variable if we managed to insert the icon.
+    if ($found) {
+        $toolbar = implode("\n", $groups);
+        set_config('toolbar', $toolbar, 'editor_atto');
+    }
+}
\ No newline at end of file
diff --git a/lib/editor/atto/plugins/wordimport/db/uninstall.php b/lib/editor/atto/plugins/wordimport/db/uninstall.php
new file mode 100644
index 0000000..6ba9556
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/db/uninstall.php
@@ -0,0 +1,62 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Atto text editor import Microsoft Word files - uninstall.
+ *
+ * @package    atto_wordimport
+ * @copyright  2015 Eoin Campbell
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ * @license    see original copyright notice below
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+
+/**
+ * Remove Wordimport plugin button from the files group on uninstall
+ *
+ * @return void
+ */
+function xmldb_atto_wordimport_uninstall() {
+    // Remove 'wordimport' from the toolbar editor_atto config variable.
+    $toolbar = get_config('editor_atto', 'toolbar');
+    if (strpos($toolbar, 'wordimport') !== false) {
+        $newgroups = array();
+        $groups = explode("\n", $toolbar);
+        foreach ($groups as $group) {
+            if (strpos($group, 'wordimport') !== false) {
+                // Remove the 'wordimport' item from the group.
+                $parts = explode('=', $group);
+                $items = explode(',', $parts[1]);
+                $newitems = array();
+                foreach ($items as $item) {
+                    if (trim($item) != 'wordimport') {
+                        $newitems[] = $item;
+                    }
+                }
+                if (!empty($newitems)) {
+                    $parts[1] = implode(',', $newitems);
+                    $newgroups[] = implode('=', $parts);
+                }
+            } else {
+                $newgroups[] = $group;
+            }
+        }
+        $toolbar = implode("\n", $newgroups);
+        set_config('toolbar', $toolbar, 'editor_atto');
+    }
+}
\ No newline at end of file
diff --git a/lib/editor/atto/plugins/wordimport/environment.xml b/lib/editor/atto/plugins/wordimport/environment.xml
new file mode 100644
index 0000000..c6615dc
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/environment.xml
@@ -0,0 +1,7 @@
+ï»¿  <COMPATIBILITY_MATRIX>
+  <PLUGIN name="atto_wordimport">
+    <PHP_EXTENSIONS>
+      <PHP_EXTENSION name="xsl" level="required" />
+    </PHP_EXTENSIONS>
+  </PLUGIN>
+</COMPATIBILITY_MATRIX>
\ No newline at end of file
diff --git a/lib/editor/atto/plugins/wordimport/import.php b/lib/editor/atto/plugins/wordimport/import.php
new file mode 100644
index 0000000..0be75d5
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/import.php
@@ -0,0 +1,83 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Atto text editor import Microsoft Word file and convert to HTML
+ *
+ * @package   atto_wordimport
+ * @copyright 2015 Eoin Campbell
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+define('AJAX_SCRIPT', true);
+// Development: turn on all debug messages and strict warnings.
+// @codingStandardsIgnoreLine define('DEBUG_WORDIMPORT', E_ALL | E_STRICT);
+define('DEBUG_WORDIMPORT', 0);
+
+require(__DIR__ . '/../../../../../config.php');
+// Include XSLT processor functions.
+require_once(__DIR__ . "/xslemulatexslt.inc");
+require(__DIR__ . '/lib.php');
+
+$itemid = required_param('itemid', PARAM_INT);
+$contextid = required_param('ctx_id', PARAM_INT);
+$filename = required_param('filename', PARAM_TEXT);
+$sesskey = required_param('sesskey', PARAM_TEXT);
+
+list($context, $course, $cm) = get_context_info_array($contextid);
+
+// Check that this user is logged in before proceeding.
+require_login($course, false, $cm);
+require_sesskey();
+
+$PAGE->set_context($context);
+
+// Get the reference only of this users' uploaded file, to avoid rogue users' accessing other peoples files.
+$fs = get_file_storage();
+$usercontext = context_user::instance($USER->id);
+if (!$file = $fs->get_file($usercontext->id, 'user', 'draft', $itemid, '/', basename($filename))) {
+    // File is not readable.
+    throw new moodle_exception(get_string('errorreadingfile', 'error', basename($filename)));
+}
+
+// Save the uploaded file to a folder so we can process it using the PHP Zip library.
+if (!$tmpfilename = $file->copy_content_to_temp()) {
+    // Cannot save file.
+    throw new moodle_exception(get_string('errorcreatingfile', 'error', basename($filename)));
+} else {
+    // Delete it from the draft file area to avoid possible name-clash messages if it is re-uploaded in the same edit.
+    $file->delete();
+}
+
+// Convert the Word file into XHTML, store any images, and delete it once we're finished.
+$htmltext = atto_wordimport_convert_to_xhtml($tmpfilename, $usercontext->id, $itemid);
+atto_wordimport_debug_unlink($tmpfilename);
+
+if (!$htmltext) {
+    // Error processing upload file.
+    throw new moodle_exception(get_string('cannotuploadfile', 'error'));
+}
+
+// Get the body content only, ignoring any metadata in the head.
+$bodytext = atto_wordimport_get_html_body($htmltext);
+// Convert the string to JSON-encoded format.
+$htmltextjson = json_encode($bodytext);
+if ($htmltextjson) {
+    echo '{"html": ' . $htmltextjson . '}';
+} else {
+    // Invalid JSON string.
+    throw new moodle_exception(get_string('invalidjson', 'repository'));
+}
diff --git a/lib/editor/atto/plugins/wordimport/lang/en/atto_wordimport.php b/lib/editor/atto/plugins/wordimport/lang/en/atto_wordimport.php
new file mode 100644
index 0000000..0e3ad22
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/lang/en/atto_wordimport.php
@@ -0,0 +1,38 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Strings for component 'atto_wordimport', language 'en'.
+ *
+ * @package    atto_wordimport
+ * @copyright  2015 Eoin Campbell
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+$string['pluginname'] = 'Import Word file';
+$string['uploading'] = 'Uploading, please wait...';
+
+// Strings used in import.php.
+$string['transformationfailed'] = 'XSLT transformation failed (<b>{$a}</b>)';
+
+// Strings used in JavaScript.
+$string['fileuploadfailed'] = 'File upload failed';
+$string['fileconversionfailed'] = 'File conversion failed';
+
+// Strings used in settings.
+$string['settings'] = 'Word file import settings';
+$string['heading1stylelevel'] = 'Heading element level for Heading 1 style';
+$string['heading1stylelevel_desc'] = 'HTML heading element level to which the Word "Heading 1" style should be mapped';
diff --git a/lib/editor/atto/plugins/wordimport/lib.php b/lib/editor/atto/plugins/wordimport/lib.php
new file mode 100644
index 0000000..c33162d
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/lib.php
@@ -0,0 +1,326 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Atto text editor import Microsoft Word files.
+ *
+ * @package    atto_wordimport
+ * @copyright  2015 Eoin Campbell
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->libdir . '/filestorage/file_storage.php');
+require_once($CFG->dirroot . '/repository/lib.php');
+require_once("$CFG->libdir/xmlize.php");
+
+
+/**
+ * Initialise the strings required for js
+ *
+ * @return void
+ */
+function atto_wordimport_strings_for_js() {
+    global $PAGE;
+
+    $strings = array(
+        'uploading',
+        'transformationfailed',
+        'fileuploadfailed',
+        'fileconversionfailed',
+        'pluginname'
+    );
+
+    $PAGE->requires->strings_for_js($strings, 'atto_wordimport');
+}
+
+
+/**
+ * Sends the parameters to JS module.
+ *
+ * @param string $elementid - unused
+ * @param stdClass $options the options for the editor, including the context
+ * @param stdClass $fpoptions - unused
+ * @return array
+ */
+function atto_wordimport_params_for_js($elementid, $options, $fpoptions) {
+    global $CFG, $USER;
+    require_once($CFG->dirroot . '/repository/lib.php');  // Load constants.
+
+    // Disabled if:
+    // - Not logged in or guest.
+    // - Files are not allowed.
+    // - Only URL are supported.
+    $disabled = !isloggedin() || isguestuser() ||
+            (!isset($options['maxfiles']) || $options['maxfiles'] == 0) ||
+            (isset($options['return_types']) && !($options['return_types'] & ~FILE_EXTERNAL));
+
+    $params = array('disabled' => $disabled, 'area' => array(), 'usercontext' => null);
+
+    if (!$disabled) {
+        $params['usercontext'] = context_user::instance($USER->id)->id;
+        foreach (array('itemid', 'context', 'areamaxbytes', 'maxbytes', 'subdirs', 'return_types') as $key) {
+            if (isset($options[$key])) {
+                if ($key === 'context' && is_object($options[$key])) {
+                    // Just context id is enough.
+                    $params['area'][$key] = $options[$key]->id;
+                } else {
+                    $params['area'][$key] = $options[$key];
+                }
+            }
+        }
+    }
+
+    return $params;
+}
+
+
+/**
+ * Extract the WordProcessingML XML files from the .docx file, and use a sequence of XSLT
+ * steps to convert it into XHTML
+ *
+ * @param string $filename name of file uploaded to file repository as a draft
+ * @param int $usercontextid ID of draft file area where images should be stored
+ * @param int $draftitemid ID of particular group in draft file area where images should be stored
+ * @return string XHTML content extracted from Word file
+ */
+function atto_wordimport_convert_to_xhtml($filename, $usercontextid, $draftitemid) {
+    global $CFG, $USER;
+
+    $word2xmlstylesheet1 = __DIR__ . "/wordml2xhtmlpass1.xsl"; // Convert WordML into basic XHTML.
+    $word2xmlstylesheet2 = __DIR__ . "/wordml2xhtmlpass2.xsl"; // Refine basic XHTML into Word-compatible XHTML.
+
+    // @codingStandardsIgnoreLine debugging(__FUNCTION__ . ":" . __LINE__ . ": filename = \"{$filename}\"", DEBUG_WORDIMPORT);
+    // Check that we can unzip the Word .docx file into its component files.
+    $zipres = zip_open($filename);
+    if (!is_resource($zipres)) {
+        // Cannot unzip file.
+        atto_wordimport_debug_unlink($filename);
+        throw new moodle_exception('cannotunzipfile', 'error');
+    }
+
+    // Check that XSLT is installed.
+    if (!class_exists('XSLTProcessor') || !function_exists('xslt_create')) {
+        // PHP extension 'xsl' is required for this action.
+        throw new moodle_exception(get_string('extensionrequired', 'tool_xmldb', 'xsl'));
+    }
+
+    // Uncomment next line to give XSLT as much memory as possible, to enable larger Word files to be imported.
+    // @codingStandardsIgnoreLine raise_memory_limit(MEMORY_HUGE);
+
+    if (!file_exists($word2xmlstylesheet1)) {
+        // XSLT stylesheet to transform WordML into XHTML is missing.
+        throw new moodle_exception('filemissing', 'moodle', $word2xmlstylesheet1);
+    }
+
+    // Set common parameters for all XSLT transformations.
+    $parameters = array (
+        'moodle_language' => current_language(),
+        'moodle_textdirection' => (right_to_left()) ? 'rtl' : 'ltr',
+        'heading1stylelevel' => get_config('atto_wordimport', 'heading1stylelevel'),
+        'pluginname' => 'atto_wordimport', // Include plugin name to control image data handling inside XSLT.
+        'debug_flag' => DEBUG_WORDIMPORT
+    );
+
+    // Pre-XSLT preparation: merge the WordML and image content from the .docx Word file into one large XML file.
+    // Initialise an XML string to use as a wrapper around all the XML files.
+    $xmldeclaration = '<?xml version="1.0" encoding="UTF-8"?>';
+    $wordmldata = $xmldeclaration . "\n<pass1Container>\n";
+    $imagestring = "";
+
+    $fs = get_file_storage();
+    // Prepare filerecord array for creating each new image file.
+    $fileinfo = array(
+        'contextid' => $usercontextid,
+        'component' => 'user',
+        'filearea' => 'draft',
+        'userid' => $USER->id,
+        'itemid' => $draftitemid,
+        'filepath' => '/',
+        'filename' => ''
+        );
+
+    $zipentry = zip_read($zipres);
+    while ($zipentry) {
+        if (!zip_entry_open($zipres, $zipentry, "r")) {
+            // Can't read the XML file from the Word .docx file.
+            zip_close($zipres);
+            throw new moodle_exception('errorunzippingfiles', 'error');
+        }
+
+        $zefilename = zip_entry_name($zipentry);
+        $zefilesize = zip_entry_filesize($zipentry);
+
+        // Insert internal images into the files table.
+        if (strpos($zefilename, "media")) {
+            // @codingStandardsIgnoreLine $imageformat = substr($zefilename, strrpos($zefilename, ".") + 1);
+            $imagedata = zip_entry_read($zipentry, $zefilesize);
+            $imagename = basename($zefilename);
+            $imagesuffix = strtolower(substr(strrchr($zefilename, "."), 1));
+            // GIF, PNG, JPG and JPEG handled OK, but bmp and other non-Internet formats are not.
+            if ($imagesuffix == 'gif' or $imagesuffix == 'png' or $imagesuffix == 'jpg' or $imagesuffix == 'jpeg') {
+                // Prepare the file details for storage, ensuring the image name is unique.
+                $imagenameunique = $imagename;
+                $file = $fs->get_file($usercontextid, 'user', 'draft', $draftitemid, '/', $imagenameunique);
+                while ($file) {
+                    $imagenameunique = basename($imagename, '.' . $imagesuffix) . '_' . substr(uniqid(), 8, 4) .
+                        '.' . $imagesuffix;
+                    $file = $fs->get_file($usercontextid, 'user', 'draft', $draftitemid, '/', $imagenameunique);
+                }
+
+                $fileinfo['filename'] = $imagenameunique;
+                $fs->create_file_from_string($fileinfo, $imagedata);
+
+                $imageurl = "$CFG->wwwroot/draftfile.php/$usercontextid/user/draft/$draftitemid/$imagenameunique";
+                // Return all the details of where the file is stored, even though we don't need them at the moment.
+                $imagestring .= "<file filename=\"media/{$imagename}\"";
+                $imagestring .= " contextid=\"{$usercontextid}\" itemid=\"{$draftitemid}\"";
+                $imagestring .= " name=\"{$imagenameunique}\" url=\"{$imageurl}\">{$imageurl}</file>\n";
+            // @codingStandardsIgnoreLine } else {
+                // @codingStandardsIgnoreLine debugging(__FUNCTION__ . ":" . __LINE__ . ": ignore unsupported media file $zefilename" .
+                // @codingStandardsIgnoreLine     " = $imagename, imagesuffix = $imagesuffix", DEBUG_WORDIMPORT);
+            }
+        } else {
+            // Look for required XML files, read and wrap it, remove the XML declaration, and add it to the XML string.
+            // Read and wrap XML files, remove the XML declaration, and add them to the XML string.
+            $xmlfiledata = preg_replace('/<\?xml version="1.0" ([^>]*)>/', "", zip_entry_read($zipentry, $zefilesize));
+            switch ($zefilename) {
+                case "word/document.xml":
+                    $wordmldata .= "<wordmlContainer>" . $xmlfiledata . "</wordmlContainer>\n";
+                    break;
+                case "docProps/core.xml":
+                    $wordmldata .= "<dublinCore>" . $xmlfiledata . "</dublinCore>\n";
+                    break;
+                case "docProps/custom.xml":
+                    $wordmldata .= "<customProps>" . $xmlfiledata . "</customProps>\n";
+                    break;
+                case "word/styles.xml":
+                    $wordmldata .= "<styleMap>" . $xmlfiledata . "</styleMap>\n";
+                    break;
+                case "word/_rels/document.xml.rels":
+                    $wordmldata .= "<documentLinks>" . $xmlfiledata . "</documentLinks>\n";
+                    break;
+                case "word/footnotes.xml":
+                    $wordmldata .= "<footnotesContainer>" . $xmlfiledata . "</footnotesContainer>\n";
+                    break;
+                case "word/_rels/footnotes.xml.rels":
+                    $wordmldata .= "<footnoteLinks>" . $xmlfiledata . "</footnoteLinks>\n";
+                    break;
+                // @codingStandardsIgnoreLine case "word/_rels/settings.xml.rels":
+                    // @codingStandardsIgnoreLine $wordmldata .= "<settingsLinks>" . $xmlfiledata . "</settingsLinks>\n";
+                    // @codingStandardsIgnoreLine break;
+                default:
+                    // @codingStandardsIgnoreLine debugging(__FUNCTION__ . ":" . __LINE__ . ": Ignore $zefilename", DEBUG_WORDIMPORT);
+            }
+        }
+        // Get the next file in the Zip package.
+        $zipentry = zip_read($zipres);
+    }  // End while loop.
+    zip_close($zipres);
+
+    // Add images section.
+    $wordmldata .= "<imagesContainer>\n" . $imagestring . "</imagesContainer>\n";
+    // Close the merged XML file.
+    $wordmldata .= "</pass1Container>";
+
+    // Pass 1 - convert WordML into linear XHTML.
+    // Create a temporary file to store the merged WordML XML content to transform.
+    $tempwordmlfilename = $CFG->tempdir . '/' . basename($filename, ".tmp") . ".wml";
+    if ((file_put_contents($tempwordmlfilename, $wordmldata)) === 0) {
+        // Cannot save the file.
+        throw new moodle_exception('cannotsavefile', 'error', $tempwordmlfilename);
+    }
+
+    $xsltproc = xslt_create();
+    if (!($xsltoutput = xslt_process($xsltproc, $tempwordmlfilename, $word2xmlstylesheet1, null, null, $parameters))) {
+        // Transformation failed.
+        atto_wordimport_debug_unlink($tempwordmlfilename);
+        throw new moodle_exception('transformationfailed', 'atto_wordimport', $tempwordmlfilename);
+    }
+    atto_wordimport_debug_unlink($tempwordmlfilename);
+    // @codingStandardsIgnoreLine debugging(__FUNCTION__ . ":" . __LINE__ . ": Import XSLT Pass 1 succeeded, XHTML output fragment = " .
+    // @codingStandardsIgnoreLine     str_replace("\n", "", substr($xsltoutput, 0, 200)), DEBUG_WORDIMPORT);
+
+    // Write output of Pass 1 to a temporary file, for use in Pass 2.
+    $tempxhtmlfilename = $CFG->tempdir . '/' . basename($filename, ".tmp") . ".if1";
+    $xsltoutput = str_replace('<p xmlns="http://www.w3.org/1999/xhtml"', '<p', $xsltoutput);
+    $xsltoutput = str_replace('<span xmlns="http://www.w3.org/1999/xhtml"', '<span', $xsltoutput);
+    $xsltoutput = str_replace(' xmlns=""', '', $xsltoutput);
+    if ((file_put_contents($tempxhtmlfilename, $xsltoutput )) === 0) {
+        // Cannot save the file.
+        throw new moodle_exception('cannotsavefile', 'error', $tempxhtmlfilename);
+    }
+
+    // Pass 2 - tidy up linear XHTML a bit.
+    if (!($xsltoutput = xslt_process($xsltproc, $tempxhtmlfilename, $word2xmlstylesheet2, null, null, $parameters))) {
+        // Transformation failed.
+        atto_wordimport_debug_unlink($tempxhtmlfilename);
+        throw new moodle_exception('transformationfailed', 'atto_wordimport', $tempxhtmlfilename);
+    }
+    atto_wordimport_debug_unlink($tempxhtmlfilename);
+
+    // Strip out superfluous namespace declarations on paragraph elements, which Moodle 2.7+ on Windows seems to throw in.
+    $xsltoutput = str_replace('<p xmlns="http://www.w3.org/1999/xhtml"', '<p', $xsltoutput);
+    $xsltoutput = str_replace('<span xmlns="http://www.w3.org/1999/xhtml"', '<span', $xsltoutput);
+    $xsltoutput = str_replace(' xmlns=""', '', $xsltoutput);
+    // Remove 'mml:' prefix from child MathML element and attributes for compatibility with MathJax.
+    $xsltoutput = str_replace('<mml:', '<', $xsltoutput);
+    $xsltoutput = str_replace('</mml:', '</', $xsltoutput);
+    $xsltoutput = str_replace(' mathvariant="normal"', '', $xsltoutput);
+    $xsltoutput = str_replace(' xmlns:mml="http://www.w3.org/1998/Math/MathML"', '', $xsltoutput);
+    $xsltoutput = str_replace('<math>', '<math xmlns="http://www.w3.org/1998/Math/MathML">', $xsltoutput);
+
+    // @codingStandardsIgnoreLine debugging(__FUNCTION__ . ":" . __LINE__ . ": Import XSLT Pass 2 succeeded, output = " .
+    // @codingStandardsIgnoreLine     str_replace("\n", "", substr($xsltoutput, 500, 2000)), DEBUG_WORDIMPORT);
+
+    // Keep the converted XHTML file for debugging if developer debugging enabled.
+    if (DEBUG_WORDIMPORT == DEBUG_DEVELOPER and debugging(null, DEBUG_DEVELOPER)) {
+        $tempxhtmlfilename = $CFG->tempdir . '/' . basename($filename, ".tmp") . ".xhtml";
+        file_put_contents($tempxhtmlfilename, $xsltoutput);
+    }
+
+    return $xsltoutput;
+}   // End function atto_wordimport_convert_to_xhtml.
+
+
+/**
+ * Get the HTML body from the converted Word file
+ *
+ * @param string $xhtmlstring complete XHTML text including head element metadata
+ * @return string XHTML text inside <body> element
+ */
+function atto_wordimport_get_html_body($xhtmlstring) {
+    $matches = null;
+    if (preg_match('/<body[^>]*>(.+)<\/body>/is', $xhtmlstring, $matches)) {
+        return $matches[1];
+    } else {
+        return $xhtmlstring;
+    }
+}
+
+/**
+ * Delete temporary files if debugging disabled
+ *
+ * @param string $filename name of file to be deleted
+ * @return void
+ */
+function atto_wordimport_debug_unlink($filename) {
+    if (DEBUG_WORDIMPORT == 0) {
+        unlink($filename);
+    }
+}
+
diff --git a/lib/editor/atto/plugins/wordimport/omml2mml.xsl b/lib/editor/atto/plugins/wordimport/omml2mml.xsl
new file mode 100644
index 0000000..4dc34b4
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/omml2mml.xsl
@@ -0,0 +1,2093 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<xsl:stylesheet
+    xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
+    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
+    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
+    xmlns:o="urn:schemas-microsoft-com:office:office"
+    xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
+    xmlns:rels="http://schemas.openxmlformats.org/package/2006/relationships"
+    xmlns:v="urn:schemas-microsoft-com:vml"
+    xmlns:ve="http://schemas.openxmlformats.org/markup-compatibility/2006"
+    xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
+    xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml"
+    xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
+    xmlns:wx="http://schemas.microsoft.com/office/word/2003/auxHint"
+    xmlns:w10="urn:schemas-microsoft-com:office:word"
+    xmlns:xs="http://www.w3.org/2001/XMLSchema"
+
+    xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
+    xmlns:customProps="http://schemas.openxmlformats.org/officeDocument/2006/custom-properties"
+    xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
+    xmlns:dc="http://purl.org/dc/elements/1.1/"
+    xmlns:dcterms="http://purl.org/dc/terms/"
+    xmlns:dcmitype="http://purl.org/dc/dcmitype/"
+    xmlns:mml="http://www.w3.org/1998/Math/MathML"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+    exclude-result-prefixes="a cp dc dcterms dcmitype xsi o r v ve w wne wp wx w10 xs rels vt customProps"
+    version="1.0">
+    
+
+  <!-- %% Global Definitions -->
+
+  <!-- Every single unicode character that is recognized by OMML as an operator -->
+  <xsl:variable name="sOperators"
+		select="concat(
+          '&#x00A8;&#x0021;&#x0022;&#x0023;&#x0026;&#x0028;&#x0029;&#x002B;&#x002C;&#x002D;&#x002E;&#x002F;&#x003A;',
+          '&#x003B;&#x003C;&#x003D;&#x003E;&#x003F;&#x0040;&#x005B;&#x005C;&#x005D;&#x005E;&#x005F;&#x0060;&#x007B;',
+          '&#x007C;&#x007D;&#x007E;&#x00A1;&#x00A6;&#x00AC;&#x00AF;&#x00B0;&#x00B1;&#x00B2;&#x00B3;&#x00B4;&#x00B7;&#x00B9;&#x00BF;',
+          '&#x00D7;&#x007E;&#x00F7;&#x02C7;&#x02D8;&#x02D9;&#x02DC;&#x02DD;&#x0300;&#x0301;&#x0302;&#x0303;&#x0304;&#x0305;&#x0306;&#x0307;&#x0308;&#x0309;',
+          '&#x030A;&#x030B;&#x030C;&#x030D;&#x030E;&#x030F;&#x0310;&#x0311;&#x0312;&#x0313;&#x0314;&#x0315;',
+          '&#x0316;&#x0317;&#x0318;&#x0319;&#x031A;&#x031B;&#x031C;&#x031D;&#x031E;&#x031F;&#x0320;&#x0321;',
+          '&#x0322;&#x0323;&#x0324;&#x0325;&#x0326;&#x0327;&#x0328;&#x0329;&#x032A;&#x032B;&#x032C;&#x032D;',
+          '&#x032E;&#x032F;&#x0330;&#x0331;&#x0332;&#x0333;&#x0334;&#x0335;&#x0336;&#x0337;&#x0338;&#x033F;',
+          '&#x2000;&#x2001;&#x2002;&#x2003;&#x2004;&#x2005;&#x2006;&#x2009;&#x200A;&#x2010;&#x2012;&#x2013;',
+          '&#x2014;&#x2016;&#x2020;&#x2021;&#x2022;&#x2024;&#x2025;&#x2026;&#x2032;&#x2033;&#x2034;&#x203C;',
+          '&#x2040;&#x2044;&#x204E;&#x204F;&#x2050;&#x2057;&#x2061;&#x2062;&#x2063;&#x2070;&#x2074;&#x2075;',
+          '&#x2076;&#x2077;&#x2078;&#x2079;&#x207A;&#x207B;&#x207C;&#x207D;&#x207E;&#x2080;&#x2081;&#x2082;',
+          '&#x2083;&#x2084;&#x2085;&#x2086;&#x2087;&#x2088;&#x2089;&#x208A;&#x208B;&#x208C;&#x208D;&#x208E;',
+          '&#x20D0;&#x20D1;&#x20D2;&#x20D3;&#x20D4;&#x20D5;&#x20D6;&#x20D7;&#x20D8;&#x20D9;&#x20DA;&#x20DB;',
+          '&#x20DC;&#x20DD;&#x20DE;&#x20DF;&#x20E0;&#x20E1;&#x20E4;&#x20E5;&#x20E6;&#x20E7;&#x20E8;&#x20E9;',
+          '&#x20EA;&#x2140;&#x2146;&#x2190;&#x2191;&#x2192;&#x2193;&#x2194;&#x2195;&#x2196;&#x2197;&#x2198;&#x2199;',
+          '&#x219A;&#x219B;&#x219C;&#x219D;&#x219E;&#x219F;&#x21A0;&#x21A1;&#x21A2;&#x21A3;&#x21A4;&#x21A5;',
+          '&#x21A6;&#x21A7;&#x21A8;&#x21A9;&#x21AA;&#x21AB;&#x21AC;&#x21AD;&#x21AE;&#x21AF;&#x21B0;&#x21B1;',
+          '&#x21B2;&#x21B3;&#x21B6;&#x21B7;&#x21BA;&#x21BB;&#x21BC;&#x21BD;&#x21BE;&#x21BF;&#x21C0;&#x21C1;',
+          '&#x21C2;&#x21C3;&#x21C4;&#x21C5;&#x21C6;&#x21C7;&#x21C8;&#x21C9;&#x21CA;&#x21CB;&#x21CC;&#x21CD;',
+          '&#x21CE;&#x21CF;&#x21D0;&#x21D1;&#x21D2;&#x21D3;&#x21D4;&#x21D5;&#x21D6;&#x21D7;&#x21D8;&#x21D9;',
+          '&#x21DA;&#x21DB;&#x21DC;&#x21DD;&#x21DE;&#x21DF;&#x21E0;&#x21E1;&#x21E2;&#x21E3;&#x21E4;&#x21E5;',
+          '&#x21E6;&#x21E7;&#x21E8;&#x21E9;&#x21F3;&#x21F4;&#x21F5;&#x21F6;&#x21F7;&#x21F8;&#x21F9;&#x21FA;',
+          '&#x21FB;&#x21FC;&#x21FD;&#x21FE;&#x21FF;&#x2200;&#x2201;&#x2202;&#x2203;&#x2204;&#x2206;&#x2207;',
+          '&#x2208;&#x2209;&#x220A;&#x220B;&#x220C;&#x220D;&#x220F;&#x2210;&#x2211;&#x2212;&#x2213;&#x2214;',
+          '&#x2215;&#x2216;&#x2217;&#x2218;&#x2219;&#x221A;&#x221B;&#x221C;&#x221D;&#x2223;&#x2224;&#x2225;',
+          '&#x2226;&#x2227;&#x2228;&#x2229;&#x222A;&#x222B;&#x222C;&#x222D;&#x222E;&#x222F;&#x2230;&#x2231;',
+          '&#x2232;&#x2233;&#x2234;&#x2235;&#x2236;&#x2237;&#x2238;&#x2239;&#x223A;&#x223B;&#x223C;&#x223D;',
+          '&#x223E;&#x2240;&#x2241;&#x2242;&#x2243;&#x2244;&#x2245;&#x2246;&#x2247;&#x2248;&#x2249;&#x224A;',
+          '&#x224B;&#x224C;&#x224D;&#x224E;&#x224F;&#x2250;&#x2251;&#x2252;&#x2253;&#x2254;&#x2255;&#x2256;',
+          '&#x2257;&#x2258;&#x2259;&#x225A;&#x225B;&#x225C;&#x225D;&#x225E;&#x225F;&#x2260;&#x2261;&#x2262;',
+          '&#x2263;&#x2264;&#x2265;&#x2266;&#x2267;&#x2268;&#x2269;&#x226A;&#x226B;&#x226C;&#x226D;&#x226E;',
+          '&#x226F;&#x2270;&#x2271;&#x2272;&#x2273;&#x2274;&#x2275;&#x2276;&#x2277;&#x2278;&#x2279;&#x227A;',
+          '&#x227B;&#x227C;&#x227D;&#x227E;&#x227F;&#x2280;&#x2281;&#x2282;&#x2283;&#x2284;&#x2285;&#x2286;',
+          '&#x2287;&#x2288;&#x2289;&#x228A;&#x228B;&#x228C;&#x228D;&#x228E;&#x228F;&#x2290;&#x2291;&#x2292;',
+          '&#x2293;&#x2294;&#x2295;&#x2296;&#x2297;&#x2298;&#x2299;&#x229A;&#x229B;&#x229C;&#x229D;&#x229E;',
+          '&#x229F;&#x22A0;&#x22A1;&#x22A2;&#x22A3;&#x22A5;&#x22A6;&#x22A7;&#x22A8;&#x22A9;&#x22AA;&#x22AB;',
+          '&#x22AC;&#x22AD;&#x22AE;&#x22AF;&#x22B0;&#x22B1;&#x22B2;&#x22B3;&#x22B4;&#x22B5;&#x22B6;&#x22B7;',
+          '&#x22B8;&#x22B9;&#x22BA;&#x22BB;&#x22BC;&#x22BD;&#x22C0;&#x22C1;&#x22C2;&#x22C3;&#x22C4;&#x22C5;',
+          '&#x22C6;&#x22C7;&#x22C8;&#x22C9;&#x22CA;&#x22CB;&#x22CC;&#x22CD;&#x22CE;&#x22CF;&#x22D0;&#x22D1;',
+          '&#x22D2;&#x22D3;&#x22D4;&#x22D5;&#x22D6;&#x22D7;&#x22D8;&#x22D9;&#x22DA;&#x22DB;&#x22DC;&#x22DD;',
+          '&#x22DE;&#x22DF;&#x22E0;&#x22E1;&#x22E2;&#x22E3;&#x22E4;&#x22E5;&#x22E6;&#x22E7;&#x22E8;&#x22E9;',
+          '&#x22EA;&#x22EB;&#x22EC;&#x22ED;&#x22EE;&#x22EF;&#x22F0;&#x22F1;&#x22F2;&#x22F3;&#x22F4;&#x22F5;',
+          '&#x22F6;&#x22F7;&#x22F8;&#x22F9;&#x22FA;&#x22FB;&#x22FC;&#x22FD;&#x22FE;&#x22FF;&#x2305;&#x2306;',
+          '&#x2308;&#x2309;&#x230A;&#x230B;&#x231C;&#x231D;&#x231E;&#x231F;&#x2322;&#x2323;&#x2329;&#x232A;',
+          '&#x233D;&#x233F;&#x23B0;&#x23B1;&#x23DC;&#x23DD;&#x23DE;&#x23DF;&#x23E0;&#x2502;&#x251C;&#x2524;',
+          '&#x252C;&#x2534;&#x2581;&#x2588;&#x2592;&#x25A0;&#x25A1;&#x25AD;&#x25B2;&#x25B3;&#x25B4;&#x25B5;',
+          '&#x25B6;&#x25B7;&#x25B8;&#x25B9;&#x25BC;&#x25BD;&#x25BE;&#x25BF;&#x25C0;&#x25C1;&#x25C2;&#x25C3;',
+          '&#x25C4;&#x25C5;&#x25CA;&#x25CB;&#x25E6;&#x25EB;&#x25EC;&#x25F8;&#x25F9;&#x25FA;&#x25FB;&#x25FC;',
+          '&#x25FD;&#x25FE;&#x25FF;&#x2605;&#x2606;&#x2772;&#x2773;&#x27D1;&#x27D2;&#x27D3;&#x27D4;&#x27D5;',
+          '&#x27D6;&#x27D7;&#x27D8;&#x27D9;&#x27DA;&#x27DB;&#x27DC;&#x27DD;&#x27DE;&#x27DF;&#x27E0;&#x27E1;',
+          '&#x27E2;&#x27E3;&#x27E4;&#x27E5;&#x27E6;&#x27E7;&#x27E8;&#x27E9;&#x27EA;&#x27EB;&#x27F0;&#x27F1;',
+          '&#x27F2;&#x27F3;&#x27F4;&#x27F5;&#x27F6;&#x27F7;&#x27F8;&#x27F9;&#x27FA;&#x27FB;&#x27FC;&#x27FD;',
+          '&#x27FE;&#x27FF;&#x2900;&#x2901;&#x2902;&#x2903;&#x2904;&#x2905;&#x2906;&#x2907;&#x2908;&#x2909;',
+          '&#x290A;&#x290B;&#x290C;&#x290D;&#x290E;&#x290F;&#x2910;&#x2911;&#x2912;&#x2913;&#x2914;&#x2915;',
+          '&#x2916;&#x2917;&#x2918;&#x2919;&#x291A;&#x291B;&#x291C;&#x291D;&#x291E;&#x291F;&#x2920;&#x2921;',
+          '&#x2922;&#x2923;&#x2924;&#x2925;&#x2926;&#x2927;&#x2928;&#x2929;&#x292A;&#x292B;&#x292C;&#x292D;',
+          '&#x292E;&#x292F;&#x2930;&#x2931;&#x2932;&#x2933;&#x2934;&#x2935;&#x2936;&#x2937;&#x2938;&#x2939;',
+          '&#x293A;&#x293B;&#x293C;&#x293D;&#x293E;&#x293F;&#x2940;&#x2941;&#x2942;&#x2943;&#x2944;&#x2945;',
+          '&#x2946;&#x2947;&#x2948;&#x2949;&#x294A;&#x294B;&#x294C;&#x294D;&#x294E;&#x294F;&#x2950;&#x2951;',
+          '&#x2952;&#x2953;&#x2954;&#x2955;&#x2956;&#x2957;&#x2958;&#x2959;&#x295A;&#x295B;&#x295C;&#x295D;',
+          '&#x295E;&#x295F;&#x2960;&#x2961;&#x2962;&#x2963;&#x2964;&#x2965;&#x2966;&#x2967;&#x2968;&#x2969;',
+          '&#x296A;&#x296B;&#x296C;&#x296D;&#x296E;&#x296F;&#x2970;&#x2971;&#x2972;&#x2973;&#x2974;&#x2975;',
+          '&#x2976;&#x2977;&#x2978;&#x2979;&#x297A;&#x297B;&#x297C;&#x297D;&#x297E;&#x297F;&#x2980;&#x2982;',
+          '&#x2983;&#x2984;&#x2985;&#x2986;&#x2987;&#x2988;&#x2989;&#x298A;&#x298B;&#x298C;&#x298D;&#x298E;',
+          '&#x298F;&#x2990;&#x2991;&#x2992;&#x2993;&#x2994;&#x2995;&#x2996;&#x2997;&#x2998;&#x2999;&#x299A;',
+          '&#x29B6;&#x29B7;&#x29B8;&#x29B9;&#x29C0;&#x29C1;&#x29C4;&#x29C5;&#x29C6;&#x29C7;&#x29C8;&#x29CE;',
+          '&#x29CF;&#x29D0;&#x29D1;&#x29D2;&#x29D3;&#x29D4;&#x29D5;&#x29D6;&#x29D7;&#x29D8;&#x29D9;&#x29DA;',
+          '&#x29DB;&#x29DF;&#x29E1;&#x29E2;&#x29E3;&#x29E4;&#x29E5;&#x29E6;&#x29EB;&#x29F4;&#x29F5;&#x29F6;',
+          '&#x29F7;&#x29F8;&#x29F9;&#x29FA;&#x29FB;&#x29FC;&#x29FD;&#x29FE;&#x29FF;&#x2A00;&#x2A01;&#x2A02;',
+          '&#x2A03;&#x2A04;&#x2A05;&#x2A06;&#x2A07;&#x2A08;&#x2A09;&#x2A0A;&#x2A0B;&#x2A0C;&#x2A0D;&#x2A0E;',
+          '&#x2A0F;&#x2A10;&#x2A11;&#x2A12;&#x2A13;&#x2A14;&#x2A15;&#x2A16;&#x2A17;&#x2A18;&#x2A19;&#x2A1A;',
+          '&#x2A1B;&#x2A1C;&#x2A1D;&#x2A1E;&#x2A1F;&#x2A20;&#x2A21;&#x2A22;&#x2A23;&#x2A24;&#x2A25;&#x2A26;',
+          '&#x2A27;&#x2A28;&#x2A29;&#x2A2A;&#x2A2B;&#x2A2C;&#x2A2D;&#x2A2E;&#x2A2F;&#x2A30;&#x2A31;&#x2A32;',
+          '&#x2A33;&#x2A34;&#x2A35;&#x2A36;&#x2A37;&#x2A38;&#x2A39;&#x2A3A;&#x2A3B;&#x2A3C;&#x2A3D;&#x2A3E;',
+          '&#x2A3F;&#x2A40;&#x2A41;&#x2A42;&#x2A43;&#x2A44;&#x2A45;&#x2A46;&#x2A47;&#x2A48;&#x2A49;&#x2A4A;',
+          '&#x2A4B;&#x2A4C;&#x2A4D;&#x2A4E;&#x2A4F;&#x2A50;&#x2A51;&#x2A52;&#x2A53;&#x2A54;&#x2A55;&#x2A56;',
+          '&#x2A57;&#x2A58;&#x2A59;&#x2A5A;&#x2A5B;&#x2A5C;&#x2A5D;&#x2A5E;&#x2A5F;&#x2A60;&#x2A61;&#x2A62;',
+          '&#x2A63;&#x2A64;&#x2A65;&#x2A66;&#x2A67;&#x2A68;&#x2A69;&#x2A6A;&#x2A6B;&#x2A6C;&#x2A6D;&#x2A6E;',
+          '&#x2A6F;&#x2A70;&#x2A71;&#x2A72;&#x2A73;&#x2A74;&#x2A75;&#x2A76;&#x2A77;&#x2A78;&#x2A79;&#x2A7A;',
+          '&#x2A7B;&#x2A7C;&#x2A7D;&#x2A7E;&#x2A7F;&#x2A80;&#x2A81;&#x2A82;&#x2A83;&#x2A84;&#x2A85;&#x2A86;',
+          '&#x2A87;&#x2A88;&#x2A89;&#x2A8A;&#x2A8B;&#x2A8C;&#x2A8D;&#x2A8E;&#x2A8F;&#x2A90;&#x2A91;&#x2A92;',
+          '&#x2A93;&#x2A94;&#x2A95;&#x2A96;&#x2A97;&#x2A98;&#x2A99;&#x2A9A;&#x2A9B;&#x2A9C;&#x2A9D;&#x2A9E;',
+          '&#x2A9F;&#x2AA0;&#x2AA1;&#x2AA2;&#x2AA3;&#x2AA4;&#x2AA5;&#x2AA6;&#x2AA7;&#x2AA8;&#x2AA9;&#x2AAA;',
+          '&#x2AAB;&#x2AAC;&#x2AAD;&#x2AAE;&#x2AAF;&#x2AB0;&#x2AB1;&#x2AB2;&#x2AB3;&#x2AB4;&#x2AB5;&#x2AB6;',
+          '&#x2AB7;&#x2AB8;&#x2AB9;&#x2ABA;&#x2ABB;&#x2ABC;&#x2ABD;&#x2ABE;&#x2ABF;&#x2AC0;&#x2AC1;&#x2AC2;',
+          '&#x2AC3;&#x2AC4;&#x2AC5;&#x2AC6;&#x2AC7;&#x2AC8;&#x2AC9;&#x2ACA;&#x2ACB;&#x2ACC;&#x2ACD;&#x2ACE;',
+          '&#x2ACF;&#x2AD0;&#x2AD1;&#x2AD2;&#x2AD3;&#x2AD4;&#x2AD5;&#x2AD6;&#x2AD7;&#x2AD8;&#x2AD9;&#x2ADA;',
+          '&#x2ADB;&#x2ADC;&#x2ADD;&#x2ADE;&#x2ADF;&#x2AE0;&#x2AE2;&#x2AE3;&#x2AE4;&#x2AE5;&#x2AE6;&#x2AE7;',
+          '&#x2AE8;&#x2AE9;&#x2AEA;&#x2AEB;&#x2AEC;&#x2AED;&#x2AEE;&#x2AEF;&#x2AF0;&#x2AF2;&#x2AF3;&#x2AF4;',
+          '&#x2AF5;&#x2AF6;&#x2AF7;&#x2AF8;&#x2AF9;&#x2AFA;&#x2AFB;&#x2AFC;&#x2AFD;&#x2AFE;&#x2AFF;&#x2B04;',
+          '&#x2B06;&#x2B07;&#x2B0C;&#x2B0D;&#x3014;&#x3015;&#x3016;&#x3017;&#x3018;&#x3019;&#xFF01;&#xFF06;',
+          '&#xFF08;&#xFF09;&#xFF0B;&#xFF0C;&#xFF0D;&#xFF0E;&#xFF0F;&#xFF1A;&#xFF1B;&#xFF1C;&#xFF1D;&#xFF1E;',
+          '&#xFF1F;&#xFF20;&#xFF3B;&#xFF3C;&#xFF3D;&#xFF3E;&#xFF3F;&#xFF5B;&#xFF5C;&#xFF5D;')" />
+
+  <!-- A string of '-'s repeated exactly as many times as the operators above -->
+  <xsl:variable name="sMinuses">
+    <xsl:call-template name="SRepeatChar">
+      <xsl:with-param name="cchRequired" select="string-length($sOperators)" />
+      <xsl:with-param name="ch" select="'-'" />
+    </xsl:call-template>
+  </xsl:variable>
+
+  <!-- Every single unicode character that is recognized by OMML as a number -->
+  <xsl:variable name="sNumbers" select="'0123456789'" />
+
+  <!-- A string of '0's repeated exactly as many times as the list of numbers above -->
+  <xsl:variable name="sZeros">
+    <xsl:call-template name="SRepeatChar">
+      <xsl:with-param name="cchRequired" select="string-length($sNumbers)" />
+      <xsl:with-param name="ch" select="'0'" />
+    </xsl:call-template>
+  </xsl:variable>
+
+  <!-- %%Template: SReplace
+
+		Replace all occurences of sOrig in sInput with sReplacement
+		and return the resulting string. -->
+  <xsl:template name="SReplace">
+    <xsl:param name="sInput" />
+    <xsl:param name="sOrig" />
+    <xsl:param name="sReplacement" />
+
+    <xsl:choose>
+      <xsl:when test="not(contains($sInput, $sOrig))">
+        <xsl:value-of select="$sInput" />
+      </xsl:when>
+      <xsl:otherwise>
+        <xsl:variable name="sBefore" select="substring-before($sInput, $sOrig)" />
+        <xsl:variable name="sAfter" select="substring-after($sInput, $sOrig)" />
+        <xsl:variable name="sAfterProcessed">
+          <xsl:call-template name="SReplace">
+            <xsl:with-param name="sInput" select="$sAfter" />
+            <xsl:with-param name="sOrig" select="$sOrig" />
+            <xsl:with-param name="sReplacement" select="$sReplacement" />
+          </xsl:call-template>
+        </xsl:variable>
+
+        <xsl:value-of select="concat($sBefore, concat($sReplacement, $sAfterProcessed))" />
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <!-- Templates -->
+  <xsl:template match="/">
+    <mml:math>
+      <xsl:apply-templates select="*" />
+    </mml:math>
+  </xsl:template>
+
+  <xsl:template match="m:borderBox">
+
+    <!-- Get Lowercase versions of properties -->
+    <xsl:variable name="sLowerCaseHideTop" select="translate(m:borderBoxPr[last()]/m:hideTop[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                             'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="sLowerCaseHideBot" select="translate(m:borderBoxPr[last()]/m:hideBot[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                             'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="sLowerCaseHideLeft" select="translate(m:borderBoxPr[last()]/m:hideLeft[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                             'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="sLowerCaseHideRight" select="translate(m:borderBoxPr[last()]/m:hideRight[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                             'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="sLowerCaseStrikeH" select="translate(m:borderBoxPr[last()]/m:strikeH[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                             'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="sLowerCaseStrikeV" select="translate(m:borderBoxPr[last()]/m:strikeV[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                             'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="sLowerCaseStrikeBLTR" select="translate(m:borderBoxPr[last()]/m:strikeBLTR[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                             'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="sLowerCaseStrikeTLBR" select="translate(m:borderBoxPr[last()]/m:strikeTLBR[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                             'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="fHideTop">
+      <xsl:call-template name="ForceTrueStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseHideTop" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:variable name="fHideBot">
+      <xsl:call-template name="ForceTrueStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseHideBot" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:variable name="fHideLeft">
+      <xsl:call-template name="ForceTrueStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseHideLeft" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:variable name="fHideRight">
+      <xsl:call-template name="ForceTrueStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseHideRight" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:variable name="fStrikeH">
+      <xsl:call-template name="ForceTrueStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseStrikeH" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:variable name="fStrikeV">
+      <xsl:call-template name="ForceTrueStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseStrikeV" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:variable name="fStrikeBLTR">
+      <xsl:call-template name="ForceTrueStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseStrikeBLTR" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:variable name="fStrikeTLBR">
+      <xsl:call-template name="ForceTrueStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseStrikeTLBR" />
+      </xsl:call-template>
+    </xsl:variable>
+
+    <xsl:choose>
+      <xsl:when test="$fHideTop=1 
+                      and $fHideBot=1 
+                      and $fHideLeft=1 
+                      and $fHideRight=1 
+                      and $fStrikeH=0 
+                      and $fStrikeV=0 
+                      and $fStrikeBLTR=0 
+                      and $fStrikeTLBR=0">
+        <mml:mrow>
+          <xsl:apply-templates select="m:e[1]" />
+        </mml:mrow>
+      </xsl:when>
+      <xsl:otherwise>
+        <mml:menclose>
+          <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+            <xsl:with-param name="fHideTop" select="$fHideTop" />
+            <xsl:with-param name="fHideBot" select="$fHideBot" />
+            <xsl:with-param name="fHideLeft" select="$fHideLeft" />
+            <xsl:with-param name="fHideRight" select="$fHideRight" />
+            <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+            <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+            <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+            <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+          </xsl:call-template>
+          <xsl:apply-templates select="m:e[1]" />
+        </mml:menclose>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template match="*">
+    <xsl:apply-templates select="*" />
+  </xsl:template>
+
+  <!--
+      { Non-combining, Upper-combining, Lower-combining }
+      {U+02D8, U+0306, U+032E}, // BREVE
+      {U+00B8, U+0312, U+0327}, // CEDILLA
+      {U+0060, U+0300, U+0316}, // GRAVE ACCENT
+      {U+002D, U+0305, U+0332}, // HYPHEN-MINUS/OVERLINE
+      {U+2212, U+0305, U+0332}, // MINUS SIGN/OVERLINE
+      {U+002E, U+0305, U+0323}, // FULL STOP/DOT ABOVE
+      {U+02D9, U+0307, U+0323}, // DOT ABOVE
+      {U+02DD, U+030B, U+02DD}, // DOUBLE ACUTE ACCENT
+      {U+00B4, U+0301, U+0317}, // ACUTE ACCENT
+      {U+007E, U+0303, U+0330}, // TILDE
+      {U+02DC, U+0303, U+0330}, // SMALL TILDE
+      {U+00A8, U+0308, U+0324}, // DIAERESIS
+      {U+02C7, U+030C, U+032C}, // CARON
+      {U+005E, U+0302, U+032D}, // CIRCUMFLEX ACCENT
+      {U+00AF, U+0305, ::::::}, // MACRON
+      {U+005F, ::::::, U+0332}, // LOW LINE
+      {U+2192, U+20D7, U+20EF}, // RIGHTWARDS ARROW
+      {U+27F6, U+20D7, U+20EF}, // LONG RIGHTWARDS ARROW
+      {U+2190, U+20D6, U+20EE}, // LEFT ARROW
+  -->
+  <xsl:template name="ToNonCombining">
+    <xsl:param name="ch" />
+    <xsl:choose>
+      <!-- BREVE -->
+      <xsl:when test="$ch='&#x0306;' or $ch='&#x032e;'">&#x02D8;</xsl:when>
+      <!-- CEDILLA -->
+      <xsl:when test="$ch='&#x0312;' or $ch='&#x0327;'">&#x00B8;</xsl:when>
+      <!-- GRAVE ACCENT -->
+      <xsl:when test="$ch='&#x0300;' or $ch='&#x0316;'">&#x0060;</xsl:when>
+      <!-- HYPHEN-MINUS/OVERLINE -->
+      <xsl:when test="$ch='&#x0305;' or $ch='&#x0332;'">&#x002D;</xsl:when>
+      <!-- MINUS SIGN/OVERLINE -->
+      <xsl:when test="$ch='&#x0305;' or $ch='&#x0332;'">&#x2212;</xsl:when>
+      <!-- FULL STOP/DOT ABOVE -->
+      <xsl:when test="$ch='&#x0305;' or $ch='&#x0323;'">&#x002E;</xsl:when>
+      <!-- DOT ABOVE -->
+      <xsl:when test="$ch='&#x0307;' or $ch='&#x0323;'">&#x02D9;</xsl:when>
+      <!-- DOUBLE ACUTE ACCENT -->
+      <xsl:when test="$ch='&#x030B;' or $ch='&#x02DD;'">&#x02DD;</xsl:when>
+      <!-- ACUTE ACCENT -->
+      <xsl:when test="$ch='&#x0301;' or $ch='&#x0317;'">&#x00B4;</xsl:when>
+      <!-- TILDE -->
+      <xsl:when test="$ch='&#x0303;' or $ch='&#x0330;'">&#x007E;</xsl:when>
+      <!-- SMALL TILDE -->
+      <xsl:when test="$ch='&#x0303;' or $ch='&#x0330;'">&#x02DC;</xsl:when>
+      <!-- DIAERESIS -->
+      <xsl:when test="$ch='&#x0308;' or $ch='&#x0324;'">&#x00A8;</xsl:when>
+      <!-- CARON -->
+      <xsl:when test="$ch='&#x030C;' or $ch='&#x032C;'">&#x02C7;</xsl:when>
+      <!-- CIRCUMFLEX ACCENT -->
+      <xsl:when test="$ch='&#x0302;' or $ch='&#x032D;'">&#x005E;</xsl:when>
+      <!-- MACRON -->
+      <xsl:when test="$ch='&#x0305;'                   ">&#x00AF;</xsl:when>
+      <!-- LOW LINE -->
+      <xsl:when test="                   $ch='&#x0332;'">&#x005F;</xsl:when>
+      <!-- RIGHTWARDS ARROW -->
+      <xsl:when test="$ch='&#x20D7;' or $ch='&#x20EF;'">&#x2192;</xsl:when>
+      <!-- LONG RIGHTWARDS ARROW -->
+      <xsl:when test="$ch='&#x20D7;' or $ch='&#x20EF;'">&#x27F6;</xsl:when>
+      <!-- LEFT ARROW -->
+      <xsl:when test="$ch='&#x20D6;' or $ch='&#x20EE;'">&#x2190;</xsl:when>
+      <xsl:otherwise>
+        <xsl:value-of select="$ch"/>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template match="m:acc">
+    <mml:mover>
+      <xsl:attribute name="accent">true</xsl:attribute>
+      <mml:mrow>
+        <xsl:apply-templates select="m:e[1]" />
+      </mml:mrow>
+      <xsl:variable name="chAcc">
+        <xsl:choose>
+          <xsl:when test="not(m:accPr[last()]/m:chr)">
+            <xsl:value-of select="'&#x0302;'" />
+          </xsl:when>
+          <xsl:otherwise>
+            <xsl:value-of select="substring(m:accPr/m:chr/@m:val,1,1)" />
+          </xsl:otherwise>
+        </xsl:choose>
+      </xsl:variable>
+      <xsl:variable name="chNonComb">
+        <xsl:call-template name="ToNonCombining">
+          <xsl:with-param name="ch" select="$chAcc" />
+        </xsl:call-template>
+      </xsl:variable>
+      <xsl:choose>
+        <xsl:when test="string-length($chAcc)=0">
+          <mml:mo/>
+        </xsl:when>
+        <xsl:otherwise>
+          <xsl:call-template name="ParseMt">
+            <xsl:with-param name="sToParse" select="$chNonComb" />
+            <xsl:with-param name="scr" select="m:e[1]/*/m:rPr[last()]/m:scr/@m:val" />
+            <xsl:with-param name="sty" select="m:e[1]/*/m:rPr[last()]/m:sty/@m:val" />
+            <xsl:with-param name="nor">
+              <xsl:choose>
+                <xsl:when test="count(m:e[1]/*/m:rPr[last()]/m:nor) = 0">0</xsl:when>
+                <xsl:otherwise>
+                  <xsl:call-template name="ForceFalseStrVal">
+                    <xsl:with-param name="str" select="translate(m:e[1]/*/m:rPr[last()]/m:nor/@m:val, 
+                                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                                 'abcdefghijklmnopqrstuvwxyz')" />
+                  </xsl:call-template>
+                </xsl:otherwise>
+              </xsl:choose>
+            </xsl:with-param>
+          </xsl:call-template>
+        </xsl:otherwise>
+      </xsl:choose>
+    </mml:mover>
+  </xsl:template>
+
+  <xsl:template name="OutputScript">
+    <xsl:param name="ndCur" select="." />
+    <xsl:choose>
+      <!-- Only output contents of $ndCur if $ndCur exists
+           and $ndCur has children -->
+      <xsl:when test="count($ndCur/*) &gt; 0">
+        <mml:mrow>
+          <xsl:apply-templates select="$ndCur" />
+        </mml:mrow>
+      </xsl:when>
+      <xsl:otherwise>
+        <mml:none />
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template match="m:sPre">
+    <mml:mmultiscripts>
+      <mml:mrow>
+        <xsl:apply-templates select="m:e[1]" />
+      </mml:mrow>
+      <mml:mprescripts />
+      <xsl:call-template name="OutputScript">
+        <xsl:with-param name="ndCur" select="m:sub[1]"/>
+      </xsl:call-template>
+      <xsl:call-template name="OutputScript">
+        <xsl:with-param name="ndCur" select="m:sup[1]" />
+      </xsl:call-template>
+    </mml:mmultiscripts>
+  </xsl:template>
+
+  <xsl:template match="m:m">
+    <mml:mtable>
+      <xsl:call-template name="CreateMathMLMatrixAttr">
+        <xsl:with-param name="mcJc" select="m:mPr[last()]/m:mcs/m:mc/m:mcPr[last()]/m:mcJc/@m:val" />
+      </xsl:call-template>
+      <xsl:for-each select="m:mr">
+        <mml:mtr>
+          <xsl:for-each select="m:e">
+            <mml:mtd>
+              <xsl:apply-templates select="." />
+            </mml:mtd>
+          </xsl:for-each>
+        </mml:mtr>
+      </xsl:for-each>
+    </mml:mtable>
+  </xsl:template>
+
+  <xsl:template name="CreateMathMLMatrixAttr">
+    <xsl:param name="mcJc" />
+    <xsl:variable name="sLowerCaseMcjc" select="translate($mcJc, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                             'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:choose>
+      <xsl:when test="$sLowerCaseMcjc='left'">
+        <xsl:attribute name="columnalign">left</xsl:attribute>
+      </xsl:when>
+      <xsl:when test="$sLowerCaseMcjc='right'">
+        <xsl:attribute name="columnalign">right</xsl:attribute>
+      </xsl:when>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template match="m:phant">
+    <xsl:variable name="sLowerCaseZeroWidVal" select="translate(m:phantPr[last()]/m:zeroWid[last()]/@m:val, 
+		                                                       'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                       'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="sLowerCaseZeroAscVal" select="translate(m:phantPr[last()]/m:zeroAsc[last()]/@m:val, 
+		                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                     'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="sLowerCaseZeroDescVal" select="translate(m:phantPr[last()]/m:zeroDesc[last()]/@m:val, 
+		                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                     'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="sLowerCaseShowVal" select="translate(m:phantPr[last()]/m:show[last()]/@m:val, 
+		                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                     'abcdefghijklmnopqrstuvwxyz')" />
+
+
+    <!-- The following properties default to 'yes' unless the last value equals 'no' or there isn't any node for 
+         the property -->
+
+    <xsl:variable name="fZeroWid">
+      <xsl:choose>
+        <xsl:when test="count(m:phantPr[last()]/m:zeroWid[last()]) = 0">0</xsl:when>
+        <xsl:otherwise>
+          <xsl:call-template name="ForceFalseStrVal">
+            <xsl:with-param name="str" select="$sLowerCaseZeroWidVal" />
+          </xsl:call-template>
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+    <xsl:variable name="fZeroAsc">
+      <xsl:choose>
+        <xsl:when test="count(m:phantPr[last()]/m:zeroAsc[last()]) = 0">0</xsl:when>
+        <xsl:otherwise>
+          <xsl:call-template name="ForceFalseStrVal">
+            <xsl:with-param name="str" select="$sLowerCaseZeroAscVal" />
+          </xsl:call-template>
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+    <xsl:variable name="fZeroDesc">
+      <xsl:choose>
+        <xsl:when test="count(m:phantPr[last()]/m:zeroDesc[last()]) = 0">0</xsl:when>
+        <xsl:otherwise>
+          <xsl:call-template name="ForceFalseStrVal">
+            <xsl:with-param name="str" select="$sLowerCaseZeroDescVal" />
+          </xsl:call-template>
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+
+    <!-- The show property defaults to 'on' unless there exists a show property and its value is 'off' -->
+
+    <xsl:variable name="fShow">
+      <xsl:call-template name="ForceFalseStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseShowVal" />
+      </xsl:call-template>
+    </xsl:variable>
+
+    <xsl:choose>
+      <!-- Show the phantom contents, therefore, just use mpadded. -->
+      <xsl:when test="$fShow = 1">
+        <xsl:element name="mml:mpadded">
+          <xsl:call-template name="CreateMpaddedAttributes">
+            <xsl:with-param name="fZeroWid" select="$fZeroWid" />
+            <xsl:with-param name="fZeroAsc" select="$fZeroAsc" />
+            <xsl:with-param name="fZeroDesc" select="$fZeroDesc" />
+          </xsl:call-template>
+          <mml:mrow>
+            <xsl:apply-templates select="m:e" />
+          </mml:mrow>
+        </xsl:element>
+      </xsl:when>
+      <!-- Don't show phantom contents, but don't smash anything, therefore, just 
+           use mphantom -->
+      <xsl:when test="$fZeroWid=0 and $fZeroAsc=0 and $fZeroDesc=0">
+        <xsl:element name="mml:mphantom">
+          <mml:mrow>
+            <xsl:apply-templates select="m:e" />
+          </mml:mrow>
+        </xsl:element>
+      </xsl:when>
+      <!-- Combination -->
+      <xsl:otherwise>
+        <xsl:element name="mml:mphantom">
+          <xsl:element name="mml:mpadded">
+            <xsl:call-template name="CreateMpaddedAttributes">
+              <xsl:with-param name="fZeroWid" select="$fZeroWid" />
+              <xsl:with-param name="fZeroAsc" select="$fZeroAsc" />
+              <xsl:with-param name="fZeroDesc" select="$fZeroDesc" />
+            </xsl:call-template>
+            <mml:mrow>
+              <xsl:apply-templates select="m:e" />
+            </mml:mrow>
+          </xsl:element>
+        </xsl:element>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template name="CreateMpaddedAttributes">
+    <xsl:param name="fZeroWid" />
+    <xsl:param name="fZeroAsc" />
+    <xsl:param name="fZeroDesc" />
+
+    <xsl:if test="$fZeroWid=1">
+      <xsl:attribute name="width">0in</xsl:attribute>
+    </xsl:if>
+    <xsl:if test="$fZeroAsc=1">
+      <xsl:attribute name="height">0in</xsl:attribute>
+    </xsl:if>
+    <xsl:if test="$fZeroDesc=1">
+      <xsl:attribute name="depth">0in</xsl:attribute>
+    </xsl:if>
+  </xsl:template>
+
+
+
+  <xsl:template match="m:rad">
+    <xsl:variable name="fDegHide">
+      <xsl:choose>
+        <xsl:when test="count(m:radPr[last()]/m:degHide)=0">0</xsl:when>
+        <xsl:otherwise>
+          <xsl:call-template name="ForceFalseStrVal">
+            <xsl:with-param name="str" select="translate(m:radPr[last()]/m:degHide/@m:val, 
+		                                                          'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                          'abcdefghijklmnopqrstuvwxyz')" />
+          </xsl:call-template>
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+    <xsl:choose>
+      <xsl:when test="$fDegHide=1">
+        <mml:msqrt>
+          <xsl:apply-templates select="m:e[1]" />
+        </mml:msqrt>
+      </xsl:when>
+      <xsl:otherwise>
+        <mml:mroot>
+          <mml:mrow>
+            <xsl:apply-templates select="m:e[1]" />
+          </mml:mrow>
+          <mml:mrow>
+            <xsl:apply-templates select="m:deg[1]" />
+          </mml:mrow>
+        </mml:mroot>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template name="OutputNaryMo">
+    <xsl:param name="ndCur" select="." />
+    <xsl:param name="fGrow" select="0" />
+    <mml:mo>
+      <xsl:choose>
+        <xsl:when test="$fGrow=1">
+          <xsl:attribute name="stretchy">true</xsl:attribute>
+        </xsl:when>
+        <xsl:otherwise>
+          <xsl:attribute name="stretchy">false</xsl:attribute>
+        </xsl:otherwise>
+      </xsl:choose>
+      <xsl:choose>
+        <xsl:when test="not($ndCur/m:naryPr[last()]/m:chr/@m:val) or
+			                            $ndCur/m:naryPr[last()]/m:chr/@m:val=''">
+          <xsl:text>&#x222b;</xsl:text>
+        </xsl:when>
+        <xsl:otherwise>
+          <xsl:value-of select="$ndCur/m:naryPr[last()]/m:chr/@m:val" />
+        </xsl:otherwise>
+      </xsl:choose>
+    </mml:mo>
+  </xsl:template>
+
+  <!-- %%Template match m:nary 
+		Process an n-ary. 
+		
+		Decides, based on which arguments are supplied, between
+		using an mo, msup, msub, or msubsup for the n-ary operator		
+	-->
+  <xsl:template match="m:nary">
+    <xsl:variable name="sLowerCaseSubHide">
+      <xsl:choose>
+        <xsl:when test="count(m:naryPr[last()]/m:subHide) = 0">
+          <xsl:text>off</xsl:text>
+        </xsl:when>
+        <xsl:otherwise>
+          <xsl:value-of select="translate(m:naryPr[last()]/m:subHide/@m:val, 
+	                                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+	                                  'abcdefghijklmnopqrstuvwxyz')" />
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+
+    <xsl:variable name="sLowerCaseSupHide">
+      <xsl:choose>
+        <xsl:when test="count(m:naryPr[last()]/m:supHide) = 0">
+          <xsl:text>off</xsl:text>
+        </xsl:when>
+        <xsl:otherwise>
+          <xsl:value-of select="translate(m:naryPr[last()]/m:supHide/@m:val, 
+	                                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+	                                  'abcdefghijklmnopqrstuvwxyz')" />
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+
+    <xsl:variable name="sLowerCaseLimLoc">
+      <xsl:value-of select="translate(m:naryPr[last()]/m:limLoc/@m:val, 
+	                                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+	                                  'abcdefghijklmnopqrstuvwxyz')" />
+    </xsl:variable>
+
+    <xsl:variable name="sLowerGrow">
+      <xsl:choose>
+        <xsl:when test="count(m:naryPr[last()]/m:grow)=0">off</xsl:when>
+        <xsl:otherwise>
+          <xsl:value-of select="translate(m:naryPr[last()]/m:grow/@m:val, 
+	                                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+	                                  'abcdefghijklmnopqrstuvwxyz')" />
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+
+    <xsl:variable name="fLimLocSubSup">
+      <xsl:choose>
+        <xsl:when test="count(m:naryPr[last()]/m:limLoc)=0 or $sLowerCaseLimLoc='subsup'">1</xsl:when>
+        <xsl:otherwise>0</xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+
+    <xsl:variable name="fGrow">
+      <xsl:call-template name="ForceFalseStrVal">
+        <xsl:with-param name="str" select="$sLowerGrow" />
+      </xsl:call-template>
+    </xsl:variable>
+
+    <xsl:variable name="fSupHide">
+      <xsl:call-template name="ForceFalseStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseSupHide" />
+      </xsl:call-template>
+    </xsl:variable>
+
+    <xsl:variable name="fSubHide">
+      <xsl:call-template name="ForceFalseStrVal">
+        <xsl:with-param name="str" select="$sLowerCaseSubHide" />
+      </xsl:call-template>
+    </xsl:variable>
+
+    <mml:mrow>
+      <xsl:choose>
+        <xsl:when test="$fSupHide=1 and $fSubHide=1">
+          <xsl:call-template name="OutputNaryMo">
+            <xsl:with-param name="ndCur" select="." />
+            <xsl:with-param name="fGrow" select="$fGrow" />
+          </xsl:call-template>
+        </xsl:when>
+        <xsl:when test="$fSubHide=1">
+          <xsl:choose>
+            <xsl:when test="$fLimLocSubSup=1">
+              <mml:msup>
+                <xsl:call-template name="OutputNaryMo">
+                  <xsl:with-param name="ndCur" select="." />
+                  <xsl:with-param name="fGrow" select="$fGrow" />
+                </xsl:call-template>
+                <mml:mrow>
+                  <xsl:apply-templates select="m:sup[1]" />
+                </mml:mrow>
+              </mml:msup>
+            </xsl:when>
+            <xsl:otherwise>
+              <mml:mover>
+                <xsl:call-template name="OutputNaryMo">
+                  <xsl:with-param name="ndCur" select="." />
+                  <xsl:with-param name="fGrow" select="$fGrow" />
+                </xsl:call-template>
+                <mml:mrow>
+                  <xsl:apply-templates select="m:sup[1]" />
+                </mml:mrow>
+              </mml:mover>
+            </xsl:otherwise>
+          </xsl:choose>
+        </xsl:when>
+        <xsl:when test="$fSupHide=1">
+          <xsl:choose>
+            <xsl:when test="$fLimLocSubSup=1">
+              <mml:msub>
+                <xsl:call-template name="OutputNaryMo">
+                  <xsl:with-param name="ndCur" select="." />
+                  <xsl:with-param name="fGrow" select="$fGrow" />
+                </xsl:call-template>
+                <mml:mrow>
+                  <xsl:apply-templates select="m:sub[1]" />
+                </mml:mrow>
+              </mml:msub>
+            </xsl:when>
+            <xsl:otherwise>
+              <mml:munder>
+                <xsl:call-template name="OutputNaryMo">
+                  <xsl:with-param name="ndCur" select="." />
+                  <xsl:with-param name="fGrow" select="$fGrow" />
+                </xsl:call-template>
+                <mml:mrow>
+                  <xsl:apply-templates select="m:sub[1]" />
+                </mml:mrow>
+              </mml:munder>
+            </xsl:otherwise>
+          </xsl:choose>
+        </xsl:when>
+        <xsl:otherwise>
+          <xsl:choose>
+            <xsl:when test="$fLimLocSubSup=1">
+              <mml:msubsup>
+                <xsl:call-template name="OutputNaryMo">
+                  <xsl:with-param name="ndCur" select="." />
+                  <xsl:with-param name="fGrow" select="$fGrow" />
+                </xsl:call-template>
+                <mml:mrow>
+                  <xsl:apply-templates select="m:sub[1]" />
+                </mml:mrow>
+                <mml:mrow>
+                  <xsl:apply-templates select="m:sup[1]" />
+                </mml:mrow>
+              </mml:msubsup>
+            </xsl:when>
+            <xsl:otherwise>
+              <mml:munderover>
+                <xsl:call-template name="OutputNaryMo">
+                  <xsl:with-param name="ndCur" select="." />
+                  <xsl:with-param name="fGrow" select="$fGrow" />
+                </xsl:call-template>
+                <mml:mrow>
+                  <xsl:apply-templates select="m:sub[1]" />
+                </mml:mrow>
+                <mml:mrow>
+                  <xsl:apply-templates select="m:sup[1]" />
+                </mml:mrow>
+              </mml:munderover>
+            </xsl:otherwise>
+          </xsl:choose>
+        </xsl:otherwise>
+      </xsl:choose>
+      <mml:mrow>
+        <xsl:apply-templates select="m:e[1]" />
+      </mml:mrow>
+    </mml:mrow>
+  </xsl:template>
+
+  <xsl:template match="m:limLow">
+    <mml:munder>
+      <mml:mrow>
+        <xsl:apply-templates select="m:e[1]" />
+      </mml:mrow>
+      <mml:mrow>
+        <xsl:apply-templates select="m:lim[1]" />
+      </mml:mrow>
+    </mml:munder>
+  </xsl:template>
+
+  <xsl:template match="m:limUpp">
+    <mml:mover>
+      <mml:mrow>
+        <xsl:apply-templates select="m:e[1]" />
+      </mml:mrow>
+      <mml:mrow>
+        <xsl:apply-templates select="m:lim[1]" />
+      </mml:mrow>
+    </mml:mover>
+  </xsl:template>
+
+  <xsl:template match="m:sSub">
+    <mml:msub>
+      <mml:mrow>
+        <xsl:apply-templates select="m:e[1]" />
+      </mml:mrow>
+      <mml:mrow>
+        <xsl:apply-templates select="m:sub[1]" />
+      </mml:mrow>
+    </mml:msub>
+  </xsl:template>
+
+  <xsl:template match="m:sSup">
+    <mml:msup>
+      <mml:mrow>
+        <xsl:apply-templates select="m:e[1]" />
+      </mml:mrow>
+      <mml:mrow>
+        <xsl:apply-templates select="m:sup[1]" />
+      </mml:mrow>
+    </mml:msup>
+  </xsl:template>
+
+  <xsl:template match="m:sSubSup">
+    <mml:msubsup>
+      <mml:mrow>
+        <xsl:apply-templates select="m:e[1]" />
+      </mml:mrow>
+      <mml:mrow>
+        <xsl:apply-templates select="m:sub[1]" />
+      </mml:mrow>
+      <mml:mrow>
+        <xsl:apply-templates select="m:sup[1]" />
+      </mml:mrow>
+    </mml:msubsup>
+  </xsl:template>
+
+  <xsl:template match="m:groupChr">
+    <xsl:variable name="ndLastGroupChrPr" select="m:groupChrPr[last()]" />
+    <xsl:variable name="sLowerCasePos" select="translate($ndLastGroupChrPr/m:pos/@m:val, 
+		                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                     'abcdefghijklmnopqrstuvwxyz')" />
+
+    <xsl:variable name="sLowerCaseVertJc" select="translate($ndLastGroupChrPr/m:vertJc/@m:val, 
+		                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                     'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:variable name="ndLastChr" select="$ndLastGroupChrPr/m:chr" />
+
+    <xsl:variable name="chr">
+      <xsl:choose>
+        <xsl:when test="$ndLastChr and (not($ndLastChr/@m:val) or string-length($ndLastChr/@m:val) = 0)"></xsl:when>
+        <xsl:when test="string-length($ndLastChr/@m:val) &gt;= 1">
+          <xsl:value-of select="substring($ndLastChr/@m:val,1,1)" />
+        </xsl:when>
+        <xsl:otherwise>
+          <xsl:text>&#x023DF;</xsl:text>
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+    <xsl:choose>
+      <xsl:when test="$sLowerCasePos = 'top'">
+        <xsl:choose>
+          <xsl:when test="$sLowerCaseVertJc = 'bot'">
+            <mml:mover accent="false">
+              <mml:mrow>
+                <xsl:apply-templates select="m:e[1]" />
+              </mml:mrow>
+              <mml:mo>
+                <xsl:value-of select="$chr" />
+              </mml:mo>
+            </mml:mover>
+          </xsl:when>
+          <xsl:otherwise>
+            <mml:munder accentunder="false">
+              <mml:mo>
+                <xsl:value-of select="$chr" />
+              </mml:mo>
+              <mml:mrow>
+                <xsl:apply-templates select="m:e[1]" />
+              </mml:mrow>
+            </mml:munder>
+          </xsl:otherwise>
+        </xsl:choose>
+      </xsl:when>
+      <xsl:otherwise>
+        <xsl:choose>
+          <xsl:when test="$sLowerCaseVertJc = 'bot'">
+            <mml:mover accent="false">
+              <mml:mo>
+                <xsl:value-of select="$chr" />
+              </mml:mo>
+              <mml:mrow>
+                <xsl:apply-templates select="m:e[1]" />
+              </mml:mrow>
+            </mml:mover>
+          </xsl:when>
+          <xsl:otherwise>
+            <mml:munder accentunder="false">
+              <mml:mrow>
+                <xsl:apply-templates select="m:e[1]" />
+              </mml:mrow>
+              <mml:mo>
+                <xsl:value-of select="$chr" />
+              </mml:mo>
+            </mml:munder>
+          </xsl:otherwise>
+        </xsl:choose>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template name="fName">
+    <xsl:for-each select="m:fName/*">
+      <xsl:apply-templates select="." />
+    </xsl:for-each>
+  </xsl:template>
+
+  <xsl:template match="m:func">
+    <mml:mrow>
+      <mml:mrow>
+        <xsl:call-template name="fName" />
+      </mml:mrow>
+      <mml:mo>&#x02061;</mml:mo>
+      <mml:mrow>
+        <xsl:apply-templates select="m:e" />
+      </mml:mrow>
+    </mml:mrow>
+  </xsl:template>
+
+  <!-- %%Template: match m:f 
+		
+		m:f maps directly to mfrac. 
+	-->
+  <xsl:template match="m:f">
+    <xsl:variable name="sLowerCaseType" select="translate(m:fPr[last()]/m:type/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')" />
+    <xsl:choose>
+      <xsl:when test="$sLowerCaseType='lin'">
+        <mml:mrow>
+          <mml:mrow>
+            <xsl:apply-templates select="m:num[1]" />
+          </mml:mrow>
+          <mml:mo>/</mml:mo>
+          <mml:mrow>
+            <xsl:apply-templates select="m:den[1]" />
+          </mml:mrow>
+        </mml:mrow>
+      </xsl:when>
+      <xsl:otherwise>
+        <mml:mfrac>
+          <xsl:call-template name="CreateMathMLFracProp">
+            <xsl:with-param name="type" select="$sLowerCaseType" />
+          </xsl:call-template>
+          <mml:mrow>
+            <xsl:apply-templates select="m:num[1]" />
+          </mml:mrow>
+          <mml:mrow>
+            <xsl:apply-templates select="m:den[1]" />
+          </mml:mrow>
+        </mml:mfrac>
+      </xsl:otherwise>
+    </xsl:choose>
+
+  </xsl:template>
+
+
+  <!-- %%Template: CreateMathMLFracProp 
+		
+			Make fraction properties based on supplied parameters.
+			OMML differentiates between a linear fraction and a skewed
+			one. For MathML, we write both as bevelled.
+	-->
+  <xsl:template name="CreateMathMLFracProp">
+    <xsl:param name="type" />
+    <xsl:variable name="sLowerCaseType" select="translate($type, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')" />
+
+    <xsl:if test="$sLowerCaseType='skw' or $sLowerCaseType='lin'">
+      <xsl:attribute name="bevelled">true</xsl:attribute>
+    </xsl:if>
+    <xsl:if test="$sLowerCaseType='nobar'">
+      <xsl:attribute name="linethickness">0pt</xsl:attribute>
+    </xsl:if>
+    <xsl:choose>
+      <xsl:when test="sLowerCaseNumJc='right'">
+        <xsl:attribute name="numalign">right</xsl:attribute>
+      </xsl:when>
+      <xsl:when test="sLowerCaseNumJc='left'">
+        <xsl:attribute name="numalign">left</xsl:attribute>
+      </xsl:when>
+    </xsl:choose>
+    <xsl:choose>
+      <xsl:when test="sLowerCaseDenJc='right'">
+        <xsl:attribute name="numalign">right</xsl:attribute>
+      </xsl:when>
+      <xsl:when test="sLowerCaseDenJc='left'">
+        <xsl:attribute name="numalign">left</xsl:attribute>
+      </xsl:when>
+    </xsl:choose>
+  </xsl:template>
+
+  <!-- %%Template: match m:e | m:den | m:num | m:lim | m:sup | m:sub 
+		
+		These element delinate parts of an expression (like the numerator).  -->
+  <xsl:template match="m:e | m:den | m:num | m:lim | m:sup | m:sub">
+    <xsl:choose>
+
+      <!-- If there is no scriptLevel specified, just call through -->
+      <xsl:when test="not(m:argPr[last()]/m:scrLvl/@m:val)">
+        <xsl:apply-templates select="*" />
+      </xsl:when>
+
+      <!-- Otherwise, create an mstyle and set the script level -->
+      <xsl:otherwise>
+        <mml:mstyle>
+          <xsl:attribute name="scriptlevel">
+            <xsl:value-of select="m:argPr[last()]/m:scrLvl/@m:val" />
+          </xsl:attribute>
+          <xsl:apply-templates select="*" />
+        </mml:mstyle>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template match="m:bar">
+    <xsl:variable name="sLowerCasePos" select="translate(m:barPr/m:pos/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                                       'abcdefghijklmnopqrstuvwxyz')" />
+
+    <xsl:variable name="fTop">
+
+      <xsl:choose>
+        <xsl:when test="$sLowerCasePos='top'">1</xsl:when>
+        <xsl:otherwise>0</xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+    <xsl:choose>
+      <xsl:when test="$fTop=1">
+        <mml:mover accent="false">
+          <mml:mrow>
+            <xsl:apply-templates select="m:e[1]" />
+          </mml:mrow>
+          <mml:mo>
+            <xsl:text>&#x00AF;</xsl:text>
+          </mml:mo>
+        </mml:mover>
+      </xsl:when>
+      <xsl:otherwise>
+        <mml:munder underaccent="false">
+          <mml:mrow>
+            <xsl:apply-templates select="m:e[1]" />
+          </mml:mrow>
+          <mml:mo>
+            <xsl:text>&#x005F;</xsl:text>
+          </mml:mo>
+        </mml:munder>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <!-- %%Template match m:d
+
+		Process a delimiter. 
+	-->
+  <xsl:template match="m:d">
+    <mml:mfenced>
+      <!-- open: default is '(' for both OMML and MathML -->
+      <xsl:if test="m:dPr[1]/m:begChr/@m:val and not(m:dPr[1]/m:begChr/@m:val ='(')">
+        <xsl:attribute name="open">
+          <xsl:value-of select="m:dPr[1]/m:begChr/@m:val" />
+        </xsl:attribute>
+      </xsl:if>
+
+      <!-- close: default is ')' for both OMML and MathML -->
+      <xsl:if test="m:dPr[1]/m:endChr/@m:val and not(m:dPr[1]/m:endChr/@m:val =')')">
+        <xsl:attribute name="close">
+          <xsl:value-of select="m:dPr[1]/m:endChr/@m:val" />
+        </xsl:attribute>
+      </xsl:if>
+
+      <!-- separator: the default is ',' for MathML, and '|' for OMML -->
+      <xsl:choose>
+        <!-- Matches MathML default. Write nothing -->
+        <xsl:when test="m:dPr[1]/m:sepChr/@m:val = ','" />
+
+        <!-- OMML default: | -->
+        <xsl:when test="not(m:dPr[1]/m:sepChr/@m:val)">
+          <xsl:attribute name="separators">
+            <xsl:value-of select="'|'" />
+          </xsl:attribute>
+        </xsl:when>
+
+        <xsl:otherwise>
+          <xsl:attribute name="separators">
+            <xsl:value-of select="m:dPr[1]/m:sepChr/@m:val" />
+          </xsl:attribute>
+        </xsl:otherwise>
+      </xsl:choose>
+
+      <!-- now write all the children. Put each one into an mrow
+			just in case it produces multiple runs, etc -->
+      <xsl:for-each select="m:e">
+        <mml:mrow>
+          <xsl:apply-templates select="." />
+        </mml:mrow>
+      </xsl:for-each>
+    </mml:mfenced>
+  </xsl:template>
+
+  <xsl:template match="m:r">
+    <xsl:variable name="fNor">
+      <xsl:choose>
+        <xsl:when test="count(child::m:rPr[last()]/m:nor) = 0">0</xsl:when>
+        <xsl:otherwise>
+          <xsl:call-template name="ForceFalseStrVal">
+            <xsl:with-param name="str" select="translate(child::m:rPr[last()]/m:nor/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                                       'abcdefghijklmnopqrstuvwxyz')" />
+          </xsl:call-template>
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:variable>
+
+    <xsl:choose>
+      <xsl:when test="$fNor=1">
+        <mml:mtext>
+          <xsl:variable name="sOutput" select="translate(.//m:t, ' ', '&#xa0;')" />
+          <xsl:value-of select="$sOutput" />
+        </mml:mtext>
+      </xsl:when>
+      <xsl:otherwise>
+        <xsl:for-each select=".//m:t">
+          <xsl:call-template name="ParseMt">
+            <xsl:with-param name="sToParse" select="text()" />
+            <xsl:with-param name="scr" select="../m:rPr[last()]/m:scr/@m:val" />
+            <xsl:with-param name="sty" select="../m:rPr[last()]/m:sty/@m:val" />
+            <xsl:with-param name="nor">0</xsl:with-param>
+          </xsl:call-template>
+        </xsl:for-each>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+
+  <xsl:template name="CreateTokenAttributes">
+    <xsl:param name="scr" />
+    <xsl:param name="sty" />
+    <xsl:param name="nor" />
+    <xsl:param name="nCharToPrint" />
+    <xsl:param name="sTokenType" />
+
+    <xsl:choose>
+      <xsl:when test="$nor=1">
+        <xsl:attribute name="mathvariant">normal</xsl:attribute>
+      </xsl:when>
+      <xsl:otherwise>
+        <xsl:variable name="mathvariant">
+          <xsl:choose>
+            <!-- numbers don't care -->
+            <xsl:when test="$sTokenType='mn'" />
+
+            <xsl:when test="$scr='monospace'">monospace</xsl:when>
+            <xsl:when test="$scr='sans-serif' and $sty='i'">sans-serif-italic</xsl:when>
+            <xsl:when test="$scr='sans-serif' and $sty='b'">bold-sans-serif</xsl:when>
+            <xsl:when test="$scr='sans-serif' and $sty='bi'">sans-serif-bold-italic</xsl:when>
+            <xsl:when test="$scr='sans-serif'">sans-serif</xsl:when>
+            <xsl:when test="$scr='fraktur' and ($sty='b' or $sty='bi')">bold-fraktur</xsl:when>
+            <xsl:when test="$scr='fraktur'">fraktur</xsl:when>
+            <xsl:when test="$scr='double-struck'">double-struck</xsl:when>
+            <xsl:when test="$scr='script' and ($sty='b' or $sty='bi')">bold-script</xsl:when>
+            <xsl:when test="$scr='script'">script</xsl:when>
+            <xsl:when test="($scr='roman' or not($scr) or $scr='') and $sty='b'">bold</xsl:when>
+            <xsl:when test="($scr='roman' or not($scr) or $scr='') and $sty='i'">italic</xsl:when>
+            <xsl:when test="($scr='roman' or not($scr) or $scr='') and $sty='p'">normal</xsl:when>
+            <xsl:when test="($scr='roman' or not($scr) or $scr='') and $sty='bi'">bold-italic</xsl:when>
+            <xsl:otherwise />
+          </xsl:choose>
+        </xsl:variable>
+        <xsl:variable name="fontweight">
+          <xsl:choose>
+            <xsl:when test="$sty='b' or $sty='bi'">bold</xsl:when>
+            <xsl:otherwise>normal</xsl:otherwise>
+          </xsl:choose>
+        </xsl:variable>
+        <xsl:variable name="fontstyle">
+          <xsl:choose>
+            <xsl:when test="$sty='p' or $sty='b'">normal</xsl:when>
+            <xsl:otherwise>italic</xsl:otherwise>
+          </xsl:choose>
+        </xsl:variable>
+
+        <!-- Writing of attributes begins here -->
+        <xsl:choose>
+          <!-- Don't write mathvariant for operators unless they want to be normal -->
+          <xsl:when test="$sTokenType='mo' and $mathvariant!='normal'" />
+
+          <!-- A single character within an mi is already italics, don't write -->
+          <xsl:when test="$sTokenType='mi' and $nCharToPrint=1 and ($mathvariant='' or $mathvariant='italic')" />
+
+          <xsl:when test="$sTokenType='mi' and $nCharToPrint &gt; 1 and ($mathvariant='' or $mathvariant='italic')">
+            <xsl:attribute name="mathvariant">
+              <xsl:value-of select="'italic'" />
+            </xsl:attribute>
+          </xsl:when>
+          <xsl:when test="$mathvariant!='italic' and $mathvariant!=''">
+            <xsl:attribute name="mathvariant">
+              <xsl:value-of select="$mathvariant" />
+            </xsl:attribute>
+          </xsl:when>
+          <xsl:otherwise>
+            <xsl:if test="not($sTokenType='mi' and $nCharToPrint=1) and $fontstyle='italic'">
+              <xsl:attribute name="fontstyle">italic</xsl:attribute>
+            </xsl:if>
+            <xsl:if test="$fontweight='bold'">
+              <xsl:attribute name="fontweight">bold</xsl:attribute>
+            </xsl:if>
+          </xsl:otherwise>
+        </xsl:choose>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template match="m:eqArr">
+    <mml:mtable>
+      <xsl:for-each select="m:e">
+        <mml:mtr>
+          <mml:mtd>
+            <xsl:choose>
+              <xsl:when test="m:argPr[last()]/m:scrLvl/@m:val!='0' or 
+					            not(m:argPr[last()]/m:scrLvl/@m:val)  or 
+					            m:argPr[last()]/m:scrLvl/@m:val=''">
+                <mml:mrow>
+                  <mml:maligngroup />
+                  <xsl:call-template name="CreateEqArrRow">
+                    <xsl:with-param name="align" select="1" />
+                    <xsl:with-param name="ndCur" select="*[1]" />
+                  </xsl:call-template>
+                </mml:mrow>
+              </xsl:when>
+              <xsl:otherwise>
+                <mml:mstyle>
+                  <xsl:attribute name="scriptlevel">
+                    <xsl:value-of select="m:argPr[last()]/m:scrLvl/@m:val" />
+                  </xsl:attribute>
+                  <mml:maligngroup />
+                  <xsl:call-template name="CreateEqArrRow">
+                    <xsl:with-param name="align" select="1" />
+                    <xsl:with-param name="ndCur" select="*[1]" />
+                  </xsl:call-template>
+                </mml:mstyle>
+              </xsl:otherwise>
+            </xsl:choose>
+          </mml:mtd>
+        </mml:mtr>
+      </xsl:for-each>
+    </mml:mtable>
+  </xsl:template>
+
+  <xsl:template name="CreateEqArrRow">
+    <xsl:param name="align" />
+    <xsl:param name="ndCur" />
+    <xsl:variable name="sAllMt">
+      <xsl:for-each select="$ndCur/m:t">
+        <xsl:value-of select="." />
+      </xsl:for-each>
+    </xsl:variable>
+    <xsl:choose>
+      <xsl:when test="$ndCur/self::m:r">
+        <xsl:call-template name="ParseEqArrMr">
+          <xsl:with-param name="sToParse" select="$sAllMt" />
+          <xsl:with-param name="scr" select="../m:rPr[last()]/m:scr/@m:val" />
+          <xsl:with-param name="sty" select="../m:rPr[last()]/m:sty/@m:val" />
+          <xsl:with-param name="nor">
+            <xsl:choose>
+              <xsl:when test="count($ndCur/m:rPr[last()]/m:nor) = 0">0</xsl:when>
+              <xsl:otherwise>
+                <xsl:call-template name="ForceFalseStrVal">
+                  <xsl:with-param name="str" select="translate($ndCur/m:rPr[last()]/m:nor/@m:val, 
+                                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
+		                                                                 'abcdefghijklmnopqrstuvwxyz')" />
+                </xsl:call-template>
+              </xsl:otherwise>
+            </xsl:choose>
+          </xsl:with-param>
+          <xsl:with-param name="align" select="$align" />
+        </xsl:call-template>
+      </xsl:when>
+      <xsl:otherwise>
+        <xsl:apply-templates select="$ndCur" />
+      </xsl:otherwise>
+    </xsl:choose>
+    <xsl:if test="count($ndCur/following-sibling::*) &gt; 0">
+      <xsl:variable name="cAmp">
+        <xsl:call-template name="CountAmp">
+          <xsl:with-param name="sAllMt" select="$sAllMt" />
+          <xsl:with-param name="cAmp" select="0" />
+        </xsl:call-template>
+      </xsl:variable>
+      <xsl:call-template name="CreateEqArrRow">
+        <xsl:with-param name="align" select="($align+($cAmp mod 2)) mod 2" />
+        <xsl:with-param name="ndCur" select="$ndCur/following-sibling::*[1]" />
+      </xsl:call-template>
+    </xsl:if>
+  </xsl:template>
+
+  <xsl:template name="CountAmp">
+    <xsl:param name="sAllMt" />
+    <xsl:param name="cAmp" />
+    <xsl:choose>
+      <xsl:when test="string-length(substring-after($sAllMt, '&amp;')) &gt; 0 or 
+			                substring($sAllMt, string-length($sAllMt))='&#x0026;'">
+        <xsl:call-template name="CountAmp">
+          <xsl:with-param name="sAllMt" select="substring-after($sAllMt, '&#x0026;')" />
+          <xsl:with-param name="cAmp" select="$cAmp+1" />
+        </xsl:call-template>
+      </xsl:when>
+      <xsl:otherwise>
+        <xsl:value-of select="$cAmp" />
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <!-- %%Template: ParseEqArrMr
+			
+			Similar to ParseMt, but this one has to do more for an equation array. 
+      In equation arrays &amp; is a special character which denotes alignment.
+      
+      The &amp; in an equation works by alternating between meaning insert alignment spacing
+      and insert alignment mark.  For each equation in the equation array
+      there is an implied align space at the beginning of the equation.  Within each equation,
+      the first &amp; means alignmark, the second, align space, the third, alignmark, etc.
+      
+      For this reason when parsing m:r's in equation arrays it is important to keep track of what
+      the next ampersand will mean.
+      
+      $align=0 => Omml's align space, which is similar to MathML's maligngroup.
+      $align=1 => Omml's alignment mark, which is similar to MathML's malignmark.
+	-->
+  <xsl:template name="ParseEqArrMr">
+    <xsl:param name="sToParse" />
+    <xsl:param name="sty" />
+    <xsl:param name="scr" />
+    <xsl:param name="nor" />
+    <xsl:param name="align" />
+
+    <xsl:if test="string-length($sToParse) &gt; 0">
+      <xsl:choose>
+        <xsl:when test="substring($sToParse,1,1) = '&amp;'">
+          <xsl:choose>
+            <xsl:when test="$align='0'">
+              <mml:maligngroup />
+            </xsl:when>
+            <xsl:when test="$align='1'">
+              <mml:malignmark />
+            </xsl:when>
+          </xsl:choose>
+          <xsl:call-template name="ParseEqArrMr">
+            <xsl:with-param name="sToParse" select="substring($sToParse,2)" />
+            <xsl:with-param name="scr" select="$scr" />
+            <xsl:with-param name="sty" select="$sty" />
+            <xsl:with-param name="nor" select="$nor" />
+            <xsl:with-param name="align">
+              <xsl:choose>
+                <xsl:when test="$align='1'">0</xsl:when>
+                <xsl:otherwise>1</xsl:otherwise>
+              </xsl:choose>
+            </xsl:with-param>
+          </xsl:call-template>
+        </xsl:when>
+        <xsl:otherwise>
+          <xsl:variable name="sRepNumWith0">
+            <xsl:call-template name="SReplaceNumWithZero">
+              <xsl:with-param name="sToParse" select="$sToParse" />
+            </xsl:call-template>
+          </xsl:variable>
+          <xsl:variable name="sRepOperWith-">
+            <xsl:call-template name="SReplaceOperWithMinus">
+              <xsl:with-param name="sToParse" select="$sRepNumWith0" />
+            </xsl:call-template>
+          </xsl:variable>
+
+          <xsl:variable name="iFirstOper" select="string-length($sRepOperWith-) - string-length(substring-after($sRepOperWith-, '-'))" />
+          <xsl:variable name="iFirstNum" select="string-length($sRepOperWith-) - string-length(substring-after($sRepOperWith-, '0'))" />
+          <xsl:variable name="iFirstAmp" select="string-length($sRepOperWith-) - string-length(substring-after($sRepOperWith-, '&#x0026;'))" />
+          <xsl:variable name="fNumAtPos1">
+            <xsl:choose>
+              <xsl:when test="substring($sRepOperWith-,1,1)='0'">1</xsl:when>
+              <xsl:otherwise>0</xsl:otherwise>
+            </xsl:choose>
+          </xsl:variable>
+          <xsl:variable name="fOperAtPos1">
+            <xsl:choose>
+              <xsl:when test="substring($sRepOperWith-,1,1)='-'">1</xsl:when>
+              <xsl:otherwise>0</xsl:otherwise>
+            </xsl:choose>
+          </xsl:variable>
+          <xsl:choose>
+
+            <!-- Case I: The string begins with neither a number, nor an operator -->
+            <xsl:when test="$fNumAtPos1='0' and $fOperAtPos1='0'">
+              <xsl:choose>
+                <xsl:when test="$nor = 0">
+                  <mml:mi>
+                    <xsl:call-template name="CreateTokenAttributes">
+                      <xsl:with-param name="scr" select="$scr" />
+                      <xsl:with-param name="sty" select="$sty" />
+                      <xsl:with-param name="nor" select="$nor" />
+                      <xsl:with-param name="nCharToPrint" select="1" />
+                      <xsl:with-param name="sTokenType" select="'mi'" />
+                    </xsl:call-template>
+                    <xsl:variable name="sOutput" select="translate(substring($sToParse, 1, 1), ' ', '&#xa0;')" />
+                    <xsl:value-of select="$sOutput" />
+                  </mml:mi>
+                </xsl:when>
+                <xsl:otherwise>
+                  <mml:mtext>
+                    <xsl:variable name="sOutput" select="translate(substring($sToParse, 1, 1), ' ', '&#xa0;')" />
+                    <xsl:value-of select="$sOutput" />
+                  </mml:mtext>
+                </xsl:otherwise>
+              </xsl:choose>
+              <xsl:call-template name="ParseEqArrMr">
+                <xsl:with-param name="sToParse" select="substring($sToParse, 2)" />
+                <xsl:with-param name="scr" select="$scr" />
+                <xsl:with-param name="sty" select="$sty" />
+                <xsl:with-param name="nor" select="$nor" />
+                <xsl:with-param name="align" select="$align" />
+              </xsl:call-template>
+            </xsl:when>
+
+            <!-- Case II: There is an operator at position 1 -->
+            <xsl:when test="$fOperAtPos1='1'">
+              <xsl:choose>
+                <xsl:when test="$nor = 0">
+                  <mml:mo>
+                    <xsl:call-template name="CreateTokenAttributes">
+                      <xsl:with-param name="scr" />
+                      <xsl:with-param name="sty" />
+                      <xsl:with-param name="nor" select="$nor" />
+                      <xsl:with-param name="sTokenType" select="'mo'" />
+                    </xsl:call-template>
+                    <xsl:value-of select="substring($sToParse,1,1)" />
+                  </mml:mo>
+                </xsl:when>
+                <xsl:otherwise>
+                  <mml:mtext>
+                    <xsl:value-of select="substring($sToParse,1,1)" />
+                  </mml:mtext>                  
+                </xsl:otherwise>
+              </xsl:choose>
+              <xsl:call-template name="ParseEqArrMr">
+                <xsl:with-param name="sToParse" select="substring($sToParse, 2)" />
+                <xsl:with-param name="scr" select="$scr" />
+                <xsl:with-param name="sty" select="$sty" />
+                <xsl:with-param name="nor" select="$nor" />
+                <xsl:with-param name="align" select="$align" />
+              </xsl:call-template>
+            </xsl:when>
+
+            <!-- Case III: There is a number at position 1 -->
+            <xsl:otherwise>
+              <xsl:variable name="sConsecNum">
+                <xsl:call-template name="SNumStart">
+                  <xsl:with-param name="sToParse" select="$sToParse" />
+                  <xsl:with-param name="sPattern" select="$sRepNumWith0" />
+                </xsl:call-template>
+              </xsl:variable>
+              <xsl:choose>
+                <xsl:when test="$nor = 0">
+                  <mml:mn>
+                    <xsl:call-template name="CreateTokenAttributes">
+                      <xsl:with-param name="scr" />
+                      <xsl:with-param name="sty" select="'p'"/>
+                      <xsl:with-param name="nor" select="$nor" />
+                      <xsl:with-param name="sTokenType" select="'mn'" />
+                    </xsl:call-template>
+                    <xsl:value-of select="$sConsecNum" />
+                  </mml:mn>
+                </xsl:when>
+                <xsl:otherwise>
+                  <mml:mtext>
+                    <xsl:value-of select="$sConsecNum" />
+                  </mml:mtext>
+                </xsl:otherwise>
+              </xsl:choose>
+              <xsl:call-template name="ParseEqArrMr">
+                <xsl:with-param name="sToParse" select="substring-after($sToParse, $sConsecNum)" />
+                <xsl:with-param name="scr" select="$scr" />
+                <xsl:with-param name="sty" select="$sty" />
+                <xsl:with-param name="nor" select="$nor" />
+                <xsl:with-param name="align" select="$align" />
+              </xsl:call-template>
+            </xsl:otherwise>
+          </xsl:choose>
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:if>
+  </xsl:template>
+
+  <!-- %%Template: ParseMt
+
+			Produce a run of text. Technically, OMML makes no distinction 
+			between numbers, operators, and other characters in a run. For 
+			MathML we need to break these into mi, mn, or mo elements. 
+			
+			See also ParseEqArrMr
+	-->
+  <xsl:template name="ParseMt">
+    <xsl:param name="sToParse" />
+    <xsl:param name="sty" />
+    <xsl:param name="scr" />
+    <xsl:param name="nor" />
+    <xsl:if test="string-length($sToParse) &gt; 0">
+      <xsl:variable name="sRepNumWith0">
+        <xsl:call-template name="SReplaceNumWithZero">
+          <xsl:with-param name="sToParse" select="$sToParse" />
+        </xsl:call-template>
+      </xsl:variable>
+      <xsl:variable name="sRepOperWith-">
+        <xsl:call-template name="SReplaceOperWithMinus">
+          <xsl:with-param name="sToParse" select="$sRepNumWith0" />
+        </xsl:call-template>
+      </xsl:variable>
+
+      <xsl:variable name="iFirstOper" select="string-length($sRepOperWith-) - string-length(substring-after($sRepOperWith-, '-'))" />
+      <xsl:variable name="iFirstNum" select="string-length($sRepOperWith-) - string-length(substring-after($sRepOperWith-, '0'))" />
+      <xsl:variable name="fNumAtPos1">
+        <xsl:choose>
+          <xsl:when test="substring($sRepOperWith-,1,1)='0'">1</xsl:when>
+          <xsl:otherwise>0</xsl:otherwise>
+        </xsl:choose>
+      </xsl:variable>
+      <xsl:variable name="fOperAtPos1">
+        <xsl:choose>
+          <xsl:when test="substring($sRepOperWith-,1,1)='-'">1</xsl:when>
+          <xsl:otherwise>0</xsl:otherwise>
+        </xsl:choose>
+      </xsl:variable>
+
+      <xsl:choose>
+
+        <!-- Case I: The string begins with neither a number, nor an operator -->
+        <xsl:when test="$fOperAtPos1='0' and $fNumAtPos1='0'">
+          <xsl:variable name="nCharToPrint">
+            <xsl:choose>
+              <xsl:when test="ancestor::m:fName">
+                <xsl:choose>
+                  <xsl:when test="($iFirstOper=$iFirstNum) and 
+											($iFirstOper=string-length($sToParse)) and
+							                (substring($sRepOperWith-, string-length($sRepOperWith-))!='0') and 
+							                (substring($sRepOperWith-, string-length($sRepOperWith-))!='-')">
+                    <xsl:value-of select="string-length($sToParse)" />
+                  </xsl:when>
+                  <xsl:when test="$iFirstOper &lt; $iFirstNum">
+                    <xsl:value-of select="$iFirstOper - 1" />
+                  </xsl:when>
+                  <xsl:otherwise>
+                    <xsl:value-of select="$iFirstNum - 1" />
+                  </xsl:otherwise>
+                </xsl:choose>
+              </xsl:when>
+              <xsl:otherwise>1</xsl:otherwise>
+            </xsl:choose>
+          </xsl:variable>
+
+          <mml:mi>
+            <xsl:call-template name="CreateTokenAttributes">
+              <xsl:with-param name="scr" select="$scr" />
+              <xsl:with-param name="sty" select="$sty" />
+              <xsl:with-param name="nor" select="$nor" />
+              <xsl:with-param name="nCharToPrint" select="$nCharToPrint" />
+              <xsl:with-param name="sTokenType" select="'mi'" />
+            </xsl:call-template>
+            <xsl:variable name="sWrite" select="translate(substring($sToParse, 1, $nCharToPrint), ' ', '&#xa0;')" />
+            <xsl:value-of select="$sWrite" />
+          </mml:mi>
+          <xsl:call-template name="ParseMt">
+            <xsl:with-param name="sToParse" select="substring($sToParse, $nCharToPrint+1)" />
+            <xsl:with-param name="scr" select="$scr" />
+            <xsl:with-param name="sty" select="$sty" />
+            <xsl:with-param name="nor" select="$nor" />
+          </xsl:call-template>
+        </xsl:when>
+
+        <!-- Case II: There is an operator at position 1 -->
+        <xsl:when test="$fOperAtPos1='1'">
+          <mml:mo>
+            <xsl:call-template name="CreateTokenAttributes">
+              <xsl:with-param name="scr" />
+              <xsl:with-param name="sty" />
+              <xsl:with-param name="nor" select="$nor" />
+              <xsl:with-param name="sTokenType" select="'mo'" />
+            </xsl:call-template>
+            <xsl:value-of select="substring($sToParse,1,1)" />
+          </mml:mo>
+          <xsl:call-template name="ParseMt">
+            <xsl:with-param name="sToParse" select="substring($sToParse, 2)" />
+            <xsl:with-param name="scr" select="$scr" />
+            <xsl:with-param name="sty" select="$sty" />
+            <xsl:with-param name="nor" select="$nor" />
+          </xsl:call-template>
+        </xsl:when>
+
+        <!-- Case III: There is a number at position 1 -->
+        <xsl:otherwise>
+          <xsl:variable name="sConsecNum">
+            <xsl:call-template name="SNumStart">
+              <xsl:with-param name="sToParse" select="$sToParse" />
+              <xsl:with-param name="sPattern" select="$sRepNumWith0" />
+            </xsl:call-template>
+          </xsl:variable>
+          <mml:mn>
+            <xsl:call-template name="CreateTokenAttributes">
+              <xsl:with-param name="scr" select="$scr" />
+              <xsl:with-param name="sty" select="'p'" />
+              <xsl:with-param name="nor" select="$nor" />
+              <xsl:with-param name="sTokenType" select="'mn'" />
+            </xsl:call-template>
+            <xsl:value-of select="$sConsecNum" />
+          </mml:mn>
+          <xsl:call-template name="ParseMt">
+            <xsl:with-param name="sToParse" select="substring-after($sToParse, $sConsecNum)" />
+            <xsl:with-param name="scr" select="$scr" />
+            <xsl:with-param name="sty" select="$sty" />
+            <xsl:with-param name="nor" select="$nor" />
+          </xsl:call-template>
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:if>
+  </xsl:template>
+
+  <!-- %%Template: SNumStart 
+	
+		Return the longest substring of sToParse starting from the 
+		start of sToParse that is a number. In addition, it takes the
+		pattern string, which is sToParse with all of its numbers 
+		replaced with a 0. sPattern should be the same length 
+		as sToParse		
+	-->
+  <xsl:template name="SNumStart">
+    <xsl:param name="sToParse" select="''" />
+    <!-- if we don't get anything, take the string itself -->
+    <xsl:param name="sPattern" select="'$sToParse'" />
+
+
+    <xsl:choose>
+      <!-- the pattern says this is a number, recurse with the rest -->
+      <xsl:when test="substring($sPattern, 1, 1) = '0'">
+        <xsl:call-template name="SNumStart">
+          <xsl:with-param name="sToParse" select="$sToParse" />
+          <xsl:with-param name="sPattern" select="substring($sPattern, 2)" />
+        </xsl:call-template>
+      </xsl:when>
+
+      <!-- the pattern says we've run out of numbers. Take as many
+				characters from sToParse as we shaved off sPattern -->
+      <xsl:otherwise>
+        <xsl:value-of select="substring($sToParse, 1, string-length($sToParse) - string-length($sPattern))" />
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <!-- %%Template SRepeatCharAcc
+	
+			The core of SRepeatChar with an accumulator. The current
+			string is in param $acc, and we will double and recurse,
+			if we're less than half of the required length or else just 
+			add the right amount of characters to the accumulator and
+			return
+	-->
+  <xsl:template name="SRepeatCharAcc">
+    <xsl:param name="cchRequired" select="1" />
+    <xsl:param name="ch" select="'-'" />
+    <xsl:param name="acc" select="$ch" />
+
+    <xsl:variable name="cchAcc" select="string-length($acc)" />
+    <xsl:choose>
+      <xsl:when test="(2 * $cchAcc) &lt; $cchRequired">
+        <xsl:call-template name="SRepeatCharAcc">
+          <xsl:with-param name="cchRequired" select="$cchRequired" />
+          <xsl:with-param name="ch" select="$ch" />
+          <xsl:with-param name="acc" select="concat($acc, $acc)" />
+        </xsl:call-template>
+      </xsl:when>
+
+      <xsl:otherwise>
+        <xsl:value-of select="concat($acc, substring($acc, 1, $cchRequired - $cchAcc))" />
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+
+  <!-- %%Template SRepeatChar
+	
+			Generates a string nchRequired long by repeating the given character ch
+	-->
+  <xsl:template name="SRepeatChar">
+    <xsl:param name="cchRequired" select="1" />
+    <xsl:param name="ch" select="'-'" />
+
+    <xsl:call-template name="SRepeatCharAcc">
+      <xsl:with-param name="cchRequired" select="$cchRequired" />
+      <xsl:with-param name="ch" select="$ch" />
+      <xsl:with-param name="acc" select="$ch" />
+    </xsl:call-template>
+  </xsl:template>
+
+  <!-- %%Template SReplaceOperWithMinus
+	
+		Go through the given string and replace every instance
+		of an operator with a minus '-'. This helps quickly identify
+		the first instance of an operator.  
+	-->
+  <xsl:template name="SReplaceOperWithMinus">
+    <xsl:param name="sToParse" select="''" />
+
+    <xsl:value-of select="translate($sToParse, $sOperators, $sMinuses)" />
+  </xsl:template>
+
+  <!-- %%Template SReplaceNumWithZero
+	
+		Go through the given string and replace every instance
+		of an number with a zero '0'. This helps quickly identify
+		the first occurence of a number. 
+		
+		Considers the '.' and ',' part of a number iff they are sandwiched 
+		between two other numbers. 0.3 will be recognized as a number,
+		x.3 will not be. Since these characters can also be an operator, this 
+		should be called before SReplaceOperWithMinus.
+	-->
+  <xsl:template name="SReplaceNumWithZero">
+    <xsl:param name="sToParse" select="''" />
+
+    <!-- First do a simple replace. Numbers will all be come 0's.
+			After this point, the pattern involving the . or , that 
+			we are looking for will become 0.0 or 0,0 -->
+    <xsl:variable name="sSimpleReplace" select="translate($sToParse, $sNumbers, $sZeros)" />
+
+    <!-- And then, replace 0.0 with just 000. This means that the . will 
+			become part of the number -->
+    <xsl:variable name="sReplacePeriod">
+      <xsl:call-template name="SReplace">
+        <xsl:with-param name="sInput" select="$sSimpleReplace" />
+        <xsl:with-param name="sOrig" select="'0.0'" />
+        <xsl:with-param name="sReplacement" select="'000'" />
+      </xsl:call-template>
+    </xsl:variable>
+
+    <!-- And then, replace 0,0 with just 000. This means that the , will 
+			become part of the number -->
+    <xsl:call-template name="SReplace">
+      <xsl:with-param name="sInput" select="$sReplacePeriod" />
+      <xsl:with-param name="sOrig" select="'0,0'" />
+      <xsl:with-param name="sReplacement" select="'000'" />
+    </xsl:call-template>
+  </xsl:template>
+
+  <!-- Template to translate Word's borderBox properties into the menclose notation attribute
+       The initial call to this SHOULD NOT pass an sAttribute.  Subsequent calls to 
+       CreateMencloseNotationAttrFromBorderBoxAttr by CreateMencloseNotationAttrFromBorderBoxAttr will
+       update the sAttribute as appropriate.
+       
+       CreateMencloseNotationAttrFromBorderBoxAttr looks at each attribute (fHideTop, fHideBot, etc.) one at a time
+       in the order they are listed and passes a modified sAttribute to CreateMencloseNotationAttrFromBorderBoxAttr.
+       Each successive call to CreateMencloseNotationAttrFromBorderBoxAttr knows which attribute to look at because 
+       the previous call should have omitted passing the attribute it just analyzed.  This is why as you read lower 
+       and lower in the template that each call to CreateMencloseNotationAttrFromBorderBoxAttr has fewer and fewer attributes.
+       -->
+  <xsl:template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+    <xsl:param name="fHideTop" />
+    <xsl:param name="fHideBot" />
+    <xsl:param name="fHideLeft" />
+    <xsl:param name="fHideRight" />
+    <xsl:param name="fStrikeH" />
+    <xsl:param name="fStrikeV" />
+    <xsl:param name="fStrikeBLTR" />
+    <xsl:param name="fStrikeTLBR" />
+    <xsl:param name="sAttribute" />
+
+    <xsl:choose>
+      <xsl:when test="string-length($sAttribute) = 0">
+        <xsl:choose>
+          <xsl:when test="string-length($fHideTop) &gt; 0
+                      and string-length($fHideBot) &gt; 0 
+                      and string-length($fHideLeft) &gt; 0
+                      and string-length($fHideRight) &gt; 0">
+
+            <xsl:choose>
+              <xsl:when test="$fHideTop = 0 
+                              and $fHideBot = 0
+                              and $fHideLeft = 0 
+                              and $fHideRight = 0">
+                <!-- We can use 'box' instead of top, bot, left, and right.  Therefore,
+                  replace sAttribute with 'box' and begin analyzing params fStrikeH
+                  and below. -->
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute">
+                    <xsl:text>box</xsl:text>
+                  </xsl:with-param>
+                </xsl:call-template>
+              </xsl:when>
+              <xsl:otherwise>
+                <!-- Can't use 'box', theremore, must analyze all attributes -->
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fHideTop" select="$fHideTop" />
+                  <xsl:with-param name="fHideBot" select="$fHideBot" />
+                  <xsl:with-param name="fHideLeft" select="$fHideLeft" />
+                  <xsl:with-param name="fHideRight" select="$fHideRight" />
+                  <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute">
+                    <!-- Assume using all four (left right top bottom).  Subsequent calls
+                         will remove the sides which aren't to be includes. -->
+                    <xsl:text>left right top bottom</xsl:text>
+                  </xsl:with-param>
+                </xsl:call-template>
+              </xsl:otherwise>
+            </xsl:choose>
+          </xsl:when>
+        </xsl:choose>
+      </xsl:when>
+      <xsl:otherwise>
+        <xsl:choose>
+          <xsl:when test="string-length($fHideTop) &gt; 0">
+            <xsl:choose>
+              <xsl:when test="$fHideTop=1">
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fHideBot" select="$fHideBot" />
+                  <xsl:with-param name="fHideLeft" select="$fHideLeft" />
+                  <xsl:with-param name="fHideRight" select="$fHideRight" />
+                  <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute">
+                    <xsl:call-template name="SReplace">
+                      <xsl:with-param name="sInput" select="$sAttribute" />
+                      <xsl:with-param name="sOrig" select="'top'" />
+                      <xsl:with-param name="sReplacement" select="''" />
+                    </xsl:call-template>
+                  </xsl:with-param>
+                </xsl:call-template>
+              </xsl:when>
+              <xsl:otherwise>
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fHideBot" select="$fHideBot" />
+                  <xsl:with-param name="fHideLeft" select="$fHideLeft" />
+                  <xsl:with-param name="fHideRight" select="$fHideRight" />
+                  <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute" select="$sAttribute" />
+                </xsl:call-template>
+              </xsl:otherwise>
+            </xsl:choose>
+          </xsl:when>
+          <xsl:when test="string-length($fHideBot) &gt; 0">
+            <xsl:choose>
+              <xsl:when test="$fHideBot=1">
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fHideLeft" select="$fHideLeft" />
+                  <xsl:with-param name="fHideRight" select="$fHideRight" />
+                  <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute">
+                    <xsl:call-template name="SReplace">
+                      <xsl:with-param name="sInput" select="$sAttribute" />
+                      <xsl:with-param name="sOrig" select="'bottom'" />
+                      <xsl:with-param name="sReplacement" select="''" />
+                    </xsl:call-template>
+                  </xsl:with-param>
+                </xsl:call-template>
+              </xsl:when>
+              <xsl:otherwise>
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fHideLeft" select="$fHideLeft" />
+                  <xsl:with-param name="fHideRight" select="$fHideRight" />
+                  <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute" select="$sAttribute" />
+                </xsl:call-template>
+              </xsl:otherwise>
+            </xsl:choose>
+          </xsl:when>
+          <xsl:when test="string-length($fHideLeft) &gt; 0">
+            <xsl:choose>
+              <xsl:when test="$fHideLeft=1">
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fHideRight" select="$fHideRight" />
+                  <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute">
+                    <xsl:call-template name="SReplace">
+                      <xsl:with-param name="sInput" select="$sAttribute" />
+                      <xsl:with-param name="sOrig" select="'left'" />
+                      <xsl:with-param name="sReplacement" select="''" />
+                    </xsl:call-template>
+                  </xsl:with-param>
+                </xsl:call-template>
+              </xsl:when>
+              <xsl:otherwise>
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fHideRight" select="$fHideRight" />
+                  <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute" select="$sAttribute" />
+                </xsl:call-template>
+              </xsl:otherwise>
+            </xsl:choose>
+          </xsl:when>
+          <xsl:when test="string-length($fHideRight) &gt; 0">
+            <xsl:choose>
+              <xsl:when test="$fHideRight=1">
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute">
+                    <xsl:call-template name="SReplace">
+                      <xsl:with-param name="sInput" select="$sAttribute" />
+                      <xsl:with-param name="sOrig" select="'right'" />
+                      <xsl:with-param name="sReplacement" select="''" />
+                    </xsl:call-template>
+                  </xsl:with-param>
+                </xsl:call-template>
+              </xsl:when>
+              <xsl:otherwise>
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fStrikeH" select="$fStrikeH" />
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute" select="$sAttribute" />
+                </xsl:call-template>
+              </xsl:otherwise>
+            </xsl:choose>
+          </xsl:when>
+          <xsl:when test="string-length($fStrikeH) &gt; 0">
+            <xsl:choose>
+              <xsl:when test="$fStrikeH=1">
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute" select="concat($sAttribute, ' horizontalstrike')" />
+                </xsl:call-template>
+              </xsl:when>
+              <xsl:otherwise>
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fStrikeV" select="$fStrikeV" />
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute" select="$sAttribute" />
+                </xsl:call-template>
+              </xsl:otherwise>
+            </xsl:choose>
+          </xsl:when>
+          <xsl:when test="string-length($fStrikeV) &gt; 0">
+            <xsl:choose>
+              <xsl:when test="$fStrikeV=1">
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute" select="concat($sAttribute, ' verticalstrike')" />
+                </xsl:call-template>
+              </xsl:when>
+              <xsl:otherwise>
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fStrikeBLTR" select="$fStrikeBLTR" />
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute" select="$sAttribute" />
+                </xsl:call-template>
+              </xsl:otherwise>
+            </xsl:choose>
+          </xsl:when>
+          <xsl:when test="string-length($fStrikeBLTR) &gt; 0">
+            <xsl:choose>
+              <xsl:when test="$fStrikeBLTR=1">
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute" select="concat($sAttribute, ' updiagonalstrike')" />
+                </xsl:call-template>
+              </xsl:when>
+              <xsl:otherwise>
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="fStrikeTLBR" select="$fStrikeTLBR" />
+                  <xsl:with-param name="sAttribute" select="$sAttribute" />
+                </xsl:call-template>
+              </xsl:otherwise>
+            </xsl:choose>
+          </xsl:when>
+          <xsl:when test="string-length($fStrikeTLBR) &gt; 0">
+            <xsl:choose>
+              <xsl:when test="$fStrikeTLBR=1">
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="sAttribute" select="concat($sAttribute, ' downdiagonalstrike')" />
+                </xsl:call-template>
+              </xsl:when>
+              <xsl:otherwise>
+                <xsl:call-template name="CreateMencloseNotationAttrFromBorderBoxAttr">
+                  <xsl:with-param name="sAttribute" select="$sAttribute" />
+                </xsl:call-template>
+              </xsl:otherwise>
+            </xsl:choose>
+          </xsl:when>
+          <xsl:otherwise>
+            <xsl:attribute name="notation">
+              <xsl:value-of select="normalize-space($sAttribute)" />
+            </xsl:attribute>
+          </xsl:otherwise>
+        </xsl:choose>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <!-- Tristate (true, false, neither) from string value -->
+  <xsl:template name="TFromStrVal">
+    <xsl:param name="str" />
+    <xsl:choose>
+      <xsl:when test="$str = 'on' or $str = '1' or $str = 'true'">1</xsl:when>
+      <xsl:when test="$str = 'off' or $str = '0' or $str = 'false'">0</xsl:when>
+      <xsl:otherwise>-1</xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <!-- Return 0 iff $str is explicitly set to a false value.  
+       Return true otherwise -->
+  <xsl:template name="ForceFalseStrVal">
+    <xsl:param name="str" />
+    <xsl:variable name="tValue">
+      <xsl:call-template name="TFromStrVal">
+        <xsl:with-param name="str" select="$str"/>
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:choose>
+      <xsl:when test="$tValue = '0'">0</xsl:when>
+      <xsl:otherwise>1</xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <!-- Return 1 iff $str is explicitly set to a true value.  
+       Return false otherwise -->
+  <xsl:template name="ForceTrueStrVal">
+    <xsl:param name="str" />
+    <xsl:variable name="tValue">
+      <xsl:call-template name="TFromStrVal">
+        <xsl:with-param name="str" select="$str"/>
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:choose>
+      <xsl:when test="$tValue = '1'">1</xsl:when>
+      <xsl:otherwise>0</xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+</xsl:stylesheet>
diff --git a/lib/editor/atto/plugins/wordimport/pix/icon.png b/lib/editor/atto/plugins/wordimport/pix/icon.png
new file mode 100644
index 0000000000000000000000000000000000000000..5fef587ab30322934dd8a23030b207a27f5df57a
GIT binary patch
literal 678
zcmV;X0$KfuP)<h;3K|Lk000e1NJLTq000mG000mO1^@s6AM^iV0000PbVXQnQ*UN;
zcVTj606}DLVr3vnZDD6+Qe|Oed2z{QJOBU!NJ&INRCwBqQ%h?TQ561WCXWdkqeUaF
zR1HFC5Mrb*1jTH8Au1x+g$ox2sVmVx;13XlqT&-&TnN$#rRt*K!nn{bY;{u-vazMM
zYNNHyqcfS@WIX3)CS$;YXZZN;J?EZtzq$8Z<#rm<6a{Vj5=sPS*6lt?!!3@hxU)L_
zDrV#?ca3eg*yp9;KB1onUEg!Q<gp{s{ezdgc|P&z=C`lonQMqZIBO>fLvrI=>2`sS
zM+XM`^Z7iY=kGz+1BgV{%fQM?1*U0X@!2KB<8i#nJmCWSq=H7%lVDjEN~IDOhtDDq
z2uP@^ih8{+W5HlhvYRv4dw~ixyaElH#9}d&%Vqq_!r?H45a66#@&=YSBs&#w0p3m5
zbvYju1DLmay#=cd4qoK5vgylqDBxs<YcsVTj1C{hT6X5jcv=;tpbe7e7BLJ1rXlb-
z{|m>5UgPOlp@Z4aaaE847o2FCCYF|#P%IW<Rs|BVO|XmxP953~Ti9)8KgWGSc#?Qm
zzJ+G9NsXnzsMbl94VBb=n*NDhJz-2a%zlph#9wDntJP$prfID+tMD&1;a3&BeLs)A
zeVdUbP7$-8<7%CyJK*kADcOaqz^|xyH?e>{eO;1M#BBw$6<}M)YjBMk$2D_RkRlBa
zuX{J~{LTsI?PxOYd$9nV-U@UFS_@qHY&-NhBn~`Y^BU=Iv;3GsV?Pi+w-K^!{eC|Q
zu_dmiUOK|;4$h2BO^z&srIcj>LUgu@!rccS@IUt3MuBq(;*S6W0Iy*&p&3hN<NyEw
M07*qoM6N<$f&*eOlK=n!

literal 0
HcmV?d00001

diff --git a/lib/editor/atto/plugins/wordimport/pix/wordimport.png b/lib/editor/atto/plugins/wordimport/pix/wordimport.png
new file mode 100644
index 0000000000000000000000000000000000000000..8163a40f8695a40ea0b065b9ef48a923cfdedfc6
GIT binary patch
literal 1120
zcmV-m1fTnfP)<h;3K|Lk000e1NJLTq000mG000mO0{{R3C@l|D00093P)t-s00001
z0RaL60s{jB1Ox;H1qB8M1_uWR2nYxX2?+`c3JVJh3=9kn4Gj(s4i66x5D*X%5fKs+
z5)%^>6ciK{6%`g178e&67#J8C85tTH8XFrM92^`S9UUGX9v>ecARr(iAt53nA|oRs
zBqSsyB_$>%CMPE+C@3f?DJd!{Dl021EG#T7EiEoCE-x=HFfcGNF)=bSGBYzXG&D3d
zH8nOiHa9mnI5;>tIXOByIy*Z%JUl!-Jv}}?K0iM{KtMo2K|w-7LPJACL_|bIMMXwN
zMn^|SNJvOYNl8jdN=r*iOiWBoO-)WtPESuyP*6}&QBhJ-Qd3h?R8&+|RaI72R##V7
zSXfwDSy@_IT3cINTwGjTU0q&YUSD5dU|?WjVPRroVq;@tWMpJzWo2e&W@l$-XlQ6@
zX=!R|YHMq2Y;0_8ZEbFDZf|dIaBy&OadC2Ta&vQYbaZreb#-=jc6WDoczAeud3kzz
zdV70&e0+R;eSLm@et&;|fPjF3fq{a8f`fyDgoK2Jg@uNOhKGlTh=_=ZiHVAeii?Yj
zjEszpjg5|uj*pLzkdTm(k&%*;l9Q8@l$4Z}m6ev3mY0{8n3$NEnVFiJnwy)OoSdAU
zot>VZo}ZteprD|kp`oIpqNAguq@<*!rKP5(rl+T;sHmu^si~@}s;jH3tgNi9t*x%E
zuCK4Ju&}VPv9YqUva_?Zw6wIfwY9dkwzs#pxVX5vxw*Q!y1To(yu7@<y}iD^zQ4b}
zz`(%4!NJ19!o$PE#KgqK#l^<P#>dCU$jHda$;ryf%FD~k%*@Qq&CSlv&d<-!(9qD)
z(b3Y<($mw^)YR0~)z#M4*4Nk9*x1<F+1c9K+S}XP+}zyV-QC{a-rwKf;Nall;o;)q
z;^X7v<mBY#<>lt)=I7_<=;-L_>FMg~>g((4?Ck9A?d|UF?(gsK@bK{Q@$vHV^7Hfa
z^z`)g_4W4l_V@Sq`1ttw`T6?#`uqF){QUg={r&#_{{R2~;;>zP0003SNkl<Zc$@(c
z0q_0*001M3y}i7;x3#meudb~^002GT>geX<;NIKX*x1<FQUDa(-rD8i)6Ce)!obea
z(NX|y>y2&Q+-_CJazQ-F$;wgyu;`?2$j@F@sggoiz_zwh0KMh8YPYvrREwTKdY+!3
zQUJW;&19pZT3Tv}K#h`<lu`h?;Miq_cyfM8lRl+_hKW)DxZBElU{sQ%L{3ls>$QVO
z0JP4`rA|z=%t1bY|NsB~z5uby-^)iu+x9^`wg3PB|FHnC$@BDLX8r$sT<ib;|NmeB
zt<eAf|NsC0|Ns8<<@o+V0ITHx{r>;|{q*bi|MK(HJ^-rs|Ni&x@&5n&;>+3pm{0(U
my}iA?y|Ajhy}iA)y^cl3Ev??VRsF^Q0000<MNUMnLSTY$en4^n

literal 0
HcmV?d00001

diff --git a/lib/editor/atto/plugins/wordimport/settings.php b/lib/editor/atto/plugins/wordimport/settings.php
new file mode 100644
index 0000000..e0dd0b6
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/settings.php
@@ -0,0 +1,46 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Atto text editor import Microsoft Word files - settings.
+ *
+ * @package    atto_wordimport
+ * @copyright  2015 Eoin Campbell
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+$ADMIN->add('editoratto', new admin_category('atto_wordimport', new lang_string('pluginname', 'atto_wordimport')));
+
+$settings = new admin_settingpage('atto_wordimport_settings', new lang_string('settings', 'atto_wordimport'));
+
+if ($ADMIN->fulltree) {
+    // What HTML heading element should be used for the Word Heading 1 style?
+    $name = new lang_string('heading1stylelevel', 'atto_wordimport');
+    $desc = new lang_string('heading1stylelevel_desc', 'atto_wordimport');
+    $default = 3;
+    $options = array_combine(range(1, 6), array('h1', 'h2', 'h3', 'h4', 'h5', 'h6'));
+
+    $setting = new admin_setting_configselect('atto_wordimport/heading1stylelevel',
+                                              $name,
+                                              $desc,
+                                              $default,
+                                              $options);
+    $settings->add($setting);
+
+
+}
diff --git a/lib/editor/atto/plugins/wordimport/version.php b/lib/editor/atto/plugins/wordimport/version.php
new file mode 100644
index 0000000..fcd6972
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/version.php
@@ -0,0 +1,31 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Atto text editor import Microsoft Word files - version.
+ *
+ * @package    atto_wordimport
+ * @copyright  2015, 2016 Eoin Campbell
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+$plugin->version   = 2017091101;        // The current plugin version (Date: YYYYMMDDXX).
+$plugin->requires  = 2014051200;        // Requires Moodle 2.7 or higher, when Atto was added to core.
+$plugin->component = 'atto_wordimport';  // Full name of the plugin (used for diagnostics).
+$plugin->maturity  = MATURITY_STABLE;
+$plugin->release   = '1.3.5 (Build 2017091101)'; // Human readable version information.
diff --git a/lib/editor/atto/plugins/wordimport/wordml2xhtmlpass1.xsl b/lib/editor/atto/plugins/wordimport/wordml2xhtmlpass1.xsl
new file mode 100644
index 0000000..adf8ee7
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/wordml2xhtmlpass1.xsl
@@ -0,0 +1,4928 @@
+ï»¿<xsl:stylesheet
+    xmlns="http://www.w3.org/1999/xhtml"
+    xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
+    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
+    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
+    xmlns:o="urn:schemas-microsoft-com:office:office"
+    xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
+    xmlns:rels="http://schemas.openxmlformats.org/package/2006/relationships"
+    xmlns:v="urn:schemas-microsoft-com:vml"
+    xmlns:ve="http://schemas.openxmlformats.org/markup-compatibility/2006"
+    xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
+    xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml"
+    xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
+    xmlns:wx="http://schemas.microsoft.com/office/word/2003/auxHint"
+    xmlns:w10="urn:schemas-microsoft-com:office:word"
+    xmlns:xs="http://www.w3.org/2001/XMLSchema"
+
+    xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
+    xmlns:customProps="http://schemas.openxmlformats.org/officeDocument/2006/custom-properties"
+    xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
+    xmlns:dc="http://purl.org/dc/elements/1.1/"
+    xmlns:dcterms="http://purl.org/dc/terms/"
+    xmlns:dcmitype="http://purl.org/dc/dcmitype/"
+    xmlns:mml="http://www.w3.org/1998/Math/MathML"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+    exclude-result-prefixes="a cp dc dcterms dcmitype xsi o r v ve w wne wp wx w10 xs rels vt customProps"
+    version="1.0">
+    
+    <!-- This stylesheet is adapted from code by Oleg Tkachenko. The original copyright notice
+         is reproduced below -->
+    <!--
+        Copyright (c) 2004-2005, Oleg Tkachenko
+        http://www.xmllab.net
+        All rights reserved.
+
+        Redistribution and use in source and binary forms, with or without 
+        modification, are permitted provided that the following conditions are 
+        met:
+
+        1. Redistributions of source code must retain the above copyright 
+             notice, this list of conditions and the following disclaimer. 
+        2. Redistributions in binary form must reproduce the above copyright 
+             notice, this list of conditions and the following disclaimer in 
+             the documentation and/or other materials provided with the 
+             distribution. 
+        3. Neither the name of Oleg Tkachenko nor the names of its contributors
+             may be used to endorse or promote products derived from this software 
+             without specific prior written permission. 
+
+        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+        "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
+        FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
+        COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
+        INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+        BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
+        OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
+        AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
+        OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
+        THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
+        DAMAGE.
+    -->
+
+<!--
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.    If not, see <http://www.gnu.org/licenses/>.
+
+ * XSLT stylesheet to transform WordProcessingML from Word 2010 files into linear XHTML format
+ *
+ * @copyright 2004-2005, Oleg Tkachenko
+ * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later (5)
+-->
+
+    <xsl:include href="omml2mml.xsl"/>
+
+    <xsl:param name="debug_flag" select="'0'"/>
+    <xsl:param name="pluginname"/>
+    <xsl:param name="moodle_language"/>
+    <xsl:param name="moodle_textdirection"/>
+
+    <xsl:output method="xml" encoding="utf-8" indent="no" omit-xml-declaration="yes"/>
+
+    <xsl:variable name="paraStyleID_Default">Normal</xsl:variable>
+
+    <xsl:variable name="charStyleSuffix">-H</xsl:variable>
+
+    <xsl:variable name="paraMarginDefaultTop">0pt</xsl:variable>
+    <xsl:variable name="paraMarginDefaultRight">0pt</xsl:variable>
+    <xsl:variable name="paraMarginDefaultBottom">.0001pt</xsl:variable>
+    <xsl:variable name="paraMarginDefaultLeft">0pt</xsl:variable>
+
+
+    <xsl:variable name="cxtSpacing_all"></xsl:variable>
+    <xsl:variable name="cxtSpacing_top">t</xsl:variable>
+    <xsl:variable name="cxtSpacing_bottom">b</xsl:variable>
+    <xsl:variable name="cxtSpacing_none">
+        <xsl:value-of select="$cxtSpacing_top"/><xsl:value-of select="$cxtSpacing_bottom"/>
+    </xsl:variable>
+
+
+    <xsl:variable name="bdrSide_top">-top</xsl:variable>
+    <xsl:variable name="bdrSide_right">-right</xsl:variable>
+    <xsl:variable name="bdrSide_bottom">-bottom</xsl:variable>
+    <xsl:variable name="bdrSide_left">-left</xsl:variable>
+    <xsl:variable name="bdrSide_char"></xsl:variable>
+
+
+    <xsl:variable name="prrFrame">1</xsl:variable>
+    <xsl:variable name="prrDefaultCellpadding">2</xsl:variable>
+    <xsl:variable name="prrCellspacing">3</xsl:variable>
+    <xsl:variable name="prrBdrPr_top">4</xsl:variable>
+    <xsl:variable name="prrBdrPr_right">5</xsl:variable>
+    <xsl:variable name="prrBdrPr_bottom">6</xsl:variable>
+    <xsl:variable name="prrBdrPr_left">7</xsl:variable>
+    <xsl:variable name="prrBdrPr_between">8</xsl:variable>
+    <xsl:variable name="prrBdrPr_bar">9</xsl:variable>
+    <xsl:variable name="prrBdrPr_insideH">A</xsl:variable>
+    <xsl:variable name="prrBdrPr_insideV">B</xsl:variable>
+    <xsl:variable name="prrListSuff">C</xsl:variable>
+    <xsl:variable name="prrListInd">D</xsl:variable>
+    <xsl:variable name="prrApplyRPr">E</xsl:variable>
+    <xsl:variable name="prrUpdateRPr">F</xsl:variable>
+    <xsl:variable name="prrApplyTcPr">G</xsl:variable>
+    <xsl:variable name="prrCustomCellpadding">H</xsl:variable>
+    <xsl:variable name="prrCantSplit">I</xsl:variable>
+    <xsl:variable name="prrTblInd">J</xsl:variable>
+    <xsl:variable name="prrList">K</xsl:variable>
+    <xsl:variable name="prrNonList">L</xsl:variable>
+
+
+    <xsl:variable name="cnfFirstRow">firstRow</xsl:variable>
+    <xsl:variable name="cnfLastRow">lastRow</xsl:variable>
+    <xsl:variable name="cnfFirstCol">firstCol</xsl:variable>
+    <xsl:variable name="cnfLastCol">lastCol</xsl:variable>
+    <xsl:variable name="cnfBand1Vert">band1Vert</xsl:variable>
+    <xsl:variable name="cnfBand2Vert">band2Vert</xsl:variable>
+    <xsl:variable name="cnfBand1Horz">band1Horz</xsl:variable>
+    <xsl:variable name="cnfBand2Horz">band2Horz</xsl:variable>
+    <xsl:variable name="cnfNECell">neCell</xsl:variable>
+    <xsl:variable name="cnfNWCell">nwCell</xsl:variable>
+    <xsl:variable name="cnfSECell">seCell</xsl:variable>
+    <xsl:variable name="cnfSWCell">swCell</xsl:variable>
+
+
+    <xsl:variable name="icnfFirstRow">1</xsl:variable>
+    <xsl:variable name="icnfLastRow">2</xsl:variable>
+    <xsl:variable name="icnfFirstCol">3</xsl:variable>
+    <xsl:variable name="icnfLastCol">4</xsl:variable>
+    <xsl:variable name="icnfBand1Vert">5</xsl:variable>
+    <xsl:variable name="icnfBand2Vert">6</xsl:variable>
+    <xsl:variable name="icnfBand1Horz">7</xsl:variable>
+    <xsl:variable name="icnfBand2Horz">8</xsl:variable>
+    <xsl:variable name="icnfNECell">9</xsl:variable>
+    <xsl:variable name="icnfNWCell">10</xsl:variable>
+    <xsl:variable name="icnfSECell">11</xsl:variable>
+    <xsl:variable name="icnfSWCell">12</xsl:variable>
+
+
+    <xsl:variable name="off">0</xsl:variable>
+    <xsl:variable name="on">1</xsl:variable>
+    <xsl:variable name="na">2</xsl:variable>
+
+
+    <xsl:variable name="sep">/</xsl:variable>
+    <xsl:variable name="sep1">|</xsl:variable>
+    <xsl:variable name="sep2">,</xsl:variable>
+
+
+    <xsl:variable name="autoColor_hex">auto</xsl:variable>
+    <xsl:variable name="autoColor_text">windowtext</xsl:variable>
+    <xsl:variable name="autoColor_bg">transparent</xsl:variable>
+
+
+    <xsl:variable name="transparentColor_hex">transparent</xsl:variable>
+    <xsl:variable name="transparentColor_text">transparent</xsl:variable>
+    <xsl:variable name="transparentColor_bg">transparent</xsl:variable>
+
+
+    <xsl:variable name="prListSuff_space">Space</xsl:variable>
+    <xsl:variable name="prListSuff_nothing">Nothing</xsl:variable>
+
+
+    <xsl:variable name="hyperLinks" select="//documentLinks/rels:Relationships/*[contains(@Type, 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink')]"/>
+    <xsl:variable name="imageLinks" select="//documentLinks/rels:Relationships/*[contains(@Type, 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image')]"/>
+    <xsl:variable name="customProps" select="//customProps/*"/>
+    <xsl:variable name="dublinCore" select="//dublinCore/cp:coreProperties"/>
+    <xsl:variable name="imagesContainer" select="//imagesContainer"/>
+
+    <xsl:variable name="nsStyles" select="//styleMap/w:styles[1]/w:style"/>
+    <xsl:variable name="ndLists" select="//wordmlContainer/w:document[1]/w:lists[1]|//w:cfChunk/w:lists"/>
+    <xsl:variable name="ndDocPr" select="//wordmlContainer/w:document[1]/w:docPr[1]"/>
+    <xsl:variable name="ndDocInfo" select="//wordmlContainer/w:document[1]/w:docInfo[1]"/>
+    <xsl:variable name="ndOfficeDocPr" select="//wordmlContainer/w:document[1]/o:DocumentProperties[1]"/>
+
+
+    <xsl:variable name="lowercase" select="'abcdefghijklmnopqrstuvwxyz'" />
+    <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'" />
+    <!-- Output a newline before paras and cells when debugging turned on -->
+    <xsl:variable name="debug_newline">
+        <xsl:if test="$debug_flag &gt;= '1'">
+            <xsl:value-of select="'&#x0a;'"/>
+        </xsl:if>
+    </xsl:variable>
+
+    <xsl:variable name="pixelsPerInch">
+        <xsl:choose>
+            <xsl:when test="$ndDocPr/w:pixelsPerInch/@w:val">
+                <xsl:value-of select="$ndDocPr/w:pixelsPerInch/@w:val"/>
+            </xsl:when>
+            <xsl:otherwise>96</xsl:otherwise>
+        </xsl:choose>
+    </xsl:variable>
+
+
+    <xsl:variable name="nfcBullet">23</xsl:variable>
+
+
+    <xsl:variable name="iEmbossImprint">1</xsl:variable>
+    <xsl:variable name="iU_Em">2</xsl:variable>
+    <xsl:variable name="iStrikeDStrike">3</xsl:variable>
+    <xsl:variable name="iSup">4</xsl:variable>
+    <xsl:variable name="iSub">5</xsl:variable>
+    <xsl:variable name="iVanishWebHidden">6</xsl:variable>
+    <xsl:variable name="iBCs">7</xsl:variable>
+    <xsl:variable name="iICs">8</xsl:variable>
+    <xsl:variable name="ISzCs">9</xsl:variable>
+
+
+    <xsl:variable name="iTextAutospaceO">1</xsl:variable>
+    <xsl:variable name="iTextAutospaceN">2</xsl:variable>
+    <xsl:variable name="iInd">3</xsl:variable>
+
+
+    <xsl:variable name="prsRDefault">
+        <xsl:value-of select="$na"/>
+        <xsl:value-of select="$na"/>
+        <xsl:value-of select="$na"/>
+        <xsl:value-of select="$na"/>
+        <xsl:value-of select="$na"/>
+        <xsl:value-of select="$na"/>
+        <xsl:value-of select="$na"/>
+        <xsl:value-of select="$na"/>
+        <xsl:value-of select="$na"/>
+    </xsl:variable>
+
+    <xsl:variable name="prsPDefault">
+        <xsl:value-of select="$na"/><xsl:value-of select="$na"/>
+    </xsl:variable>
+
+
+    <xsl:variable name="footnoteRefLink" select="'ftnref_'"/>
+    <xsl:variable name="footnoteLink" select="'ftn_'"/>
+    <xsl:variable name="endnoteRefLink" select="'ednref_'"/>
+    <xsl:variable name="endnoteLink" select="'edn_'"/>
+
+    <xsl:template name="ConvertHexToDec">
+        <xsl:param name="value"/>
+        <xsl:param name="i" select="1"/>
+        <xsl:param name="s" select="1"/>
+        <xsl:variable name="hexDigit" select="substring($value,$i,1)"/>
+        <xsl:if test="not($hexDigit = '')">
+            <xsl:text> </xsl:text>
+            <xsl:choose>
+                <xsl:when test="$hexDigit = 'A'">10</xsl:when>
+                <xsl:when test="$hexDigit = 'B'">11</xsl:when>
+                <xsl:when test="$hexDigit = 'C'">12</xsl:when>
+                <xsl:when test="$hexDigit = 'D'">13</xsl:when>
+                <xsl:when test="$hexDigit = 'E'">14</xsl:when>
+                <xsl:when test="$hexDigit = 'F'">15</xsl:when>
+                <xsl:otherwise><xsl:value-of select="$hexDigit"/></xsl:otherwise>
+            </xsl:choose>
+            <xsl:call-template name="ConvertHexToDec">
+                <xsl:with-param name="value" select="$value"/>
+                <xsl:with-param name="i" select="$i+$s"/>
+                <xsl:with-param name="s" select="$s"/>
+            </xsl:call-template>
+        </xsl:if>
+    </xsl:template>
+
+
+    <xsl:template name="ConvBorderStyle">
+        <xsl:param name="value"/>
+        <xsl:choose>
+            <xsl:when test="$value='none' or $value='nil'">none</xsl:when>
+            <xsl:when test="$value='single'">solid</xsl:when>
+            <xsl:when test="contains($value,'stroke')">solid</xsl:when>
+            <xsl:when test="$value='dashed'">dashed</xsl:when>
+            <xsl:when test="contains($value,'dash')">dashed</xsl:when>
+            <xsl:when test="$value='double'">double</xsl:when>
+            <xsl:when test="$value='triple'">double</xsl:when>
+            <xsl:when test="contains($value,'double')">double</xsl:when>
+            <xsl:when test="contains($value,'gap')">double</xsl:when>
+            <xsl:when test="$value='dotted'">dotted</xsl:when>
+            <xsl:when test="$value='three-d-emboss'">ridge</xsl:when>
+            <xsl:when test="$value='three-d-engrave'">groove</xsl:when>
+            <xsl:when test="$value='outset'">outset</xsl:when>
+            <xsl:when test="$value='inset'">inset</xsl:when>
+            <xsl:otherwise>solid</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template name="ConvBorderWidth">
+        <xsl:param name="value"/>
+        <xsl:choose>
+            <xsl:when test="$value='none'">0</xsl:when>
+            <xsl:when test="$value='solid'">1</xsl:when>
+            <xsl:when test="$value='dashed'">1</xsl:when>
+            <xsl:when test="$value='double'">3</xsl:when>
+            <xsl:when test="$value='dotted'">1</xsl:when>
+            <xsl:otherwise>1</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="EvalTableWidth">
+        <xsl:choose>
+            <xsl:when test="@w:type = 'auto'">auto</xsl:when>
+            <xsl:when test="@w:type = 'pct'"><xsl:value-of select="@w:w div 50"/>%</xsl:when>
+            <xsl:otherwise><xsl:value-of select="@w:w div 20"/>pt</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="ConvColor">
+        <xsl:param name="value"/>
+        <xsl:choose>
+            <xsl:when test="$value='black'">black</xsl:when>
+            <xsl:when test="$value='blue'">blue</xsl:when>
+            <xsl:when test="$value='cyan'">aqua</xsl:when>
+            <xsl:when test="$value='green'">lime</xsl:when>
+            <xsl:when test="$value='magenta'">fuchsia</xsl:when>
+            <xsl:when test="$value='red'">red</xsl:when>
+            <xsl:when test="$value='yellow'">yellow</xsl:when>
+            <xsl:when test="$value='white'">white</xsl:when>
+            <xsl:when test="$value='dark-blue'">navy</xsl:when>
+            <xsl:when test="$value='dark-cyan'">teal</xsl:when>
+            <xsl:when test="$value='dark-green'">green</xsl:when>
+            <xsl:when test="$value='dark-magenta'">purple</xsl:when>
+            <xsl:when test="$value='dark-red'">maroon</xsl:when>
+            <xsl:when test="$value='dark-yellow'">olive</xsl:when>
+            <xsl:when test="$value='dark-gray'">gray</xsl:when>
+            <xsl:when test="$value='light-gray'">silver</xsl:when>
+            <xsl:when test="$value='none'">transparent</xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="ConvHexColor">
+        <xsl:param name="value"/>
+        <xsl:param name="autoColor" select="$autoColor_text"/>
+        <xsl:param name="transparentColor">transparent</xsl:param>
+        <xsl:choose>
+            <xsl:when test="$value = $autoColor_hex or $value = ''">
+                <xsl:value-of select="$autoColor"/>
+            </xsl:when>
+            <xsl:when test="$value = $transparentColor_hex">
+                <xsl:value-of select="$transparentColor"/>
+            </xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="concat('#',$value)"/>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="EvalBooleanType">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'off' or @w:val = 'none'  or @w:val = '0'"><xsl:value-of select="$off"/></xsl:when>
+            <xsl:otherwise><xsl:value-of select="$on"/></xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="GetBorderPr">
+            <xsl:value-of select="@w:val"/><xsl:value-of select="$sep2"/>
+            <xsl:value-of select="@w:color"/><xsl:value-of select="$sep2"/>
+            <xsl:text>0</xsl:text>
+            <xsl:value-of select="$sep2"/>
+            <xsl:value-of select="@w:space"/><xsl:value-of select="$sep2"/>
+            <xsl:value-of select="@w:shadow"/>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyBorderPr">
+        <xsl:param name="pr.bdr"/>
+        <xsl:param name="bdrSide" select="$bdrSide_char"/>
+        <xsl:if test="not($pr.bdr='')">
+            <xsl:text>border</xsl:text><xsl:value-of select="$bdrSide"/><xsl:text>:</xsl:text>
+            <xsl:variable name="borderStyle">
+                <xsl:call-template name="ConvBorderStyle">
+                    <xsl:with-param name="value" select="substring-before($pr.bdr,$sep2)"/>
+                </xsl:call-template>
+            </xsl:variable>
+            <xsl:value-of select="$borderStyle"/>
+            <xsl:variable name="temp" select="substring-after($pr.bdr,$sep2)"/>
+            <xsl:text> </xsl:text>
+            <xsl:call-template name="ConvHexColor">
+                <xsl:with-param name="value" select="substring-before($temp,$sep2)"/>
+            </xsl:call-template>
+            <xsl:text> </xsl:text>
+            <!--<xsl:value-of select="substring-before(substring-after($temp,$sep2),$sep2) div 20"/><xsl:text>pt;</xsl:text>-->
+            <xsl:call-template name="ConvBorderWidth">
+                <xsl:with-param name="value" select="$borderStyle"/>
+            </xsl:call-template>
+            <xsl:text>px;</xsl:text>
+            <xsl:if test="$bdrSide = $bdrSide_char">padding:0;</xsl:if>
+        </xsl:if>
+    </xsl:template>
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    <xsl:template name="ApplyTextDirection">
+        <xsl:text>layout-flow:</xsl:text>
+        <xsl:choose>
+            <xsl:when test="@w:val = 'tb-rl-v'">vertical-ideographic</xsl:when>
+            <xsl:when test="@w:val = 'lr-tb-v'">horizontal-ideographic</xsl:when>
+            <xsl:otherwise>normal</xsl:otherwise>
+        </xsl:choose>
+        <xsl:text>;</xsl:text>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyCellMar">
+        <xsl:choose>
+            <xsl:when test="@w:val='none'">none</xsl:when>
+            <xsl:otherwise>
+                <xsl:text>padding:</xsl:text>
+                <xsl:choose><xsl:when test="w:top"><xsl:for-each select="w:top[1]"><xsl:call-template name="EvalTableWidth"/></xsl:for-each></xsl:when><xsl:otherwise>0</xsl:otherwise></xsl:choose><xsl:text> </xsl:text>
+                <xsl:choose><xsl:when test="w:right"><xsl:for-each select="w:right[1]"><xsl:call-template name="EvalTableWidth"/></xsl:for-each></xsl:when><xsl:otherwise>0</xsl:otherwise></xsl:choose><xsl:text> </xsl:text>
+                <xsl:choose><xsl:when test="w:bottom"><xsl:for-each select="w:bottom[1]"><xsl:call-template name="EvalTableWidth"/></xsl:for-each></xsl:when><xsl:otherwise>0</xsl:otherwise></xsl:choose><xsl:text> </xsl:text>
+                <xsl:choose><xsl:when test="w:left"><xsl:for-each select="w:left[1]"><xsl:call-template name="EvalTableWidth"/></xsl:for-each></xsl:when><xsl:otherwise>0</xsl:otherwise></xsl:choose><xsl:text>;</xsl:text>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+
+
+    <xsl:template name="PrsUpdatePPr">
+        <xsl:param name="prsP" select="$prsPDefault"/>
+        <xsl:param name="ndPrContainer" select="."/>
+
+        <xsl:variable name="prsPTemp">
+            <xsl:for-each select="$ndPrContainer">
+                <xsl:call-template name="PrsUpdatePPrCore">
+                    <xsl:with-param name="prsP" select="$prsP"/>
+                </xsl:call-template>
+            </xsl:for-each>
+        </xsl:variable>
+        <xsl:choose>
+            <xsl:when test="$prsPTemp=''">
+                <xsl:value-of select="$prsP"/>
+            </xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="$prsPTemp"/>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+
+    <xsl:template name="FetchBasedOnPropertyBoolean">
+            <xsl:param name="match" select="''"/>
+
+            <xsl:choose>
+                    <xsl:when test="$match">
+                            <xsl:for-each select="$match">
+                                    <xsl:call-template name="EvalBooleanType"/>
+                            </xsl:for-each>
+                    </xsl:when>
+                    <xsl:when test="../w:basedOn">
+                            <xsl:variable name="sBasedOn">
+                                    <xsl:value-of select="../w:basedOn/@w:val"/>
+                            </xsl:variable>
+                            <xsl:for-each select="$nsStyles[@w:styleId=$sBasedOn]">
+                                    <xsl:call-template name="FetchBasedOnPropertyBoolean"><xsl:with-param name="match" select="$match"/></xsl:call-template>
+                            </xsl:for-each>
+                    </xsl:when>
+                    <xsl:otherwise>
+                            <xsl:value-of select="$na"/>
+                    </xsl:otherwise>
+            </xsl:choose>
+    </xsl:template>
+
+    <xsl:variable name="fbopModeIndentLeft" select="'1'"/>
+    <xsl:variable name="fbopModeIndentLeftChars" select="'2'"/>
+    <xsl:variable name="fbopModeIndentRight" select="'3'"/>
+    <xsl:variable name="fbopModeIndentRightChars" select="'4'"/>
+    <xsl:variable name="fbopModeIndentHanging" select="'5'"/>
+    <xsl:variable name="fbopModeIndentHangingChars" select="'6'"/>
+    <xsl:variable name="fbopModeIndentFirstLine" select="'7'"/>
+    <xsl:variable name="fbopModeIndentFirstLineChars" select="'8'"/>
+
+    <xsl:template name="FetchBasedOnProperty">
+            <xsl:param name="mode" select="''"/>
+            <xsl:param name="sDefault" select="''"/>
+
+            <xsl:variable name="sValue">
+                    <xsl:choose>
+                            <xsl:when test="$mode=$fbopModeIndentLeft">
+                                    <xsl:value-of select="w:ind[1]/@w:left"/>
+                            </xsl:when>
+                            <xsl:when test="$mode=$fbopModeIndentLeftChars">
+                                    <xsl:value-of select="w:ind[1]/@w:left-chars"/>
+                            </xsl:when>
+                            <xsl:when test="$mode=$fbopModeIndentRight">
+                                    <xsl:value-of select="w:ind[1]/@w:right"/>
+                            </xsl:when>
+                            <xsl:when test="$mode=$fbopModeIndentRightChars">
+                                    <xsl:value-of select="w:ind[1]/@w:right-chars"/>
+                            </xsl:when>
+                            <xsl:when test="$mode=$fbopModeIndentHanging">
+                                    <xsl:value-of select="w:ind[1]/@w:hanging"/>
+                            </xsl:when>
+                            <xsl:when test="$mode=$fbopModeIndentHangingChars">
+                                    <xsl:value-of select="w:ind[1]/@w:hanging-chars"/>
+                            </xsl:when>
+                            <xsl:when test="$mode=$fbopModeIndentFirstLine">
+                                    <xsl:value-of select="w:ind[1]/@w:first-line"/>
+                            </xsl:when>
+                            <xsl:when test="$mode=$fbopModeIndentFirstLineChars">
+                                    <xsl:value-of select="w:ind[1]/@w:first-line-chars"/>
+                            </xsl:when>
+                            <xsl:otherwise>
+                                    <xsl:text></xsl:text>
+                            </xsl:otherwise>
+                    </xsl:choose>
+            </xsl:variable>
+
+            <xsl:choose>
+                    <xsl:when test="not($sValue='')">
+                            <xsl:value-of select="$sValue"/>
+                    </xsl:when>
+                    <xsl:when test="../w:basedOn">
+                            <xsl:variable name="sBasedOn">
+                                    <xsl:value-of select="../w:basedOn/@w:val"/>
+                            </xsl:variable>
+                            <xsl:for-each select="$nsStyles[@w:styleId=$sBasedOn]/w:pPr[1]">
+                                    <xsl:call-template name="FetchBasedOnProperty"><xsl:with-param name="mode" select="$mode"/></xsl:call-template>
+                            </xsl:for-each>
+                    </xsl:when>
+                    <xsl:otherwise>
+                            <xsl:value-of select="$sDefault"/>
+                    </xsl:otherwise>
+            </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="PrsUpdatePPrCore">
+        <xsl:param name="prsP" select="$prsPDefault"/>
+        <xsl:for-each select="w:pPr[1]">
+
+            <xsl:variable name="fTextAutospaceO">
+
+                <xsl:for-each select="w:autoSpaceDE[1]">
+                    <xsl:call-template name="EvalBooleanType"/>
+                </xsl:for-each>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="$fTextAutospaceO=''">
+                    <xsl:value-of select="substring($prsP, $iTextAutospaceO, 1)"/>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:value-of select="$fTextAutospaceO"/>
+                </xsl:otherwise>
+            </xsl:choose>
+
+
+            <xsl:variable name="fTextAutospaceN">
+                <xsl:for-each select="w:autoSpaceDN[1]">
+                    <xsl:call-template name="EvalBooleanType"/>
+                </xsl:for-each>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="$fTextAutospaceN=''">
+                    <xsl:value-of select="substring($prsP, $iTextAutospaceN, 1)"/>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:value-of select="$fTextAutospaceN"/>
+                </xsl:otherwise>
+            </xsl:choose>
+
+
+                    <xsl:variable name="prsDefaultInd" select="substring($prsP, $iInd)"/>
+                    <xsl:variable name="sDefLeft" select="substring-before($prsDefaultInd,$sep2)"/><xsl:variable name="temp1" select="substring-after($prsDefaultInd,$sep2)"/>
+                    <xsl:variable name="sDefLeftChars" select="substring-before($temp1,$sep2)"/><xsl:variable name="temp2" select="substring-after($temp1,$sep2)"/>
+                    <xsl:variable name="sDefRight" select="substring-before($temp2,$sep2)"/><xsl:variable name="temp3" select="substring-after($temp2,$sep2)"/>
+                    <xsl:variable name="sDefRightChars" select="substring-before($temp3,$sep2)"/><xsl:variable name="temp4" select="substring-after($temp3,$sep2)"/>
+                    <xsl:variable name="sDefHanging" select="substring-before($temp4,$sep2)"/><xsl:variable name="temp5" select="substring-after($temp4,$sep2)"/>
+                    <xsl:variable name="sDefHangingChars" select="substring-before($temp5,$sep2)"/><xsl:variable name="temp6" select="substring-after($temp5,$sep2)"/>
+                    <xsl:variable name="sDefFirstLine" select="substring-before($temp6,$sep2)"/>
+                    <xsl:variable name="sDefFirstLineChars" select="substring-after($temp6,$sep2)"/>
+
+            <xsl:variable name="nInd">
+
+                            <xsl:call-template name="FetchBasedOnProperty">
+                                    <xsl:with-param name="mode" select="$fbopModeIndentLeft"/>
+                                    <xsl:with-param name="sDefault" select="$sDefLeft"/>
+                            </xsl:call-template>
+
+                            <xsl:value-of select="$sep2"/>
+
+                            <xsl:call-template name="FetchBasedOnProperty">
+                                    <xsl:with-param name="mode" select="$fbopModeIndentLeftChars"/>
+                                    <xsl:with-param name="sDefault" select="$sDefLeftChars"/>
+                            </xsl:call-template>
+
+                            <xsl:value-of select="$sep2"/>
+
+                            <xsl:call-template name="FetchBasedOnProperty">
+                                    <xsl:with-param name="mode" select="$fbopModeIndentRight"/>
+                                    <xsl:with-param name="sDefault" select="$sDefRight"/>
+                            </xsl:call-template>
+
+                            <xsl:value-of select="$sep2"/>
+
+                            <xsl:call-template name="FetchBasedOnProperty">
+                                    <xsl:with-param name="mode" select="$fbopModeIndentRightChars"/>
+                                    <xsl:with-param name="sDefault" select="$sDefRightChars"/>
+                            </xsl:call-template>
+
+                            <xsl:value-of select="$sep2"/>
+
+                            <xsl:call-template name="FetchBasedOnProperty">
+                                    <xsl:with-param name="mode" select="$fbopModeIndentHanging"/>
+                                    <xsl:with-param name="sDefault" select="$sDefHanging"/>
+                            </xsl:call-template>
+
+                            <xsl:value-of select="$sep2"/>
+
+                            <xsl:call-template name="FetchBasedOnProperty">
+                                    <xsl:with-param name="mode" select="$fbopModeIndentHangingChars"/>
+                                    <xsl:with-param name="sDefault" select="$sDefHangingChars"/>
+                            </xsl:call-template>
+
+                            <xsl:value-of select="$sep2"/>
+
+                            <xsl:call-template name="FetchBasedOnProperty">
+                                    <xsl:with-param name="mode" select="$fbopModeIndentFirstLine"/>
+                                    <xsl:with-param name="sDefault" select="$sDefFirstLine"/>
+                            </xsl:call-template>
+
+                            <xsl:value-of select="$sep2"/>
+
+                            <xsl:call-template name="FetchBasedOnProperty">
+                                    <xsl:with-param name="mode" select="$fbopModeIndentFirstLineChars"/>
+                                    <xsl:with-param name="sDefault" select="$sDefFirstLineChars"/>
+                            </xsl:call-template>
+
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="$nInd=''">
+                    <xsl:value-of select="substring($prsP, $iInd)"/>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:value-of select="$nInd"/>
+                </xsl:otherwise>
+            </xsl:choose>
+        </xsl:for-each>
+    </xsl:template>
+
+
+
+    <xsl:template name="PrsUpdateRPr">
+        <xsl:param name="prsR" select="$prsRDefault"/>
+        <xsl:param name="ndPrContainer" select="."/>
+        <xsl:variable name="prsRTemp">
+            <xsl:for-each select="$ndPrContainer">
+                <xsl:call-template name="PrsUpdateRPrCore">
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:call-template>
+            </xsl:for-each>
+        </xsl:variable>
+        <xsl:choose>
+            <xsl:when test="$prsRTemp=''">
+                <xsl:value-of select="$prsR"/>
+            </xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="$prsRTemp"/>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+
+    <xsl:template name="PrsUpdateRPrCore">
+        <xsl:param name="prsR" select="$prsRDefault"/>
+        <xsl:param name="type" select="$prrNonList"/>
+
+        <xsl:for-each select="w:rPr[1]">
+
+            <xsl:variable name="fEmbossImprint">
+                <xsl:variable name="condition1"><xsl:for-each select="w:emboss[1]"><xsl:call-template name="EvalBooleanType"/></xsl:for-each></xsl:variable>
+                <xsl:variable name="condition2"><xsl:for-each select="w:imprint[1]"><xsl:call-template name="EvalBooleanType"/></xsl:for-each></xsl:variable>
+                <xsl:choose>
+                    <xsl:when test="$condition1 = $on or $condition2 = $on">
+                        <xsl:value-of select="$on"/>
+                    </xsl:when>
+                    <xsl:when test="$condition1 = $off or $condition2 = $off">
+                        <xsl:value-of select="$off"/>
+                    </xsl:when>
+                </xsl:choose>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="$fEmbossImprint = ''"><xsl:value-of select="substring($prsR,$iEmbossImprint,1)"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$fEmbossImprint"/></xsl:otherwise>
+            </xsl:choose>
+
+
+            <xsl:variable name="fU_Em">
+                <xsl:variable name="condition1"><xsl:for-each select="w:u[1]"><xsl:call-template name="EvalBooleanType"/></xsl:for-each></xsl:variable>
+                <xsl:variable name="condition2"><xsl:for-each select="w:em[1]"><xsl:call-template name="EvalBooleanType"/></xsl:for-each></xsl:variable>
+                <xsl:choose><xsl:when test="$condition1 = $on or $condition2 = $on"><xsl:value-of select="$on"/></xsl:when><xsl:when test="$condition1 = $off or $condition2 = $off"><xsl:value-of select="$off"/></xsl:when></xsl:choose>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="$fU_Em = ''">
+                    <xsl:choose>
+                        <xsl:when test="$type=$prrList">
+                            <xsl:value-of select="$off"/>
+                        </xsl:when>
+                        <xsl:otherwise>
+                            <xsl:value-of select="substring($prsR,$iU_Em,1)"/>
+                        </xsl:otherwise>
+                    </xsl:choose>
+                </xsl:when>
+                <xsl:otherwise><xsl:value-of select="$fU_Em"/></xsl:otherwise>
+            </xsl:choose>
+
+            <xsl:variable name="fStrikeDStrike">
+                <xsl:variable name="condition1"><xsl:for-each select="w:strike[1]"><xsl:call-template name="EvalBooleanType"/></xsl:for-each></xsl:variable>
+                <xsl:variable name="condition2"><xsl:for-each select="w:dstrike[1]"><xsl:call-template name="EvalBooleanType"/></xsl:for-each></xsl:variable>
+                <xsl:choose><xsl:when test="$condition1 = $on or $condition2 = $on"><xsl:value-of select="$on"/></xsl:when><xsl:when test="$condition1 = $off or $condition2 = $off"><xsl:value-of select="$off"/></xsl:when></xsl:choose>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="$fStrikeDStrike = ''"><xsl:value-of select="substring($prsR,$iStrikeDStrike,1)"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$fStrikeDStrike"/></xsl:otherwise>
+            </xsl:choose>
+
+
+
+
+            <xsl:variable name="fSup">
+                <xsl:choose>
+                    <xsl:when test="w:vertAlign/@w:val='superscript'"><xsl:value-of select="$on"/></xsl:when>
+                    <xsl:otherwise><xsl:value-of select="$off"/></xsl:otherwise>
+                </xsl:choose>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="not(w:vertAlign)"><xsl:value-of select="substring($prsR,$iSup,1)"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$fSup"/></xsl:otherwise>
+            </xsl:choose>
+
+            <xsl:variable name="fSub">
+                <xsl:choose>
+                    <xsl:when test="w:vertAlign/@w:val='subscript'"><xsl:value-of select="$on"/></xsl:when>
+                    <xsl:otherwise><xsl:value-of select="$off"/></xsl:otherwise>
+                </xsl:choose>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="not(w:vertAlign)"><xsl:value-of select="substring($prsR,$iSub,1)"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$fSub"/></xsl:otherwise>
+            </xsl:choose>
+
+            <xsl:variable name="fVanishWebHidden">
+                <xsl:variable name="condition1"><xsl:for-each select="w:vanish[1]"><xsl:call-template name="EvalBooleanType"/></xsl:for-each></xsl:variable>
+                <xsl:variable name="condition2"><xsl:for-each select="w:webHidden[1]"><xsl:call-template name="EvalBooleanType"/></xsl:for-each></xsl:variable>
+                <xsl:choose><xsl:when test="$condition1 = $on or $condition2 = $on"><xsl:value-of select="$on"/></xsl:when><xsl:when test="$condition1 = $off or $condition2 = $off"><xsl:value-of select="$off"/></xsl:when></xsl:choose>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="$fVanishWebHidden = ''"><xsl:value-of select="substring($prsR,$iVanishWebHidden,1)"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$fVanishWebHidden"/></xsl:otherwise>
+            </xsl:choose>
+
+            <xsl:variable name="fBCs">
+                <xsl:for-each select="w:bCs[1]"><xsl:call-template name="EvalBooleanType"/></xsl:for-each>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="$fBCs = ''"><xsl:value-of select="substring($prsR,$iBCs,1)"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$fBCs"/></xsl:otherwise>
+            </xsl:choose>
+
+            <xsl:variable name="fICs">
+                <xsl:for-each select="w:i-cs[1]"><xsl:call-template name="EvalBooleanType"/></xsl:for-each>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="$fICs = ''"><xsl:value-of select="substring($prsR,$iICs,1)"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$fICs"/></xsl:otherwise>
+            </xsl:choose>
+
+            <xsl:variable name="nSzCs" select="string(w:sz-cs[1]/@w:val)"/>
+            <xsl:choose>
+                <xsl:when test="$nSzCs = ''"><xsl:value-of select="substring($prsR,$ISzCs)"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$nSzCs"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:for-each>
+    </xsl:template>
+
+    <xsl:template name="GetSinglePPr">
+        <xsl:param name="type"/>
+        <xsl:param name="sParaStyleName"/>
+
+        <xsl:variable name="result">
+            <xsl:call-template name="GetSinglePPrCore">
+                <xsl:with-param name="type" select="$type"/>
+            </xsl:call-template>
+        </xsl:variable>
+
+        <xsl:if test="$result=''">
+            <xsl:for-each select="$sParaStyleName">
+                <xsl:call-template name="GetSinglePPrCore">
+                    <xsl:with-param name="type" select="$type"/>
+                </xsl:call-template>
+            </xsl:for-each>
+        </xsl:if>
+        <xsl:value-of select="$result"/>
+    </xsl:template>
+
+    <xsl:template name="GetSinglePPrCore">
+        <xsl:param name="type"/>
+        <xsl:for-each select="w:pPr[1]">
+            <xsl:choose>
+                <xsl:when test="$type = $prrBdrPr_top">
+                    <xsl:for-each select="w:bdr[1]/w:top[1]">
+                        <xsl:call-template name="GetBorderPr"/>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrBdrPr_right">
+                    <xsl:for-each select="w:bdr[1]/w:right[1]">
+                        <xsl:call-template name="GetBorderPr"/>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrBdrPr_bottom">
+                    <xsl:for-each select="w:bdr[1]/w:bottom[1]">
+                        <xsl:call-template name="GetBorderPr"/>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrBdrPr_left">
+                    <xsl:for-each select="w:bdr[1]/w:left[1]">
+                        <xsl:call-template name="GetBorderPr"/>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrBdrPr_between">
+                    <xsl:for-each select="w:bdr[1]/w:between[1]">
+                        <xsl:call-template name="GetBorderPr"/>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrBdrPr_bar">
+                    <xsl:for-each select="w:bdr[1]/w:bar[1]">
+                        <xsl:call-template name="GetBorderPr"/>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrFrame">
+                    <xsl:for-each select="w:framePr[1]">
+                        <xsl:value-of select="@w:w"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:h"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:h-rule"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:x-align"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:vspace"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:hspace"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:wrap"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:drop-cap"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:lines"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:x"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:y-align"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:y"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:hanchor"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:vanchor"/><xsl:value-of select="$sep2"/>
+                        <xsl:value-of select="@w:anchor-lock"/>
+                    </xsl:for-each>
+                </xsl:when>
+            </xsl:choose>
+        </xsl:for-each>
+    </xsl:template>
+
+
+    <xsl:template name="GetSingleTblPr">
+        <xsl:param name="type"/>
+        <xsl:param name="sTblStyleName"/>
+        <xsl:variable name="result">
+            <xsl:call-template name="GetSingleTblPrCore">
+                <xsl:with-param name="type" select="$type"/>
+            </xsl:call-template>
+        </xsl:variable>
+
+        <xsl:if test="$result='' and $sTblStyleName">
+            <xsl:for-each select="$sTblStyleName">
+                <xsl:call-template name="GetSingleTblPrCore"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+            </xsl:for-each>
+        </xsl:if>
+        <xsl:value-of select="$result"/>
+    </xsl:template>
+
+    <xsl:template name="GetSingleTblPrCore">
+        <xsl:param name="type"/>
+        <xsl:for-each select="w:tblPr[1]">
+            <xsl:choose>
+                <xsl:when test="$type = $prrBdrPr_top">
+                    <xsl:for-each select="w:tblBorders[1]/w:top[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrBdrPr_left">
+                    <xsl:for-each select="w:tblBorders[1]/w:left[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrBdrPr_bottom">
+                    <xsl:for-each select="w:tblBorders[1]/w:bottom[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrBdrPr_right">
+                    <xsl:for-each select="w:tblBorders[1]/w:right[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrBdrPr_insideH">
+                    <xsl:for-each select="w:tblBorders[1]/w:insideH[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrBdrPr_insideV">
+                    <xsl:for-each select="w:tblBorders[1]/w:insideV[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrDefaultCellpadding">
+                    <xsl:for-each select="w:tblCellMar[1]"><xsl:call-template name="ApplyCellMar"/></xsl:for-each>
+                </xsl:when>
+                <xsl:when test="$type = $prrCellspacing">
+                    <xsl:value-of select="w:tblCellSpacing[1]/@w:w"/>
+                </xsl:when>
+                <xsl:when test="$type = $prrTblInd">
+                    <xsl:for-each select="w:tblInd[1]">
+                        <xsl:call-template name="EvalTableWidth"/>
+                    </xsl:for-each>
+                </xsl:when>
+            </xsl:choose>
+        </xsl:for-each>
+    </xsl:template>
+
+
+
+
+    <xsl:template name="WrapCnf">
+        <xsl:param name="sTblStyleName"/>
+        <xsl:param name="cnfCol"/>
+        <xsl:param name="cnfRow"/>
+        <xsl:param name="prsPAccum"/>
+        <xsl:param name="prsP"/>
+        <xsl:param name="prsR"/>
+
+        <xsl:choose>
+
+            <xsl:when test="substring($cnfRow,$icnfBand1Horz,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfBand1Horz][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfBand1Horz)}">
+                <xsl:call-template name="WrapCnf.a">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/>
+                </xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:when test="substring($cnfRow,$icnfBand2Horz,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfBand2Horz][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfBand2Horz)}">
+                <xsl:call-template name="WrapCnf.a">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/>
+                </xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:otherwise>
+
+                <xsl:call-template name="WrapCnf.a">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/><xsl:with-param name="prsP" select="$prsP"/><xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:call-template>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+    <xsl:template name="WrapCnf.a">
+        <xsl:param name="sTblStyleName"/><xsl:param name="cnfCol"/><xsl:param name="cnfRow"/>
+        <xsl:param name="prsPAccum"/><xsl:param name="prsP"/><xsl:param name="prsR"/>
+        <xsl:choose>
+
+            <xsl:when test="substring($cnfCol,$icnfBand1Vert,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfBand1Vert][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfBand1Vert)}">
+                <xsl:call-template name="WrapCnf.b">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/>
+                </xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:when test="substring($cnfCol,$icnfBand2Vert,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfBand2Vert][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfBand2Vert)}">
+                <xsl:call-template name="WrapCnf.b">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/>
+                </xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:otherwise>
+
+                <xsl:call-template name="WrapCnf.b">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/><xsl:with-param name="prsP" select="$prsP"/><xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:call-template>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+    <xsl:template name="WrapCnf.b">
+        <xsl:param name="sTblStyleName"/><xsl:param name="cnfCol"/><xsl:param name="cnfRow"/>
+        <xsl:param name="prsPAccum"/><xsl:param name="prsP"/><xsl:param name="prsR"/>
+        <xsl:choose>
+
+            <xsl:when test="substring($cnfCol,$icnfFirstCol,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfFirstCol][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfFirstCol)}">
+                <xsl:call-template name="WrapCnf.c">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/>
+                </xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:when test="substring($cnfCol,$icnfLastCol,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfLastCol][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfLastCol)}">
+                <xsl:call-template name="WrapCnf.c">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/>
+                </xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:otherwise>
+
+                <xsl:call-template name="WrapCnf.c">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/><xsl:with-param name="prsP" select="$prsP"/><xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:call-template>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+    <xsl:template name="WrapCnf.c">
+        <xsl:param name="sTblStyleName"/><xsl:param name="cnfCol"/><xsl:param name="cnfRow"/>
+        <xsl:param name="prsPAccum"/><xsl:param name="prsP"/><xsl:param name="prsR"/>
+        <xsl:choose>
+
+            <xsl:when test="substring($cnfRow,$icnfFirstRow,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfFirstRow][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfFirstRow)}">
+                <xsl:call-template name="WrapCnf.d">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/>
+                </xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:when test="substring($cnfRow,$icnfLastRow,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfLastRow][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfLastRow)}">
+                <xsl:call-template name="WrapCnf.d">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/>
+                </xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:otherwise>
+
+                <xsl:call-template name="WrapCnf.d">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/><xsl:with-param name="prsP" select="$prsP"/><xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:call-template>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+    <xsl:template name="WrapCnf.d">
+        <xsl:param name="sTblStyleName"/><xsl:param name="cnfCol"/><xsl:param name="cnfRow"/>
+        <xsl:param name="prsPAccum"/><xsl:param name="prsP"/><xsl:param name="prsR"/>
+        <xsl:choose>
+
+            <xsl:when test="substring($cnfCol,$icnfNECell,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfNECell][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfNECell)}">
+                <xsl:call-template name="DisplayBodyContent"><xsl:with-param name="ns.content" select="*"/><xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/></xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:when test="substring($cnfCol,$icnfNWCell,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfNWCell][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfNWCell)}">
+                <xsl:call-template name="DisplayBodyContent"><xsl:with-param name="ns.content" select="*"/><xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/></xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:when test="substring($cnfCol,$icnfSECell,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfSECell][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfSECell)}">
+                <xsl:call-template name="DisplayBodyContent"><xsl:with-param name="ns.content" select="*"/><xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/></xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:when test="substring($cnfCol,$icnfSWCell,1)=$on">
+                <xsl:variable name="p.cnfType" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfSWCell][1]"/>
+
+                <xsl:variable name="prsP.updated">
+                    <xsl:call-template name="PrsUpdatePPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsP" select="$prsP"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsR.updated">
+                    <xsl:call-template name="PrsUpdateRPr"><xsl:with-param name="ndPrContainer" select="$p.cnfType"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:variable>
+                <xsl:variable name="prsPAccum.updated">
+                    <xsl:value-of select="$prsPAccum"/><xsl:for-each select="$p.cnfType"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+                </xsl:variable>
+
+                <div class="{concat($sTblStyleName/@w:styleId,'-',$cnfSWCell)}">
+                <xsl:call-template name="DisplayBodyContent"><xsl:with-param name="ns.content" select="*"/><xsl:with-param name="prsPAccum" select="$prsPAccum.updated"/><xsl:with-param name="prsP" select="$prsP.updated"/><xsl:with-param name="prsR" select="$prsR.updated"/></xsl:call-template>
+                </div>
+            </xsl:when>
+
+            <xsl:otherwise>
+
+                <xsl:call-template name="DisplayBodyContent"><xsl:with-param name="ns.content" select="*"/><xsl:with-param name="prsPAccum" select="$prsPAccum"/><xsl:with-param name="prsP" select="$prsP"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="GetCnfPr.all">
+        <xsl:param name="type"/><xsl:param name="cnfCol"/><xsl:param name="cnfRow"/>
+        <xsl:choose>
+            <xsl:when test="substring($cnfRow,$icnfBand1Horz,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfBand1Horz][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+            <xsl:when test="substring($cnfRow,$icnfBand2Horz,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfBand2Horz][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+        </xsl:choose>
+        <xsl:choose>
+            <xsl:when test="substring($cnfCol,$icnfBand1Vert,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfBand1Vert][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfBand2Vert,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfBand2Vert][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+        </xsl:choose>
+        <xsl:choose>
+            <xsl:when test="substring($cnfCol,$icnfFirstCol,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfFirstCol][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfLastCol,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfLastCol][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+        </xsl:choose>
+        <xsl:choose>
+            <xsl:when test="substring($cnfRow,$icnfFirstRow,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfFirstRow][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+            <xsl:when test="substring($cnfRow,$icnfLastRow,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfLastRow][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+        </xsl:choose>
+        <xsl:choose>
+            <xsl:when test="substring($cnfCol,$icnfNECell,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfNECell][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfNWCell,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfNWCell][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfSECell,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfSECell][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfSWCell,1)=$on">
+                <xsl:for-each select="w:tblStylePr[@w:type=$cnfSWCell][1]">
+                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+
+
+
+    <xsl:template name="GetCnfPr.cell">
+        <xsl:param name="type"/><xsl:param name="cnfCol"/><xsl:param name="cnfRow"/>
+        <xsl:variable name="result1">
+            <xsl:choose>
+                <xsl:when test="substring($cnfCol,$icnfNECell,1)=$on">
+                    <xsl:for-each select="w:tblStylePr[@w:type=$cnfNECell][1]">
+                        <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="substring($cnfCol,$icnfNWCell,1)=$on">
+                    <xsl:for-each select="w:tblStylePr[@w:type=$cnfNWCell][1]">
+                        <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="substring($cnfCol,$icnfSECell,1)=$on">
+                    <xsl:for-each select="w:tblStylePr[@w:type=$cnfSECell][1]">
+                        <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="substring($cnfCol,$icnfSWCell,1)=$on">
+                    <xsl:for-each select="w:tblStylePr[@w:type=$cnfSWCell][1]">
+                        <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                    </xsl:for-each>
+                </xsl:when>
+            </xsl:choose>
+        </xsl:variable>
+        <xsl:value-of select="$result1"/>
+        <xsl:if test="$result1=''">
+            <xsl:variable name="result2">
+                <xsl:choose>
+                    <xsl:when test="substring($cnfRow,$icnfFirstRow,1)=$on">
+                        <xsl:for-each select="w:tblStylePr[@w:type=$cnfFirstRow][1]">
+                            <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                        </xsl:for-each>
+                    </xsl:when>
+                    <xsl:when test="substring($cnfRow,$icnfLastRow,1)=$on">
+                        <xsl:for-each select="w:tblStylePr[@w:type=$cnfLastRow][1]">
+                            <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                        </xsl:for-each>
+                    </xsl:when>
+                </xsl:choose>
+            </xsl:variable>
+            <xsl:value-of select="$result2"/>
+            <xsl:if test="$result2=''">
+                <xsl:variable name="result3">
+                    <xsl:choose>
+                        <xsl:when test="substring($cnfCol,$icnfFirstCol,1)=$on">
+                            <xsl:for-each select="w:tblStylePr[@w:type=$cnfFirstCol][1]">
+                                <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                            </xsl:for-each>
+                        </xsl:when>
+                        <xsl:when test="substring($cnfCol,$icnfLastCol,1)=$on">
+                            <xsl:for-each select="w:tblStylePr[@w:type=$cnfLastCol][1]">
+                                <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                            </xsl:for-each>
+                        </xsl:when>
+                    </xsl:choose>
+                </xsl:variable>
+                <xsl:value-of select="$result3"/>
+                <xsl:if test="$result3=''">
+                    <xsl:variable name="result4">
+                        <xsl:choose>
+                            <xsl:when test="substring($cnfCol,$icnfBand1Vert,1)=$on">
+                                <xsl:for-each select="w:tblStylePr[@w:type=$cnfBand1Vert][1]">
+                                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                                </xsl:for-each>
+                            </xsl:when>
+                            <xsl:when test="substring($cnfCol,$icnfBand2Vert,1)=$on">
+                                <xsl:for-each select="w:tblStylePr[@w:type=$cnfBand2Vert][1]">
+                                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                                </xsl:for-each>
+                            </xsl:when>
+                        </xsl:choose>
+                    </xsl:variable>
+                    <xsl:value-of select="$result4"/>
+                    <xsl:if test="$result4=''">
+                        <xsl:choose>
+                            <xsl:when test="substring($cnfRow,$icnfBand1Horz,1)=$on">
+                                <xsl:for-each select="w:tblStylePr[@w:type=$cnfBand1Horz][1]">
+                                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                                </xsl:for-each>
+                            </xsl:when>
+                            <xsl:when test="substring($cnfRow,$icnfBand2Horz,1)=$on">
+                                <xsl:for-each select="w:tblStylePr[@w:type=$cnfBand2Horz][1]">
+                                    <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                                </xsl:for-each>
+                            </xsl:when>
+                        </xsl:choose>
+                    </xsl:if>
+                </xsl:if>
+            </xsl:if>
+        </xsl:if>
+    </xsl:template>
+
+
+
+
+    <xsl:template name="GetCnfPr.row">
+        <xsl:param name="type"/><xsl:param name="cnfRow"/>
+        <xsl:variable name="result1">
+            <xsl:choose>
+                <xsl:when test="substring($cnfRow,$icnfFirstRow,1)=$on">
+                    <xsl:for-each select="w:tblStylePr[@w:type=$cnfFirstRow][1]">
+                        <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="substring($cnfRow,$icnfLastRow,1)=$on">
+                    <xsl:for-each select="w:tblStylePr[@w:type=$cnfLastRow][1]">
+                        <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                    </xsl:for-each>
+                </xsl:when>
+            </xsl:choose>
+        </xsl:variable>
+        <xsl:value-of select="$result1"/>
+        <xsl:if test="$result1=''">
+            <xsl:choose>
+                <xsl:when test="substring($cnfRow,$icnfBand1Horz,1)=$on">
+                    <xsl:for-each select="w:tblStylePr[@w:type=$cnfBand1Horz][1]">
+                        <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="substring($cnfRow,$icnfBand2Horz,1)=$on">
+                    <xsl:for-each select="w:tblStylePr[@w:type=$cnfBand2Horz][1]">
+                        <xsl:call-template name="GetCnfPr.a"><xsl:with-param name="type" select="$type"/></xsl:call-template>
+                    </xsl:for-each>
+                </xsl:when>
+            </xsl:choose>
+        </xsl:if>
+    </xsl:template>
+
+
+    <xsl:template name="GetCnfPr.a">
+        <xsl:param name="type"/>
+        <xsl:choose>
+            <xsl:when test="$type = $prrApplyTcPr">
+                <xsl:call-template name="ApplyTcPr.class"/>
+            </xsl:when>
+            <xsl:when test="$type = $prrCustomCellpadding">
+                <xsl:for-each select="w:tcPr[1]/w:tcMar[1]"><xsl:call-template name="ApplyCellMar"/></xsl:for-each>
+            </xsl:when>
+            <xsl:when test="$type = $prrDefaultCellpadding">
+                <xsl:for-each select="w:tblPr[1]/w:tblCellMar[1]"><xsl:call-template name="ApplyCellMar"/></xsl:for-each>
+            </xsl:when>
+            <xsl:when test="$type = $prrCantSplit">
+                <xsl:for-each select="w:trPr[1]/w:cantSplit[1]">
+                    <xsl:choose>
+                        <xsl:when test="@w:val = 'off'">page-break-inside:auto;</xsl:when>
+                        <xsl:otherwise>page-break-inside:avoid;</xsl:otherwise>
+                    </xsl:choose>
+                </xsl:for-each>
+            </xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="GetCnfType">
+        <xsl:param name="cnfCol"/><xsl:param name="cnfRow"/>
+        <xsl:choose>
+            <xsl:when test="substring($cnfCol,$icnfNECell,1)=$on">
+                <xsl:value-of select="$cnfNECell"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfNWCell,1)=$on">
+                <xsl:value-of select="$cnfNWCell"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfSECell,1)=$on">
+                <xsl:value-of select="$cnfSECell"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfSWCell,1)=$on">
+                <xsl:value-of select="$cnfSWCell"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfRow,$icnfFirstRow,1)=$on">
+                <xsl:value-of select="$cnfFirstRow"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfRow,$icnfLastRow,1)=$on">
+                <xsl:value-of select="$cnfLastRow"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfFirstCol,1)=$on">
+                <xsl:value-of select="$cnfFirstCol"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfLastCol,1)=$on">
+                <xsl:value-of select="$cnfLastCol"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfBand1Vert,1)=$on">
+                <xsl:value-of select="$cnfBand1Vert"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfBand2Vert,1)=$on">
+                <xsl:value-of select="$cnfBand2Vert"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfRow,$icnfBand1Horz,1)=$on">
+                <xsl:value-of select="$cnfBand1Horz"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfRow,$icnfBand2Horz,1)=$on">
+                <xsl:value-of select="$cnfBand2Horz"/>
+            </xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="GetCnfTypeRow">
+        <xsl:param name="cnfRow"/>
+        <xsl:choose>
+            <xsl:when test="substring($cnfRow,$icnfFirstRow,1)=$on">
+                <xsl:value-of select="$cnfFirstRow"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfRow,$icnfLastRow,1)=$on">
+                <xsl:value-of select="$cnfLastRow"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfRow,$icnfBand1Horz,1)=$on">
+                <xsl:value-of select="$cnfBand1Horz"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfRow,$icnfBand2Horz,1)=$on">
+                <xsl:value-of select="$cnfBand2Horz"/>
+            </xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template name="GetCnfTypeCol">
+        <xsl:param name="cnfCol"/>
+        <xsl:choose>
+            <xsl:when test="substring($cnfCol,$icnfNECell,1)=$on">
+                <xsl:value-of select="$cnfNECell"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfNWCell,1)=$on">
+                <xsl:value-of select="$cnfNWCell"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfSECell,1)=$on">
+                <xsl:value-of select="$cnfSECell"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfSWCell,1)=$on">
+                <xsl:value-of select="$cnfSWCell"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfFirstCol,1)=$on">
+                <xsl:value-of select="$cnfFirstCol"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfLastCol,1)=$on">
+                <xsl:value-of select="$cnfLastCol"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfBand1Vert,1)=$on">
+                <xsl:value-of select="$cnfBand1Vert"/>
+            </xsl:when>
+            <xsl:when test="substring($cnfCol,$icnfBand2Vert,1)=$on">
+                <xsl:value-of select="$cnfBand2Vert"/>
+            </xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+
+
+
+    <xsl:template name="RecursiveRStyledGetBorderPr">
+        <xsl:param name="rStyleId"/>
+
+        <xsl:variable name="myStyle" select="($nsStyles[@w:styleId=$rStyleId])[1]" />
+
+        <xsl:if test="not($rStyleId='')">
+            <xsl:choose>
+                <xsl:when test="$myStyle/w:rPr[1]/w:bdr[1]">
+                    <xsl:for-each select="$myStyle/w:rPr[1]/w:bdr[1]">
+                        <xsl:call-template name="GetBorderPr"/>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:if test="$myStyle/w:basedOn">
+                        <xsl:call-template name="RecursiveRStyledGetBorderPr">
+                            <xsl:with-param name="rStyleId" select="$myStyle/w:basedOn/@w:val" />
+                        </xsl:call-template>
+                    </xsl:if>
+                </xsl:otherwise>
+            </xsl:choose>
+
+
+        </xsl:if>
+    </xsl:template>
+
+
+    <xsl:template name="DisplayRBorder">
+        <xsl:param name="ns.content" select="*"/>
+        <xsl:param name="i.range.start" select="1"/>
+        <xsl:param name="i.this" select="number($i.range.start)"/>
+        <xsl:param name="pr.bdr.prev" select="''"/>
+        <xsl:param name="b.bidi"/>
+        <xsl:param name="prsR"/>
+        <xsl:choose>
+
+            <xsl:when test="($ns.content)[$i.this]">
+                <xsl:for-each select="($ns.content)[$i.this]">
+                    <xsl:choose>
+
+                        <xsl:when test="name() = 'w:proofErr' or (name() = 'aml:annotation' and not(@w:type = 'Word.Insertion'))">
+                            <xsl:call-template name="DisplayRBorder">
+                                <xsl:with-param name="ns.content" select="$ns.content"/>
+                                <xsl:with-param name="i.range.start" select="$i.range.start"/>
+                                <xsl:with-param name="i.this" select="$i.this+1"/>
+                                <xsl:with-param name="pr.bdr.prev" select="$pr.bdr.prev"/>
+                                <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                                <xsl:with-param name="prsR" select="$prsR"/>
+                            </xsl:call-template>
+                        </xsl:when>
+                        <xsl:otherwise>
+
+                            <xsl:variable name="pr.bdr.this">
+                                <xsl:choose>
+
+                                    <xsl:when test="name()='aml:annotation'"/>
+
+
+                                    <xsl:otherwise>
+
+                                        <xsl:for-each select="descendant-or-self::*[name()='w:pPr' or name()='w:r'][1]">
+                                            <xsl:choose>
+                                                <xsl:when test="w:rPr[1]/w:bdr[1]">
+                                                    <xsl:for-each select="w:rPr[1]/w:bdr[1]">
+                                                        <xsl:call-template name="GetBorderPr"/>
+                                                    </xsl:for-each>
+                                                </xsl:when>
+
+
+                                                <xsl:otherwise>
+                                                    <xsl:call-template name="RecursiveRStyledGetBorderPr">
+                                                        <xsl:with-param name="rStyleId" select="w:rPr[1]/w:rStyle[1]/@w:val" />
+                                                    </xsl:call-template>
+                                                </xsl:otherwise>
+                                            </xsl:choose>
+                                        </xsl:for-each>
+                                    </xsl:otherwise>
+                                </xsl:choose>
+                            </xsl:variable>
+                            <xsl:choose>
+
+                                <xsl:when test="$pr.bdr.prev = $pr.bdr.this">
+
+                                    <xsl:call-template name="DisplayRBorder">
+                                        <xsl:with-param name="ns.content" select="$ns.content"/>
+                                        <xsl:with-param name="i.range.start" select="$i.range.start"/>
+                                        <xsl:with-param name="i.this" select="$i.this+1"/>
+                                        <xsl:with-param name="pr.bdr.prev" select="$pr.bdr.prev"/>
+                                        <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                                        <xsl:with-param name="prsR" select="$prsR"/>
+                                    </xsl:call-template>
+                                </xsl:when>
+
+                                <xsl:otherwise>
+
+                                    <xsl:call-template name="WrapRBorder">
+                                        <xsl:with-param name="ns.content" select="$ns.content"/>
+                                        <xsl:with-param name="i.bdrRange.start" select="$i.range.start"/>
+                                        <xsl:with-param name="i.bdrRange.end" select="$i.this"/>
+                                        <xsl:with-param name="pr.bdr" select="$pr.bdr.prev"/>
+                                        <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                                        <xsl:with-param name="prsR" select="$prsR"/>
+                                    </xsl:call-template>
+
+                                    <xsl:call-template name="DisplayRBorder">
+                                        <xsl:with-param name="ns.content" select="$ns.content"/>
+                                        <xsl:with-param name="i.range.start" select="$i.this"/>
+                                        <xsl:with-param name="i.this" select="$i.this+1"/>
+                                        <xsl:with-param name="pr.bdr.prev" select="$pr.bdr.this"/>
+                                        <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                                        <xsl:with-param name="prsR" select="$prsR"/>
+                                    </xsl:call-template>
+                                </xsl:otherwise>
+                            </xsl:choose>
+                        </xsl:otherwise>
+                    </xsl:choose>
+                </xsl:for-each>
+            </xsl:when>
+
+            <xsl:otherwise>
+
+                <xsl:call-template name="WrapRBorder">
+                    <xsl:with-param name="ns.content" select="$ns.content"/>
+                    <xsl:with-param name="i.bdrRange.start" select="$i.range.start"/>
+                    <xsl:with-param name="i.bdrRange.end" select="$i.this"/>
+                    <xsl:with-param name="pr.bdr" select="$pr.bdr.prev"/>
+                    <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:call-template>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="WrapRBorder">
+        <xsl:param name="ns.content"/>
+        <xsl:param name="i.bdrRange.start"/>
+        <xsl:param name="i.bdrRange.end"/>
+        <xsl:param name="pr.bdr"/>
+        <xsl:param name="b.bidi"/>
+        <xsl:param name="prsR"/>
+        <xsl:choose>
+
+            <xsl:when test="$pr.bdr = ''">
+                <xsl:apply-templates select="($ns.content)[position() &gt;= $i.bdrRange.start and position() &lt; $i.bdrRange.end]">
+                    <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:apply-templates>
+            </xsl:when>
+
+            <xsl:otherwise>
+                <span>
+                <xsl:attribute name="style">
+                    <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$pr.bdr"/></xsl:call-template>
+                </xsl:attribute>
+                <xsl:apply-templates select="($ns.content)[position() &gt;= $i.bdrRange.start and position() &lt; $i.bdrRange.end]">
+                    <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:apply-templates>
+                </span>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="DisplayPBorderOld">
+        <xsl:param name="pr.frame.prev"/>
+        <xsl:param name="pr.bdrTop.prev"/>
+        <xsl:param name="pr.bdrLeft.prev"/>
+        <xsl:param name="pr.bdrBottom.prev"/>
+        <xsl:param name="pr.bdrRight.prev"/>
+        <xsl:param name="pr.bdrBetween.prev"/>
+        <xsl:param name="pr.bdrBar.prev"/>
+        <xsl:param name="ns.content"/>
+        <xsl:param name="i.range.start" select="1"/>
+        <xsl:param name="i.this" select="number($i.range.start)"/>
+        <xsl:param name="prsPAccum"/>
+        <xsl:param name="prsP"/>
+        <xsl:param name="prsR"/>
+        <xsl:choose>
+
+            <xsl:when test="($ns.content)[$i.this]">
+                <xsl:for-each select="($ns.content)[$i.this]">
+                    <xsl:variable name="pstyle">
+                        <xsl:call-template name="GetPStyleId"/>
+                    </xsl:variable>
+                    <xsl:variable name="sParaStyleName" select="($nsStyles[@w:styleId=$pstyle])[1]"/>
+
+                    <xsl:variable name="pr.frame.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrFrame"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrTop.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_top"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrLeft.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_left"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrBottom.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_bottom"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrRight.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_right"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrBetween.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_between"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrBar.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_bar"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:choose>
+
+                        <xsl:when test="0 = 1 and $pr.frame.prev = $pr.frame.this and $pr.bdrTop.prev = $pr.bdrTop.this and $pr.bdrLeft.prev = $pr.bdrLeft.this and $pr.bdrBottom.prev = $pr.bdrBottom.this and $pr.bdrRight.prev = $pr.bdrRight.this and $pr.bdrBetween.prev = $pr.bdrBetween.this and $pr.bdrBar.prev = $pr.bdrBar.this">
+                            <xsl:call-template name="DisplayPBorder">
+                                <xsl:with-param name="ns.content" select="$ns.content"/>
+                                <xsl:with-param name="i.range.start" select="$i.range.start"/>
+                                <xsl:with-param name="i.this" select="$i.this+1"/>
+                                <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                                <xsl:with-param name="prsP" select="$prsP"/>
+                                <xsl:with-param name="prsR" select="$prsR"/>
+                                <xsl:with-param name="pr.frame.prev" select="$pr.frame.prev"/>
+                                <xsl:with-param name="pr.bdrTop.prev" select="$pr.bdrTop.prev"/>
+                                <xsl:with-param name="pr.bdrLeft.prev" select="$pr.bdrLeft.prev"/>
+                                <xsl:with-param name="pr.bdrBottom.prev" select="$pr.bdrBottom.prev"/>
+                                <xsl:with-param name="pr.bdrRight.prev" select="$pr.bdrRight.prev"/>
+                                <xsl:with-param name="pr.bdrBetween.prev" select="$pr.bdrBetween.prev"/>
+                                <xsl:with-param name="pr.bdrBar.prev" select="$pr.bdrBar.prev"/>
+                            </xsl:call-template>
+                        </xsl:when>
+
+                        <xsl:otherwise>
+
+                            <xsl:call-template name="wrapFrame">
+                                <xsl:with-param name="ns.content" select="$ns.content"/>
+                                <xsl:with-param name="i.bdrRange.start" select="$i.range.start"/>
+                                <xsl:with-param name="i.bdrRange.end" select="$i.this"/>
+                                <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                                <xsl:with-param name="prsP" select="$prsP"/>
+                                <xsl:with-param name="prsR" select="$prsR"/>
+                                <xsl:with-param name="framePr" select="$pr.frame.prev"/>
+                                <xsl:with-param name="pr.bdrTop" select="$pr.bdrTop.prev"/>
+                                <xsl:with-param name="pr.bdrLeft" select="$pr.bdrLeft.prev"/>
+                                <xsl:with-param name="pr.bdrBottom" select="$pr.bdrBottom.prev"/>
+                                <xsl:with-param name="pr.bdrRight" select="$pr.bdrRight.prev"/>
+                                <xsl:with-param name="pr.bdrBetween" select="$pr.bdrBetween.prev"/>
+                                <xsl:with-param name="pr.bdrBar" select="$pr.bdrBar.prev"/>
+                            </xsl:call-template>
+
+                            <xsl:call-template name="DisplayPBorder">
+                                <xsl:with-param name="ns.content" select="$ns.content"/>
+                                <xsl:with-param name="i.range.start" select="$i.this"/>
+                                <xsl:with-param name="i.this" select="$i.this+1"/>
+                                <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                                <xsl:with-param name="prsP" select="$prsP"/>
+                                <xsl:with-param name="prsR" select="$prsR"/>
+                                <xsl:with-param name="pr.frame.prev" select="$pr.frame.this"/>
+                                <xsl:with-param name="pr.bdrTop.prev" select="$pr.bdrTop.this"/>
+                                <xsl:with-param name="pr.bdrLeft.prev" select="$pr.bdrLeft.this"/>
+                                <xsl:with-param name="pr.bdrBottom.prev" select="$pr.bdrBottom.this"/>
+                                <xsl:with-param name="pr.bdrRight.prev" select="$pr.bdrRight.this"/>
+                                <xsl:with-param name="pr.bdrBetween.prev" select="$pr.bdrBetween.this"/>
+                                <xsl:with-param name="pr.bdrBar.prev" select="$pr.bdrBar.this"/>
+                            </xsl:call-template>
+                        </xsl:otherwise>
+                    </xsl:choose>
+                </xsl:for-each>
+            </xsl:when>
+
+            <xsl:otherwise>
+                <xsl:call-template name="wrapFrame">
+                    <xsl:with-param name="ns.content" select="$ns.content"/>
+                    <xsl:with-param name="i.bdrRange.start" select="$i.range.start"/>
+                    <xsl:with-param name="i.bdrRange.end" select="$i.this"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                    <xsl:with-param name="prsP" select="$prsP"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                    <xsl:with-param name="framePr" select="$pr.frame.prev"/>
+                    <xsl:with-param name="pr.bdrTop" select="$pr.bdrTop.prev"/>
+                    <xsl:with-param name="pr.bdrLeft" select="$pr.bdrLeft.prev"/>
+                    <xsl:with-param name="pr.bdrBottom" select="$pr.bdrBottom.prev"/>
+                    <xsl:with-param name="pr.bdrRight" select="$pr.bdrRight.prev"/>
+                    <xsl:with-param name="pr.bdrBetween" select="$pr.bdrBetween.prev"/>
+                    <xsl:with-param name="pr.bdrBar" select="$pr.bdrBar.prev"/>
+                </xsl:call-template>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template name="DisplayPBorder">
+        <xsl:param name="pr.frame.prev"/>
+        <xsl:param name="pr.bdrTop.prev"/>
+        <xsl:param name="pr.bdrLeft.prev"/>
+        <xsl:param name="pr.bdrBottom.prev"/>
+        <xsl:param name="pr.bdrRight.prev"/>
+        <xsl:param name="pr.bdrBetween.prev"/>
+        <xsl:param name="pr.bdrBar.prev"/>
+        <xsl:param name="ns.content"/>
+        <xsl:param name="i.range.start" select="1"/>
+        <xsl:param name="i.this" select="number($i.range.start)"/>
+        <xsl:param name="prsPAccum"/>
+        <xsl:param name="prsP"/>
+        <xsl:param name="prsR"/>
+        <xsl:choose>
+
+            <xsl:when test="($ns.content)[$i.this]">
+                <xsl:for-each select="($ns.content)">
+
+                    <xsl:variable name="pstyle">
+                        <xsl:call-template name="GetPStyleId"/>
+                    </xsl:variable>
+                    <xsl:variable name="sParaStyleName" select="($nsStyles[@w:styleId=$pstyle])[1]"/>
+
+                    <xsl:variable name="pr.frame.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrFrame"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrTop.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_top"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrLeft.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_left"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrBottom.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_bottom"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrRight.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_right"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrBetween.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_between"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+                    <xsl:variable name="pr.bdrBar.this">
+                        <xsl:call-template name="GetSinglePPr"><xsl:with-param name="type" select="$prrBdrPr_bar"/><xsl:with-param name="sParaStyleName" select="$sParaStyleName"/></xsl:call-template>
+                    </xsl:variable>
+
+                            <xsl:call-template name="wrapFrame">
+                                <xsl:with-param name="ns.content" select="."/>
+                                <xsl:with-param name="i.bdrRange.start" select="1"/>
+                                <xsl:with-param name="i.bdrRange.end" select="2"/>
+                                <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                                <xsl:with-param name="prsP" select="$prsP"/>
+                                <xsl:with-param name="prsR" select="$prsR"/>
+                                <xsl:with-param name="framePr" select="$pr.frame.prev"/>
+                                <xsl:with-param name="pr.bdrTop" select="$pr.bdrTop.prev"/>
+                                <xsl:with-param name="pr.bdrLeft" select="$pr.bdrLeft.prev"/>
+                                <xsl:with-param name="pr.bdrBottom" select="$pr.bdrBottom.prev"/>
+                                <xsl:with-param name="pr.bdrRight" select="$pr.bdrRight.prev"/>
+                                <xsl:with-param name="pr.bdrBetween" select="$pr.bdrBetween.prev"/>
+                                <xsl:with-param name="pr.bdrBar" select="$pr.bdrBar.prev"/>
+                            </xsl:call-template>
+                </xsl:for-each>
+
+            </xsl:when>
+
+            <xsl:otherwise>
+                <xsl:call-template name="wrapFrame">
+                    <xsl:with-param name="ns.content" select="$ns.content"/>
+                    <xsl:with-param name="i.bdrRange.start" select="$i.range.start"/>
+                    <xsl:with-param name="i.bdrRange.end" select="$i.this"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                    <xsl:with-param name="prsP" select="$prsP"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                    <xsl:with-param name="framePr" select="$pr.frame.prev"/>
+                    <xsl:with-param name="pr.bdrTop" select="$pr.bdrTop.prev"/>
+                    <xsl:with-param name="pr.bdrLeft" select="$pr.bdrLeft.prev"/>
+                    <xsl:with-param name="pr.bdrBottom" select="$pr.bdrBottom.prev"/>
+                    <xsl:with-param name="pr.bdrRight" select="$pr.bdrRight.prev"/>
+                    <xsl:with-param name="pr.bdrBetween" select="$pr.bdrBetween.prev"/>
+                    <xsl:with-param name="pr.bdrBar" select="$pr.bdrBar.prev"/>
+                </xsl:call-template>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="wrapFrame">
+        <xsl:param name="framePr"/>
+        <xsl:param name="pr.bdrTop"/><xsl:param name="pr.bdrLeft"/><xsl:param name="pr.bdrBottom"/><xsl:param name="pr.bdrRight"/><xsl:param name="pr.bdrBetween"/><xsl:param name="pr.bdrBar"/>
+        <xsl:param name="ns.content"/>
+        <xsl:param name="i.bdrRange.start"/>
+        <xsl:param name="i.bdrRange.end"/>
+        <xsl:param name="prsPAccum"/>
+        <xsl:param name="prsP"/>
+        <xsl:param name="prsR"/>
+        <xsl:choose>
+
+            <xsl:when test="$framePr = ''">
+                <xsl:call-template name="wrapPBdr">
+                    <xsl:with-param name="ns.content" select="$ns.content"/>
+                    <xsl:with-param name="i.bdrRange.start" select="$i.bdrRange.start"/><xsl:with-param name="i.bdrRange.end" select="$i.bdrRange.end"/>
+                    <xsl:with-param name="pr.bdrTop" select="$pr.bdrTop"/><xsl:with-param name="pr.bdrLeft" select="$pr.bdrLeft"/><xsl:with-param name="pr.bdrBottom" select="$pr.bdrBottom"/><xsl:with-param name="pr.bdrRight" select="$pr.bdrRight"/><xsl:with-param name="pr.bdrBetween" select="$pr.bdrBetween"/><xsl:with-param name="pr.bdrBar" select="$pr.bdrBar"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                    <xsl:with-param name="prsP" select="$prsP"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:call-template>
+            </xsl:when>
+
+            <xsl:otherwise>
+                <xsl:variable name="width" select="substring-before($framePr,$sep2)"/><xsl:variable name="framePr1" select="substring-after($framePr,$sep2)"/>
+                <xsl:variable name="height" select="substring-before($framePr1,$sep2)"/><xsl:variable name="framePr2" select="substring-after($framePr1,$sep2)"/>
+                <xsl:variable name="hrule" select="substring-before($framePr2,$sep2)"/><xsl:variable name="framePr3" select="substring-after($framePr2,$sep2)"/>
+                <xsl:variable name="xalign" select="substring-before($framePr3,$sep2)"/><xsl:variable name="framePr4" select="substring-after($framePr3,$sep2)"/>
+                <xsl:variable name="vspace" select="substring-before($framePr4,$sep2)"/><xsl:variable name="framePr5" select="substring-after($framePr4,$sep2)"/>
+                <xsl:variable name="hspace" select="substring-before($framePr5,$sep2)"/><xsl:variable name="framePr6" select="substring-after($framePr5,$sep2)"/>
+                <xsl:variable name="wrap" select="substring-before($framePr6,$sep2)"/>
+
+                <table cellspacing="0" cellpadding="0" hspace="0" vspace="0">
+                <xsl:if test="not($width = '' and $height='')">
+                    <xsl:attribute name="style">
+                        <xsl:if test="not($width = '')">width:<xsl:value-of select="number($width) div 20"/>pt;</xsl:if>
+                        <xsl:if test="not($height = '')">height:<xsl:value-of select="number($height) div 20"/>pt;</xsl:if>
+                    </xsl:attribute>
+                </xsl:if>
+                <xsl:attribute name="align">
+                    <xsl:choose>
+                        <xsl:when test="$xalign = 'right' or $xalign = 'outside'">right</xsl:when>
+                        <xsl:otherwise>left</xsl:otherwise>
+                    </xsl:choose>
+                </xsl:attribute>
+                <tr><td valign="top" align="left">
+                <xsl:attribute name="style">
+                    <xsl:text>padding:</xsl:text>
+                    <xsl:choose><xsl:when test="$vspace = ''">0</xsl:when><xsl:otherwise><xsl:value-of select="number($vspace) div 20"/>pt</xsl:otherwise></xsl:choose><xsl:text> </xsl:text>
+                    <xsl:choose><xsl:when test="$hspace = ''">0</xsl:when><xsl:otherwise><xsl:value-of select="number($hspace) div 20"/>pt</xsl:otherwise></xsl:choose><xsl:text>;</xsl:text>
+                </xsl:attribute>
+
+                <xsl:call-template name="wrapPBdr">
+                    <xsl:with-param name="ns.content" select="$ns.content"/>
+                    <xsl:with-param name="i.bdrRange.start" select="$i.bdrRange.start"/><xsl:with-param name="i.bdrRange.end" select="$i.bdrRange.end"/>
+                    <xsl:with-param name="pr.bdrTop" select="$pr.bdrTop"/><xsl:with-param name="pr.bdrLeft" select="$pr.bdrLeft"/><xsl:with-param name="pr.bdrBottom" select="$pr.bdrBottom"/><xsl:with-param name="pr.bdrRight" select="$pr.bdrRight"/><xsl:with-param name="pr.bdrBetween" select="$pr.bdrBetween"/><xsl:with-param name="pr.bdrBar" select="$pr.bdrBar"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                    <xsl:with-param name="prsP" select="$prsP"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:call-template>
+                </td></tr></table>
+                <xsl:if test="$wrap = '' or $wrap = 'none' or $wrap = 'not-beside'"><br/></xsl:if>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="wrapPBdr">
+        <xsl:param name="pr.bdrTop"/><xsl:param name="pr.bdrLeft"/><xsl:param name="pr.bdrBottom"/><xsl:param name="pr.bdrRight"/><xsl:param name="pr.bdrBetween"/><xsl:param name="pr.bdrBar"/>
+        <xsl:param name="ns.content"/>
+        <xsl:param name="i.bdrRange.start"/>
+        <xsl:param name="i.bdrRange.end"/>
+        <xsl:param name="prsPAccum"/>
+        <xsl:param name="prsP"/>
+        <xsl:param name="prsR"/>
+        <xsl:choose>
+
+            <xsl:when test="$pr.bdrTop = '' and $pr.bdrLeft = '' and $pr.bdrBottom = '' and $pr.bdrRight = '' and $pr.bdrBar = ''">
+                <xsl:apply-templates select="($ns.content)[position() &gt;= $i.bdrRange.start and position() &lt; $i.bdrRange.end]">
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                    <xsl:with-param name="prsP" select="$prsP"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                    <xsl:with-param name="pr.bdrBetween" select="$pr.bdrBetween"/>
+                </xsl:apply-templates>
+            </xsl:when>
+
+            <xsl:otherwise>
+                <div>
+
+                <xsl:attribute name="style">
+                    <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$pr.bdrBar"/><xsl:with-param name="bdrSide" select="$bdrSide_left"/></xsl:call-template>
+                    <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$pr.bdrTop"/><xsl:with-param name="bdrSide" select="$bdrSide_top"/></xsl:call-template>
+                    <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$pr.bdrLeft"/><xsl:with-param name="bdrSide" select="$bdrSide_left"/></xsl:call-template>
+                    <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$pr.bdrBottom"/><xsl:with-param name="bdrSide" select="$bdrSide_bottom"/></xsl:call-template>
+                    <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$pr.bdrRight"/><xsl:with-param name="bdrSide" select="$bdrSide_right"/></xsl:call-template>
+                    <xsl:text>padding:</xsl:text>
+                    <xsl:variable name="topPad" select="substring-before(substring-after(substring-after(substring-after($pr.bdrTop,$sep2),$sep2),$sep2),$sep2)"/>
+                    <xsl:variable name="rightPad" select="substring-before(substring-after(substring-after(substring-after($pr.bdrRight,$sep2),$sep2),$sep2),$sep2)"/>
+                    <xsl:variable name="bottomPad" select="substring-before(substring-after(substring-after(substring-after($pr.bdrBottom,$sep2),$sep2),$sep2),$sep2)"/>
+                    <xsl:variable name="leftPad" select="substring-before(substring-after(substring-after(substring-after($pr.bdrLeft,$sep2),$sep2),$sep2),$sep2)"/>
+                    <xsl:choose><xsl:when test="$topPad = ''">0</xsl:when><xsl:otherwise><xsl:value-of select="$topPad"/>pt</xsl:otherwise></xsl:choose><xsl:text> </xsl:text>
+                    <xsl:choose><xsl:when test="$rightPad = ''">0</xsl:when><xsl:otherwise><xsl:value-of select="$rightPad"/>pt</xsl:otherwise></xsl:choose><xsl:text> </xsl:text>
+                    <xsl:choose><xsl:when test="$bottomPad = ''">0</xsl:when><xsl:otherwise><xsl:value-of select="$bottomPad"/>pt</xsl:otherwise></xsl:choose><xsl:text> </xsl:text>
+                    <xsl:choose><xsl:when test="$leftPad = ''">0</xsl:when><xsl:otherwise><xsl:value-of select="$leftPad"/>pt</xsl:otherwise></xsl:choose><xsl:text>;</xsl:text>
+                </xsl:attribute>
+
+                <xsl:apply-templates select="($ns.content)[position() &gt;= $i.bdrRange.start and position() &lt; $i.bdrRange.end]">
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                    <xsl:with-param name="prsP" select="$prsP"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                    <xsl:with-param name="pr.bdrBetween" select="$pr.bdrBetween"/>
+                </xsl:apply-templates>
+                </div>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+
+
+    <xsl:template name="ApplyArgs">
+        <xsl:param name="value"/>
+        <xsl:variable name="attributeName" select="normalize-space(substring-before($value,'='))"/>
+        <xsl:variable name="afterName" select="concat(substring-after($value,'='),' ')"/>
+        <xsl:if test="not($attributeName = '')">
+            <xsl:attribute name="{$attributeName}"><xsl:value-of select="normalize-space(translate(substring-before($afterName,' '),'&quot;',' '))"/></xsl:attribute>
+            <xsl:call-template name="ApplyArgs"><xsl:with-param name="value" select="normalize-space(substring-after($afterName,' '))"/></xsl:call-template>
+        </xsl:if>
+    </xsl:template>
+
+
+    <xsl:template match="w:scriptAnchor">
+        <script>
+        <xsl:apply-templates select="*" mode="scriptAnchor"/>
+        </script>
+    </xsl:template>
+    <xsl:template match="w:args" mode="scriptAnchor">
+        <xsl:call-template name="ApplyArgs"><xsl:with-param name="value" select="."/></xsl:call-template>
+    </xsl:template>
+    <xsl:template match="w:language" mode="scriptAnchor">
+        <xsl:attribute name="language"><xsl:value-of select="."/></xsl:attribute>
+    </xsl:template>
+    <xsl:template match="w:scriptId" mode="scriptAnchor">
+        <xsl:attribute name="id"><xsl:value-of select="."/></xsl:attribute>
+    </xsl:template>
+    <xsl:template match="w:scriptText" mode="scriptAnchor">
+        <xsl:value-of disable-output-escaping="yes" select="."/>
+    </xsl:template>
+    <xsl:template match="*" mode="scriptAnchor"/>
+
+
+    <xsl:template match="w:applet">
+        <applet>
+        <xsl:apply-templates select="*" mode="applet"/>
+        </applet>
+    </xsl:template>
+    <xsl:template match="w:appletText" mode="applet">
+        <xsl:value-of disable-output-escaping="yes" select="."/>
+    </xsl:template>
+    <xsl:template match="w:args" mode="applet">
+        <xsl:call-template name="ApplyArgs"><xsl:with-param name="value" select="."/></xsl:call-template>
+    </xsl:template>
+    <xsl:template match="*" mode="applet"/>
+
+
+    <xsl:template match="w:txbxContent">
+        <xsl:call-template name="DisplayBodyContent">
+            <xsl:with-param name="ns.content" select="*"/>
+        </xsl:call-template>
+    </xsl:template>
+
+
+    <xsl:template match="w:pict">
+        <xsl:apply-templates select="*"/>
+    </xsl:template>
+
+
+    <xsl:template match="w:br">
+        <br>
+        <!-- Adding @clear causes presentation problems on the Download page, and possibly others too -->
+        <xsl:attribute name="clear">
+            <xsl:choose>
+                <xsl:when test="@w:clear"><xsl:value-of select="@w:clear"/></xsl:when>
+                <xsl:otherwise>all</xsl:otherwise>
+            </xsl:choose>
+        </xsl:attribute>
+        <xsl:if test="@w:type = 'page'">
+            <xsl:attribute name="style">page-break-before:always</xsl:attribute>
+        </xsl:if>
+        </br>
+    </xsl:template>
+
+
+    <xsl:template match="w:instrText">
+    </xsl:template>
+
+
+    <xsl:template match="w:delText">
+        <del>
+        <xsl:value-of select="."/>
+        </del>
+    </xsl:template>
+
+
+    <xsl:template match="w:t">
+        <xsl:value-of select="."/>
+    </xsl:template>
+
+
+    <xsl:template match="w:sym">
+        <span><xsl:attribute name="style">font-family:<xsl:value-of select="@w:font"/></xsl:attribute>
+            <xsl:choose>
+                <xsl:when test="starts-with(@w:char, 'F0')">
+                    <xsl:text disable-output-escaping="yes">&amp;</xsl:text>#x<xsl:value-of select="substring-after(@w:char, 'F0')"/><xsl:text>;</xsl:text>
+                </xsl:when>
+                <xsl:when test="starts-with(@w:char, 'f0')">
+                    <xsl:text disable-output-escaping="yes">&amp;</xsl:text>#x<xsl:value-of select="substring-after(@w:char, 'f0')"/><xsl:text>;</xsl:text>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:text disable-output-escaping="yes">&amp;</xsl:text>#x<xsl:value-of select="@w:char"/><xsl:text>;</xsl:text>
+                </xsl:otherwise>
+            </xsl:choose></span>
+    </xsl:template>
+
+    <xsl:template name="OutputTlcChar">
+        <xsl:param name="count" select="0"/>
+        <xsl:param name="tlc" select="' '"/>
+        <xsl:value-of select="$tlc"/>
+        <xsl:if test="$count > 1">
+            <xsl:call-template name="OutputTlcChar">
+                <xsl:with-param name="count" select="$count - 1"/>
+                <xsl:with-param name="tlc" select="$tlc"/>
+            </xsl:call-template>
+        </xsl:if>
+    </xsl:template>
+
+
+    <xsl:template match="w:softHyphen">
+        <xsl:text>&#xAD;</xsl:text>
+    </xsl:template>
+
+
+    <xsl:template match="w:noBreakHyphen">
+        <xsl:text disable-output-escaping="yes">&amp;#8209;</xsl:text>
+    </xsl:template>
+
+
+    <xsl:template name="DisplayRContent">
+        <xsl:apply-templates select="*"/>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyRPr.once">
+        <xsl:param name="rStyleId"/>
+        <xsl:param name="b.bidi"/>
+        <xsl:param name="prsR"/>
+
+        <xsl:variable name="b.complexScript">
+            <xsl:choose>
+                <xsl:when test="w:rPr[1]/w:cs[1] or w:rPr[1]/w:rtl[1]"><xsl:value-of select="$on"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$off"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+        <xsl:if test="$b.complexScript = $on">
+            <xsl:variable name="suffix.complexScript">-CS</xsl:variable>
+            <xsl:variable name="b.font-weight" select="substring($prsR,$iBCs,1)"/>
+            <xsl:variable name="b.font-style" select="substring($prsR,$iICs,1)"/>
+            <xsl:variable name="pr.sz" select="substring($prsR,$ISzCs)"/>
+
+            <xsl:choose>
+                <xsl:when test="$b.font-style = $on">font-style:italic;</xsl:when>
+                <xsl:otherwise>font-style:normal;</xsl:otherwise>
+            </xsl:choose>
+
+            <xsl:choose>
+                <xsl:when test="$b.font-weight = $on">font-weight:bold;</xsl:when>
+                <xsl:otherwise>font-weight:normal;</xsl:otherwise>
+            </xsl:choose>
+
+            <xsl:choose>
+                <xsl:when test="$pr.sz = ''">font-size:12pt;</xsl:when>
+                <xsl:otherwise>
+                    <xsl:text>font-size:</xsl:text>
+                    <xsl:value-of select="number($pr.sz) div 2"/>
+                    <xsl:text>pt;</xsl:text>
+                </xsl:otherwise>
+            </xsl:choose>
+        </xsl:if>
+
+        <xsl:if test="not($b.bidi = '')">
+            <xsl:choose>
+                <xsl:when test="$b.bidi = $on and not($b.complexScript = $on)">direction:ltr;</xsl:when>
+                <xsl:when test="not($b.bidi = $on) and $b.complexScript = $on">direction:rtl;</xsl:when>
+            </xsl:choose>
+        </xsl:if>
+
+        <xsl:if test="substring($prsR,$iEmbossImprint,1) = $on">color:gray;</xsl:if>
+
+        <xsl:variable name="b.line-through" select="substring($prsR,$iStrikeDStrike,1)"/>
+        <xsl:variable name="b.underline" select="substring($prsR,$iU_Em,1)"/>
+        <xsl:choose>
+            <xsl:when test="$b.line-through = $off and $b.underline = $off">text-decoration:none;</xsl:when>
+            <xsl:when test="$b.line-through = $on and $b.underline = $on">text-decoration:underline;</xsl:when>
+            <xsl:when test="$b.line-through = $on">text-decoration:line-through;</xsl:when>
+            <xsl:when test="$b.underline = $on">text-decoration:underline;</xsl:when>
+        </xsl:choose>
+
+        <xsl:variable name="fSup" select="substring($prsR,$iSup,1)"/>
+        <xsl:variable name="fSub" select="substring($prsR,$iSub,1)"/>
+        <xsl:choose>
+            <xsl:when test="$fSup = $on and $fSub = $on">vertical-align:baseline;</xsl:when>
+            <xsl:when test="$fSub = $on">vertical-align:sub;</xsl:when>
+            <xsl:when test="$fSup = $on">vertical-align:super;</xsl:when>
+        </xsl:choose>
+
+        <xsl:if test="not($rStyleId='CommentReference')">
+            <xsl:if test="substring($prsR,$iVanishWebHidden,1) = $on">display:none;</xsl:if>
+        </xsl:if>
+    </xsl:template>
+
+
+    <xsl:template name="RecursiveApplyRPr.class">
+        <xsl:if test="w:basedOn">
+            <xsl:variable name="baseStyleName" select="w:basedOn[1]/@w:val" />
+            <xsl:variable name="sParaStyleBase" select="($nsStyles[@w:styleId=$baseStyleName])[1]"/>
+            <xsl:for-each select="$sParaStyleBase"><xsl:call-template name="RecursiveApplyRPr.class" /></xsl:for-each>
+        </xsl:if>
+
+
+        <xsl:call-template name="ApplyRPr.class"/>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyRPr.class">
+        <xsl:for-each select="w:rPr[1]">
+            <xsl:apply-templates select="*" mode="rpr"/>
+        </xsl:for-each>
+    </xsl:template>
+
+
+    <xsl:template match="w:highlight" mode="rpr">background:<xsl:call-template name="ConvColor"><xsl:with-param name="value" select="@w:val"/></xsl:call-template>;</xsl:template>
+
+
+    <xsl:template match="w:color" mode="rpr">color:<xsl:call-template name="ConvHexColor"><xsl:with-param name="value" select="@w:val"/></xsl:call-template>;</xsl:template>
+
+    <xsl:template match="w:smallCaps" mode="rpr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'off'">font-variant:normal;</xsl:when>
+            <xsl:otherwise>font-variant:small-caps;</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:asianLayout" mode="rpr">
+        <xsl:choose>
+            <xsl:when test="@w:vert = 'on'">layout-flow:horizontal;</xsl:when>
+            <xsl:when test="@w:vert-compress = 'on'">layout-flow:horizontal;</xsl:when>
+            <xsl:when test="@w:vert = 'off' or @w:vert-compress = 'off'">layout-flow:normal;</xsl:when>
+        </xsl:choose>
+        <xsl:if test="@w:combine = 'lines'">text-combine:lines;</xsl:if>
+    </xsl:template>
+
+    <xsl:template match="w:spacing" mode="rpr">letter-spacing:<xsl:value-of select="@w:val div 20"/>pt;</xsl:template>
+
+    <xsl:template match="w:position" mode="rpr">
+        <xsl:variable name="fDropCap">
+             <xsl:value-of select="ancestor::w:p[1]/w:pPr/w:framePr/@w:drop-cap"/>
+        </xsl:variable>
+        <xsl:if test="$fDropCap=''">
+            <xsl:text>position:relative;top:</xsl:text>
+            <xsl:value-of select="@w:val div -2"/>
+            <xsl:text>pt;</xsl:text>
+        </xsl:if>
+    </xsl:template>
+    <xsl:template match="w:fitText" mode="rpr">text-fit:<xsl:value-of select="@w:val div 20"/>pt;</xsl:template>
+    <xsl:template match="w:shadow" mode="rpr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'off'">text-shadow:none;</xsl:when>
+            <xsl:otherwise>text-shadow:0.2em 0.2em;</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:caps" mode="rpr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'off'">text-transform:none;</xsl:when>
+            <xsl:otherwise>text-transform:uppercase;</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:sz" mode="rpr">font-size:<xsl:value-of select="@w:val div 2"/>pt;</xsl:template>
+
+    <xsl:template match="w:b" mode="rpr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'off'">font-weight:normal;</xsl:when>
+            <xsl:otherwise>font-weight:bold;</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:i" mode="rpr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'off'">font-style:normal;</xsl:when>
+            <xsl:otherwise>font-style:italic;</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template match="*" mode="rpr"/>
+
+
+    <xsl:template name="RecursivePrsUpdateRPr">
+        <xsl:param name="prsR" />
+        <xsl:param name="rStyleId" />
+
+        <xsl:variable name="myStyle" select="($nsStyles[@w:styleId=$rStyleId])[1]"/>
+
+        <xsl:variable name="prsR.updated">
+            <xsl:choose>
+                <xsl:when test="$myStyle/w:basedOn">
+                    <xsl:call-template name="RecursivePrsUpdateRPr">
+                        <xsl:with-param name="prsR" select="$prsR" />
+                        <xsl:with-param name= "rStyleId" select="$myStyle/w:basedOn/@w:val" />
+                    </xsl:call-template>
+                </xsl:when>
+                <xsl:otherwise><xsl:value-of select="$prsR" /></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+
+        <xsl:call-template name="PrsUpdateRPr">
+            <xsl:with-param name="ndPrContainer" select="$myStyle"/>
+            <xsl:with-param name="prsR" select="$prsR.updated"/>
+        </xsl:call-template>
+    </xsl:template>
+
+
+
+    <xsl:template name="DisplayR">
+        <xsl:param name="b.bidi"/>
+        <xsl:param name="prsR"/>
+
+        <xsl:variable name="rStyleId" select="string(w:rPr/w:rStyle/@w:val)"/>
+
+        <xsl:variable name="prsR.updated">
+
+            <xsl:variable name="prsR.updated1">
+                <xsl:call-template name="RecursivePrsUpdateRPr">
+                    <xsl:with-param name="rStyleId" select="$rStyleId"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                </xsl:call-template>
+            </xsl:variable>
+
+            <xsl:variable name="prsR.updated2">
+                <xsl:call-template name="PrsUpdateRPr">
+                    <xsl:with-param name="prsR" select="$prsR.updated1"/>
+                </xsl:call-template>
+            </xsl:variable>
+
+            <xsl:variable name="prsRTemp3"/>
+            <xsl:choose>
+                <xsl:when test="$prsRTemp3=''">
+                    <xsl:value-of select="$prsR.updated2"/>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:value-of select="$prsRTemp3"/>
+                </xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+        <xsl:variable name="pr.listSuff"/>
+        <xsl:variable name="styleMod">
+            <xsl:call-template name="ApplyRPr.class"/>
+
+            <xsl:variable name="ilfo" select="w:listPr/w:ilfo/@w:val" />
+            <xsl:variable name="ilvl" select="w:listPr/w:ilvl/@w:val" />
+            <xsl:variable name="ilstDef" select="$ndLists/w:list[@w:ilfo=$ilfo]/w:ilst/@w:val" />
+            <xsl:variable name="listDef" select="$ndLists/w:listDef[@w:listDefId=$ilstDef]" />
+
+            <xsl:call-template name="ApplyRPr.once">
+                <xsl:with-param name="rStyleId" select="$rStyleId"/>
+                <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                <xsl:with-param name="prsR" select="$prsR.updated"/>
+            </xsl:call-template>
+
+
+            <xsl:variable name="isBullets">
+                <xsl:for-each select="w:listPr[1]"><xsl:call-template name="IsListBullet" /></xsl:for-each>
+            </xsl:variable>
+
+            <xsl:if test="$isBullets=$on or ancestor::w:rt">
+                <xsl:text>font-style:normal;text-decoration:none;font-weight:normal;</xsl:text>
+            </xsl:if>
+        </xsl:variable>
+        <xsl:choose>
+            <xsl:when test="$rStyleId='' and $styleMod=''">
+                <xsl:call-template name="DisplayRContent"/>
+
+                <xsl:if test="$pr.listSuff = $prListSuff_space"><xsl:text> </xsl:text></xsl:if>
+            </xsl:when>
+            <xsl:otherwise>
+                <span>
+
+                <xsl:if test="not($rStyleId='')">
+                    <xsl:attribute name="class"><xsl:value-of select="$rStyleId"/><xsl:value-of select="$charStyleSuffix"/></xsl:attribute>
+                </xsl:if>
+
+                <xsl:if test="not($styleMod='')">
+                        <xsl:attribute name="style"><xsl:value-of select="$styleMod"/></xsl:attribute>
+                </xsl:if>
+
+
+
+                                <xsl:choose>
+                        <xsl:when test="contains($styleMod, 'vertical-align:super') or contains($styleMod, 'vertical-align:sub')">
+                                         <span>
+                                <xsl:attribute name="style">font-size:smaller;</xsl:attribute>
+                                        <xsl:call-template name="DisplayRContent"/>
+                                             </span>
+                                        </xsl:when>
+                                        <xsl:otherwise>
+                             <xsl:call-template name="DisplayRContent"/>
+                                     </xsl:otherwise>
+                                 </xsl:choose>
+
+
+                </span>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template match="w:r">
+        <xsl:param name="b.bidi" select="''"/>
+        <xsl:param name="prsR" select="$prsRDefault"/>
+
+        <xsl:if test="not(w:fldChar or w:instrText)">
+
+
+            <xsl:variable name="instrText" select="preceding-sibling::w:r[w:instrText][1]" />
+
+
+            <xsl:variable name="nInstrText" select="normalize-space(concat($instrText, ' -'))" />
+            <xsl:variable name="instruction" select="substring-before($nInstrText, ' ')" />
+
+
+            <xsl:choose>
+                <xsl:when test="translate($instruction, $lowercase, $uppercase)='HYPERLINK'">
+                    <a>
+                        <xsl:variable name="href">
+                            <xsl:choose>
+                                <xsl:when test="contains($nInstrText,'\l')">
+                                    <!-- DH: Added this part to preserve file name -->
+                                    <xsl:variable name="fieldContent" select="translate(substring-after($nInstrText, concat($instruction, ' ')), '&quot;', '')"/>
+                                    <xsl:variable name="linkedFile" select="normalize-space((tokenize(substring-before($fieldContent, '\l '), '(/)|(\\)'))[last()])"/>
+                                    <xsl:value-of select="$linkedFile"/>
+                                    <!-- End of added part -->
+                                    <xsl:text>#</xsl:text>
+                                    <xsl:value-of select="translate(substring-before(substring-after($nInstrText, '\l '),' '),'&quot;', '')"/></xsl:when>
+                                <xsl:otherwise>
+                                    <xsl:value-of select="translate(substring-before(substring-after($nInstrText, concat($instruction, ' ')),' '),'&quot;', '')"/>
+                                </xsl:otherwise>
+                            </xsl:choose>
+                        </xsl:variable>
+
+                        <xsl:if test="not($href='')"><xsl:attribute name="href"><xsl:value-of select="$href"/></xsl:attribute></xsl:if>
+
+                        <xsl:if test="contains($nInstrText,'\t') or contains($nInstrText, '\n')">
+                            <xsl:attribute name="target">
+                                <xsl:choose>
+                                    <xsl:when test="contains($nInstrText, '\n')">
+                                        <xsl:text>_new</xsl:text>
+                                    </xsl:when>
+                                    <xsl:otherwise>
+                                        <xsl:value-of select="translate(substring-before(substring-after($nInstrText, '\t '),' '),'&quot;', '')"/>
+                                    </xsl:otherwise>
+                                </xsl:choose>
+                            </xsl:attribute>
+                        </xsl:if>
+
+                        <xsl:if test="contains($nInstrText,'\o')">
+                            <xsl:attribute name="title">
+                                <xsl:value-of select="translate(substring-before(substring-after($nInstrText, '\o '),' '),'&quot;', '')"/>
+                            </xsl:attribute>
+                        </xsl:if>
+
+                        <xsl:call-template name="DisplayR">
+                            <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                            <xsl:with-param name="prsR" select="$prsR"/>
+                        </xsl:call-template>
+
+                    </a>
+                </xsl:when>
+
+                <xsl:otherwise>
+
+
+                    <xsl:call-template name="DisplayR">
+                        <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                        <xsl:with-param name="prsR" select="$prsR"/>
+                    </xsl:call-template>
+                </xsl:otherwise>
+            </xsl:choose>
+        </xsl:if>
+
+
+        <xsl:if test="w:instrText">
+            <xsl:variable name="refcontent" select="normalize-space(w:instrText)"/>
+
+            <xsl:choose>
+                <xsl:when test="starts-with($refcontent, 'REF')">
+                    <xsl:variable name="href">
+                        <xsl:choose>
+                            <xsl:when test="contains($refcontent, '\')">
+                                <xsl:value-of select="normalize-space(substring-after(substring-before($refcontent, '\'), 'REF '))"/>
+                            </xsl:when>
+                            <xsl:otherwise>
+                                <xsl:value-of select="normalize-space(substring-after($refcontent, 'REF '))"/>
+                            </xsl:otherwise>
+                        </xsl:choose>
+                    </xsl:variable>
+                    <!-- Ignore cross-references -->
+                    <!--<a class="xref" href="{$href}"></a> -->
+                </xsl:when>
+                <xsl:when test="contains($refcontent, 'XE')">
+                    <a class="index_term" href="{normalize-space(substring-after($refcontent, 'XE '))}"></a>
+                </xsl:when>
+                <xsl:when test="contains($refcontent, 'xe')">
+                    <a class="index_term" href="{normalize-space(substring-after($refcontent, 'xe '))}"></a>
+                </xsl:when>
+                <xsl:when test="starts-with($refcontent, 'TOC')">
+                    <a class="toc" href="{normalize-space(substring-after($refcontent, 'TOC '))}"></a>
+                </xsl:when>
+                <!-- DH: The HYPERLINK bit was commented out but it seems useful to me! I added the '\l' part -->
+                <!-- This is probably not useful -->
+                <xsl:when test="starts-with($refcontent, 'HYPERLINK')">
+                    <xsl:choose>
+                        <xsl:when test="contains($refcontent, '\l')">
+                            <a href="{concat('#', normalize-space(translate(substring-after($refcontent, '\l '), '&#34;', '')))}">
+                                <xsl:apply-templates/>
+                            </a>
+                        </xsl:when>
+                        <xsl:otherwise>
+                            <a href="{normalize-space(translate(substring-after($refcontent, 'HYPERLINK '), '&#34;', ''))}">
+                                <xsl:apply-templates/>
+                            </a>
+                        </xsl:otherwise>
+                    </xsl:choose>
+                </xsl:when>
+                <xsl:otherwise>
+                    <a href="{$refcontent}"></a>
+                </xsl:otherwise>
+            </xsl:choose>
+        </xsl:if>
+
+
+    </xsl:template>
+
+    <xsl:template match="w:r/w:fldChar[@w:fldCharType = 'begin']">
+        <span class="field_begin"><xsl:apply-templates/></span>
+    </xsl:template>
+    <xsl:template match="w:r/w:fldChar[@w:fldCharType = 'end']">
+        <span class="field_end"><xsl:apply-templates/></span>
+    </xsl:template>
+
+    <xsl:template match="w:r[count(preceding-sibling::w:r[w:fldChar/@w:fldCharType='begin']) = count(preceding-sibling::w:r[w:fldChar/@w:fldCharType='end'])]">
+        <xsl:param name="b.bidi" select="''"/>
+        <xsl:param name="prsR" select="$prsRDefault"/>
+        <xsl:call-template name="DisplayR">
+            <xsl:with-param name="b.bidi" select="$b.bidi"/>
+            <xsl:with-param name="prsR" select="$prsR"/>
+        </xsl:call-template>
+    </xsl:template>
+
+
+    <xsl:template match="w:pPr">
+        <xsl:param name="b.bidi" select="''"/>
+        <xsl:param name="prsR" select="$prsRDefault"/>
+        <xsl:call-template name="DisplayR">
+            <xsl:with-param name="b.bidi" select="$b.bidi"/>
+            <xsl:with-param name="prsR" select="$prsR"/>
+        </xsl:call-template>
+    </xsl:template>
+
+
+    <xsl:template name="DisplayHlink">
+        <xsl:param name="b.bidi"/>
+        <xsl:param name="prsR"/>
+
+        <!-- Figure out hyperlink targets -->
+        <xsl:variable name="current_rId" select="@r:id"/>
+        <xsl:call-template name="debugComment">
+            <xsl:with-param name="comment_text" select="concat('current_rId = ', $current_rId, '; link text = ', current(), '; Relationship/@Id = ', $hyperLinks[@Id = $current_rId]/@Id, '; Target = ', $hyperLinks[@Id = $current_rId]/@Target)"/>
+            <xsl:with-param name="inline" select="'true'"/>
+            <xsl:with-param name="condition" select="$debug_flag = '2' and @r:id"/>
+        </xsl:call-template>
+
+        <a>
+            <xsl:variable name="href">
+                <xsl:choose>
+                    <xsl:when test="@r:id">
+                        <xsl:variable name="target">
+                            <xsl:choose>
+                                <xsl:when test="ancestor::w:footnote">
+                                    <xsl:value-of select="//footnoteLinks/rels:Relationships/rels:Relationship[@Id = $current_rId]/@Target"/>
+                                </xsl:when>
+                                <xsl:otherwise>
+                                    <xsl:value-of select="$hyperLinks[@Id = $current_rId]/@Target"/>
+                                </xsl:otherwise>    
+                            </xsl:choose>
+                        </xsl:variable>
+                        <xsl:choose>
+                            <xsl:when test="starts-with($target, 'file:///')">
+                                <xsl:value-of select="tokenize($target, '\\')[last()]"/>
+                            </xsl:when>
+                            <xsl:otherwise>
+                                <xsl:value-of select="$target"/>
+                            </xsl:otherwise>
+                        </xsl:choose>
+                        <xsl:if test="@w:anchor">#<xsl:value-of select="@w:anchor"/></xsl:if> <!-- DH: added this line -->
+                    </xsl:when>
+                    <xsl:otherwise>
+                        <xsl:for-each select="@w:dest">
+                            <xsl:value-of select="."/>
+                        </xsl:for-each>
+                        <xsl:choose>
+                            <xsl:when test="@w:anchor">#<xsl:value-of select="@w:anchor"/></xsl:when>
+                            <xsl:when test="@w:arbLocation"># <xsl:value-of select="@w:arbLocation"/></xsl:when>
+                        </xsl:choose>
+                    </xsl:otherwise>
+                </xsl:choose>
+            </xsl:variable>
+            <xsl:choose>
+                <xsl:when test="not($href='')">
+                    <xsl:attribute name="href">
+                        <xsl:value-of select="$href"/>
+                    </xsl:attribute>
+                </xsl:when>
+                <xsl:otherwise>
+                </xsl:otherwise>
+            </xsl:choose>
+            <!-- Not sure if w:hyperlink/@w:target exists, cf. http://officeopenxml.com/WPhyperlink.php -->
+            <xsl:for-each select="@w:target">
+                <xsl:attribute name="target">
+                    <xsl:value-of select="."/>
+                </xsl:attribute>
+            </xsl:for-each>
+            <!-- Open link in new or named window, cf. http://officeopenxml.com/WPhyperlink.php -->
+            <xsl:if test="@w:tgtFrame">
+                <xsl:attribute name="target">
+                    <xsl:value-of select="@w:tgtFrame"/>
+                </xsl:attribute>
+            </xsl:if>
+            <xsl:for-each select="@w:screenTip">
+                <xsl:attribute name="title">
+                    <xsl:value-of select="."/>
+                </xsl:attribute>
+            </xsl:for-each>
+            <xsl:call-template name="DisplayPContent">
+                <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                <xsl:with-param name="prsR" select="$prsR"/>
+            </xsl:call-template>
+        </a>
+    </xsl:template>
+
+
+    <xsl:template match="w:hyperlink">
+        <xsl:param name="b.bidi" select="''"/>
+        <xsl:param name="prsR" select="$prsRDefault"/>
+        <xsl:call-template name="DisplayHlink">
+            <xsl:with-param name="b.bidi" select="$b.bidi"/>
+            <xsl:with-param name="prsR" select="$prsR"/>
+        </xsl:call-template>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyPPr.once">
+        <xsl:param name="i.bdrRange.this"/>
+        <xsl:param name="i.bdrRange.last"/>
+        <xsl:param name="pr.bdrBetween"/>
+        <xsl:param name="prsP"/>
+        <xsl:param name="b.bidi"/>
+
+        <xsl:if test="not($i.bdrRange.this = $i.bdrRange.last)">
+            <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$pr.bdrBetween"/><xsl:with-param name="bdrSide" select="$bdrSide_bottom"/></xsl:call-template>
+        </xsl:if>
+
+        <xsl:if test="not($pr.bdrBetween = '')">
+            <xsl:choose>
+                <xsl:when test="$i.bdrRange.this = 1">padding:0 0 1pt;</xsl:when>
+                <xsl:when test="$i.bdrRange.this = i.bdrRange.last">padding:1pt 0 0;</xsl:when>
+                <xsl:otherwise>padding:1pt 0 1pt;</xsl:otherwise>
+            </xsl:choose>
+        </xsl:if>
+
+        <xsl:choose>
+            <xsl:when test="$b.bidi = $off">direction:ltr;unicode-bidi:normal;</xsl:when>
+            <xsl:when test="$b.bidi = $on">direction:rtl;unicode-bidi:embed;text-align:right;</xsl:when>
+        </xsl:choose>
+
+        <xsl:variable name="nInd" select="substring($prsP,$iInd)"/>
+        <xsl:variable name="pr.listInd"/>
+        <xsl:if test="not($nInd='' and $pr.listInd='')">
+
+            <xsl:variable name="nInd.left" select="substring-before($nInd,$sep2)"/><xsl:variable name="temp1" select="substring-after($nInd,$sep2)"/>
+            <xsl:variable name="nInd.leftChars" select="substring-before($temp1,$sep2)"/><xsl:variable name="temp2" select="substring-after($temp1,$sep2)"/>
+            <xsl:variable name="nInd.right" select="substring-before($temp2,$sep2)"/><xsl:variable name="temp3" select="substring-after($temp2,$sep2)"/>
+            <xsl:variable name="nInd.rightChars" select="substring-before($temp3,$sep2)"/><xsl:variable name="temp4" select="substring-after($temp3,$sep2)"/>
+            <xsl:variable name="nInd.hanging" select="substring-before($temp4,$sep2)"/><xsl:variable name="temp5" select="substring-after($temp4,$sep2)"/>
+            <xsl:variable name="nInd.hangingChars" select="substring-before($temp5,$sep2)"/><xsl:variable name="temp6" select="substring-after($temp5,$sep2)"/>
+            <xsl:variable name="nInd.firstLine" select="substring-before($temp6,$sep2)"/>
+            <xsl:variable name="nInd.firstLineChars" select="substring-after($temp6,$sep2)"/>
+            <xsl:variable name="pr.listInd.left" select="substring-before($pr.listInd,$sep2)"/><xsl:variable name="temp1a" select="substring-after($pr.listInd,$sep2)"/>
+            <xsl:variable name="pr.listInd.leftChars" select="substring-before($temp1a,$sep2)"/><xsl:variable name="temp2a" select="substring-after($temp1a,$sep2)"/>
+            <xsl:variable name="pr.listInd.hanging" select="substring-before($temp2a,$sep2)"/>
+            <xsl:variable name="pr.listInd.hangingChars" select="substring-after($temp2a,$sep2)"/>
+
+            <xsl:variable name="marginSide.before">margin-<xsl:choose><xsl:when test="$b.bidi=$on">right</xsl:when><xsl:otherwise>left</xsl:otherwise></xsl:choose>:</xsl:variable>
+            <xsl:variable name="marginSide.after">margin-<xsl:choose><xsl:when test="$b.bidi=$on">left</xsl:when><xsl:otherwise>right</xsl:otherwise></xsl:choose>:</xsl:variable>
+
+            <xsl:choose>
+
+                <xsl:when test="not($nInd.left = '')"><xsl:value-of select="$marginSide.before"/><xsl:value-of select="number($nInd.left) div 20"/>pt;</xsl:when>
+                <xsl:when test="not($nInd.leftChars = '' and $nInd.hangingChars='')">
+                    <xsl:value-of select="$marginSide.before"/>
+                    <xsl:variable name="leftchars"><xsl:choose><xsl:when test="$nInd.leftChars=''">0</xsl:when><xsl:otherwise><xsl:value-of select="number($nInd.leftChars) div 100"/></xsl:otherwise></xsl:choose></xsl:variable>
+                    <xsl:variable name="hangingchars"><xsl:choose><xsl:when test="$nInd.hangingChars=''">0</xsl:when><xsl:otherwise><xsl:value-of select="number($nInd.hangingChars) div 100"/></xsl:otherwise></xsl:choose></xsl:variable>
+                    <xsl:value-of select="$leftchars + $hangingchars"/>
+                    <xsl:text>em;</xsl:text>
+                </xsl:when>
+
+                <xsl:when test="not($pr.listInd.left = '')"><xsl:value-of select="$marginSide.before"/><xsl:value-of select="number($pr.listInd.left) div 20"/>pt;</xsl:when>
+                <xsl:when test="not($pr.listInd.leftChars = '' and $pr.listInd.hangingChars='')">
+                    <xsl:value-of select="$marginSide.before"/>
+                    <xsl:variable name="leftchars"><xsl:choose><xsl:when test="$pr.listInd.leftChars=''">0</xsl:when><xsl:otherwise><xsl:value-of select="number($pr.listInd.leftChars) div 100 * 12"/></xsl:otherwise></xsl:choose></xsl:variable>
+                    <xsl:variable name="hangingchars"><xsl:choose><xsl:when test="$pr.listInd.hangingChars=''">0</xsl:when><xsl:otherwise><xsl:value-of select="number($pr.listInd.hangingChars) div 100 * 12"/></xsl:otherwise></xsl:choose></xsl:variable>
+                    <xsl:value-of select="$leftchars + $hangingchars"/>
+                    <xsl:text>pt;</xsl:text>
+                </xsl:when>
+            </xsl:choose>
+
+            <xsl:choose>
+                <xsl:when test="not($nInd.right = '')"><xsl:value-of select="$marginSide.after"/><xsl:value-of select="number($nInd.right) div 20"/>pt;</xsl:when>
+                <xsl:when test="not($nInd.rightChars = '')"><xsl:value-of select="$marginSide.after"/><xsl:value-of select="number($nInd.rightChars) div 100"/>em;</xsl:when>
+            </xsl:choose>
+
+            <xsl:choose>
+                <xsl:when test="not($nInd.hanging='')">text-indent:<xsl:value-of select="number($nInd.hanging) div -20"/>pt;</xsl:when>
+                <xsl:when test="not($nInd.hangingChars='')">text-indent:<xsl:value-of select="number($nInd.hangingChars) div -100"/>em;</xsl:when>
+                <xsl:when test="not($nInd.firstLine='')">text-indent:<xsl:value-of select="number($nInd.firstLine) div 20"/>pt;</xsl:when>
+                <xsl:when test="not($nInd.firstLineChars='')">text-indent:<xsl:value-of select="number($nInd.firstLineChars) div 100"/>em;</xsl:when>
+                <xsl:when test="not($pr.listInd.hanging='')">text-indent:<xsl:value-of select="number($pr.listInd.hanging) div -20"/>pt;</xsl:when>
+                <xsl:when test="not($pr.listInd.hangingChars='')">text-indent:<xsl:value-of select="number($pr.listInd.hangingChars) div -100 * 12"/>pt;</xsl:when>
+            </xsl:choose>
+        </xsl:if>
+
+        <xsl:variable name="fTextAutospaceO" select="substring($prsP,$iTextAutospaceO,1)"/>
+        <xsl:variable name="fTextAutospaceN" select="substring($prsP,$iTextAutospaceN,1)"/>
+        <xsl:choose>
+            <xsl:when test="not($fTextAutospaceN = $off) and $fTextAutospaceO = $off">text-autospace:ideograph-numeric;</xsl:when>
+            <xsl:when test="not($fTextAutospaceO = $off) and $fTextAutospaceN = $off">text-autospace:ideograph-other;</xsl:when>
+            <xsl:when test="$fTextAutospaceO = $off and $fTextAutospaceN = $off">text-autospace:none;</xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyPPr.many">
+        <xsl:param name="cxtSpacing" select="$cxtSpacing_all"/>
+
+        <xsl:variable name="spacing" select="w:pPr[1]/w:spacing[1]"/>
+        <xsl:choose>
+            <xsl:when test="($spacing/@w:before-autospacing and not($spacing/@w:before-autospacing = 'off')) or $cxtSpacing = $cxtSpacing_none or $cxtSpacing = $cxtSpacing_bottom">
+
+            </xsl:when>
+            <xsl:when test="$spacing/@w:before">margin-top:<xsl:value-of select="$spacing/@w:before div 20"/>pt;</xsl:when>
+            <xsl:when test="$spacing/@w:before-lines">margin-top:<xsl:value-of select="$spacing/@w:before-lines *.12"/>pt;</xsl:when>
+        </xsl:choose>
+        <xsl:choose>
+            <xsl:when test="($spacing/@w:after-autospacing and not($spacing/@w:after-autospacing = 'off')) or $cxtSpacing = $cxtSpacing_none or $cxtSpacing = $cxtSpacing_top">
+
+            </xsl:when>
+
+            <xsl:when test="$spacing/@w:after">margin-bottom:<xsl:value-of select="$spacing/@w:after div 20"/>pt;</xsl:when>
+            <xsl:when test="$spacing/@w:after-lines">margin-bottom:<xsl:value-of select="$spacing/@w:after-lines *.12"/>pt;</xsl:when>
+        </xsl:choose>
+        <xsl:for-each select="w:pPr[1]">
+
+            <xsl:for-each select="w:snapToGrid[1]">
+                <xsl:choose>
+                    <xsl:when test="@w:val = 'off'">layout-grid-mode:char;</xsl:when>
+                    <xsl:otherwise>layout-grid-mode:both;</xsl:otherwise>
+                </xsl:choose>
+            </xsl:for-each>
+
+            <xsl:for-each select="w:keepNext[1]">
+                <xsl:choose>
+                    <xsl:when test="@w:val = 'off'">page-break-after:auto;</xsl:when>
+                    <xsl:otherwise>page-break-after:avoid;</xsl:otherwise>
+                </xsl:choose>
+            </xsl:for-each>
+
+            <xsl:for-each select="w:pageBreakBefore[1]">
+                <xsl:choose>
+                    <xsl:when test="@w:val = 'off'">page-break-before:auto;</xsl:when>
+                    <xsl:otherwise>page-break-before:always;</xsl:otherwise>
+                </xsl:choose>
+            </xsl:for-each>
+        </xsl:for-each>
+    </xsl:template>
+
+
+    <xsl:template name="RecursiveApplyPPr.class">
+        <xsl:if test="w:basedOn">
+            <xsl:variable name="baseStyleName" select="w:basedOn[1]/@w:val" />
+            <xsl:variable name="sParaStyleBase" select="($nsStyles[@w:styleId=$baseStyleName])[1]"/>
+            <xsl:for-each select="$sParaStyleBase"><xsl:call-template name="RecursiveApplyPPr.class" /></xsl:for-each>
+        </xsl:if>
+
+
+        <xsl:call-template name="ApplyPPr.class"/>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyPPr.class">
+        <xsl:apply-templates select="w:pPr[1]/*" mode="ppr"/>
+    </xsl:template>
+
+    <xsl:template match="w:textDirection" mode="ppr"><xsl:call-template name="ApplyTextDirection"/></xsl:template>
+
+    <xsl:template match="w:spacing[@w:line-rule or @w:line]" mode="ppr">
+        <xsl:choose>
+            <xsl:when test="not(@w:line-rule) or @w:line-rule = 'auto'">line-height:<xsl:value-of select="@w:line div 240"/>;</xsl:when>
+            <xsl:otherwise>line-height:<xsl:value-of select="@w:line div 20"/>pt;</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:topLinePunct" mode="ppr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'off'">punctuation-trim:none;</xsl:when>
+            <xsl:otherwise>punctuation-trim:leading;</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:overflowPunct" mode="ppr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'off'">punctuation-wrap:simple;</xsl:when>
+            <xsl:otherwise>punctuation-wrap:hanging;</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:jc" mode="ppr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'left'">text-align:left;</xsl:when>
+            <xsl:when test="@w:val = 'center'">text-align:center;</xsl:when>
+            <xsl:when test="@w:val = 'right'">text-align:right;</xsl:when>
+            <xsl:when test="@w:val = 'both'">text-align:justify;text-justify:inter-ideograph;</xsl:when>
+            <xsl:when test="@w:val = 'distribute'">text-align:justify;text-justify:distribute-all-lines;</xsl:when>
+            <xsl:when test="@w:val = 'low-kashida'">text-align:justify;text-justify:kashida;text-kashida:0%;</xsl:when>
+            <xsl:when test="@w:val = 'medium-kashida'">text-align:justify;text-justify:kashida;text-kashida:10%;</xsl:when>
+            <xsl:when test="@w:val = 'high-kashida'">text-align:justify;text-justify:kashida;text-kashida:20%;</xsl:when>
+            <xsl:when test="@w:val = 'thai-distribute'">text-align:justify;text-justify:inter-cluster;</xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:textAlignment" mode="ppr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'top'">vertical-align:top;</xsl:when>
+            <xsl:when test="@w:val = 'center'">vertical-align:middle;</xsl:when>
+            <xsl:when test="@w:val = 'baseline'">vertical-align:baseline;</xsl:when>
+            <xsl:when test="@w:val = 'bottom'">vertical-align:bottom;</xsl:when>
+            <xsl:when test="@w:val = 'auto'">vertical-align:baseline;</xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:wordWrap" mode="ppr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'off'">word-break:break-all;</xsl:when>
+            <xsl:otherwise>word-break:normal;</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="*" mode="ppr"/>
+
+
+    <xsl:template name="DisplayPContent">
+        <xsl:param name="b.bidi"/>
+        <xsl:param name="prsR"/>
+        <xsl:call-template name="DisplayRBorder">
+            <xsl:with-param name="b.bidi" select="$b.bidi"/>
+            <xsl:with-param name="prsR" select="$prsR"/>
+        </xsl:call-template>
+
+        <xsl:if test="count(*[not(name()='w:pPr')])=0"><xsl:text disable-output-escaping="yes">&#160;</xsl:text></xsl:if>
+    </xsl:template>
+
+    <xsl:template name="GetPStyleId">
+        <xsl:choose>
+            <xsl:when test="w:pPr/w:pStyle/@w:val">
+                <xsl:value-of select="w:pPr/w:pStyle/@w:val"/>
+            </xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="$paraStyleID_Default"/>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="RecursiveApplyPPr.many">
+        <xsl:if test="w:basedOn">
+            <xsl:variable name="baseStyleName" select="w:basedOn[1]/@w:val" />
+            <xsl:variable name="sParaStyleBase" select="($nsStyles[@w:styleId=$baseStyleName])[1]"/>
+            <xsl:for-each select="$sParaStyleBase"><xsl:call-template name="RecursiveApplyPPr.many" /></xsl:for-each>
+        </xsl:if>
+
+
+        <xsl:call-template name="ApplyPPr.many"/>
+
+    </xsl:template>
+
+
+    <xsl:template match="w:p">
+        <xsl:param name="bdrBetween" select="''"/>
+        <xsl:param name="prsPAccum" select="''"/>
+        <xsl:param name="prsP" select="$prsPDefault"/>
+        <xsl:param name="prsR" select="$prsRDefault"/>
+
+        <xsl:if test="not(w:pPr/w:pStyle/@w:val='z-TopofForm') and not(w:pPr/w:pStyle/@w:val='z-BottomofForm')">
+            <xsl:value-of select="'&#x0a;'"/>
+            <p>
+
+                <xsl:variable name="pStyleId">
+                    <xsl:call-template name="GetPStyleId"/>
+                </xsl:variable>
+                <xsl:variable name="sMappedStyleName" select="translate(($nsStyles[@w:styleId=$pStyleId])[1]/w:name/@w:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ', 'abcdefghijklmnopqrstuvwxyz')"/>
+                <xsl:attribute name="class">
+                    <xsl:value-of select="$sMappedStyleName"/>
+                </xsl:attribute>
+                <xsl:variable name="sParaStyleName" select="($nsStyles[@w:styleId=$pStyleId])[1]"/>
+                <xsl:variable name="b.bidi">
+                    <xsl:for-each select="w:pPr[1]/w:bidi[1]">
+                        <xsl:choose>
+                            <xsl:when test="@w:val = 'off'">
+                                <xsl:value-of select="$off"/>
+                            </xsl:when>
+                            <xsl:otherwise>
+                                <xsl:value-of select="$on"/>
+                            </xsl:otherwise>
+                        </xsl:choose>
+                    </xsl:for-each>
+                </xsl:variable>
+
+
+        <xsl:variable name="prsR.updated">
+            <xsl:call-template name="PrsUpdateRPr">
+                <xsl:with-param name="ndPrContainer" select="$sParaStyleName"/>
+                <xsl:with-param name="prsR" select="$prsR"/>
+            </xsl:call-template>
+        </xsl:variable>
+
+
+        <xsl:variable name="prsP.updated1">
+            <xsl:call-template name="PrsUpdatePPr">
+                <xsl:with-param name="ndPrContainer" select="$sParaStyleName"/>
+                <xsl:with-param name="prsP" select="$prsP"/>
+            </xsl:call-template>
+        </xsl:variable>
+
+        <xsl:variable name="prsP.updated">
+            <xsl:call-template name="PrsUpdatePPr">
+                <xsl:with-param name="prsP" select="$prsP.updated1"/>
+            </xsl:call-template>
+        </xsl:variable>
+
+
+        <xsl:variable name="styleMod">
+
+            <xsl:value-of select="$prsPAccum"/>
+
+
+            <xsl:for-each select="$sParaStyleName"><xsl:call-template name="RecursiveApplyPPr.many"/></xsl:for-each>
+
+
+            <xsl:call-template name="ApplyPPr.many">
+                <xsl:with-param name="cxtSpacing">
+                    <xsl:variable name="cspacing" select="$sParaStyleName/w:pPr[1]/w:contextualSpacing[1]"/>
+                    <xsl:if test="$cspacing and not($cspacing/@w:val = 'off')">
+                        <xsl:if test="following-sibling::*[1]/w:pPr[1]/w:pStyle[1]/@w:val = $pStyleId"><xsl:value-of select="$cxtSpacing_top"/></xsl:if>
+                        <xsl:if test="preceding-sibling::*[1]/w:pPr[1]/w:pStyle[1]/@w:val = $pStyleId"><xsl:value-of select="$cxtSpacing_bottom"/></xsl:if>
+                    </xsl:if>
+                </xsl:with-param>
+            </xsl:call-template>
+
+            <xsl:call-template name="ApplyPPr.class"/>
+
+            <xsl:call-template name="ApplyPPr.once">
+                <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                <xsl:with-param name="prsP" select="$prsP.updated"/>
+                <xsl:with-param name="i.bdrRange.this" select="position()"/>
+                <xsl:with-param name="i.bdrRange.last" select="last()"/>
+                <xsl:with-param name="pr.bdrBetween" select="$bdrBetween"/>
+            </xsl:call-template>
+        </xsl:variable>
+        <xsl:if test="not($styleMod='')"><xsl:attribute name="style"><xsl:value-of select="$styleMod"/></xsl:attribute></xsl:if>
+
+        <!-- Take out redundant span - DH -->
+        <!--<span>
+            <xsl:attribute name="class">
+                <xsl:value-of select="$pStyleId"/>
+                <xsl:value-of select="$charStyleSuffix"/>
+            </xsl:attribute>-->
+            <xsl:call-template name="DisplayPContent">
+                <xsl:with-param name="b.bidi" select="$b.bidi"/>
+                <xsl:with-param name="prsR" select="$prsR.updated"/>
+            </xsl:call-template>
+        <!--</span>-->
+        </p>
+        </xsl:if>
+    </xsl:template>
+
+
+    <xsl:template name="DisplayBodyContent">
+
+        <xsl:param name="ns.content" select="descendant::*[(parent::wx:sect or parent::wx:sub-section) and not(name()='wx:sub-section')]"/>
+        <xsl:param name="prsPAccum" select="''"/>
+        <xsl:param name="prsP" select="$prsPDefault"/>
+        <xsl:param name="prsR" select="$prsRDefault"/>
+        <xsl:apply-templates>
+            <xsl:with-param name="ns.content" select="$ns.content"/>
+            <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+            <xsl:with-param name="prsP" select="$prsP"/>
+            <xsl:with-param name="prsR" select="$prsR"/>
+        </xsl:apply-templates>
+
+        <xsl:if test="count($ns.content)=0"><xsl:text disable-output-escaping="yes">&#160;</xsl:text></xsl:if>
+    </xsl:template>
+
+
+    <xsl:template name="RecursiveApplyTcPr.class">
+        <xsl:if test="w:basedOn">
+            <xsl:variable name="baseStyleName" select="w:basedOn[1]/@w:val" />
+            <xsl:variable name="sTblStyleBase" select="($nsStyles[@w:styleId=$baseStyleName])[1]"/>
+            <xsl:for-each select="$sTblStyleBase"><xsl:call-template name="RecursiveApplyTcPr.class" /></xsl:for-each>
+        </xsl:if>
+
+
+        <xsl:call-template name="ApplyTcPr.class"/>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyTcPr.class">
+        <xsl:apply-templates select="w:tcPr[1]/*" mode="tcpr"/>
+    </xsl:template>
+
+    <xsl:template match="w:textFlow" mode="tcpr"><xsl:call-template name="ApplyTextDirection"/></xsl:template>
+
+    <xsl:template match="w:tcFitText" mode="tcpr">
+        <xsl:if test="not(@w:val = 'off')">text-fit:100%;</xsl:if>
+    </xsl:template>
+
+    <xsl:template match="w:vAlign" mode="tcpr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'center'">vertical-align:middle;</xsl:when>
+            <xsl:when test="@w:val = 'bottom'">vertical-align:bottom;</xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:noWrap" mode="tcpr">
+        <xsl:choose>
+            <xsl:when test="@w:val = 'off'">white-space:normal;</xsl:when>
+            <xsl:otherwise>white-space:nowrap;</xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:tcW" mode="tcpr">width:<xsl:call-template name="EvalTableWidth"/>;</xsl:template>
+    <xsl:template match="*" mode="tcpr"/>
+
+
+    <xsl:template name="ApplyExtraCornerBorders">
+        <xsl:param name="cnfType" />
+        <xsl:param name="sTblStyleName" />
+        <xsl:choose>
+            <xsl:when test="$cnfType=$cnfNWCell"><xsl:call-template name="ApplyExtraCornerBordersNW"><xsl:with-param name="sTblStyle" select="$sTblStyleName" /></xsl:call-template></xsl:when>
+            <xsl:when test="$cnfType=$cnfNECell"><xsl:call-template name="ApplyExtraCornerBordersNE"><xsl:with-param name="sTblStyle" select="$sTblStyleName" /></xsl:call-template></xsl:when>
+            <xsl:when test="$cnfType=$cnfSECell"><xsl:call-template name="ApplyExtraCornerBordersSE"><xsl:with-param name="sTblStyle" select="$sTblStyleName" /></xsl:call-template></xsl:when>
+            <xsl:when test="$cnfType=$cnfSWCell"><xsl:call-template name="ApplyExtraCornerBordersSW"><xsl:with-param name="sTblStyle" select="$sTblStyleName" /></xsl:call-template></xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyExtraCornerBordersNW">
+        <xsl:param name="sTblStyle" />
+
+
+        <xsl:variable name="firstColBorders" select="$sTblStyle/w:tblStylePr[@w:type=$cnfFirstCol][1]/w:tcPr[1]/w:tcBorders[1]" />
+        <xsl:variable name="firstRowBorders" select="$sTblStyle/w:tblStylePr[@w:type=$cnfFirstRow][1]/w:tcPr[1]/w:tcBorders[1]" />
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstRowBorders/w:top[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_top"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstColBorders/w:top[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_top"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstRowBorders/w:left[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_left"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstColBorders/w:left[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_left"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstRowBorders/w:right[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_right"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstColBorders/w:right[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_right"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstRowBorders/w:bottom[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_bottom"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstColBorders/w:bottom[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_bottom"/>
+        </xsl:call-template>
+    </xsl:template>
+
+    <xsl:template name="ApplyExtraCornerBordersNE">
+        <xsl:param name="sTblStyle" />
+
+
+        <xsl:variable name="lastColBorders"    select="$sTblStyle/w:tblStylePr[@w:type=$cnfLastCol][1]/w:tcPr[1]/w:tcBorders[1]" />
+        <xsl:variable name="firstRowBorders" select="$sTblStyle/w:tblStylePr[@w:type=$cnfFirstRow][1]/w:tcPr[1]/w:tcBorders[1]" />
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstRowBorders/w:top[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_top"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastColBorders/w:top[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_top"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstRowBorders/w:left[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_left"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastColBorders/w:left[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_left"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstRowBorders/w:right[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_right"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastColBorders/w:right[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_right"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstRowBorders/w:bottom[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_bottom"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastColBorders/w:bottom[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_bottom"/>
+        </xsl:call-template>
+    </xsl:template>
+
+    <xsl:template name="ApplyExtraCornerBordersSE">
+        <xsl:param name="sTblStyle" />
+
+
+        <xsl:variable name="lastColBorders"    select="$sTblStyle/w:tblStylePr[@w:type=$cnfLastCol][1]/w:tcPr[1]/w:tcBorders[1]" />
+        <xsl:variable name="lastRowBorders" select="$sTblStyle/w:tblStylePr[@w:type=$cnfLastRow][1]/w:tcPr[1]/w:tcBorders[1]" />
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastRowBorders/w:top[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_top"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastColBorders/w:top[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_top"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastRowBorders/w:left[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_left"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastColBorders/w:left[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_left"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastRowBorders/w:right[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_right"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastColBorders/w:right[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_right"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastColBorders/w:bottom[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_bottom"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastRowBorders/w:bottom[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_bottom"/>
+        </xsl:call-template>
+
+    </xsl:template>
+
+    <xsl:template name="ApplyExtraCornerBordersSW">
+        <xsl:param name="sTblStyle" />
+
+
+        <xsl:variable name="firstColBorders"    select="$sTblStyle/w:tblStylePr[@w:type=$cnfFirstCol][1]/w:tcPr[1]/w:tcBorders[1]" />
+        <xsl:variable name="lastRowBorders" select="$sTblStyle/w:tblStylePr[@w:type=$cnfLastRow][1]/w:tcPr[1]/w:tcBorders[1]" />
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastRowBorders/w:top[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_top"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstColBorders/w:top[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_top"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastRowBorders/w:left[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_left"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstColBorders/w:left[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_left"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastRowBorders/w:right[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_right"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstColBorders/w:right[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_right"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$lastRowBorders/w:bottom[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_bottom"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="ApplyBorderPr">
+            <xsl:with-param name="pr.bdr"><xsl:for-each select="$firstColBorders/w:bottom[1]"><xsl:call-template name="GetBorderPr" /></xsl:for-each></xsl:with-param>
+            <xsl:with-param name="bdrSide" select="$bdrSide_bottom"/>
+        </xsl:call-template>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyTcBordersFromCnf">
+        <xsl:param name="tcBorders" />
+        <xsl:param name="sTblStyleName" />
+        <xsl:param name="cnfType" />
+        <xsl:param name="thisRow"/>
+        <xsl:param name="lastRow"/>
+        <xsl:param name="bdr.top"/>
+        <xsl:param name="bdr.left"/>
+        <xsl:param name="bdr.bottom"/>
+        <xsl:param name="bdr.right"/>
+        <xsl:param name="bdrSide_right.bidi" />
+        <xsl:param name="bdrSide_left.bidi" />
+
+
+
+        <xsl:variable name="thisBdr.top">
+            <xsl:choose>
+                <xsl:when test="$tcBorders/w:top"><xsl:for-each select="$tcBorders/w:top[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                <xsl:when test="not($cnfType='')">
+                    <xsl:choose>
+                        <xsl:when test="$cnfType=$cnfBand1Vert or $cnfType=$cnfBand2Vert or $cnfType=$cnfFirstCol or $cnfType=$cnfLastCol">
+                            <xsl:variable name="p.cnfFirstRow" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfFirstRow][1]"/>
+                            <xsl:choose>
+                                <xsl:when test="$p.cnfFirstRow and $thisRow=2"><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:top[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                                <xsl:when test="not($p.cnfFirstRow) and $thisRow=1"><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:top[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                                <xsl:otherwise><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:insideH[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:otherwise>
+                            </xsl:choose>
+                        </xsl:when>
+                        <xsl:otherwise>
+                            <xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:top[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each>
+                        </xsl:otherwise>
+                    </xsl:choose>
+                </xsl:when>
+                <xsl:otherwise><xsl:value-of select="$bdr.top"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+        <xsl:variable name="thisBdr.bottom">
+            <xsl:choose>
+                <xsl:when test="$tcBorders/w:bottom"><xsl:for-each select="$tcBorders/w:bottom[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                <xsl:when test="not($cnfType='')">
+                    <xsl:choose>
+                        <xsl:when test="$cnfType=$cnfBand1Vert or $cnfType=$cnfBand2Vert or $cnfType=$cnfFirstCol or $cnfType=$cnfLastCol">
+                            <xsl:variable name="p.cnfLastRow" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfLastRow][1]"/>
+                            <xsl:choose>
+                                <xsl:when test="$p.cnfLastRow and $thisRow=$lastRow - 1"><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:bottom[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                                <xsl:when test="not($p.cnfLastRow) and $thisRow=$lastRow"><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:bottom[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                                <xsl:otherwise><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:insideH[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:otherwise>
+                            </xsl:choose>
+                        </xsl:when>
+                        <xsl:otherwise>
+                            <xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:bottom[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each>
+                        </xsl:otherwise>
+                    </xsl:choose>
+                </xsl:when>
+                <xsl:otherwise><xsl:value-of select="$bdr.bottom"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+        <xsl:variable name="thisBdr.left">
+            <xsl:choose>
+                <xsl:when test="$tcBorders/w:left"><xsl:for-each select="$tcBorders/w:left[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                <xsl:when test="not($cnfType='')">
+                    <xsl:choose>
+                        <xsl:when test="$cnfType=$cnfBand1Horz or $cnfType=$cnfBand2Horz">
+                            <xsl:variable name="p.cnfFirstCol" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfFirstCol][1]"/>
+                            <xsl:choose>
+                                <xsl:when test="$p.cnfFirstCol and position()=2"><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:left[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                                <xsl:when test="not($p.cnfFirstCol) and position()=1"><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:left[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                                <xsl:otherwise><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:insideV[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:otherwise>
+                            </xsl:choose>
+                        </xsl:when>
+                        <xsl:when test="$cnfType=$cnfFirstRow or $cnfType=$cnfLastRow">
+                            <xsl:choose>
+                                <xsl:when test="position()=1"><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:left[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                                <xsl:otherwise><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:insideV[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:otherwise>
+                            </xsl:choose>
+                        </xsl:when>
+                        <xsl:otherwise>
+                            <xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:left[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each>
+                        </xsl:otherwise>
+                    </xsl:choose>
+                </xsl:when>
+                <xsl:otherwise><xsl:value-of select="$bdr.left"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+        <xsl:variable name="thisBdr.right">
+            <xsl:choose>
+                <xsl:when test="$tcBorders/w:right"><xsl:for-each select="$tcBorders/w:right[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                <xsl:when test="not($cnfType='')">
+                    <xsl:choose>
+                        <xsl:when test="$cnfType=$cnfBand1Horz or $cnfType=$cnfBand2Horz">
+                            <xsl:variable name="p.cnfLastCol" select="$sTblStyleName/w:tblStylePr[@w:type=$cnfLastCol][1]"/>
+                            <xsl:choose>
+                                <xsl:when test="$p.cnfLastCol and position()=last() - 1"><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:right[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                                <xsl:when test="not($p.cnfLastCol) and position()=last()"><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:right[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                                <xsl:otherwise><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:insideV[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:otherwise>
+                            </xsl:choose>
+                        </xsl:when>
+                        <xsl:when test="$cnfType=$cnfFirstRow or $cnfType=$cnfLastRow">
+                            <xsl:choose>
+                                <xsl:when test="position()=last()"><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:right[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:when>
+                                <xsl:otherwise><xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:insideV[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each></xsl:otherwise>
+                            </xsl:choose>
+                        </xsl:when>
+                        <xsl:otherwise>
+                            <xsl:for-each select="$sTblStyleName/w:tblStylePr[@w:type=$cnfType][1]/w:tcPr[1]/w:tcBorders[1]/w:right[1]"><xsl:call-template name="GetBorderPr"/></xsl:for-each>
+                        </xsl:otherwise>
+                    </xsl:choose>
+                </xsl:when>
+                <xsl:otherwise><xsl:value-of select="$bdr.right"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+
+        <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$thisBdr.top"/><xsl:with-param name="bdrSide" select="$bdrSide_top"/></xsl:call-template>
+        <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$thisBdr.right"/><xsl:with-param name="bdrSide" select="$bdrSide_right.bidi"/></xsl:call-template>
+        <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$thisBdr.bottom"/><xsl:with-param name="bdrSide" select="$bdrSide_bottom"/></xsl:call-template>
+        <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$thisBdr.left"/><xsl:with-param name="bdrSide" select="$bdrSide_left.bidi"/></xsl:call-template>
+
+    </xsl:template>
+
+
+    <xsl:template name="ApplyTcPr.once">
+        <xsl:param name="cellspacing"/>
+        <xsl:param name="cellpadding.default"/>
+        <xsl:param name="cellpadding.custom"/>
+        <xsl:param name="bdr.top"/>
+        <xsl:param name="bdr.left"/>
+        <xsl:param name="bdr.bottom"/>
+        <xsl:param name="bdr.right"/>
+        <xsl:param name="bdr.insideV"/>
+        <xsl:param name="thisRow"/>
+        <xsl:param name="lastRow"/>
+        <xsl:param name="sTblStyleName"/>
+        <xsl:param name="cnfRow"/>
+        <xsl:param name="cnfCol"/>
+        <xsl:param name="b.bidivisual"/>
+
+
+
+
+
+
+
+        <xsl:variable name="cnfType">
+            <xsl:if test="not($cnfRow='' and $cnfCol='')">
+                <xsl:call-template name="GetCnfType"><xsl:with-param name="cnfRow" select="$cnfRow"/><xsl:with-param name="cnfCol" select="$cnfCol"/>
+                </xsl:call-template>
+            </xsl:if>
+        </xsl:variable>
+
+        <xsl:variable name="cnfTypeRow">
+            <xsl:if test="not($cnfRow='')">
+                <xsl:call-template name="GetCnfTypeRow"><xsl:with-param name="cnfRow" select="$cnfRow"/></xsl:call-template>
+            </xsl:if>
+        </xsl:variable>
+
+        <xsl:variable name="cnfTypeCol">
+            <xsl:if test="not($cnfCol='')">
+                <xsl:call-template name="GetCnfTypeCol"><xsl:with-param name="cnfCol" select="$cnfCol"/></xsl:call-template>
+            </xsl:if>
+        </xsl:variable>
+
+        <xsl:variable name="tcborders" select="w:tcPr[1]/w:tcBorders[1]"/>
+
+        <xsl:variable name="bdrSide_left.bidi">
+            <xsl:choose>
+                <xsl:when test="$b.bidivisual = $on"><xsl:value-of select="$bdrSide_right"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$bdrSide_left"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+        <xsl:variable name="bdrSide_right.bidi">
+            <xsl:choose>
+                <xsl:when test="$b.bidivisual = $on"><xsl:value-of select="$bdrSide_left"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$bdrSide_right"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+
+
+
+
+        <xsl:for-each select="$sTblStyleName/w:tblPr[1]/w:tblBorders[1]">
+            <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$bdr.top"/><xsl:with-param name="bdrSide" select="$bdrSide_top"/></xsl:call-template>
+            <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$bdr.bottom"/><xsl:with-param name="bdrSide" select="$bdrSide_bottom"/></xsl:call-template>
+            <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$bdr.right"/><xsl:with-param name="bdrSide" select="$bdrSide_right.bidi"/></xsl:call-template>
+            <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$bdr.left"/><xsl:with-param name="bdrSide" select="$bdrSide_left.bidi"/></xsl:call-template>
+        </xsl:for-each>
+
+
+        <xsl:call-template name="ApplyExtraCornerBorders"><xsl:with-param name="cnfType" select="$cnfType" /><xsl:with-param name="sTblStyleName" select="$sTblStyleName" /></xsl:call-template>
+
+
+        <xsl:call-template name="ApplyTcBordersFromCnf">
+            <xsl:with-param name="cnfType" select="$cnfTypeRow" />
+            <xsl:with-param name="sTblStyleName" select="$sTblStyleName" />
+            <xsl:with-param name="tcBorders" select="$tcborders" />
+            <xsl:with-param name="bdrSide_right.bidi" select="$bdrSide_right.bidi" />
+            <xsl:with-param name="bdrSide_left.bidi" select="$bdrSide_left.bidi" />
+            <xsl:with-param name="thisRow" select="$thisRow"/>
+            <xsl:with-param name="lastRow" select="$lastRow"/>
+
+            <xsl:with-param name="bdr.top" select="$bdr.top"/>
+            <xsl:with-param name="bdr.left" select="$bdr.left"/>
+            <xsl:with-param name="bdr.right" select="$bdr.right"/>
+            <xsl:with-param name="bdr.bottom" select="$bdr.bottom"/>
+        </xsl:call-template>
+
+
+        <xsl:call-template name="ApplyTcBordersFromCnf">
+            <xsl:with-param name="cnfType" select="$cnfTypeCol" />
+            <xsl:with-param name="sTblStyleName" select="$sTblStyleName" />
+            <xsl:with-param name="tcBorders" select="$tcborders" />
+            <xsl:with-param name="bdrSide_right.bidi" select="$bdrSide_right.bidi" />
+            <xsl:with-param name="bdrSide_left.bidi" select="$bdrSide_left.bidi" />
+            <xsl:with-param name="thisRow" select="$thisRow"/>
+            <xsl:with-param name="lastRow" select="$lastRow"/>
+
+            <xsl:with-param name="bdr.top" select="$bdr.top"/>
+            <xsl:with-param name="bdr.left" select="$bdr.left"/>
+            <xsl:with-param name="bdr.right" select="$bdr.right"/>
+            <xsl:with-param name="bdr.bottom" select="$bdr.bottom"/>
+        </xsl:call-template>
+
+
+
+
+
+
+        <xsl:variable name="cellpadding.custom.merged">
+
+            <xsl:variable name="temp.direct">
+                <xsl:for-each select="w:tcPr[1]/w:tcMar[1]"><xsl:call-template name="ApplyCellMar"/></xsl:for-each>
+            </xsl:variable>
+            <xsl:value-of select="$temp.direct"/>
+            <xsl:if test="$temp.direct=''">
+
+                <xsl:variable name="temp.cnf">
+                    <xsl:for-each select="$sTblStyleName">
+                        <xsl:call-template name="GetCnfPr.cell">
+                            <xsl:with-param name="type" select="$prrCustomCellpadding"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                        </xsl:call-template>
+                    </xsl:for-each>
+                </xsl:variable>
+                <xsl:value-of select="$temp.cnf"/>
+                <xsl:if test="$temp.cnf=''">
+
+                    <xsl:value-of select="$cellpadding.custom"/>
+                </xsl:if>
+            </xsl:if>
+        </xsl:variable>
+        <xsl:variable name="cellpadding.default.merged">
+
+            <xsl:variable name="temp.cnf">
+                <xsl:for-each select="$sTblStyleName">
+                    <xsl:call-template name="GetCnfPr.cell">
+                        <xsl:with-param name="type" select="$prrDefaultCellpadding"/><xsl:with-param name="cnfCol" select="$cnfCol"/><xsl:with-param name="cnfRow" select="$cnfRow"/>
+                    </xsl:call-template>
+                </xsl:for-each>
+            </xsl:variable>
+            <xsl:value-of select="$temp.cnf"/>
+            <xsl:if test="$temp.cnf=''">
+
+                <xsl:value-of select="$cellpadding.default"/>
+            </xsl:if>
+        </xsl:variable>
+        <xsl:choose>
+            <xsl:when test="$cellpadding.custom.merged = 'none' and not($cellpadding.default.merged='')"><xsl:value-of select="$cellpadding.default.merged"/></xsl:when>
+            <xsl:when test="not($cellpadding.custom.merged='')"><xsl:value-of select="$cellpadding.custom.merged"/></xsl:when>
+            <xsl:when test="not($cellpadding.default.merged='')"><xsl:value-of select="$cellpadding.default.merged"/></xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+
+    <xsl:template match="w:tc">
+        <xsl:param name="sTblStyleName"/>
+        <xsl:param name="prsPAccum"/>
+        <xsl:param name="prsP"/>
+        <xsl:param name="prsR"/>
+        <xsl:param name="cellspacing"/>
+        <xsl:param name="cellpadding.default"/>
+        <xsl:param name="cellpadding.custom"/>
+        <xsl:param name="bdr.top"/>
+        <xsl:param name="bdr.left"/>
+        <xsl:param name="bdr.bottom"/>
+        <xsl:param name="bdr.right"/>
+        <xsl:param name="bdr.insideV"/>
+        <xsl:param name="bdr.insideH"/>
+        <xsl:param name="thisRow"/>
+        <xsl:param name="lastRow"/>
+        <xsl:param name="cnfRow"/>
+        <xsl:param name="b.bidivisual"/>
+        <xsl:param name="table_celltype" select="'td'"/>
+
+        <xsl:variable name="cnfCol" select="string(w:tcPr[1]/w:cnfStyle[1]/@w:val)"/>
+        <xsl:variable name="vmerge" select="w:tcPr[1]/w:vmerge[1]"/>
+        <xsl:variable name="me" select="." />
+        <xsl:variable name="tblCount" select="count(ancestor::w:tbl)" />
+        <xsl:variable name="meInContext" select="ancestor::w:tr[1]/*[count($me|descendant-or-self::*)=count(descendant-or-self::*)]" />
+        <xsl:variable name="before" select="count($meInContext/preceding-sibling::*[descendant-or-self::*[name()='w:tc' and (count(ancestor::w:tbl)=$tblCount)]])" />
+        <xsl:variable name="after" select="count($meInContext/following-sibling::*[descendant-or-self::*[name()='w:tc' and (count(ancestor::w:tbl)=$tblCount)]])" />
+
+        <xsl:if test="not($vmerge and not($vmerge/@w:val))">
+            <xsl:value-of select="$debug_newline"/>
+            <xsl:element name="{$table_celltype}">
+
+        <xsl:if test="$sTblStyleName/@w:styleId != ''">
+            <xsl:attribute name="class">
+                <xsl:value-of select="$sTblStyleName/@w:styleId"/>
+            </xsl:attribute>
+        </xsl:if>
+
+            <xsl:for-each select="w:tcPr[1]/w:gridSpan[1]/@w:val">
+                <xsl:attribute name="colspan">
+                    <xsl:value-of select="."/>
+                </xsl:attribute>
+            </xsl:for-each>
+
+            <xsl:variable name="rowspan">
+                <xsl:choose>
+                    <xsl:when test="not($vmerge)">1</xsl:when>
+                    <xsl:when test="$vmerge/@wx:rowspan"><xsl:value-of select="$vmerge/@wx:rowspan"/></xsl:when>
+
+
+                    <xsl:otherwise>
+                        <xsl:variable name="myRow" select="ancestor::w:tr[1]" />
+                        <xsl:variable name="myRowInContext" select="$myRow/ancestor::w:tbl[1]/*[count($myRow|descendant-or-self::*)=count(descendant-or-self::*)]" />
+                        <xsl:variable name="belowMe" select="$myRowInContext/following-sibling::*//w:tc[count(ancestor::w:tbl)=$tblCount][$before + 1]" />
+                        <xsl:variable name="NextRestart" select="($belowMe//w:tcPr/w:vmerge[@w:val='restart'])[1]" />
+                        <xsl:variable name="NextRestartInContext" select="$NextRestart/ancestor::w:tbl[1]/*[count($NextRestart|descendant-or-self::*)=count(descendant-or-self::*)]" />
+                        <xsl:variable name="mergesAboveMe"                                select="count($myRowInContext/preceding-sibling::*[(descendant-or-self::*[name()='w:tc'])[$before + 1][descendant-or-self::*[name()='w:vmerge']]])" />
+                        <xsl:variable name="mergesAboveNextRestart" select="count($NextRestartInContext/preceding-sibling::*[(descendant-or-self::*[name()='w:tc'])[$before + 1][descendant-or-self::*[name()='w:vmerge']]])" />
+
+                        <xsl:choose>
+                            <xsl:when test="$NextRestart"><xsl:value-of select="$mergesAboveNextRestart - $mergesAboveMe"/></xsl:when>
+                            <xsl:when test="$vmerge/@w:val"><xsl:value-of select="count($belowMe[descendant-or-self::*[name()='w:vmerge']]) + 1" /></xsl:when>
+                            <xsl:otherwise>1</xsl:otherwise>
+                        </xsl:choose>
+                    </xsl:otherwise>
+                </xsl:choose>
+            </xsl:variable>
+
+            <xsl:if test="$vmerge">
+                <xsl:attribute name="rowspan">
+                    <xsl:value-of select="$rowspan"/>
+                </xsl:attribute>
+            </xsl:if>
+            <xsl:variable name="lastRow.updated" select="$lastRow - $rowspan + 1"/>
+
+            <xsl:variable name="bdr.bottom.updated">
+                <xsl:choose>
+                    <xsl:when test="$cellspacing='' and $thisRow=$lastRow.updated"><xsl:value-of select="$bdr.bottom"/></xsl:when>
+                    <xsl:otherwise><xsl:value-of select="$bdr.insideH"/></xsl:otherwise>
+                </xsl:choose>
+            </xsl:variable>
+            <xsl:variable name="bdr.left.updated">
+                <xsl:choose>
+                    <xsl:when test="$cellspacing='' and $before=0"><xsl:value-of select="$bdr.left"/></xsl:when>
+                    <xsl:otherwise><xsl:value-of select="$bdr.insideV"/></xsl:otherwise>
+                </xsl:choose>
+            </xsl:variable>
+            <xsl:variable name="bdr.right.updated">
+                <xsl:choose>
+                    <xsl:when test="$cellspacing='' and $after=0"><xsl:value-of select="$bdr.right"/></xsl:when>
+                    <xsl:otherwise><xsl:value-of select="$bdr.insideV"/></xsl:otherwise>
+                </xsl:choose>
+            </xsl:variable>
+
+            <xsl:attribute name="style">
+
+                <xsl:if test="not($cnfRow='' and $cnfCol='')">
+                    <xsl:for-each select="$sTblStyleName">
+                        <xsl:call-template name="GetCnfPr.all">
+                            <xsl:with-param name="type" select="$prrApplyTcPr"/>
+                            <xsl:with-param name="cnfRow" select="$cnfRow"/><xsl:with-param name="cnfCol" select="$cnfCol"/>
+                        </xsl:call-template>
+                    </xsl:for-each>
+                </xsl:if>
+
+                <xsl:call-template name="ApplyTcPr.class"/>
+                <xsl:call-template name="ApplyTcPr.once">
+                    <xsl:with-param name="thisRow" select="$thisRow"/><xsl:with-param name="lastRow" select="$lastRow.updated"/>
+                    <xsl:with-param name="cellspacing" select="$cellspacing"/><xsl:with-param name="cellpadding.default" select="$cellpadding.default"/><xsl:with-param name="cellpadding.custom" select="$cellpadding.custom"/>
+                    <xsl:with-param name="bdr.top" select="$bdr.top"/><xsl:with-param name="bdr.left" select="$bdr.left.updated"/><xsl:with-param name="bdr.right" select="$bdr.right.updated"/><xsl:with-param name="bdr.bottom" select="$bdr.bottom.updated"/>
+                    <xsl:with-param name="bdr.insideV" select="$bdr.insideV"/>
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfRow" select="$cnfRow"/><xsl:with-param name="cnfCol" select="$cnfCol"/>
+                    <xsl:with-param name="b.bidivisual" select="$b.bidivisual"/>
+                </xsl:call-template>
+            </xsl:attribute>
+            <xsl:choose>
+                <xsl:when test="$cnfRow='' and $cnfCol=''">
+
+                    <xsl:call-template name="DisplayBodyContent"><xsl:with-param name="ns.content" select="*"/><xsl:with-param name="prsPAccum" select="$prsPAccum"/><xsl:with-param name="prsP" select="$prsP"/><xsl:with-param name="prsR" select="$prsR"/></xsl:call-template>
+                </xsl:when>
+                <xsl:otherwise>
+
+                    <xsl:call-template name="WrapCnf">
+                        <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/><xsl:with-param name="cnfRow" select="$cnfRow"/><xsl:with-param name="cnfCol" select="$cnfCol"/>
+                        <xsl:with-param name="prsPAccum" select="$prsPAccum"/><xsl:with-param name="prsP" select="$prsP"/><xsl:with-param name="prsR" select="$prsR"/>
+                    </xsl:call-template>
+                </xsl:otherwise>
+            </xsl:choose>
+            </xsl:element>
+        </xsl:if>
+    </xsl:template>
+
+
+    <xsl:template name="RecursiveApplyTrPr.class">
+        <xsl:if test="w:basedOn">
+            <xsl:variable name="baseStyleName" select="w:basedOn[1]/@w:val" />
+            <xsl:variable name="sTblStyleBase" select="($nsStyles[@w:styleId=$baseStyleName])[1]"/>
+            <xsl:for-each select="$sTblStyleBase"><xsl:call-template name="RecursiveApplyTrPr.class" /></xsl:for-each>
+        </xsl:if>
+
+
+        <xsl:call-template name="ApplyTrPr.class"/>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyTrPr.class">
+        <xsl:for-each select="w:trPr">
+
+            <xsl:text>height:</xsl:text>
+            <xsl:choose><xsl:when test="w:trHeight/@w:val"><xsl:value-of select="w:trHeight[1]/@w:val div 20"/>pt</xsl:when><xsl:otherwise>0</xsl:otherwise></xsl:choose>
+            <xsl:text>;</xsl:text>
+
+            <xsl:for-each select="w:cantSplit[1]">
+                <xsl:choose>
+                    <xsl:when test="@w:val = 'off'">page-break-inside:auto;</xsl:when>
+                    <xsl:otherwise>page-break-inside:avoid;</xsl:otherwise>
+                </xsl:choose>
+            </xsl:for-each>
+        </xsl:for-each>
+    </xsl:template>
+
+
+    <xsl:template name="DisplayEmptyCell">
+        <xsl:param name="i" select="1"/>
+        <xsl:param name="table_celltype"/>
+
+        <xsl:element name="{$table_celltype}">
+            <xsl:attribute name="colspan">
+                <xsl:value-of select="$i"/>
+            </xsl:attribute>
+        </xsl:element>
+    </xsl:template>
+
+
+    <xsl:template match="w:tr">
+        <xsl:param name="sTblStyleName"/>
+        <xsl:param name="prsPAccum"/>
+        <xsl:param name="prsP"/>
+        <xsl:param name="prsR"/>
+        <xsl:param name="cellspacing"/>
+        <xsl:param name="cellpadding.default"/>
+        <xsl:param name="cellpadding.custom"/>
+        <xsl:param name="bdr.top"/>
+        <xsl:param name="bdr.left"/>
+        <xsl:param name="bdr.bottom"/>
+        <xsl:param name="bdr.right"/>
+        <xsl:param name="bdr.insideH"/>
+        <xsl:param name="bdr.insideV"/>
+        <xsl:param name="b.bidivisual"/>
+        <xsl:param name="table_celltype" select="'td'"/>
+
+        <xsl:value-of select="$debug_newline"/>
+        <tr>
+
+        <xsl:if test="$sTblStyleName/@w:styleId != ''">
+            <xsl:attribute name="class">
+                <xsl:value-of select="$sTblStyleName/@w:styleId"/>
+            </xsl:attribute>
+        </xsl:if>
+
+        <xsl:variable name="cnfRow" select="string(w:trPr[1]/w:cnfStyle[1]/@w:val)"/>
+
+        <xsl:variable name="styleMod">
+
+            <xsl:if test="not($cnfRow='')">
+                <xsl:for-each select="$sTblStyleName">
+                    <xsl:call-template name="GetCnfPr.row"><xsl:with-param name="type" select="$prrCantSplit"/><xsl:with-param name="cnfRow" select="$cnfRow"/></xsl:call-template>
+                </xsl:for-each>
+            </xsl:if>
+
+            <xsl:call-template name="ApplyTrPr.class"/>
+        </xsl:variable>
+        <xsl:if test="not($styleMod='')">
+            <xsl:attribute name="style"><xsl:value-of select="$styleMod"/></xsl:attribute>
+        </xsl:if>
+
+        <xsl:variable name="me" select="." />
+        <xsl:variable name="tblCount" select="count(ancestor::w:tbl)" />
+        <xsl:variable name="meInContext" select="ancestor::w:tbl[1]/*[count($me|descendant-or-self::*)=count(descendant-or-self::*)]" />
+        <xsl:variable name="before" select="count($meInContext/preceding-sibling::*[descendant-or-self::*[name()='w:tr' and (count(ancestor::w:tbl)=$tblCount)]])" />
+        <xsl:variable name="after" select="count($meInContext/following-sibling::*[descendant-or-self::*[name()='w:tr' and (count(ancestor::w:tbl)=$tblCount)]])" />
+        <xsl:variable name="thisRow" select="$before + 1"/>
+        <xsl:variable name="lastRow" select="$before + $after + 1"/>
+
+        <xsl:variable name="bdr.top.updated">
+            <xsl:choose>
+                <xsl:when test="$cellspacing='' and $thisRow=1"><xsl:value-of select="$bdr.top"/></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$bdr.insideH"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+        <xsl:for-each select="w:trPr[1]/w:gridBefore[1]/@w:val">
+            <xsl:call-template name="DisplayEmptyCell">
+                <xsl:with-param name="i"><xsl:value-of select="."/></xsl:with-param>
+                <xsl:with-param name="table_celltype"><xsl:value-of select="$table_celltype"/></xsl:with-param>
+            </xsl:call-template>
+        </xsl:for-each>
+
+        <xsl:apply-templates select="*[not(name()='w:trPr')]">
+            <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+            <xsl:with-param name="prsP" select="$prsP"/>
+            <xsl:with-param name="prsR" select="$prsR"/>
+            <xsl:with-param name="thisRow" select="$thisRow"/><xsl:with-param name="lastRow" select="$lastRow"/>
+            <xsl:with-param name="cellspacing" select="$cellspacing"/><xsl:with-param name="cellpadding.default" select="$cellpadding.default"/><xsl:with-param name="cellpadding.custom" select="$cellpadding.custom"/>
+            <xsl:with-param name="bdr.top" select="$bdr.top.updated"/><xsl:with-param name="bdr.left" select="$bdr.left"/><xsl:with-param name="bdr.right" select="$bdr.right"/><xsl:with-param name="bdr.bottom" select="$bdr.bottom"/><xsl:with-param name="bdr.insideV" select="$bdr.insideV"/><xsl:with-param name="bdr.insideH" select="$bdr.insideH"/>
+            <xsl:with-param name="cnfRow" select="$cnfRow"/>
+            <xsl:with-param name="b.bidivisual" select="$b.bidivisual"/>
+            <xsl:with-param name="table_celltype" select="$table_celltype"/>
+        </xsl:apply-templates>
+
+        <xsl:for-each select="w:trPr[1]/w:gridAfter[1]/@w:val">
+            <xsl:call-template name="DisplayEmptyCell">
+                <xsl:with-param name="i"><xsl:value-of select="."/></xsl:with-param>
+                <xsl:with-param name="table_celltype"><xsl:value-of select="$table_celltype"/></xsl:with-param>
+            </xsl:call-template>
+        </xsl:for-each>
+        </tr>
+    </xsl:template>
+
+
+    <xsl:template name="RecursiveApplyTblPr.class">
+        <xsl:if test="w:basedOn">
+            <xsl:variable name="baseStyleName" select="w:basedOn[1]/@w:val" />
+            <xsl:variable name="sTblStyleBase" select="($nsStyles[@w:styleId=$baseStyleName])[1]"/>
+            <xsl:for-each select="$sTblStyleBase"><xsl:call-template name="RecursiveApplyTblPr.class" /></xsl:for-each>
+        </xsl:if>
+
+
+        <xsl:call-template name="ApplyTblPr.class"/>
+    </xsl:template>
+
+
+    <xsl:template name="ApplyTblPr.class">
+        <xsl:for-each select="w:tblPr[1]">
+
+            <xsl:if test="w:tblpPr/@w:topFromText">margin-top:<xsl:value-of select="w:tblpPr/@w:topFromText[1] div 20"/>pt;</xsl:if>
+            <xsl:if test="w:tblpPr/@w:rightFromText">margin-right:<xsl:value-of select="w:tblpPr/@w:rightFromText[1] div 20"/>pt;</xsl:if>
+            <xsl:if test="w:tblpPr/@w:bottomFromText">margin-bottom:<xsl:value-of select="w:tblpPr/@w:bottomFromText[1] div 20"/>pt;</xsl:if>
+            <xsl:if test="w:tblpPr/@w:leftFromText">margin-left:<xsl:value-of select="w:tblpPr/@w:leftFromText[1] div 20"/>pt;</xsl:if>
+
+            <xsl:for-each select="w:tblW[1]">width:<xsl:call-template name="EvalTableWidth"/>;</xsl:for-each>
+        </xsl:for-each>
+    </xsl:template>
+
+
+    <xsl:template name="tblCore">
+        <xsl:value-of select="$debug_newline"/>
+        <table>
+
+        <xsl:variable name="tStyleId">
+            <xsl:value-of select="w:tblPr[1]/w:tblStyle[1]/@w:val"/>
+        </xsl:variable>
+
+        <!-- Check if this table is a question meta-table, to distinguish between tables inside the content -->
+        <xsl:variable name="tableType">
+            <xsl:if test="w:tr[1]/w:tc[2]/w:p[1]/w:pPr[1]/w:pStyle[1]/@w:val = 'QFType'">
+                <xsl:value-of select="' moodleQuestion'"/>
+            </xsl:if>
+        </xsl:variable>
+
+        <xsl:attribute name="class"><xsl:value-of select="concat($tStyleId, $tableType)"/></xsl:attribute>
+        <xsl:variable name="sTblStyleName" select="($nsStyles[@w:styleId=$tStyleId])[1]"/>
+
+        <xsl:variable name="cellspacingTEMP">
+            <xsl:call-template name="GetSingleTblPr">
+                <xsl:with-param name="type" select="$prrCellspacing"/><xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+        <xsl:variable name="cellspacing">
+            <xsl:choose>
+
+                <xsl:when test="$cellspacingTEMP='0'"></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$cellspacingTEMP"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+        <xsl:variable name="cellpadding.default">
+            <xsl:call-template name="GetSingleTblPr">
+                <xsl:with-param name="type" select="$prrDefaultCellpadding"/><xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+        <xsl:variable name="cellpadding.custom">
+            <xsl:for-each select="$sTblStyleName/w:tcPr[1]/w:tcMar[1]">
+                <xsl:call-template name="ApplyCellMar"/>
+            </xsl:for-each>
+        </xsl:variable>
+
+        <xsl:variable name="tblInd">
+            <xsl:call-template name="GetSingleTblPr">
+                <xsl:with-param name="type" select="$prrTblInd"/><xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+
+        <xsl:variable name="bdr.top">
+            <xsl:call-template name="GetSingleTblPr">
+                <xsl:with-param name="type" select="$prrBdrPr_top"/><xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+        <xsl:variable name="bdr.left">
+            <xsl:call-template name="GetSingleTblPr">
+                <xsl:with-param name="type" select="$prrBdrPr_left"/><xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+        <xsl:variable name="bdr.bottom">
+            <xsl:call-template name="GetSingleTblPr">
+                <xsl:with-param name="type" select="$prrBdrPr_bottom"/><xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+        <xsl:variable name="bdr.right">
+            <xsl:call-template name="GetSingleTblPr">
+                <xsl:with-param name="type" select="$prrBdrPr_right"/><xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+
+        <xsl:variable name="bdr.insideH">
+            <xsl:call-template name="GetSingleTblPr">
+                <xsl:with-param name="type" select="$prrBdrPr_insideH"/><xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+        <xsl:variable name="bdr.insideV">
+            <xsl:call-template name="GetSingleTblPr">
+                <xsl:with-param name="type" select="$prrBdrPr_insideV"/><xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+
+        <xsl:variable name="b.bidivisual">
+            <xsl:for-each select="w:tblPr[1]/w:bidiVisual[1]">
+                <xsl:choose>
+                    <xsl:when test="@w:val = 'off'"><xsl:value-of select="$off"/></xsl:when>
+                    <xsl:otherwise><xsl:value-of select="$on"/></xsl:otherwise>
+                </xsl:choose>
+            </xsl:for-each>
+        </xsl:variable>
+
+        <xsl:variable name="align"><xsl:for-each select="w:tblPr[1]/w:tblpPr[1]/@w:tblpXSpec"><xsl:value-of select="."/></xsl:for-each></xsl:variable>
+        <xsl:if test="not($align='')"><xsl:attribute name="align"><xsl:choose><xsl:when test="$align = 'right' or $align = 'outside'">right</xsl:when><xsl:otherwise>left</xsl:otherwise></xsl:choose></xsl:attribute></xsl:if>
+
+        <xsl:attribute name="cellspacing">
+            <xsl:choose>
+                <xsl:when test="$cellspacing=''">0</xsl:when>
+                <xsl:otherwise><xsl:value-of select="($cellspacing div 1440) * $pixelsPerInch"/></xsl:otherwise>
+            </xsl:choose>
+        </xsl:attribute>
+        <xsl:if test="$cellspacing=''"><xsl:attribute name="cellspacing">0</xsl:attribute></xsl:if>
+
+        <xsl:variable name="styleMod">
+            <xsl:call-template name="ApplyTblPr.class"/>
+
+            <xsl:choose>
+                <xsl:when test="$cellspacing=''">border-collapse:collapse;</xsl:when>
+                <xsl:otherwise>
+                    <xsl:text>border-collapse:separate;</xsl:text>
+                    <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$bdr.top"/><xsl:with-param name="bdrSide" select="$bdrSide_top"/></xsl:call-template>
+                    <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$bdr.left"/><xsl:with-param name="bdrSide" select="$bdrSide_left"/></xsl:call-template>
+                    <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$bdr.bottom"/><xsl:with-param name="bdrSide" select="$bdrSide_bottom"/></xsl:call-template>
+                    <xsl:call-template name="ApplyBorderPr"><xsl:with-param name="pr.bdr" select="$bdr.right"/><xsl:with-param name="bdrSide" select="$bdrSide_right"/></xsl:call-template>
+                </xsl:otherwise>
+            </xsl:choose>
+
+            <xsl:if test="$b.bidivisual=$on">direction:rtl;</xsl:if>
+
+            <xsl:if test="not(w:tblPr/w:tblpPr)">
+                <xsl:text>margin-</xsl:text>
+                <xsl:choose>
+                    <xsl:when test="$b.bidivisual=$on">right</xsl:when>
+                    <xsl:otherwise>left</xsl:otherwise>
+                </xsl:choose>
+                <xsl:text>:</xsl:text>
+                <xsl:value-of select="$tblInd"/>
+                <xsl:text>;</xsl:text>
+            </xsl:if>
+        </xsl:variable>
+        <xsl:if test="not($styleMod='')">
+            <xsl:attribute name="style"><xsl:value-of select="$styleMod"/></xsl:attribute>
+        </xsl:if>
+
+        <xsl:variable name="prsPAccum">
+
+            <xsl:for-each select="w:tblPr[1]/w:bidiVisual[1]">
+                <xsl:if test="not(@w:val = 'off')">
+                    <xsl:value-of select="concat('direction:', $moodle_textdirection, ';')"/>
+                </xsl:if>
+            </xsl:for-each>
+
+            <xsl:for-each select="$sTblStyleName"><xsl:call-template name="ApplyPPr.many"/></xsl:for-each>
+        </xsl:variable>
+
+        <xsl:variable name="prsR">
+            <xsl:call-template name="PrsUpdateRPr">
+                <xsl:with-param name="ndPrContainer" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+
+        <xsl:variable name="prsP">
+            <xsl:call-template name="PrsUpdatePPr">
+                <xsl:with-param name="ndPrContainer" select="$sTblStyleName"/>
+            </xsl:call-template>
+        </xsl:variable>
+
+        <!-- Check for Heading Row Repeat flag, and insert thead/tbody to separate them -->
+        <xsl:if test="w:tr[1]/w:trPr/w:tblHeader">
+            <thead>
+                <xsl:apply-templates select="*[not(name()='w:tblPr' or name()='w:tblGrid') and w:trPr/w:tblHeader]">
+                    <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+                    <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                    <xsl:with-param name="prsP" select="$prsP"/>
+                    <xsl:with-param name="prsR" select="$prsR"/>
+                    <xsl:with-param name="cellspacing" select="$cellspacing"/><xsl:with-param name="cellpadding.default" select="$cellpadding.default"/><xsl:with-param name="cellpadding.custom" select="$cellpadding.custom"/>
+                    <xsl:with-param name="bdr.top" select="$bdr.top"/><xsl:with-param name="bdr.left" select="$bdr.left"/><xsl:with-param name="bdr.right" select="$bdr.right"/><xsl:with-param name="bdr.bottom" select="$bdr.bottom"/>
+                    <xsl:with-param name="bdr.insideH" select="$bdr.insideH"/><xsl:with-param name="bdr.insideV" select="$bdr.insideV"/>
+                    <xsl:with-param name="b.bidivisual" select="$b.bidivisual"/>
+                    <xsl:with-param name="table_celltype" select="'th'"/>
+                </xsl:apply-templates>
+            </thead>
+        </xsl:if>
+        <tbody>
+            <xsl:apply-templates select="*[not(name()='w:tblPr' or name()='w:tblGrid') and not(w:trPr/w:tblHeader)]">
+                <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+                <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                <xsl:with-param name="prsP" select="$prsP"/>
+                <xsl:with-param name="prsR" select="$prsR"/>
+                <xsl:with-param name="cellspacing" select="$cellspacing"/><xsl:with-param name="cellpadding.default" select="$cellpadding.default"/><xsl:with-param name="cellpadding.custom" select="$cellpadding.custom"/>
+                <xsl:with-param name="bdr.top" select="$bdr.top"/><xsl:with-param name="bdr.left" select="$bdr.left"/><xsl:with-param name="bdr.right" select="$bdr.right"/><xsl:with-param name="bdr.bottom" select="$bdr.bottom"/>
+                <xsl:with-param name="bdr.insideH" select="$bdr.insideH"/><xsl:with-param name="bdr.insideV" select="$bdr.insideV"/>
+                <xsl:with-param name="b.bidivisual" select="$b.bidivisual"/>
+            </xsl:apply-templates>
+        </tbody>
+        <!--<xsl:for-each select="w:tblGrid[1]">
+            <xsl:text disable-output-escaping="yes">&lt;![if !supportMisalignedColumns]&gt;</xsl:text>
+            <tr height="0">
+            <xsl:for-each select="w:gridCol">
+                <xsl:variable name="gridStyle">margin:0;padding:0;border:none;width:<xsl:call-template name="EvalTableWidth"/>;</xsl:variable>
+                <td style="{$gridStyle}"/>
+            </xsl:for-each>
+            </tr>
+            <xsl:text disable-output-escaping="yes">&lt;![endif]&gt;</xsl:text>
+        </xsl:for-each>-->
+        </table>
+    </xsl:template>
+
+    <xsl:template match="w:tbl[w:tblPr/w:jc/@w:val]">
+        <xsl:variable name="p.Jc" select="w:tblPr/w:jc/@w:val"/>
+        <div>
+            <xsl:attribute name="align"><xsl:value-of select="$p.Jc"/></xsl:attribute>
+
+            <xsl:call-template name="tblCore"/>
+        </div>
+    </xsl:template>
+
+    <xsl:template match="w:tbl">
+        <xsl:call-template name="tblCore"/>
+    </xsl:template>
+
+    <xsl:template name="hrCore">
+        <xsl:param name="p.Hr"/>
+            <hr>
+                <xsl:attribute name="style"><xsl:value-of select="substring-after($p.Hr/@style, ';')"/></xsl:attribute>
+                <xsl:attribute name="align"><xsl:value-of select="$p.Hr/@o:hralign"/></xsl:attribute>
+                <xsl:if test="$p.Hr/@o:hrnoshade='t'">
+                    <xsl:attribute name="noshade">
+                        <xsl:text>1</xsl:text>
+                    </xsl:attribute>
+                    <xsl:attribute name="color">
+                        <xsl:value-of select="$p.Hr/@fillcolor"/>
+                    </xsl:attribute>
+                </xsl:if>
+                <xsl:if test="$p.Hr/@o:hrpct">
+                    <xsl:attribute name="width">
+                        <xsl:value-of select="$p.Hr/@o:hrpct div 10"/>
+                        <xsl:text>%</xsl:text>
+                    </xsl:attribute>
+                </xsl:if>
+            </hr>
+    </xsl:template>
+
+    <xsl:template match="w:body">
+
+        <xsl:attribute name="style">
+            <xsl:variable name="divBody" select="//wordmlContainer/w:document/w:divs/w:div[w:bodyDiv/@w:val='on']"/>
+            <xsl:variable name="dxaBodyLeft">
+                <xsl:value-of select="$divBody/w:marLeft/@w:val"/>
+            </xsl:variable>
+            <xsl:variable name="dxaBodyRight">
+                <xsl:value-of select="$divBody/w:marRight/@w:val"/>
+            </xsl:variable>
+            <xsl:if test="not($dxaBodyLeft='' or $dxaBodyLeft=0)">
+                    <xsl:text>margin-left:</xsl:text><xsl:value-of select="$dxaBodyLeft div 20"/><xsl:text>pt;</xsl:text>
+            </xsl:if>
+            <xsl:if test="not($dxaBodyRight='' or $dxaBodyRight=0)">
+                <xsl:text>margin-right:</xsl:text><xsl:value-of select="$dxaBodyRight div 20"/><xsl:text>pt;</xsl:text>
+            </xsl:if>
+        </xsl:attribute>
+        <xsl:apply-templates select="*"/>
+    </xsl:template>
+
+
+    <xsl:template match="w:font">
+        <xsl:text>@font-face{font-family:"</xsl:text>
+        <xsl:value-of select="@w:name"/>
+        <xsl:text>";panose-1:</xsl:text>
+        <xsl:variable name="panose1">
+            <xsl:call-template name="ConvertHexToDec">
+                <xsl:with-param name="value" select="w:panose-1[1]/@w:val"/>
+                <xsl:with-param name="i" select="2"/>
+                <xsl:with-param name="s" select="2"/>
+            </xsl:call-template>
+        </xsl:variable>
+        <xsl:value-of select="substring($panose1,2)"/>
+        <xsl:text>;}</xsl:text>
+    </xsl:template>
+
+
+    <xsl:template name="MakeRStyle">
+        <xsl:param name="basetype"/>
+        <xsl:text>.</xsl:text><xsl:value-of select="@w:styleId"/><xsl:value-of select="$charStyleSuffix"/>
+        <xsl:text>{</xsl:text>
+            <xsl:call-template name="MakeRStyleCore"><xsl:with-param name="basetype" select="$basetype"/></xsl:call-template>
+        <xsl:text>}
+            </xsl:text>
+    </xsl:template>
+
+    <xsl:template name="MakeRStyleCore">
+        <xsl:param name="basetype"/>
+
+            <xsl:choose>
+                    <xsl:when test="w:basedOn/@w:val">
+                            <xsl:variable name="sBasedOn">
+                                    <xsl:value-of select="w:basedOn/@w:val"/>
+                            </xsl:variable>
+                            <xsl:for-each select="$nsStyles[@w:styleId=$sBasedOn]">
+                                    <xsl:call-template name="MakeRStyleCore"><xsl:with-param name="basetype" select="$basetype"/></xsl:call-template>
+                            </xsl:for-each>
+                    </xsl:when>
+                    <xsl:otherwise>
+                            <xsl:if test="$basetype='paragraph'">
+
+                                    <xsl:text>font-size: 10pt;</xsl:text>
+                            </xsl:if>
+                    </xsl:otherwise>
+            </xsl:choose>
+
+
+            <xsl:call-template name="ApplyRPr.class"/>
+    </xsl:template>
+
+    <xsl:template name="MakePStyle">
+
+            <xsl:text>.</xsl:text>
+            <xsl:value-of select="@w:styleId"/>
+            <xsl:text>{
+            </xsl:text>
+            <xsl:call-template name="MakePStyleCore"/>
+            <xsl:text>}
+            </xsl:text>
+
+            <xsl:call-template name="MakeRStyle"><xsl:with-param name="basetype" select="'paragraph'"/></xsl:call-template>
+    </xsl:template>
+
+    <xsl:template name="MakePStyleCore">
+        <xsl:param name="beforeAutospace" select="$off" />
+        <xsl:param name="afterAutospace" select="$off" />
+
+
+        <xsl:variable name="spacing" select="w:pPr[1]/w:spacing[1]"/>
+        <xsl:variable name="beforeAutospaceHere">
+            <xsl:choose>
+                <xsl:when test="$spacing/@w:before-autospacing = 'on'"><xsl:value-of select="$on" /></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$beforeAutospace" /></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+        <xsl:variable name="afterAutospaceHere">
+            <xsl:choose>
+                <xsl:when test="$spacing/@w:after-autospacing = 'on'"><xsl:value-of select="$on" /></xsl:when>
+                <xsl:otherwise><xsl:value-of select="$afterAutospace" /></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+            <xsl:choose>
+                    <xsl:when test="w:basedOn/@w:val">
+                            <xsl:variable name="sBasedOn">
+                                    <xsl:value-of select="w:basedOn/@w:val"/>
+                            </xsl:variable>
+                            <xsl:for-each select="$nsStyles[@w:styleId=$sBasedOn]">
+                                    <xsl:call-template name="MakePStyleCore">
+                        <xsl:with-param name="beforeAutospace" select="$beforeAutospaceHere" />
+                        <xsl:with-param name="afterAutospace" select="$afterAutospaceHere" />
+                    </xsl:call-template>
+                            </xsl:for-each>
+                    </xsl:when>
+                    <xsl:otherwise>
+                            <xsl:text>margin-left:</xsl:text>
+                            <xsl:value-of select="$paraMarginDefaultLeft"/>
+                            <xsl:text>;margin-right:</xsl:text>
+                            <xsl:value-of select="$paraMarginDefaultRight"/>
+
+                            <xsl:if test="not($beforeAutospace = $on)" >
+                    <xsl:if test="(not($spacing/@w:before-autospacing) or $spacing/@w:before-autospacing = 'off')">
+                        <xsl:text>;margin-top:</xsl:text><xsl:value-of select="$paraMarginDefaultTop"/>
+                    </xsl:if>
+                </xsl:if>
+
+                            <xsl:if test="not($afterAutospace = $on)" >
+                    <xsl:if test="(not($spacing/@w:after-autospacing) or $spacing/@w:after-autospacing = 'off')">
+                        <xsl:text>;margin-bottom:</xsl:text><xsl:value-of select="$paraMarginDefaultBottom"/>
+                    </xsl:if>
+                </xsl:if>
+
+                            <xsl:text>;font-size:10.0pt;font-family:"Times New Roman";</xsl:text>
+                    </xsl:otherwise>
+            </xsl:choose>
+
+            <xsl:call-template name="ApplyPPr.class"/>
+    </xsl:template>
+
+    <xsl:template name="MakeTblStyle">
+            <xsl:variable name="styleId" select="@w:styleId"/>
+
+            <xsl:text>.</xsl:text><xsl:value-of select="$styleId"/>
+            <xsl:text>{</xsl:text><xsl:call-template name="RecursiveApplyTblPr.class"/><xsl:text>} </xsl:text>
+
+            <xsl:text>.</xsl:text><xsl:value-of select="$styleId"/>
+            <xsl:text>{</xsl:text><xsl:call-template name="RecursiveApplyTrPr.class"/><xsl:text>} </xsl:text>
+
+            <xsl:text>.</xsl:text><xsl:value-of select="$styleId"/>
+            <xsl:text>{vertical-align:top;</xsl:text>
+
+            <xsl:call-template name="RecursiveApplyTcPr.class"/>
+
+            <xsl:call-template name="RecursiveApplyPPr.class"/>
+
+            <xsl:call-template name="RecursiveApplyRPr.class"/>
+            <xsl:text>} </xsl:text>
+
+            <xsl:for-each select="w:tblStylePr">
+                    <xsl:text>.</xsl:text><xsl:value-of select="$styleId"/>-<xsl:value-of select="@w:type"/>
+                    <xsl:text>{vertical-align:top;</xsl:text>
+                    <xsl:call-template name="ApplyPPr.class"/>
+                    <xsl:call-template name="ApplyRPr.class"/>
+                    <xsl:text>} </xsl:text>
+            </xsl:for-each>
+    </xsl:template>
+
+
+    <xsl:template match="w:style">
+        <xsl:choose>
+
+            <xsl:when test="@w:type = 'character'">
+                <xsl:call-template name="MakeRStyle"/>
+            </xsl:when>
+
+            <xsl:when test="@w:type = 'paragraph'">
+                            <xsl:call-template name="MakePStyle"/>
+                    </xsl:when>
+
+            <xsl:when test="@w:type = 'table'">
+                            <xsl:call-template name="MakeTblStyle"/>
+            </xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="w:bookmarkStart">
+        <a class="bookmarkStart" name="{@w:name}" id="{@w:id}"/>
+    </xsl:template>
+
+    <xsl:template match="w:bookmarkEnd">
+        <a class="bookmarkEnd" id="{@w:id}"/>
+    </xsl:template>
+
+    <xsl:template name="copyElements">
+        <xsl:param name="sTblStyleName"/>
+        <xsl:param name="prsPAccum"/>
+        <xsl:param name="prsP"/>
+        <xsl:param name="prsR"/>
+        <xsl:param name="cellspacing"/>
+        <xsl:param name="cellpadding.default"/>
+        <xsl:param name="cellpadding.custom"/>
+        <xsl:param name="bdr.top"/>
+        <xsl:param name="bdr.left"/>
+        <xsl:param name="bdr.bottom"/>
+        <xsl:param name="bdr.right"/>
+        <xsl:param name="bdr.insideV"/>
+        <xsl:param name="bdr.insideH"/>
+        <xsl:param name="thisRow"/>
+        <xsl:param name="lastRow"/>
+        <xsl:param name="cnfRow"/>
+        <xsl:param name="b.bidivisual"/>
+        <xsl:element name="{name()}" namespace="{namespace-uri()}">
+            <xsl:for-each select="@*">
+                <xsl:attribute name="{name()}" namespace="{namespace-uri()}">
+                    <xsl:value-of select="."/>
+                </xsl:attribute>
+            </xsl:for-each>
+            <xsl:apply-templates>
+                        <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+                        <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+                        <xsl:with-param name="prsP" select="$prsP"/>
+                        <xsl:with-param name="prsR" select="$prsR"/>
+                        <xsl:with-param name="cellspacing" select="$cellspacing"/>
+                        <xsl:with-param name="cellpadding.default" select="$cellpadding.default"/>
+                        <xsl:with-param name="cellpadding.custom" select="$cellpadding.custom"/>
+                        <xsl:with-param name="bdr.top" select="$bdr.top"/>
+                        <xsl:with-param name="bdr.left" select="$bdr.left"/>
+                        <xsl:with-param name="bdr.bottom" select="$bdr.bottom"/>
+                        <xsl:with-param name="bdr.right" select="$bdr.right"/>
+                        <xsl:with-param name="bdr.insideV" select="$bdr.insideV"/>
+                        <xsl:with-param name="bdr.insideH" select="$bdr.insideH"/>
+                        <xsl:with-param name="thisRow" select="$thisRow"/>
+                        <xsl:with-param name="lastRow" select="$lastRow"/>
+                        <xsl:with-param name="cnfRow" select="$cnfRow"/>
+                        <xsl:with-param name="b.bidivisual" select="$b.bidivisual"/>
+                    </xsl:apply-templates>
+        </xsl:element>
+    </xsl:template>
+
+    <xsl:template match="*">
+        <xsl:param name="sTblStyleName"/>
+        <xsl:param name="prsPAccum"/>
+        <xsl:param name="prsP"/>
+        <xsl:param name="prsR"/>
+        <xsl:param name="cellspacing"/>
+        <xsl:param name="cellpadding.default"/>
+        <xsl:param name="cellpadding.custom"/>
+        <xsl:param name="bdr.top"/>
+        <xsl:param name="bdr.left"/>
+        <xsl:param name="bdr.bottom"/>
+        <xsl:param name="bdr.right"/>
+        <xsl:param name="bdr.insideV"/>
+        <xsl:param name="bdr.insideH"/>
+        <xsl:param name="thisRow"/>
+        <xsl:param name="lastRow"/>
+        <xsl:param name="cnfRow"/>
+        <xsl:param name="b.bidivisual"/>
+        <xsl:call-template name="copyElements">
+            <xsl:with-param name="sTblStyleName" select="$sTblStyleName"/>
+            <xsl:with-param name="prsPAccum" select="$prsPAccum"/>
+            <xsl:with-param name="prsP" select="$prsP"/>
+            <xsl:with-param name="prsR" select="$prsR"/>
+            <xsl:with-param name="cellspacing" select="$cellspacing"/>
+            <xsl:with-param name="cellpadding.default" select="$cellpadding.default"/>
+            <xsl:with-param name="cellpadding.custom" select="$cellpadding.custom"/>
+            <xsl:with-param name="bdr.top" select="$bdr.top"/>
+            <xsl:with-param name="bdr.left" select="$bdr.left"/>
+            <xsl:with-param name="bdr.bottom" select="$bdr.bottom"/>
+            <xsl:with-param name="bdr.right" select="$bdr.right"/>
+            <xsl:with-param name="bdr.insideV" select="$bdr.insideV"/>
+            <xsl:with-param name="bdr.insideH" select="$bdr.insideH"/>
+            <xsl:with-param name="thisRow" select="$thisRow"/>
+            <xsl:with-param name="lastRow" select="$lastRow"/>
+            <xsl:with-param name="cnfRow" select="$cnfRow"/>
+            <xsl:with-param name="b.bidivisual" select="$b.bidivisual"/>
+            </xsl:call-template>
+    </xsl:template>
+
+    <xsl:template match="v:*"/>
+
+    <xsl:template match="w:ruby">
+        <ruby>
+
+
+            <xsl:attribute name="lang">
+                <xsl:value-of select="w:rubyPr/w:lid/@w:val" />
+            </xsl:attribute>
+
+            <xsl:attribute name="style">
+
+
+                <xsl:variable name="align" select="w:rubyPr/w:rubyAlign/@w:val" />
+                <xsl:text>ruby-align:</xsl:text>
+                <xsl:choose>
+                    <xsl:when test="$align='rightVertical'"><xsl:text>auto</xsl:text></xsl:when>
+                    <xsl:when test="$align='distributeLetter'"><xsl:text>distribute-letter</xsl:text></xsl:when>
+                    <xsl:when test="$align='distributeSpace'"><xsl:text>distribute-space</xsl:text></xsl:when>
+                    <xsl:otherwise><xsl:value-of select="$align" /></xsl:otherwise>
+                </xsl:choose>
+
+
+            </xsl:attribute>
+
+            <span>
+                <xsl:if test="w:rubyPr/w:hpsBaseText">
+                    <xsl:attribute name="style">
+                        <xsl:text>font-size:</xsl:text>
+                        <xsl:value-of select="w:rubyPr/w:hpsBaseText/@w:val" /><xsl:text>pt;</xsl:text>
+                    </xsl:attribute>
+                </xsl:if>
+
+                <xsl:apply-templates select="w:rubyBase/w:r"/>
+            </span>
+
+
+            <rt>
+                <span>
+                    <xsl:if test="w:rubyPr/w:hps">
+                        <xsl:attribute name="style">
+                            <xsl:text>font-size:</xsl:text>
+                            <xsl:value-of select="w:rubyPr/w:hps/@w:val div 2" /><xsl:text>pt;</xsl:text>
+                        </xsl:attribute>
+
+
+                        <xsl:apply-templates select="w:rt/w:r/w:t"/>
+                    </xsl:if>
+                </span>
+            </rt>
+        </ruby>
+    </xsl:template>
+
+
+    <!-- Footnote handling replaced -->
+    <!--<xsl:template match="w:footnote">
+
+        <xsl:variable name="me" select="." />
+        <xsl:variable name="meInContext" select="ancestor::w:r[1]/*[count($me|descendant-or-self::*)=count(descendant-or-self::*)]" />
+        <xsl:variable name="start">
+            <xsl:choose>
+                <xsl:when test="$ndDocPr/w:footnotePr/w:numStart">
+                    <xsl:value-of select="$ndDocPr/w:footnotePr/w:numStart/@w:val" />
+                </xsl:when>
+                <xsl:otherwise><xsl:value-of select="1" /></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+        <xsl:variable name="position" select="count($meInContext/preceding::*[name()='w:footnote' and ancestor::w:body]) + $start" />
+
+        <sup>
+            <a>
+                <xsl:attribute name="name"><xsl:value-of select="$footnoteRefLink" /><xsl:value-of select="$position" /></xsl:attribute>
+                <xsl:attribute name="href"><xsl:text>#</xsl:text><xsl:value-of select="$footnoteLink" /><xsl:value-of select="$position" /></xsl:attribute>
+                <xsl:text>[</xsl:text><xsl:value-of select="$position" /><xsl:text>]</xsl:text>
+            </a>
+        </sup>
+    </xsl:template>-->
+
+
+
+    <xsl:template match="w:endnote">
+
+        <xsl:variable name="me" select="." />
+        <xsl:variable name="meInContext" select="ancestor::w:r[1]/*[count($me|descendant-or-self::*)=count(descendant-or-self::*)]" />
+        <xsl:variable name="start">
+            <xsl:choose>
+                <xsl:when test="$ndDocPr/w:endnotePr/w:numStart">
+                    <xsl:value-of select="$ndDocPr/w:endnotePr/w:numStart/@w:val" />
+                </xsl:when>
+                <xsl:otherwise><xsl:value-of select="1" /></xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+        <xsl:variable name="position" select="count($meInContext/preceding::*[name()='w:endnote' and ancestor::w:body]) + $start" />
+
+        <sup>
+            <a>
+                <xsl:attribute name="name"><xsl:value-of select="$endnoteRefLink" /><xsl:value-of select="$position" /></xsl:attribute>
+                <xsl:attribute name="href"><xsl:text>#</xsl:text><xsl:value-of select="$endnoteLink" /><xsl:value-of select="$position" /></xsl:attribute>
+                <xsl:text>[</xsl:text><xsl:value-of select="$position" /><xsl:text>]</xsl:text>
+            </a>
+        </sup>
+    </xsl:template>
+
+
+    <xsl:template name="IsListBullet">
+
+
+
+        <xsl:variable name="ilfo" select="w:ilfo/@w:val"/>
+        <xsl:variable name="ilvl" select="w:ilvl/@w:val"/>
+        <xsl:variable name="list" select="$ndLists/w:list[@w:ilfo=$ilfo][1]"/>
+
+        <xsl:variable name="nfc">
+
+
+            <xsl:choose>
+                <xsl:when test="$ndLists/w:listDef[@w:listDefId=$list/w:ilst/@w:val][1]/w:lvl[@w:ilvl=$ilvl][1]">
+                    <xsl:for-each select="$ndLists/w:listDef[@w:listDefId=$list/w:ilst/@w:val][1]/w:lvl[@w:ilvl=$ilvl][1]">
+                        <xsl:choose>
+                            <xsl:when test="$list/w:lvlOverride[@w:ilvl=$ilvl]/w:nfc">
+                                <xsl:value-of select="$list/w:lvlOverride[@w:ilvl=$ilvl]/w:nfc/@w:val" />
+                            </xsl:when>
+                            <xsl:otherwise>
+                                <xsl:value-of select="$ndLists/w:listDef[@w:listDefId=$list/w:ilst/@w:val][1]/w:lvl[@w:ilvl=$ilvl][1]/w:nfc/@w:val" />
+                            </xsl:otherwise>
+                        </xsl:choose>
+                    </xsl:for-each>
+                </xsl:when>
+
+                <xsl:when test="$list/w:lvlOverride[@w:ilvl=$ilvl]">
+                    <xsl:for-each select="$list/w:lvlOverride[@w:ilvl=$ilvl]">
+                        <xsl:value-of select="w:nfc/@w:val" />
+                    </xsl:for-each>
+                </xsl:when>
+
+                <xsl:when test="$ndLists/w:listDef[@w:listDefId=$list/w:ilst/@w:val][1]/w:listStyleLink">
+                    <xsl:variable name="linkedStyleId" select="$ndLists/w:listDef[@w:listDefId=$list/w:ilst/@w:val][1]/w:listStyleLink/@w:val" />
+                    <xsl:variable name="linkedStyle" select="$nsStyles[@w:styleId=$linkedStyleId]" />
+                    <xsl:variable name="linkedList" select="w:list[@w:ilfo=$linkedStyle/w:pPr/w:listPr/w:ilfo/@w:val]" />
+                    <xsl:for-each select="$ndLists/w:listDef[@w:listDefId=$linkedList/w:ilst/@w:val][1]/w:lvl[@w:ilvl=$ilvl][1]">
+                        <xsl:value-of select="w:nfc/@w:val" />
+                    </xsl:for-each>
+                </xsl:when>
+            </xsl:choose>
+        </xsl:variable>
+
+        <xsl:if test="$nfc=$nfcBullet"><xsl:value-of select="$on" /></xsl:if>
+    </xsl:template>
+
+
+    <xsl:template match="w:fldSimple">
+        <xsl:apply-templates/>
+    </xsl:template>
+
+
+    <xsl:template match="w:*"/>
+
+    <xsl:template match="wx:*"/>
+
+    <xsl:template match="o:WordFieldCodes"/>
+
+    <xsl:template match="w:cfChunk">
+        <xsl:apply-templates />
+    </xsl:template>
+
+    <xsl:template match="//wordmlContainer/w:document">
+    
+        <html>
+            <head>
+                <!-- Dublin Core properties from file docProps/core.xml-->
+                <xsl:for-each select="$dublinCore/*">
+                    <xsl:if test="string-length(.) &gt; 0">
+                        <xsl:value-of select="$debug_newline"/>
+                        <meta name="{concat('dc:', local-name())}" content="{normalize-space(.)}"/>
+                    </xsl:if>
+                </xsl:for-each>
+                <!-- Custom document properties from file docProps/custom.xml-->
+                <xsl:for-each select="$customProps/*">
+                    <xsl:if test="local-name() = 'property'">
+                        <xsl:value-of select="$debug_newline"/>
+                        <meta name="{@name}" content="{normalize-space(.)}"/>
+                    </xsl:if>
+                </xsl:for-each>
+
+                <!-- Image data in Base64, generated from files in word/media folder of .docx file -->
+                <xsl:if test="$debug_flag &gt; 1">
+                    <xsl:value-of select="$debug_newline"/>
+                    <imagesContainer>
+                        <xsl:for-each select="$imagesContainer/*">
+                            <xsl:value-of select="$debug_newline"/>
+                            <file filename="{@filename}" mime-type="{@mime-type}">
+                                <xsl:value-of select="substring(normalize-space(.), 1, 100)"/>
+                            </file>
+                        </xsl:for-each>
+                        <xsl:value-of select="$debug_newline"/>
+                    </imagesContainer>
+                    <xsl:value-of select="$debug_newline"/>
+                </xsl:if>
+                <!-- Image relationships from file word/_rels/document.xml.rels -->
+                <xsl:if test="$debug_flag &gt; 1">
+                    <xsl:value-of select="$debug_newline"/>
+                    <imageLinks>
+                        <xsl:for-each select="$imageLinks">
+                            <xsl:value-of select="$debug_newline"/>
+                            <Relationship Id="{@Id}" Target="{@Target}" TargetMode="{@TargetMode}"/>
+                        </xsl:for-each>
+                        <xsl:value-of select="$debug_newline"/>
+                    </imageLinks>
+                </xsl:if>
+                <!-- Style mapping language-specific names to language-independent ids from file word/styles.xml -->
+                <xsl:if test="$debug_flag &gt; 1">
+                    <xsl:value-of select="$debug_newline"/>
+                    <styleMap>
+                        <xsl:comment><xsl:value-of select="concat('style count: ', count($nsStyles[name() = 'w:style']))"/></xsl:comment>
+                        <xsl:for-each select="$nsStyles">
+                            <xsl:value-of select="$debug_newline"/>
+                            <style styleId="{@w:styleId}" styleName="{w:name/@w:val}" customStyle="{@w:customStyle}"/>
+                        </xsl:for-each>
+                        <xsl:value-of select="$debug_newline"/>
+                    </styleMap>
+                </xsl:if>
+                <!-- Hyperlink mapping from file word/_rels/document.xml.rels -->
+                <xsl:if test="$debug_flag &gt; 1">
+                    <xsl:value-of select="$debug_newline"/>
+                    <hyperLinks>
+                        <xsl:comment><xsl:value-of select="concat('link count: ', count($hyperLinks))"/></xsl:comment>
+                        <xsl:for-each select="$hyperLinks">
+                            <xsl:value-of select="$debug_newline"/>
+                            <xsl:element name="Relationship">
+                                <xsl:attribute name="Id">
+                                    <xsl:value-of select="@Id"/>
+                                </xsl:attribute>
+                                <xsl:attribute name="Target">
+                                    <xsl:value-of select="@Target"/>
+                                </xsl:attribute>
+                                <xsl:attribute name="TargetMode">
+                                    <xsl:value-of select="@TargetMode"/>
+                                </xsl:attribute>
+                            </xsl:element>
+                        </xsl:for-each>
+                        <xsl:value-of select="$debug_newline"/>
+                    </hyperLinks>
+                    <xsl:value-of select="$debug_newline"/>
+                </xsl:if>
+            </head>
+            <body>
+                <div class="level1">
+                    <xsl:apply-templates select="w:body | w:cfChunk"/>
+
+                    <xsl:if test="//w:body//w:endnote">
+                        <xsl:variable name="start">
+                            <xsl:choose>
+                                <xsl:when test="$ndDocPr/w:endnotePr/w:numStart">
+                                    <xsl:value-of select="$ndDocPr/w:endnotePr/w:numStart/@w:val" />
+                                </xsl:when>
+                                <xsl:otherwise><xsl:value-of select="0" /></xsl:otherwise>
+                            </xsl:choose>
+                        </xsl:variable>
+                        <hr align="left" size="1" width="33%" />
+                        <xsl:for-each select="//w:body//w:endnote">
+                            <a target="self">
+                                <xsl:attribute name="href">
+                                    <xsl:text>#</xsl:text>
+                                    <xsl:value-of select="$endnoteRefLink" />
+                                    <xsl:value-of select="position() + $start" />
+                                </xsl:attribute>
+                                <xsl:attribute name="name">
+                                    <xsl:value-of select="$endnoteLink" />
+                                    <xsl:value-of select="position() + $start" />
+                                </xsl:attribute>
+                                <xsl:text>[</xsl:text>
+                                <xsl:value-of select="position() + $start" />
+                                <xsl:text>]</xsl:text>
+                            </a>
+                            <xsl:apply-templates select="*" />
+                        </xsl:for-each>
+                    </xsl:if>
+                </div>
+            </body>
+            <!-- Keep original images data if importing directly into database -->
+            <xsl:if test="$pluginname = 'atto_wordimport'">
+                <xsl:apply-templates select="//imagesContainer"/>
+            </xsl:if>
+        </html>
+    </xsl:template>
+    
+
+    <!-- Handle images -->
+    <xsl:template match="w:p/w:r/w:drawing">
+        <!-- Embedded images -->
+        <xsl:variable name="img_rid" select=".//a:blip/@r:embed"/>
+        <xsl:variable name="img_filename" select="$imageLinks[@Id = $img_rid]/@Target"/>
+        <xsl:call-template name="debugComment">
+            <xsl:with-param name="comment_text" select="concat('img_rid = ', $img_rid, '; img_filename = ', $img_filename)"/>
+            <xsl:with-param name="inline" select="'true'"/>
+            <xsl:with-param name="condition" select="$debug_flag = '2' and $img_rid != ''"/>
+        </xsl:call-template>
+
+        <!-- External linked images -->
+        <xsl:variable name="img_external_rid" select=".//a:blip/@r:link"/>
+        <xsl:variable name="img_external_filename" select="$imageLinks[@Id = $img_external_rid]/@Target"/>
+        <xsl:call-template name="debugComment">
+            <xsl:with-param name="comment_text" select="concat('img_external_rid = ', $img_external_rid, '; img_external_filename = ', $img_external_filename)"/>
+            <xsl:with-param name="inline" select="'true'"/>
+            <xsl:with-param name="condition" select="$debug_flag = '2' and $img_external_rid != ''"/>
+        </xsl:call-template>
+
+        <!-- Hyperlinked images -->
+        <xsl:variable name="img_hyperlink_rid" select=".//a:hlinkClick/@r:id"/>
+        <xsl:variable name="img_hyperlink" select="$hyperLinks[@Id = $img_hyperlink_rid]/@Target"/>
+        <xsl:call-template name="debugComment">
+            <xsl:with-param name="comment_text" select="concat('img_hyperlink_rid = ', $img_hyperlink_rid, '; img_hyperlink = ', $img_hyperlink)"/>
+            <xsl:with-param name="inline" select="'true'"/>
+            <xsl:with-param name="condition" select="$debug_flag = '2' and $img_hyperlink_rid != ''"/>
+        </xsl:call-template>
+
+        <!-- Map title field to alt attribute -->
+        <xsl:variable name="img_alt" select="wp:inline/wp:docPr/@title"/>
+        <!-- The wp:extent/@cx and @cy attributes define the size of the image. They are denominated in 
+             EMUs (English Metric Units); 1 inch = 914400, therefore 1 pixel = 914400 / 96 (dpi) = 9525 
+             cf. http://polymathprogrammer.com/2009/10/22/english-metric-units-and-open-xml/ -->
+        <!-- Map wp:extent/@cx and @cy fields to width/height, and round to integers -->
+        <xsl:variable name="img_width" select="substring-before(wp:inline/wp:extent/@cx div 9525, '.')"/>
+        <xsl:variable name="img_height" select="substring-before(wp:inline/wp:extent/@cy div 9525, '.')"/>
+
+        <!-- Map description field to longdesc attribute -->
+        <xsl:variable name="img_longdesc" select="wp:inline/wp:docPr/@descr"/>
+        <!-- Map name field to id attribute: it contains a sequence number for the image, e.g. "Picture 1" -->
+        <xsl:variable name="img_id" select="translate(wp:inline/wp:docPr/@name, ' ', '')"/>
+        <!-- Store the internal file name in the class attribute, for want of a better place
+        <xsl:variable name="img_class" select="$img_filename"/>
+        -->
+        <!-- Store the image data or URL in the src attribute -->
+        <xsl:variable name="img_src">
+            <xsl:choose>
+            <xsl:when test="$img_rid != '' and $pluginname = 'atto_wordimport'">
+                <!-- Dereference the reference ID field to get the file name, and map to the src attribute -->
+                <xsl:value-of select="$imagesContainer/file[@filename = $img_filename]"/>
+            </xsl:when>
+            <xsl:when test="$img_rid != '' and $pluginname = 'booktool_wordimport'">
+                <!-- Dereference the reference ID field to get the file name, and map to the src attribute -->
+                <xsl:value-of select="substring-after($img_filename, '/')"/>
+            </xsl:when>
+            <xsl:when test="$img_rid != ''">
+                <!-- Dereference the reference ID field to get the file name, and map to the src attribute -->
+                <xsl:value-of select="concat('data:', $imagesContainer/file[@filename = $img_filename]/@mime-type, ';base64,', $imagesContainer/file[@filename = $img_filename])"/>
+            </xsl:when>
+            <xsl:when test="$img_external_rid != ''">
+                <!-- External image, so just keep the URL -->
+                <xsl:value-of select="$img_external_filename"/>
+            </xsl:when>
+            </xsl:choose>
+        </xsl:variable>
+
+        <!-- Handle case where image might be hyperlinked -->
+        <xsl:choose>
+        <xsl:when test="$img_hyperlink != ''">
+            <!-- The image is linked -->
+            <a href="{$img_hyperlink}">
+                <img src="{$img_src}" id="{$img_id}" alt="{$img_alt}" longdesc="{$img_longdesc}">
+                    <xsl:if test="$img_width != ''">
+                        <xsl:attribute name="width">
+                            <xsl:value-of select="$img_width"/>
+                        </xsl:attribute>
+                        <xsl:attribute name="height">
+                            <xsl:value-of select="$img_height"/>
+                        </xsl:attribute>
+                    </xsl:if>
+                </img>
+            </a>
+        </xsl:when>
+        <xsl:otherwise>
+            <!-- The image is not linked -->
+            <img src="{$img_src}" id="{$img_id}" alt="{$img_alt}" longdesc="{$img_longdesc}">
+                <xsl:if test="$img_width != ''">
+                    <xsl:attribute name="width">
+                        <xsl:value-of select="$img_width"/>
+                    </xsl:attribute>
+                    <xsl:attribute name="height">
+                        <xsl:value-of select="$img_height"/>
+                    </xsl:attribute>
+                </xsl:if>
+            </img>
+        </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+    
+    <xsl:template match="w:p/w:r/w:pict">
+        <xsl:choose>
+            <xsl:when test="v:shape/@alt">
+                <img src="{v:shape/@alt}"/>
+            </xsl:when>
+            <xsl:otherwise>
+            </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <!-- Handle equations by converting them to MathML -->
+    <xsl:template match="m:oMathPara">
+        <xsl:apply-templates/>
+    </xsl:template>
+    <xsl:template match="m:oMathParaPr"/>
+
+    <xsl:template match="m:oMath">
+        <math xmlns="http://www.w3.org/1998/Math/MathML">
+            <xsl:apply-templates />
+        </math>
+    </xsl:template>
+
+    <!-- Handle w:dir, which Word sometimes wraps around w:r elements in RTL texts like Arabic -->
+    <xsl:template match="w:dir">
+        <xsl:apply-templates/>
+    </xsl:template>
+
+    <!-- Delete the bookmark marking the last cursor position-->
+    <xsl:template match="w:bookmarkStart[@w:name = '_GoBack']"/>
+    <xsl:template match="w:bookmarkEnd[@w:id = '0']"/>
+
+    <!-- Footnote references: ignore them for the moment -->
+    <xsl:template match="w:r[w:rPr/w:rStyle/@w:val = 'FootnoteReference' and w:footnoteReference]"/>
+    <!--
+    <xsl:template match="w:footnoteReference">
+        <sup>
+            <a class="fnref" href="{concat('#', $footnoteRefLink, @w:id)}" name="{concat($footnoteLink, @w:id)}"/>
+        </sup>
+    </xsl:template>
+    -->
+
+    <xsl:template match="/">
+        <xsl:apply-templates select="//wordmlContainer/w:document"/>
+    </xsl:template>
+
+    <!-- Roll up adjacent w:instrText elements to avoid splitting of Word field code 
+    <xsl:template match="/">
+        <xsl:variable name="instrText">
+            <xsl:apply-templates mode="instrText"/>
+        </xsl:variable>
+        <xsl:apply-templates select="$instrText" mode="continue"/>
+    </xsl:template>
+
+    <xsl:template match="/" mode="continue">
+        <xsl:apply-templates select="*"/>
+    </xsl:template>
+-->
+    <xsl:template match="w:p" mode="instrText">
+        <xsl:copy>
+            <xsl:apply-templates select="@*" mode="instrText"/>
+            <xsl:apply-templates select="*" mode="instrText"/>
+        </xsl:copy>
+    </xsl:template>
+
+
+    <xsl:template match="imagesContainer|customProps|styleMap|imageLinks">
+    <!--
+        <xsl:comment>
+            <xsl:value-of select="concat(name(), ' Container deleted')"/>
+            <xsl:value-of select="concat(count(*), ' images')"/>
+        </xsl:comment>
+        -->
+    </xsl:template>
+    <xsl:template match="dublinCore|documentLinks|styleMap">
+    <!--
+        <xsl:comment><xsl:value-of select="concat(name(), ' Container deleted')"/></xsl:comment>
+        -->
+    </xsl:template>
+    <xsl:template match="pass1Container|wordmlContainer">
+    <!--
+        <xsl:comment><xsl:value-of select="concat(name(), ' Container deleted')"/></xsl:comment>
+        -->
+        <xsl:apply-templates/>
+    </xsl:template>
+
+<!-- Include debugging information in the output -->
+<xsl:template name="debugComment">
+    <xsl:param name="comment_text"/>
+    <xsl:param name="inline" select="'false'"/>
+    <xsl:param name="condition" select="'true'"/>
+
+    <xsl:if test="boolean($condition) and $debug_flag &gt;= 1">
+        <xsl:if test="$inline = 'false'"><xsl:text>&#x0a;</xsl:text></xsl:if>
+        <xsl:comment><xsl:value-of select="concat('Debug: ', $comment_text)"/></xsl:comment>
+        <xsl:if test="$inline = 'false'"><xsl:text>&#x0a;</xsl:text></xsl:if>
+    </xsl:if>
+</xsl:template>
+</xsl:stylesheet>
diff --git a/lib/editor/atto/plugins/wordimport/wordml2xhtmlpass2.xsl b/lib/editor/atto/plugins/wordimport/wordml2xhtmlpass2.xsl
new file mode 100644
index 0000000..f963c7a
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/wordml2xhtmlpass2.xsl
@@ -0,0 +1,699 @@
+ï»¿<?xml version="1.0" encoding="UTF-8"?>
+<!--
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.    If not, see <http://www.gnu.org/licenses/>.
+
+ * XSLT stylesheet to transform rough XHTML derived from Word 2010 files into a more hierarchical format with divs wrapping each heading and table (question name and item)
+ *
+ * @package atto_wordimport
+ * @copyright 2010-2016 Eoin Campbell
+ * @author Eoin Campbell
+ * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later (5)
+-->
+
+<xsl:stylesheet
+    xmlns="http://www.w3.org/1999/xhtml"
+    xmlns:x="http://www.w3.org/1999/xhtml"
+    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+    xmlns:mml="http://www.w3.org/1998/Math/MathML"
+    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
+    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
+    exclude-result-prefixes="x mc"
+    version="1.0">
+    <xsl:output method="xml" encoding="UTF-8" indent="no" omit-xml-declaration="yes"/>
+    <xsl:preserve-space elements="x:span x:p"/>
+
+    <xsl:param name="debug_flag" select="0"/>
+    <xsl:param name="pluginname"/>
+    <xsl:param name="course_id"/>
+    <xsl:param name="heading1stylelevel"/> <!-- Should be 1 for Books and WordTable, 3 for Atto -->
+
+    <!-- Figure out an offset by which to demote headings e.g. Heading 1  to H2, etc. -->
+    <!-- Use a system default, or a document-specific override -->
+    <xsl:variable name="moodleHeading1Level" select="/x:html/x:head/x:meta[@name = 'moodleHeading1Level']/@content"/>
+    <xsl:variable name="heading_demotion_offset">
+        <xsl:choose>
+        <xsl:when test="$moodleHeading1Level != ''">
+            <xsl:value-of select="$moodleHeading1Level - 1"/>
+        </xsl:when>
+        <xsl:otherwise>
+            <xsl:value-of select="$heading1stylelevel - 1"/>
+        </xsl:otherwise>
+        </xsl:choose>
+    </xsl:variable>
+
+    <!-- Output a newline before paras and cells when debugging turned on -->
+    <xsl:variable name="debug_newline">
+        <xsl:if test="$debug_flag &gt;= 1">
+            <xsl:value-of select="'&#x0a;'"/>
+        </xsl:if>
+    </xsl:variable>
+
+    <xsl:template match="/">
+        <xsl:apply-templates/>
+    </xsl:template>
+    
+    <!-- Start: Identity transformation -->
+    <xsl:template match="*">
+        <xsl:copy>
+            <xsl:apply-templates select="@*"/>
+            <xsl:apply-templates/>
+        </xsl:copy>
+    </xsl:template>
+
+    <xsl:template match="@*|comment()|processing-instruction()">
+        <xsl:copy/>
+    </xsl:template>
+    <!-- End: Identity transformation -->
+    
+    <xsl:template match="text()">
+        <xsl:value-of select="translate(., '&#x2009;', '&#x202f;')"/>
+    </xsl:template>
+
+    <!-- Remove empty class attributes -->
+    <xsl:template match="@class[.='']"/>
+    
+    <!-- Omit superfluous MathML markup attributes -->
+    <xsl:template match="@mathvariant"/>
+
+     <!-- Delete superfluous spans that wrap the complete para content -->
+    <xsl:template match="x:span[count(.//node()[self::x:span]) = count(.//node())]" priority="2"/>
+
+    <!-- Out go horizontal bars -->
+    <xsl:template match="x:p[@class='horizontalbar']"/>
+
+    <!-- Convert i to em -->
+    <xsl:template match="x:em[@class = 'italic']|x:i">
+        <em>
+            <xsl:apply-templates select="."/>
+        </em>
+    </xsl:template>
+
+    <!-- Convert b or em/@class=bold to strong -->
+    <xsl:template match="x:em[@class = 'bold']|x:b">
+        <strong>
+            <xsl:apply-templates select="."/>
+        </strong>
+    </xsl:template>
+
+    <!-- For character level formatting - bold, italic, subscript, superscript - use semantic HTML rather than CSS styling -->
+    <!-- Convert style properties inside span element to elements instead -->
+    <xsl:template match="x:span[@style]">
+        <xsl:apply-templates select="." mode="styleProperty">
+            <xsl:with-param name="styleProperty" select="@style"/>
+        </xsl:apply-templates>
+    </xsl:template>
+
+    <!-- Span elements that contain only the class attribute are usually used for named character styles like Hyperlink, Strong and Emphasis -->
+    <xsl:template match="x:span[@class and count(@*) = 1]">
+        <xsl:apply-templates select="." mode="styleProperty">
+            <xsl:with-param name="styleProperty" select="concat(@class, ';')"/>
+        </xsl:apply-templates>
+    </xsl:template>
+
+    <!-- Recursive loop to convert style properties inside span element to elements instead -->
+    <xsl:template match="x:span" mode="styleProperty">
+        <xsl:param name="styleProperty"/>
+
+        <!-- Get the first property in the list -->
+        <xsl:variable name="stylePropertyFirst">
+            <xsl:choose>
+            <xsl:when test="contains($styleProperty, ';')">
+                <xsl:value-of select="substring-before($styleProperty, ';')"/>
+            </xsl:when>
+            <xsl:otherwise>
+            </xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+        <!-- Get the remaining properties for passing on in recursive loop-->
+        <xsl:variable name="stylePropertyRemainder">
+            <xsl:choose>
+            <xsl:when test="contains($styleProperty, ';')">
+                <xsl:value-of select="substring-after($styleProperty, ';')"/>
+            </xsl:when>
+            <xsl:otherwise>
+            </xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+        <!--
+        <xsl:call-template name="debugComment">
+            <xsl:with-param name="comment_text" select="concat('$stylePropertyRemainder = ', $stylePropertyRemainder, '; $stylePropertyFirst = ', $stylePropertyFirst)"/>
+            <xsl:with-param name="inline" select="'true'"/>
+            <xsl:with-param name="condition" select="contains($styleProperty, '-H') and $debug_flag &gt;= 2"/>
+        </xsl:call-template>
+        -->
+
+        <xsl:choose>
+        <xsl:when test="$styleProperty = ''">
+            <!-- No styles left, so just process the children in the normal way -->
+            <xsl:apply-templates select="node()"/>
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst = 'color:#000000'">
+            <!-- Omit spans that define text colour to black -->
+            <xsl:apply-templates select="." mode="styleProperty">
+                <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+            </xsl:apply-templates>
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst = 'color:#1155CC' and parent::x:a">
+            <!-- Omit explicit text colour definition inside a hyperlink -->
+            <xsl:apply-templates select="." mode="styleProperty">
+                <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+            </xsl:apply-templates>
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst = 'font-weight:bold' or $stylePropertyFirst = 'Strong-H'">
+            <!-- Convert bold style to strong element -->
+            <strong>
+                <xsl:apply-templates select="." mode="styleProperty">
+                    <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+                </xsl:apply-templates>
+            </strong>
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst = 'font-style:italic' or $stylePropertyFirst = 'Emphasis-H'">
+            <!-- Convert italic style to emphasis element -->
+            <em>
+                <xsl:apply-templates select="." mode="styleProperty">
+                    <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+                </xsl:apply-templates>
+            </em>
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst = 'text-decoration:underline' and (@class = 'Hyperlink-H' or @class = 'hyperlink-h')">
+            <!-- Ignore underline style if it is in a hyperlink-->
+            <xsl:apply-templates select="." mode="styleProperty">
+                <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+            </xsl:apply-templates>
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst = 'text-decoration:underline' and parent::x:a and contains(@style, 'color:#1155CC')">
+            <!-- Ignore underline style if it is in a hyperlink-->
+                <xsl:apply-templates select="." mode="styleProperty">
+                    <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+                </xsl:apply-templates>
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst = 'text-decoration:underline'">
+            <!-- Convert underline style to u element -->
+            <u>
+                <xsl:apply-templates select="." mode="styleProperty">
+                    <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+                </xsl:apply-templates>
+            </u>
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst = 'vertical-align:super'">
+            <!-- Only superscript style present so no need for further x:span processing, and omit x:span element -->
+            <sup>
+                <xsl:apply-templates select="." mode="styleProperty">
+                    <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+                </xsl:apply-templates>
+            </sup>
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst = 'vertical-align:sub'">
+            <!-- Only subscript style present so no need for further x:span processing, and omit x:span element -->
+            <sub>
+                <xsl:apply-templates select="." mode="styleProperty">
+                    <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+                </xsl:apply-templates>
+            </sub>
+        </xsl:when>
+        <xsl:when test="starts-with($stylePropertyFirst, 'direction:')">
+            <!-- Handle inline text direction directive-->
+            <xsl:variable name="textDirection" select="substring-after($stylePropertyFirst, 'direction:')"/>
+            <span dir="{$textDirection}">
+                <xsl:apply-templates select="." mode="styleProperty">
+                    <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+                </xsl:apply-templates>
+            </span>
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst = 'font-size:smaller' or $stylePropertyFirst = 'font-size:11pt' or $stylePropertyFirst = 'font-size:12pt' or $stylePropertyFirst = 'font-size:13pt' or $stylePropertyFirst = 'font-style:normal' or $stylePropertyFirst = 'font-weight:normal' or $stylePropertyFirst = 'font-size:1pt' or $stylePropertyFirst = 'unicode-bidi:embed'">
+            <!-- Ignore smaller font size style, as it is only in sub and superscripts; ignore some odd styles in Arabic samples -->
+            <xsl:apply-templates select="." mode="styleProperty">
+                <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+            </xsl:apply-templates>
+        </xsl:when>
+        <xsl:otherwise>
+            <!-- Keep any remaining styles, such as strikethrough or font size changes, using a span element with a style attribute containing only those styles not already handled -->
+            <!--<xsl:comment><xsl:value-of select="concat('$stylePropertyRemainder = ', $stylePropertyRemainder, '; $stylePropertyFirst = ', $stylePropertyFirst)"/></xsl:comment>-->
+            <span>
+                <xsl:for-each select="@*">
+                    <xsl:choose>
+                    <xsl:when test="name() = 'style'">
+                        <xsl:attribute name="style">
+                            <xsl:value-of select="$stylePropertyFirst"/>
+                        </xsl:attribute>
+                    </xsl:when>
+                    <xsl:otherwise>
+                        <xsl:attribute name="{name()}">
+                            <xsl:value-of select="."/>
+                        </xsl:attribute>
+                    </xsl:otherwise>
+                    </xsl:choose>
+                </xsl:for-each>
+                <xsl:apply-templates select="." mode="styleProperty">
+                    <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+                </xsl:apply-templates>
+            </span>
+        </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template match="x:div[@class = 'level0']">
+        <xsl:copy>
+            <xsl:for-each select="@*[name() != 'style']">
+                <xsl:apply-templates select="."/>
+            </xsl:for-each>
+
+            <xsl:apply-templates/>
+        </xsl:copy>
+    </xsl:template>
+    
+    <!-- Demote Heading styles by the required amount -->
+    <xsl:template match="x:p[starts-with(@class, 'heading')]" priority="2">
+        <xsl:variable name="heading_level" select="substring-after(@class, 'heading')"/>
+        <xsl:variable name="computed_heading_level">
+            <xsl:choose>
+            <xsl:when test="$heading_level + $heading_demotion_offset &gt; 5">
+                <xsl:text>6</xsl:text>
+            </xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="$heading_level + $heading_demotion_offset"/>
+            </xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+        <xsl:variable name="heading_tag" select="concat('h', $computed_heading_level)"/>
+        <xsl:element name="{$heading_tag}">
+            <xsl:apply-templates select="node()"/>
+        </xsl:element>
+    </xsl:template>
+
+<!-- Handle simple unnested lists, as long as they use the explicit "List Number" or "List Bullet" styles -->
+
+    <!-- Assemble numbered lists -->
+    <xsl:template match="x:p[starts-with(@class, 'listnumber')]" priority="2">
+        <xsl:if test="not(starts-with(preceding-sibling::x:p[1]/@class, 'listnumber'))">
+            <!-- First item in a list, so wrap it in a ol, and drag in the rest of the items -->
+            <ol>
+                <li>
+                    <xsl:apply-templates/>
+                </li>
+
+                <!-- Recursively process following paragraphs until we hit one that isn't a list item -->
+                <xsl:apply-templates select="following-sibling::x:p[1]" mode="listItem">
+                    <xsl:with-param name="listType" select="'listnumber'"/>
+                </xsl:apply-templates>
+            </ol>
+        </xsl:if>
+        <!-- Silently ignore the item if it is not the first -->
+    </xsl:template>
+
+    <!-- Assemble bullet lists -->
+    <xsl:template match="x:p[starts-with(@class, 'listbullet')]" priority="2">
+        <xsl:if test="not(starts-with(preceding-sibling::x:p[1]/@class, 'listbullet'))">
+            <!-- First item in a list, so wrap it in a ul, and drag in the rest of the items -->
+            <xsl:value-of select="$debug_newline"/>
+            <ul>
+                <xsl:value-of select="$debug_newline"/>
+                <li>
+                    <xsl:apply-templates/>
+                </li>
+
+                <!-- Recursively process following paragraphs until we hit one that isn't a list item -->
+                <xsl:apply-templates select="following-sibling::x:p[1]" mode="listItem">
+                    <xsl:with-param name="listType" select="'listbullet'"/>
+                </xsl:apply-templates>
+            </ul>
+        </xsl:if>
+        <!-- Silently ignore the item if it is not the first -->
+    </xsl:template>
+
+    <!-- Output a list item only if it has the right class -->
+    <xsl:template match="x:p" mode="listItem">
+        <xsl:param name="listType"/>
+
+        <xsl:choose>
+        <xsl:when test="starts-with(@class, $listType)">
+            <xsl:value-of select="$debug_newline"/>
+            <li>
+                <xsl:apply-templates/>
+            </li>
+
+                <!-- Recursively process following paragraphs until we hit one that isn't a list item -->
+                <xsl:apply-templates select="following-sibling::x:p[1]" mode="listItem">
+                    <xsl:with-param name="listType" select="$listType"/>
+                </xsl:apply-templates>
+        </xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+    <!-- Paragraphs -->
+    <xsl:template match="x:p">
+        <p>
+            <!-- Keep text direction RTL if specified -->
+            <xsl:if test="contains(@style, 'direction:rtl')">
+                <xsl:attribute name="dir">
+                    <xsl:value-of select="'rtl'"/>
+                </xsl:attribute>
+            </xsl:if>
+            <!-- Keep text alignment if specified
+            <xsl:if test="contains(@style, 'text-align:')">
+                <xsl:attribute name="style">
+                    <xsl:value-of select="concat('text-align:', substring-before(substring-after(@style, 'text-align:'), ';'))"/>
+                </xsl:attribute>
+            </xsl:if>
+             -->
+
+            <xsl:apply-templates select="@*"/>
+            <xsl:apply-templates select="node()"/>
+        </p>
+    </xsl:template>
+
+    <!-- Preformatted text -->
+    <xsl:template match="x:p[starts-with(@class, 'macro') or starts-with(@class, 'htmlpreformatted')]" priority="2">
+        <xsl:variable name="paraClass" select="@class"/>
+        <xsl:if test="not(starts-with(preceding-sibling::x:p[1]/@class, $paraClass))">
+            <!-- First item in a sequence of preformatted text, so start a '<pre>', and pull in succeeding lines -->
+            <xsl:value-of select="$debug_newline"/>
+            <pre>
+                <xsl:apply-templates/>
+                <!-- Recursively process following paragraphs until we hit one that isn't a list item -->
+                <xsl:apply-templates select="following-sibling::x:p[1]" mode="preformatted"/>
+            </pre>
+        </xsl:if>
+        <!-- Silently ignore the item if it is not the first -->
+    </xsl:template>
+
+    <!-- Output another preformatted line only if it has the right class -->
+    <xsl:template match="x:p" mode="preformatted">
+
+        <xsl:choose>
+        <xsl:when test="starts-with(@class, 'macro') or starts-with(@class, 'htmlpreformatted')">
+            <xsl:value-of select="'&#x0a;'"/>
+                <xsl:apply-templates/>
+                <!-- Recursively process following paragraphs until we hit one that isn't a pre -->
+                <xsl:apply-templates select="following-sibling::x:p[1]"  mode="preformatted"/>
+        </xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+    <!-- Remove redundant style information, retaining only borders and widths on table cells, and text direction in paragraphs-->
+    <xsl:template match="@style[not(parent::x:table) and not(parent::x:span)]" priority="1">
+        <xsl:variable name="processedStyle">
+            <xsl:call-template name="paraStyleProps">
+                <xsl:with-param name="styleProperty" select="."/>
+            </xsl:call-template>
+        </xsl:variable>
+        <xsl:if test="$processedStyle != ''">
+            <xsl:attribute name="style">
+                <xsl:value-of select="$processedStyle"/>
+            </xsl:attribute>
+        </xsl:if>
+    </xsl:template>
+
+    <xsl:template name="paraStyleProps">
+        <xsl:param name="styleProperty"/>
+        <!-- Get the first property in the list -->
+        <xsl:variable name="stylePropertyFirst">
+            <xsl:if test="contains($styleProperty, ';')">
+                <xsl:value-of select="substring-before($styleProperty, ';')"/>
+            </xsl:if>
+        </xsl:variable>
+
+        <!-- Get the remaining properties for passing on in recursive loop-->
+        <xsl:variable name="stylePropertyRemainder">
+            <xsl:if test="contains($styleProperty, ';')">
+                <xsl:value-of select="substring-after($styleProperty, ';')"/>
+            </xsl:if>
+        </xsl:variable>
+
+        <xsl:choose>
+        <xsl:when test="starts-with($stylePropertyFirst, 'margin-') or starts-with($stylePropertyFirst, 'page-break')">
+            <!-- Ignore margin or page-break settings -->
+        </xsl:when>
+        <xsl:when test="starts-with($stylePropertyFirst, 'direction:ltr')">
+            <!-- Remove LTR direction, as it is sometimes both ltr and rtl from Pass 1-->
+        </xsl:when>
+        <xsl:when test="starts-with($stylePropertyFirst, 'text-autospace:')">
+            <!-- Ignore text settings -->
+        </xsl:when>
+        <xsl:when test="starts-with($stylePropertyFirst, 'layout-grid-mode:')">
+            <!-- Ignore table settings -->
+        </xsl:when>
+        <xsl:when test="starts-with($stylePropertyFirst, 'unicode-bidi:') or starts-with($stylePropertyFirst, 'text-justify:')">
+            <!-- Ignore some RTL settings -->
+        </xsl:when>
+        <xsl:when test="$stylePropertyFirst != ''">
+            <xsl:value-of select="concat($stylePropertyFirst, ';')"/>
+        </xsl:when>
+        </xsl:choose>
+
+        <!-- Now process the remaining properties -->
+        <xsl:if test="$stylePropertyRemainder != ''">
+            <xsl:call-template name="paraStyleProps">
+                <xsl:with-param name="styleProperty" select="$stylePropertyRemainder"/>
+            </xsl:call-template>
+        </xsl:if>
+
+    </xsl:template>
+
+    <!-- Omit common classes like Normal and Body Text -->
+    <xsl:template match="@class">
+        <xsl:choose>
+        <xsl:when test="contains(., 'normal') or contains(., 'bodytext')">
+        </xsl:when>
+        <xsl:when test="contains(., 'tablehead') or contains(., 'tablerowhead')">
+        </xsl:when>
+        <xsl:otherwise>
+            <xsl:attribute name="class">
+                <xsl:value-of select="."/>
+            </xsl:attribute>
+        </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+    <!-- Delete any temporary ToC Ids to enable differences to be checked more easily, reduce clutter -->
+    <xsl:template match="x:a[starts-with(translate(@name, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '_toc') and @class = 'bookmarkStart' and count(@*) =3 and not(node())]" priority="4"/>
+    <xsl:template match="x:a[@class = 'bookmarkStart' and count(@*) = 3 and not(node())]" priority="4"/>
+    <!-- Delete any spurious OLE_LINK bookmarks that Word inserts -->
+    <xsl:template match="x:a[starts-with(translate(@name, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'ole_link') and @class = 'bookmarkStart']" priority="4"/>
+    <xsl:template match="x:a[starts-with(translate(@name, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '_goback') and @class = 'bookmarkStart']" priority="4"/>
+    <xsl:template match="x:a[@class='bookmarkEnd' and not(node())]" priority="2"/>
+    <xsl:template match="x:a[@href='\* MERGEFORMAT']" priority="2"/>
+
+    <!-- Handle tables differently depending on the context (booktool, qformat) -->
+    <xsl:template match="x:table">
+        <!-- If not in qformat and a table contains a heading in the first heading cell, then it's a text panel, and we use the Bootstrap panel class -->
+        <xsl:variable name="tblHeadingClass" select="x:thead/x:tr[1]/x:th[1]/x:p[1]/@class"/>
+        <xsl:variable name="panelType" select="concat('panel-type', substring-after($tblHeadingClass, 'heading'))"/>
+        <xsl:choose>
+        <xsl:when test="starts-with($tblHeadingClass, 'heading') and ($pluginname != 'qformat_wordtable')">
+            <div class="{concat('panel ', $panelType)}">
+                <div class="panel-heading">
+                    <xsl:apply-templates select="x:thead/x:tr[1]/x:th[1]/x:p"/>
+                </div>
+                <div class="panel-body">
+                    <xsl:apply-templates select="x:tbody/x:tr[1]/x:td[1]/node()"/>
+                </div>
+            </div>
+        </xsl:when>
+        <xsl:otherwise>
+            <table>
+                <xsl:apply-templates select="@*"/>
+
+                <!-- Check if a table has a title in the previous paragraph-->
+                <xsl:if test="preceding-sibling::x:p[1]/@class = 'tabletitle'">
+                    <caption>
+                        <xsl:apply-templates select="preceding-sibling::x:p[1]" mode="tablecaption"/>
+                    </caption>
+                </xsl:if>
+
+                <xsl:apply-templates/>
+            </table>
+        </xsl:otherwise>
+        </xsl:choose>
+    </xsl:template>
+
+    <!-- Omit table titles, since they are included in the table itself-->
+    <xsl:template match="x:p[@class = 'tabletitle']"/>
+    <!-- Process the table titles as a caption-->
+    <xsl:template match="x:p[@class = 'tabletitle']" mode="tablecaption">
+        <xsl:apply-templates/>
+    </xsl:template>
+
+    <!-- Clean up table style so that border is either on or off -->
+    <xsl:template match="x:table/@style" priority="2">
+        <!-- Get the style of the 1st body cell in the 1st row of the table -->
+        <xsl:variable name="tdStyle" select="../x:tbody/x:tr/x:td/@style"/>
+        <!-- Get the style of the top border only -->
+        <xsl:variable name="tdStyleBorder" select="substring-before(substring-after($tdStyle, 'border-top:'), ';')"/>
+        <xsl:variable name="tdStyleBorderWidth" select="substring-after(substring-after($tdStyleBorder, ' '), ' ')"/>
+        <xsl:variable name="tdStyleBorderType" select="substring-before($tdStyleBorder, ' ')"/>
+        <!-- Get the 2nd item of the top border style settings, which is the color value -->
+        <xsl:variable name="tdStyleBorderColor" select="substring-before(substring-after($tdStyleBorder, ' '), ' ')"/>
+
+        <xsl:variable name="tableBorderStyleKeep">
+            <xsl:choose>
+    <!-- Remove negative indent on tables, so that the first column is not partially hidden-->
+            <xsl:when test="contains(., 'margin-left:-')">
+                    <xsl:value-of select="substring-before(., 'margin-left:-')"/>
+            </xsl:when>
+            <xsl:otherwise>
+                    <xsl:value-of select="."/>
+            </xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+        <xsl:variable name="tableBorderColor">
+            <xsl:choose>
+            <!-- Replace windowtext with black-->
+            <xsl:when test="$tdStyleBorderColor = 'windowtext'">
+                    <xsl:value-of select="'black'"/>
+            </xsl:when>
+            <xsl:otherwise>
+                    <xsl:value-of select="$tdStyleBorderColor"/>
+            </xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+
+            <xsl:attribute name="style">
+            <xsl:value-of select="concat('cellpadding:1pt; border:', $tdStyleBorderType, ' ', $tableBorderColor, ' ', $tdStyleBorderWidth, '; ', $tableBorderStyleKeep)"/>
+            </xsl:attribute>
+    </xsl:template>
+
+    <!-- Clean up cell styles to reduce verbosity -->
+    <xsl:template match="x:td/@style|x:th/@style" priority="1"/>
+
+    <!-- Handle table body explicitly, so that rows can be marked odd or even -->
+    <xsl:template match="x:tbody">
+        <tbody>
+            <xsl:apply-templates select="x:tr"/>
+        </tbody>
+    </xsl:template>
+
+    <!-- Mark table rows odd or even -->
+    <xsl:template match="x:tbody/x:tr">
+        <xsl:variable name="row_class">
+            <xsl:choose>
+            <xsl:when test="position() mod 2 = 1">
+                <xsl:value-of select="'r0'"/>
+            </xsl:when>
+            <xsl:otherwise>
+                <xsl:value-of select="'r1'"/>
+            </xsl:otherwise>
+            </xsl:choose>
+        </xsl:variable>
+        <tr class="{$row_class}" style="vertical-align: text-top">
+            <xsl:apply-templates/>
+        </tr>
+    </xsl:template>
+
+    <!-- Convert table body cells containing headings into th's -->
+    <xsl:template match="x:td[contains(x:p[1]/@class, 'tablerowhead')]">
+        <xsl:value-of select="$debug_newline"/>
+        <th>
+            <xsl:apply-templates/>
+        </th>
+    </xsl:template>
+
+    <!-- Block quotes - wrap them in a blockquote wrapper -->
+    <xsl:template match="x:p[@class = 'blockquote' or @class = 'block quote']">
+        <xsl:variable name="paraClass" select="@class"/>
+        <xsl:if test="not(starts-with(preceding-sibling::x:p[1]/@class, 'blockquote'))">
+            <blockquote>
+                <p>
+                    <xsl:for-each select="@*">
+                        <xsl:if test="name() != 'class'">
+                            <xsl:apply-templates select="."/>
+                        </xsl:if>
+                    </xsl:for-each>
+                    <xsl:apply-templates/>
+                </p>
+                <!-- Recursively process following paragraphs until we hit one that isn't the same as this one -->
+                <xsl:apply-templates select="following-sibling::x:p[1]" mode="paraClassSequence">
+                    <xsl:with-param name="paraClass" select="$paraClass"/>
+                </xsl:apply-templates>
+            </blockquote>
+        </xsl:if>
+    </xsl:template>
+
+    <!-- Bootstrap framework alerts - wrap them in a div/@class="alert" wrapper -->
+    <xsl:template match="x:p[@class = 'danger' or @class = 'info' or @class = 'success' or @class = 'warning']">
+        <xsl:variable name="paraClass" select="@class"/>
+        <xsl:if test="not(starts-with(preceding-sibling::x:p[1]/@class, $paraClass))">
+            <div class="{concat('alert alert-', $paraClass)}">
+                <p>
+                    <xsl:for-each select="@*">
+                        <xsl:if test="name() != 'class'">
+                            <xsl:apply-templates select="."/>
+                        </xsl:if>
+                    </xsl:for-each>
+                    <xsl:apply-templates/>
+                </p>
+                <!-- Recursively process following paragraphs until we hit one that isn't the same as this one -->
+                <xsl:apply-templates select="following-sibling::x:p[1]" mode="paraClassSequence">
+                    <xsl:with-param name="paraClass" select="$paraClass"/>
+                </xsl:apply-templates>
+            </div>
+        </xsl:if>
+    </xsl:template>
+
+    <xsl:template match="x:p" mode="paraClassSequence">
+        <xsl:param name="paraClass"/>
+
+        <!-- Process this paragraph if it has the same class as the last one -->
+        <xsl:if test="starts-with(@class, $paraClass)">
+            <xsl:value-of select="$debug_newline"/>
+            <p>
+                <xsl:for-each select="@*">
+                    <xsl:if test="name() != 'class'">
+                        <xsl:apply-templates select="."/>
+                    </xsl:if>
+                </xsl:for-each>
+                <xsl:apply-templates/>
+            </p>
+            <!-- Recursively process following paragraphs until we hit one that isn't the same as this one -->
+            <xsl:apply-templates select="following-sibling::x:p[1]" mode="paraClassSequence">
+                <xsl:with-param name="paraClass" select="$paraClass"/>
+            </xsl:apply-templates>
+        </xsl:if>
+    </xsl:template>
+
+    <!-- Process Figure captions, so that they can be explicitly styled -->
+    <xsl:template match="x:p[@class = 'caption' or @class = 'MsoCaption']">
+        <p class="figure-caption"><xsl:apply-templates/></p>
+    </xsl:template>
+
+    <!-- Strip out VML/drawingML markup from Word 2010 files (cf. http://officeopenxml.com/drwOverview.php)-->
+    <xsl:template match="mc:AlternateContent|m:ctrlPr"/>
+
+    <!-- Delete unused image, hyperlink and style info -->
+    <xsl:template match="x:imageLinks|x:imagesContainer|x:styleMap|x:hyperLinks"/>
+
+    <xsl:template match="@name[parent::x:a]">
+        <xsl:attribute name="name">
+            <xsl:value-of select="translate(., 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')"/>
+        </xsl:attribute>
+    </xsl:template>
+
+    <!-- Include debugging information in the output -->
+    <xsl:template name="debugComment">
+        <xsl:param name="comment_text"/>
+        <xsl:param name="inline" select="'false'"/>
+        <xsl:param name="condition" select="'true'"/>
+
+        <xsl:if test="boolean($condition) and $debug_flag &gt;= 1">
+            <xsl:if test="$inline = 'false'"><xsl:text>&#x0a;</xsl:text></xsl:if>
+            <xsl:comment><xsl:value-of select="concat('Debug: ', $comment_text)"/></xsl:comment>
+            <xsl:if test="$inline = 'false'"><xsl:text>&#x0a;</xsl:text></xsl:if>
+        </xsl:if>
+    </xsl:template>
+</xsl:stylesheet>
\ No newline at end of file
diff --git a/lib/editor/atto/plugins/wordimport/xslemulatexslt.inc b/lib/editor/atto/plugins/wordimport/xslemulatexslt.inc
new file mode 100644
index 0000000..5f57d17
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/xslemulatexslt.inc
@@ -0,0 +1,95 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Atto text editor import Microsoft Word file and convert to HTML
+ *
+ * @package   atto_wordimport
+ * @copyright 2015 Eoin Campbell
+ * @copyright 2005 Ziba Scott
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+
+// This file is copied from moodle/backup/bb/xsl_emulate_xslt.inc.
+
+// This file adds xslt_xxx emulation functions.
+// It is intended for systems, e.g. those running PHP 5, where:
+// 1) The XSLT library is not installed.
+// 2) The XSL library is installed.
+//
+// Note that not everything is implemented.
+// In particular, only the bare minimum to support the BB conversion is here.
+
+// This silliness is required to prevent PHP from evaluating the function() blocks before processing the return;s.
+if (true) {
+
+    if (function_exists('xslt_create')) {
+        return;     // Function xslt_create() already exists, so emulation isn't needed.
+    }
+    if (!class_exists('XSLTProcessor')) {
+        return;     // There is no XSLTProcessor class, so emulation isn't possible.
+    }
+    if (!class_exists('DOMDocument')) {
+        return;       // There is no DOMDocument class, so emulation isn't possible.
+    }
+
+    /**
+     * Dummy function to call XSLT processor if not already defined
+     *
+     * @return XSLTProcessor object
+     */
+    function xslt_create() {
+        return new XSLTProcessor();
+    }
+
+
+    /**
+     * Mimic xslt_create function call using XSLTProcessor
+     *
+     * @param stdClass $proc XSLT object
+     * @param string $xmlfile XML file to process
+     * @param string $xslfile to process XML with
+     * @param string $resultfile containing output
+     * @param string[] $unsupportedargs dummy
+     * @param string[] $parameters dummy
+     * @return bool true if transformation succeeded
+     */
+    function xslt_process($proc, $xmlfile, $xslfile, $resultfile = null, $unsupportedargs = null, $parameters = null) {
+        $doc = new DOMDocument;
+        $doc->load($xmlfile);
+        $xsl = new DOMDocument;
+        $xsl->load($xslfile);
+
+        // Set the html template file parameter.
+        foreach ($parameters as $paramname => $paramvalue) {
+            $proc->setParameter('', $paramname, $paramvalue);
+        }
+
+        $proc->importStylesheet($xsl);
+
+        // Squash warnings because XSLT complains about COURSE_ACCESS tags which really are invalid XML (multiple root elements).
+        if ($resultfile !== null) {
+            $fp = fopen($resultfile, 'w');
+            fwrite($fp, @$proc->transformToXML($doc));
+            fclose($fp);
+            return true;
+        } else {
+            return @$proc->transformToXML($doc);
+        }
+    }
+
+}
diff --git a/lib/editor/atto/plugins/wordimport/yui/build/moodle-atto_wordimport-button/moodle-atto_wordimport-button-debug.js b/lib/editor/atto/plugins/wordimport/yui/build/moodle-atto_wordimport-button/moodle-atto_wordimport-button-debug.js
new file mode 100644
index 0000000000000000000000000000000000000000..3c1514336c17cb896669ff69aa66fddd05890d8c
GIT binary patch
literal 14199
zcmcIrZFAc;68`RAfpKptIkBm<clX7qTf4E{`0BTj<!e2;jE52-i8V#CBqiIY(SN_^
z0SF4DsJC3I$%G_`UF<IQ9rVNfh2wf&voVSyFOUarmPL=xQR4ZdI7+gE?id4MV_)>g
zVK4KeP&6O*#r4V6*`Ap0?6g{<GxSr@_X8<#jol;@QD0msY~nx+vn)PrwKR4oN(L>!
z5G<cT*hET^M*ZyBP2{0?jmDzqh9Z%kpJs^<3V=EjZs@h5M2sTO@4pfQ#>Sy16Oj$2
z$Ye4~xiTMqxxN>_$WSJ3Aa2Lq!0(AmzbC^~3KukTBppgmbQK;#oRfyToCa|o0kKPN
z_l5NFJ`od{q~!kZW{n)-zK9YM({wXZo`@(W+#bk%6@d$~45+if_?$ma_@SbF7{%aa
z2xQ>y*$)EIm13OA{y5m@G7yIN?V|JX=Ds6Nt{=p2C++shb?4zdCTGJ4Z{<X4RM^14
z2a}L$;)dBP2q%WCv-XFN06F>j;_{;N0P@B8Md$kL?oOQFw8e?IJ!y9?KHOiPw8iax
z`}XGU%n{-a;(;89V1;n|YJU<bJej$EkQ$aBu%#)e3p_D&ClXuRll}y>xuO@vq-@Q$
zaa}iv!hvEl*By{`(HCKq?TZxT{gA8L^YgPa2**m-u=CvYwDqF{U4647-iYJa?LD~z
zDe$W(yLwH65`Qqvg!um5cmEV;5w_-oJBqt92-J)mDG}5xN%%nav(_LEoMAQ!w7_mJ
z#RR&OXq^C_775Z6L8ZqqpOqF^f;fRqLgQbs+n%2RsWw(|<@b_^mLz_I1#6>>gYm!*
z9l(=#WvqHg!0b~ccem>YJ`@B<y(EgUD|2u#55v>jMk5?&(Fm5&bA#ZO2zyZo)5sJa
z+-EY(QYbS}{r<6Yb*X^WBdtu4+>KrgHOHYlk|{PsiYupfGXghF#m~wIakXRcEJKie
z<!H_y3FVwADcmYfF%6=fxQY01b9H-jeRkcUw-QI9QCXp}zr#I*Y906BRKmes23Fm~
zOD_gtlt?@#nVNEOb@Izu=j`hC@}#3MHN;!>g7A$W{Lw(9N$+TPIvpp$Y_<zs&G>{1
zpX}KRVmkfC??aWnY&e^#3uougyJ9+R`Tf~!3D{6lJ7+U}C7>Bu2N@?a#r`PAHk&0;
zAdhzKvE}e-2A$R%`Gar-B(vFcI&u@J7VmoF6ndd%f#D^D_qdtxynt1=#Al5yUtNpK
z_hvKSBM|SF&u;zLc)xmM&q8l!=fNqIui048zQ&%TwGMjo;QZ{S(&;4<?!4K63)T_w
z!C9__`{L8*eFjMGx3Y8Iyn%a7WM3vSgv!%~VHCY_g69lAERZ_F!uu<0@ke<q;FIUW
z0S?Ae>)ji;b%eVZLC%9UDdgtOaSS7dO}>i99QU0;T};Vd5og+NI4JM|%AbJ2d`e4Q
z7Z4nZa2y~Mskb&?o~I&DCb+>2y>R{&vPKdSijmIGz>EK1nG|cO8|%ekk#01ZW++7X
z52gx_{|sRuCCRi?QX+I?%ZE*T`Ah+ZVt^nc#&J#w5Wwo18S)ipAhTuz@z?DJ(rfJ5
zi*T_-X5%E(YQ*Q6W|+4M9IjKVM{`abU;1!?hoUjhpK>3=cl`1FhX|Qfh#fyHdnoOV
z^gMwKC<wZUR7)gbrtvywXc(m#G#8=v`5XyZ?Dw8z(rg5N_=F5j&3hce#|4rOo>T7Q
zAaXtZZg0*n(a!1#I!Oj;nZ;szW)=punD)_56hhX}$t5(LChp)AuS-;5b%oc`v5$)K
zQgj+C^2Nk=x#23{X{I$zZ}N*c&ULSr`(hH3S9c_)QTGoR;*7bhi=46p#OhWenM3xN
zL=)dr$zx?rqwtK0NPj{^6ev4#A_h#Pj&7IvnW3|oT`@dytd&npyAeFJ8_vY@5SEkY
zxte1vZ!&Jji+V3P3%SwOZLy_CnlD@B87-+haCTK?Dl0)h*6D4EnFP>wL{hZa^S6z?
zGT0obK;Td*%d_AB`#A;W7cavE;~}j2_p8f~C@9+U&#_FiCiG2n4t1qzYt9@5VR3YX
zfZwp0q)z9e?YluL=h|*rH#|&R**@`Uk8EV^MKUeCj!KY_AHEamxZn4g(d0kU(fW_t
zmA|!|jAZ6yQA~S^FtvV_wg(6Py?Nz~Ge4kQA6fi_gJ$Dp6d=h>$1w{sc&q)g-`Epx
zb5(WJ3Uj_T<@i_l3FP2?m{wW9bFQ!jFk?hO?=?jNA$!m<<j_a;ewqtYr?j%RWjYQr
zYpeL0Vj@z75}6iiJZ{-Ps#3A%a^*2p5A(i%_pWXxXWNT{z<=G{Tszo-ROaiY@V=?+
zAd|G*6#>nUq}fQ8EyVfNxsFVdC|LzTs9X)H(N|6nsix!p;l7-`^rR{t%d407li=oO
z>8%+uS4K*3iNril%28!UBkeShUYMMtA0cxSF-n|lzSjnaxhg~V6}AsL!#~N+33yAm
z60xe_St3@Vqlr668=vlD)YsCZ1)F8;>uh0kCM0au$_4D{4-QJ?qJ=?$9>8M!KFSn&
z-UBy)B&;4rDXFj#@!sAQ!ZoL;QBqWlhuEwI<AjV+|EOKZ0(lpuv1f-udx5&~GPCoi
znPoDxCR#UhRw#AD+#ey=wynSHIMv?2WEZCd>18jE$e#(2`(vmc3bvQb@x3yfpUIK$
z5lG*afb>uq03|lNBTw>`Kzzcjf`Wec2Tndx28xIAg=#Y0w=W6S3jA(MrwlEYYAs!-
zrmcB8)zXEo1JIxHET7WVuCqa>tT7&na|laCU*sy_crJ;zqVb+1IgjSi2-H$Y<@1nX
zH+NC|?e5c5!3x?7Nfc!iyG?&(iEqnGs7JE|KpSdcE;Xb+$yip_My;j{q_BnDZE&hK
zn^j4Yhpb9f->Rf%SBMRzY-s0CCI`_gpuDb6lT3nEOj7|(OwWk)-0iuZgn7>2mI{eA
z`3%V%m=KF*;M#P?5Mw1Yh^l#|MP;C=EKMag%5tFnF<W;~$_Gbhom~VFn9C@JS~W}U
zfJ&;9AT{yPx}^SfSY$!5-58xX?TT8H&~sR}A*k!jFg-xzMVks~+?a*6Lv2Tr*`rB?
zgHb?<s5emfLKT!xPSH!dGo_vFO1Y|Z9@VB>KnMyqVepE&i6wx_M73TZisd~YmC{gA
zReed-iLp7Ve?-~hr*cJwAU$<6w}akdii#F1Hl+inJ|Fq^TM%K7sQe@qOU4~|w?Q_v
zjDW#a(^_5%2o}YRq@ZrKPwzfEEOx6QnQY9{(v`VvO{z*kQ2Mb8g97Kqq0YxZ4x7_`
z9|iiJ_zB*vAr8%oj+s|>h{Q^zpj?5Kf#^JcY*y5aQ#14jkP?kz%zd|rNvAN%jqmO*
zzFwYGFV6Kx2!E=Vc_iv^!P&DSxKV|Z!>2+biHxI^JxX7u*xEvY$v}<Up6As~<q7t5
z%3{0(x{-9OD>u5FQAh_JF8Zlc*>{nK+Gau;q=U{?d<#W)2P#?Mgc6lzM;w?jJ#vFA
zJ!<Jb(o_)lmk?y>GS^zbq+<}^jsEC?Dh06HOLSG(Cbz}O^A?<w=yFvgP(@WEVu=6H
z^nXQ%yu;I(k^3akl|}ukE71`$B;h_k;b_2gk4PVWAW<}F8$OllJuW{8?q_bC7<l`(
zYD$EosTwA18b1;ElmA&8p{~lb=oV@-qTz2rN=n{7>z>ss_+CZc8lMnd6d6xtwcx9H
zrnUIAK!gk@76EvwthE4;r#t{Er9kVzdN{KQGbC!(YQ@+(VB=N*Yi`$p=&aCQtjGx~
zpf%QN_G6w$LThNCi!XqzWL5J5C5`<M{X(A1xdL&wCx=mhW4&@gVmmuJM)*kC++&^G
zfg7w^wdMQrlw7&6N78l$Lva$G@HO=<f>|^|N$^H|_l`dn)Qtm9Efy^+PmLrhjU|($
zm}X~Ql<J%shz)%e5vwqyYO*Rr>J8fWaHRDipDJv-X_LcL8kC%d_DE66Xt7|Vx$C#s
z3Pj5Bn2ykVM8aECGm8-cCmRJ0yH}Aj77n0MrSq4X_~m<tg&<10Q7w`b^UDj+g6)bl
z>x#|NI?%zTtq*qRH8Uzt$^*~=0uWt(SvR+Dj&K|3Wi54w<tT!So+%32Z>WTYt}N~X
z(U3CcX}Zf&KZhijRhW=lsBv*<;T7cMmR?X-v2QNGps;C=$DY4gpN9}-=0Vc--5#@W
z8C6}3<4p4-Yh{SdIzNObthMp$mNH9PAn2NnqKRx)ibgZDdMyXK>RUc<p$fTC^l`qA
zqo+p2<~BrL7G17N<-v^*f5o<sP5E{$AX=A}iWUl7-@;Mz(uR<|Y}N1C@60`XR{d%9
zB`S@zjm51*yrR8GYREQru8dNZc#E#aP|s_f>8S1m%DM_NU7e~{K39`3$b!?QiKD#;
z#B`!5R6P%#Y6#UkW6m6?rZZwQzpN3+nk7C|!Wk@kYjFGSBtoD@PSZ!#zM?N`)~go;
zbcioj%YrDjw>|P8Jg6L-3i{M*U(=81z1AexY%3(EiZI2MR%?j^!ZZ?3#W4YztE@H3
zhXoWJgr>d*!IvWHqYr)pQjV2IXy*E5vC}}C>sN}U2A#R)?5ql{W~#Yj+gT{rL_;&f
zT({Wwjl!?NyX?AcG_K+?@S8{HDu$9czc^S|v68M5=1l{tL9~Ei^H6S3m@83Pae7-y
z3>pi?mZ9EYFxT~=-^?`E6>52YdU|L~T-!t*xy#~T@AAxA=DKc8Ht^8=(6wd$fRob2
zle4`IvIeuLxqj8dBZIW=x_wrm<;s&4lUbDNm%2q(jeS{GQpLDQmQsaTowd+=s}r<G
z^s=zabvs)z@$GeNH3|9AN<qbT_}7Hg8fmnpvhh*@s845l*%)6fW9RuPr9QPS;_>QG
zT3sd&MG)wNa~*lb7i=YKU3X$zMat)|;N{95PCYeqdbc#;l?TIh)SEH8+SaYz4?{oj
zzLboOEps!Myfs^Yxf|QgeQkLzZZ^ffZt7^(3v~4i`<&fg-`vwZDSP~alXQc_zOu=$
zkK}c`f9>hI4Q%e2o?q8}48RxlT_6L>E4$ObZgpC3Lz{bj8h@+5lRL76WKOtqR?TBU
zv>C|BSWj>1to{G`R>071UsVyJPWtiZ4jUZx+k7t^-P?%GJr^*?`DU!{x*`$EKiE9Y
zKbFJ}B0S6!1k``(n>clX!?vN3^%{3t*Cef@jAQj?wANF7b<gydd!kjIXUpJM4s@Gz
z?UqP+A-<I7!HL=1wpODXt>T#O)w+G;hiK~a8drUbexy49Xld2-8Vjv9hhG(4tI_6j
zcqh|WHyTS#w)=>4#`3Hz|6Efsh*WE5#xLv1?MbK8zB{x&3Nv4H+hd$Kaf30w-y#o%
zn5^%c@potL5|HVf8htn0p>`-D8pr=WYu{bmTpvR|)7|`=gmm{%eA><bm`8W>)nBO`
L=+BvUKNJ3cwTTKs

literal 0
HcmV?d00001

diff --git a/lib/editor/atto/plugins/wordimport/yui/build/moodle-atto_wordimport-button/moodle-atto_wordimport-button-min.js b/lib/editor/atto/plugins/wordimport/yui/build/moodle-atto_wordimport-button/moodle-atto_wordimport-button-min.js
new file mode 100644
index 0000000000000000000000000000000000000000..d02a19dd8e90d18831f6e9ab54c55abbecd08a75
GIT binary patch
literal 4035
zcmc&%ZExhZ5&qs^;bRI%?9yCc(SF&Ddb!+7lcK&moPB+PdsxsCwaZu%RgzlU74+Zx
zjHum}H%<by2yzE_`7%QeXP#$f^v_S<NtNdbtE|mSeWpUNt2^s*Q#ICwvzrzRH4{Z!
zXTjJy(IW6}tK3PQvLj(8T>9l#rdpqPm!+)hT37ZxJ5gnz8GdNibzhj`<j&+_)Az#<
zZH{x=o|~fYqtr&5^#)q;m*jRUM}m#hUe`g9iGA;EsZ%yx+l%|~Kzn43S=SYG=&nk+
zwSi*SWvvgk8l+%sv?42&_oeX=9fqVnS=*l-rA^-VCMOvh?KkIt`f{mdtt#ysmFa|C
z$Yb|$`OV<%RLgIa*D`Zj1xW5<pyh?sxe3;-NL9WW#vjTSwu|e}qFZIHb9mCFF7*(t
zMctOAFtrH=@BNQ<i+vn<XNn|jjF)R25|$gUZc3dq&YcdetCzzbpb>3KI+NLY!4A-1
zf>vHx;H1W#i&|u=EN@hHJH6y^!^Zl+xbz!)_tuoUG1;wl2`f!~%fukI+Nc^B{5#M`
z5}%sVs(jeu{r>QmZtWkL(etPsJtF~8mOI-#edcSY)~~U<JN3yc5BBe&e*6p|y^fA6
z_HVHbq0cieOzI@POZb!&g-vUHck+*mzkVA+^HKl1)jllA{SpjG)0DB%>Cc|i^88;i
zx7qz~=Q2PLQgjE0+_UEgIg6J9ANhj^>U9R!t#vwyE>U#2#L7YJlEiSvA2@EXlC)Zn
z`R~uqc^A^ZT)uxN8|A#lCdh=KdVQtu10M{HXp!1E>qZ++=uH<gvrbF(y}EyMpXtE^
z33O^{pzp#fTL*ySWq51BtPj@I^qx(qN-n$v?QTCcISk7a-uJrn`b5hXHtf<7oqkr^
zU<#8B<UUg+j-BKq-c9YG&7=dzyjttUg=~W<DNZXNoT=9dgHc=UhIcSA-okiK|Ci*l
zHf7{(;%Ule(e*;5EDQH5V)e}6#dy<wkR}&J%1qGJxDkh<OmU0%xB3C%a8R+9<6Iys
z&P#JMk64`(i|5V2Uq3%EYaVm2Y&Ojcwv2Q<LA)CcZ2$Sq6%+B)ySqDQZJ1><HDjl2
zRt$gJ;cqFPopXUW>l(hrq!&k6-%;TQXg3kG5xWuOk-NaLmfsE>y#Z3-h^m3F62}GH
zrkbW4gEZgP`C#sSRTkD&D)=*7AcPvYZYk+XdTrxu21g+-RY`~+cG%KOueN%h!(e?#
zgIwt?^oAHIOaU5o<y7qp?M_c0&j-Hvr&lFnyAB%ywK_d*L4c=pug^cr@X+X3>56nr
zl233w^1Muo!RSVX4UTN<To<O+`3p8@i^CS;Phfoum%N7kVw0YW2J9F46A40WX{Sox
z-+Yf`E&(T>6rg5fJ(U2XJzoZiB1e9CtqawbfqVsO+vWpuoLUcz!CEE}90CF(^;J70
z))l=5S@Mx9qwDbesZzu>I49$XFA>y)*s@N~m+P;pom1Dd8D*EpR$f=v>(9}ha1D!>
zGu|B;WpcV;`n*xm<a~L96n5JmG<3ZsY5Yv>99g!b$2grzWTk<#KxES1Po@$CJ&Ga|
z$WVt1BmD=hJ^MN0mry(rOU;QWSEkZ%H$ob_DN`W}t&jw8pmY|nNa7G2vQ@%=_gw#x
z&)6B8ZIBHMN|8|alz$Q7M-<qmHlcoMm($|WSV)+eQ=J5hR=z?7o}@K_mTRXlO@c87
z&|soQwaOO_im3mIlnpnV$Jttd;PubepVW*E3xtu>zhJY5i&{9MUyf&@d_Ag5`B7b}
zr*(-Gj_Oj4>>rEL>1h&(@lIEEs}o9ozi=fX`b0+-3PV8Z2mSC+SNPB?khFlUMAp;O
zaX@^a4SkR1(lfk)+6q957Wx0_;$#2f^vCXfk^Gc<MGb{t)w!s%DAgW4)z3Rv%Xc>4
zcg*$JVT2b1h^C}|+wsL7j4>O&+L$uOI_HaD7%D&Bbc|hxpEMXqO#2jrihF1<cIlUj
zEdgZgQ5>}=Kh|)RsUO+_J82En|I~)Wf}XGs?=PQdKw`TAe8qO-C|Ug4t(`bZ4Lwn7
z=%$`}4V&+)(8FZ7q9%9f$<**|m5!BcXtc(cXS|Q?+Oy|<FS?gkS067I-R|3Jf$!$B
z)eCCI6q4U=-u3v0PaO93-`;$@{O<j`ubJo^J`)TQ-r{=K3r{}%&SKNZKKFe2oBskq
C*`HSc

literal 0
HcmV?d00001

diff --git a/lib/editor/atto/plugins/wordimport/yui/build/moodle-atto_wordimport-button/moodle-atto_wordimport-button.js b/lib/editor/atto/plugins/wordimport/yui/build/moodle-atto_wordimport-button/moodle-atto_wordimport-button.js
new file mode 100644
index 0000000000000000000000000000000000000000..c67939c0ae7fe4c7774e02eac44650a706828590
GIT binary patch
literal 12841
zcmcIrTT|mk8hz(ibdjyt%z!+}?!J(ah0H*P4Yx986KZyf5?0&pAWK?FHn1-L_dTau
zEw^OZhS`aWn%1SiTlaTw&F#&p=LbQ%HICyTlzV=j$9Io$8mMs+r}^If1P`Ltt{6<B
zey-w3v~PFC#nJikj+kw2bvmLqQkfX2PzsERpXMSSh;xli?1@pHC;Od_!S2QBumc!^
z6*CB%N-45<kU#pV+!xRBMD+bgq%u%ho+@wv)Vc7ZpcAKJ90zLfObmE7i2|95d?ZCK
z({V=1y!qwgM*Jcpnfjr)n%sw~FV0k7Mwt{oc;u68Bm;4;@etyKJX{w%h?5wIeM-A4
zq{91DOl6u;`oCHl1;Sksr(~w>=j1#UaYDEqu=^}RA8c7rZ%Ocle1TAr=6n<<kYxm9
zknT~1p}3b~lF7j&+$9+-hWPEY_wn+kCyp*|#cxO5?$Jf>_6JPPM={>YsWhmtfuVws
zSk=^z@@Ftk4Clw)_a6ar^z-T2Y3~;7i<8sd#qssEIJxYKBXM=q?VY~AIXmi#tDElC
z<@K>A#5I-&>p%o+7I&ccCzT?Qxv#>^ihPSL&A?q4h><^)*xJ5SQ}E`Cew>iA4ckV#
zei%nXEoPxRVC!@sqB!3b8QA-=P_@U$M{gKSw60<2x$9ZyCl9*%W=p&ghl$^R@P|_1
zS5tQVnhd3CILd|i{@r(f7soNS=Dj~o?qwM283j@zXdp@WP!96WFbTa;J`T--U7d+3
zbSE`B0X!WtWH^FKPhdW4EwBP{1e=7$KVi26l>@0UR&lQSX-rEJzrliyQ6}MJs3H&W
zWL_Jqc_d)=nO=AQUWEz@0;EA2C)kw*IE07cnQfyHPV#sR%jo-I_)LWTID%>98V{~>
z8RZ$28K{2$*gHSd!1|U}rdhs^pDZ_rkw2ChHbjbZuW>U%Kg-0=+6R%^A!L>j*gp4+
z<adPfj`b>BX-P2+OFQ*b@&5As>hj|FqDOBf4n(U)p|!ikJ%nl<_Tf~b;dKsC{WQo<
zhf$nL+@`sna(aIB%W?1c{Oater!lp}Tm6FYtsm8RD6+JFusxei(r`ZChOXwk!@xUt
zwuYF^zEK0Ha*&Vab3Jf&alb8QvyK|f=PSTQlG-_+n~{L_$tK7ol^OO&JGS{ejYD~`
z?LJ!#pXJbLBas?LV<4H&XS1=NLbZ6+pJdPrJqrS_V7$-Ggy#jUz9c^9*=p)$xl}Np
ztAIefT0Oh-Q|pKI8+#lDTU)nYseJ9$lJ>QBJfn5cn_KT^Ka*ZRm2l_n7F@82h_~Kq
zE!-8KKJPL>a=*2m^WqKMYbpmal@U~)HVmWaPg30H@L{1e5f<KGTZ<YOv4D4hf&&~*
zq|v)KaO((n34&YzYtqQ=o5KV~44ZrwcLnZii@KbWKO@d`{b*R?1C*LVz+y^Ak4p&l
zMKlQ!iu7Aot{~8nCl}mchF&=T8e3zD2*pUJa>%0oE7OvezHnabm+3~EX@*9Ge_*Qc
z_>Wi&q$Ig<N_q+X#PMNMB_Fwfkr*P#h)Gg#0tB$Sc8+|-8_K-hLj3jbLm9MoTp}cv
z%6yVWMvZtsHv;oggTr+i^=L1c<4Xk>xG!3Z{HgFUe8(T(zmJhwMcDEEs)sV($jlSS
zfWq(|k!r<C*l8RW0*&G<hvp*GKAs>UOH}_srtMa!q6cJfdfwd#J}#7W@SJj!gs~r(
zcRLGtiFV%1&`~<fsv?%#Gj}j(V#Y^%afG#oPOjkLL+TGd;B|!yP}g`J9s8&`uSBPb
zW?xK|&kffB&j@XJdQ%MIu+Y6m>B~t-Uj4C{#rJ=}5a-NgedLrqAl8=>$sDrBG@hzJ
zCyzCnR^b^Fk^V%8C{T9fL=2cn9sPUeXO_=$cFpj_p;10DyN}_a{b(*8N3fhC&ovT*
zyv?}1AnrdEA{0j3w8f4d8M$1QXSAg5z}eN6sj38n#H6<wW)i^I5m_<IUc7DXRKXTN
zB?6C1S)Bz3I4C%%zIYm?cpky3e?LF_h=QUk|1*(U-iE#z$)T<^Z6le7AS@0J5b#^B
zkksj7X$O9o$%VE%)(sES)wWN3#v|Lc4q};=UPmWL$PeF%Y%&-qW;Df*e02V;cjYe~
zFDIJ?TU@3c&6uYDCA|F#i$=CQfDu%eVnH8^1%pGZ3Z65BdfA6IAlp4?_NZi<yKmI0
zE3-+MJB!NK6o^PQO5{YS#<;kDtMl*9CFKc}1oOUs_pWIsXS+nf;6JY~FFdSOCJTBQ
z{A4D3$oU+{LO}Z?Yc7&iggC!G*OO@)r|TdHRVWN~@7(JnDfIk5{HNomzSL!2mHI-X
z2<rYE4Ras!nlTMhB84u}XVk;-*qApG0h=8RV&qsNK{1jq_PUNso21g%-kV(fC_f?K
z72zt(>e6JzvJx$g(L;jwaFd`CmH}<8PLB8UrKfWtVO>ttcEN5v6tiWsfeX5a0!|H3
zP|!#2`5{)q={8itzl(_1?yeB7Jwr8-p|;z{W=(Px(mma=hY$_hEvzvr6}{^qQ1m-m
zJ8sZ&2{b*g3cI+QJ0?SGqNOvtgi^Qc^#QWtBBXeHR&{ZD@1OG14+QDwPj|?42~c=W
zs2)nIr`%IP6;9=HtO5d=s|t{LR0TjW%s$40d?pa@aH*l7--Dr7JgEXDqvTY#gKoNK
z1nY$AzGH%WhecJ#RFqj~k@$2>N$LUgA4NXS)z#h!S!;V61=aR0jS56jvZryJbAen+
zZ;eUlWqB)F-*Q0;f$gnbUA!^x7xE#UNGH-!Thd1TqgA=o+QPs&)hPJ7#3MkaqAOZm
zCbQGRCQUwaa}pcZ4F!~}&8de?ddg`!NQl`nk)HT{Kaen_#oJ19z9B~-n?oD6&|uq`
zB3NdeBmt4Cs9v~jRO*%C`9+xn^fX~R4C-_1nN02;t{#d#PGAk~N{L-dA5w&Sg?8Wx
zCiYmkKn48--7VuZI@2idSPDIjLz8V~dx()}{U9}(uvqn|mq^_DRQ_l<4!I)w4OFvK
z1?@dE^rx<Ex#T)MQkCAF-gE~D?)x$dpHYi2t=8F{(F??zqK~4}1S+bo*{C`RHb?hl
zxVHG|{7WOqKKQxcL%%LVl?aM$>B0Rjo_zZ)m~fwHUy_Lx&pr5|VLoz<fML+^S|tSp
z%gc=L-9+uvyU!jA$a?Uk7>iVIZGPC0{&69=`iT#Ng5=iqEuMiLHhc#PMemOI2mDY=
z>|2VSomX{T#7d>$x&kXh#z}G8uBjQP=BT-myo?jfeYcFsBpce{Zf`HYhKDI=RI{@t
zN@|QirTc>iq6rt=GPCSUU5t3VD_10yNu06or(}k$EftsoNDmzy`j8KD;3JuHRoJ{o
zrzW|A68b|Oayg-b!LF7E6Qj3mk=&h;{Eljj=($2G96ckgB}~S71K#efc~Iv7Hg$$B
z0^7o_s61c5xqvCpL<%+0H4z^14^8f8bcB06jTrk65?x5tYo_uVBhL{2;{#gZwp&8}
z@B@pYO}$mz@E<VzD7e;z;o!mBw{<lq9L>lI;qv&2z@OA-V<4sqF-x~pix3TeORJ>U
zTLsQCHB(SQZM_XXA?}f?KP;zfi+qI>t9MIG$Y|;?fV&#4C4eGv08k~7*aX(c8AX&M
z-EpXu&o%*DlLxH5+yr8BE0<WASpl?S2#d@-OH_oG77venfiTvWqd3ILQ#BKJeFyyv
zT#jt-FbD0ytJDqAaV14Asy)ITlbmztwwLk{s%<V28{#o?;Wy&Dcl_-z-`V5Tl4y0m
zwe!_AL!GXEgGMmiM{}T~a=6aPM($dxi_=hOm#Mbl9#7ias>7xd0_|NkMjH!hUYTt#
z`%Lu6OB`;xUaU_v#9mc8`3+uM1^Y!Yse;ND){}TG{OSU!6uYKHO~p`!4pe1jY0f^c
z5k_YRMRK->gB3c{stW1!_*KO_w}Jl4(MotS&2ZU$L&5b8b;YV&!wM1&Ib(KWx&X^N
z#W`fTW+r@0cSzn}(j#!^zpPI{h$?ds@%7yTOSp=v$-8r={ZX_k#LGGdgeR=CF`GzP
zk`4$~bR17*yH?8Bnf0;i)a!3~|5Xccm%!_aaq5v##{mwC(SnDMs2|U*EX`fAbqjaj
z*=ty5^9kP>GRciCp6ce;JcA`+$2E-}PNCS)-6~3*!dKn5MQ6t*CDhd?()JoMQ+??6
zC#lINWK!A6<iir+h-Er59O{~uonWE67|gpuZQ7_>_%(t+<|XlQ2hOe7<$#0pr!lf(
zbSVa?%GPwKEWPH1fDZA+`nA}w#E?QaXEg<*ViE@&Su7sP<|$fE%pI#qI>mqh`ZOCS
z-TKg)N7z*lZ3VF7mw9XpZO5<V!7VyF7UHaP=ys|du>~wj8hpH+VaM0{d<$ns3;*&M
zU?J^T5$}sbg2iS>@>Rk7Qn$Sl!OH`NMPWzs;zWbja$?aqC|(&*ECxGn4ls769sjg|
zV+q*t^#RE2GTWgx2vw3gi}<DEmj$po_Ll^-I?Vb2N9Us3-ghXSVJ3|S8C8v6?}6*&
zdB2{8qRU!x@jCn)Jbs-Wu+o)U<ttgSY1H=f2|fyhwER-Z9JQ3;V!fxYlPNqU7WCG;
zh=cM2k;+PLI%cUO<^5MM`l`X}yLQ3vh6JY0(Av|S`egUsEkR5t>HSEB!I!e}V#|D)
zhkCVGf4Uoco%?#_VV1iw_WGrcX7hrspWz;kS=#PM_oVId3y!~BJocJBMRSg3x{Di+
z#4MmYGJCveI>F<M=F->&XEW^AR~@mr(DvFKp<S8JP!60$vWH!TsP?vG+CC`Q*vxO`
z*zNy1;Iq8Dqt21_p&z~`e!;1qEBDeVo{QLClYl+hv(K8wran&7JU(ky>WzNmtNV#R
z-7l>31FsB4)v)uD#>I+NUh?+Ud2lK2wr$j}R;TQsKRcIq{FXzXQ2YAB%L7v`q8HK7
zZYg!lcD|iJy5O!zbczp*G?&O;w&wg6lq?_hdfn@N=i><b4Wj#u6Q_PS!FLQ~q?Fb9
zA`kyl!e0S0TX18p=3Cri%|z?)U&r0+)60uP2szs>PW-a%eer3#`25^-4fS``d*)bw
I`!nJH2PWQwl>h($

literal 0
HcmV?d00001

diff --git a/lib/editor/atto/plugins/wordimport/yui/src/button/build.json b/lib/editor/atto/plugins/wordimport/yui/src/button/build.json
new file mode 100644
index 0000000..7092ded
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/yui/src/button/build.json
@@ -0,0 +1,10 @@
+{
+    "name": "moodle-atto_wordimport-button",
+    "builds": {
+        "moodle-atto_wordimport-button": {
+            "jsfiles": [
+                "button.js"
+            ]
+        }
+    }
+}
diff --git a/lib/editor/atto/plugins/wordimport/yui/src/button/js/button.js b/lib/editor/atto/plugins/wordimport/yui/src/button/js/button.js
new file mode 100644
index 0000000..6309199
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/yui/src/button/js/button.js
@@ -0,0 +1,322 @@
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/*
+ * @package    atto_wordimport
+ * @copyright  2015 Eoin Campbell
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+/**
+ * @module moodle-atto_wordimport-button
+ */
+
+/**
+ * Atto text editor import Microsoft Word file plugin.
+ *
+ * This plugin adds the ability to drop a Word file in and have it automatically
+ * convert the contents into XHTML and into the text box.
+ *
+ * @namespace M.atto_wordimport
+ * @class Button
+ * @extends M.editor_atto.EditorPlugin
+ */
+
+var COMPONENTNAME = 'atto_wordimport',
+    // @codingStandardsIgnoreStart
+    IMAGETEMPLATE = '' +
+        '<img src="{{url}}" alt="{{alt}}" ' +
+            '{{#if width}}width="{{width}}" {{/if}}' +
+            '{{#if height}}height="{{height}}" {{/if}}' +
+            '{{#if presentation}}role="presentation" {{/if}}' +
+            'style="{{alignment}}{{margin}}{{customstyle}}"' +
+            '{{#if classlist}}class="{{classlist}}" {{/if}}' +
+            '{{#if id}}id="{{id}}" {{/if}}' +
+            '/>';
+    // @codingStandardsIgnoreEnd
+
+Y.namespace('M.atto_wordimport').Button = Y.Base.create('button', Y.M.editor_atto.EditorPlugin, [], {
+
+    /**
+     * A reference to the current selection at the time that the dialogue
+     * was opened.
+     *
+     * @property _currentSelection
+     * @type Range
+     * @private
+     */
+    _currentSelection: null,
+
+    /**
+     * Add event listeners.
+     *
+     * @method initializer
+     */
+
+    initializer: function() {
+        // If we don't have the capability to view then give up.
+        if (this.get('disabled')) {
+            return;
+        }
+
+        this.addButton({
+            icon: 'wordimport',
+            iconComponent: COMPONENTNAME,
+            callback: function() {
+                    this.get('host').showFilepicker('link', this._handleWordFileUpload, this);
+            },
+            callbackArgs: 'wordimport'
+        });
+        this.editor.on('drop', this._handleWordFileDragDrop, this);
+    },
+
+    /**
+     * Handle a Word file upload via the filepicker
+     *
+     * @method _handleWordFileUpload
+     * @param {object} params The parameters provided by the filepicker.
+     * containing information about the file.
+     * @private
+     * @return {boolean} whether the uploaded file is .docx
+     */
+    _handleWordFileUpload: function(params) {
+        var host = this.get('host'),
+            fpoptions = host.get('filepickeroptions'),
+            options = fpoptions.link,
+            self = this,
+            xhr = new XMLHttpRequest();
+
+        if (params.url === '') {
+            return false;
+        }
+
+        // Return if selected file doesn't have Word 2010 suffix.
+        if (/\.docx$/.test(params.file) === false) {
+            Y.log(M.util.get_string('xmlnotsupported', COMPONENTNAME) + params.file);
+            return false;
+        }
+
+        // Kick off a XMLHttpRequest.
+        xhr.onreadystatechange = function() {
+            var uploadResult;
+
+            if (xhr.readyState === 4) {
+                if (xhr.status === 200) {
+                    uploadResult = JSON.parse(xhr.responseText);
+                    if (uploadResult) {
+                        if (uploadResult.error) {
+                            return new M.core.ajaxException(uploadResult);
+                        }
+
+                        // Insert content from file at current focus point.
+                        host.insertContentAtFocusPoint(uploadResult.html);
+                        self.markUpdated();
+                    }
+                } else {
+                    Y.use('moodle-core-notification-alert', function() {
+                        new M.core.alert({message: M.util.get_string('servererror', 'moodle')});
+                    });
+                }
+            }
+        };
+
+        var filename = 'filename=' + params.file,
+            contextID = 'ctx_id=' + options.context.id,
+            itemid = 'itemid=' + options.itemid,
+            sessionkey = 'sesskey=' + M.cfg.sesskey,
+            phpImportURL = '/lib/editor/atto/plugins/wordimport/import.php?';
+        Y.log('WordImport: File info: ' + contextID + ';' + itemid + ';' + filename);
+        xhr.open("GET", M.cfg.wwwroot + phpImportURL + contextID + '&' + itemid + '&' + filename + '&' + sessionkey, true);
+        xhr.send();
+
+        return true;
+    },
+
+    /**
+     * Handle a drag and drop event with a Word file.
+     *
+     * @method _handleWordFileDragDrop
+     * @param {EventFacade} e
+     * @private
+     * @return {boolean} whether the dragged file is .docx
+     */
+    _handleWordFileDragDrop: function(e) {
+
+        var self = this,
+            host = this.get('host'),
+            template = Y.Handlebars.compile(IMAGETEMPLATE),
+            requiredFileType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
+
+        host.saveSelection();
+        e = e._event;
+
+        // Only handle the event if a Word 2010 file was dropped in.
+        var handlesDataTransfer = (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length);
+        if (handlesDataTransfer && requiredFileType === e.dataTransfer.files[0].type) {
+            var options = host.get('filepickeroptions').link,
+                savepath = (options.savepath === undefined) ? '/' : options.savepath,
+                formData = new FormData(),
+                timestamp = 0,
+                uploadid = "",
+                xhr = new XMLHttpRequest(),
+                imagehtml = "",
+                keys = Object.keys(options.repositories);
+
+            Y.log('WordImport: Word 2010 (.docx) file dragged in ' + e.dataTransfer.files[0].type);
+            e.preventDefault();
+            e.stopPropagation();
+
+            formData.append('repo_upload_file', e.dataTransfer.files[0]);
+            formData.append('itemid', options.itemid);
+
+            // List of repositories is an object rather than an array.  This makes iteration more awkward.
+            for (var i = 0; i < keys.length; i++) {
+                if (options.repositories[keys[i]].type === 'upload') {
+                    formData.append('repo_id', options.repositories[keys[i]].id);
+                    break;
+                }
+            }
+            formData.append('env', options.env);
+            formData.append('sesskey', M.cfg.sesskey);
+            formData.append('client_id', options.client_id);
+            formData.append('savepath', savepath);
+            formData.append('ctx_id', options.context.id);
+            Y.log('WordImport: options.context.id = ' + options.context.id);
+
+            // Insert spinner as a placeholder.
+            timestamp = new Date().getTime();
+            uploadid = 'moodleimage_' + Math.round(Math.random() * 100000) + '-' + timestamp;
+            Y.log('WordImport: _handleWordFileDragDrop initial uploadid = ' + uploadid);
+            host.focus();
+            host.restoreSelection();
+            imagehtml = template({
+                url: M.util.image_url("i/loading_small", 'moodle'),
+                alt: M.util.get_string('uploading', COMPONENTNAME),
+                id: uploadid
+            });
+            host.insertContentAtFocusPoint(imagehtml);
+            self.markUpdated();
+
+            // Kick off a XMLHttpRequest to upload the dragged-in file.
+            xhr.onreadystatechange = function() {
+                var placeholder = self.editor.one('#' + uploadid),
+                    dragdropResult,
+                    file;
+                Y.log('WordImport: _handleWordFileDragDrop referenced uploadid = ' + uploadid);
+
+                if (xhr.readyState === 4) {
+                    if (xhr.status === 200) {
+                        dragdropResult = JSON.parse(xhr.responseText);
+                        if (dragdropResult) {
+                            if (dragdropResult.error) {
+                                if (placeholder) {
+                                    placeholder.remove(true);
+                                }
+                                Y.log('WordImport: _handleWordFileDragDrop upload failed.');
+                                Y.log('WordImport: dragdropResult = ' + dragdropResult);
+                                Y.use('moodle-core-notification-alert', function() {
+                                    new M.core.alert({message: M.util.get_string('fileuploadfailed', 'atto_wordimport')});
+                                });
+                                // @codingStandardsIgnoreLine return new M.core.ajaxException(dragdropResult);
+                            }
+
+                            file = dragdropResult.file;
+                            if (dragdropResult.event && dragdropResult.event === 'fileexists') {
+                                // A file with this name is already in use here - rename to avoid conflict.
+                                file = dragdropResult.newfile;
+                                Y.log('WordImport: _handleWordFileDragDrop upload is a duplicate file, renaming.');
+                            }
+
+                            // Word file uploaded, so kick off another XMLHttpRequest to convert it into HTML.
+                            xhr.onreadystatechange = function() {
+                                var placeholder = self.editor.one('#' + uploadid),
+                                    convertResult,
+                                    newhtml;
+
+                                Y.log('WordImport: _handleWordFileDragDrop referenced uploadid = ' + uploadid);
+                                if (xhr.readyState === 4) {
+                                    if (xhr.status === 200) {
+                                        convertResult = JSON.parse(xhr.responseText);
+                                        if (convertResult) {
+                                            if (convertResult.error) {
+                                                if (placeholder) {
+                                                    placeholder.remove(true);
+                                                }
+                                                Y.log('WordImport: _handleWFDD: convertResult = ' + convertResult);
+                                                Y.log('WordImport: _handleWFDD: typeof = ' + typeof (M.core.ajaxException));
+                                                Y.use('moodle-core-notification-alert', function() {
+                                                    new M.core.alert({message: M.util.get_string('fileconversionfailed',
+                                                            'atto_wordimport')});
+                                                });
+                                                // @codingStandardsIgnoreLine var error_obj = M.core.ajaxException(convertResult);
+                                                // @codingStandardsIgnoreLine return error_obj;
+                                            }
+
+                                            // Replace placeholder with actual content from Word file.
+                                            newhtml = Y.Node.create(convertResult.html);
+                                            if (placeholder) {
+                                                placeholder.replace(newhtml);
+                                            } else {
+                                                self.editor.appendChild(newhtml);
+                                            }
+                                        }
+                                    } else {
+                                        Y.use('moodle-core-notification-alert', function() {
+                                            new M.core.alert({message: M.util.get_string('servererror', 'moodle')});
+                                        });
+                                    }
+                                }
+                            };
+
+                            var contextID = 'ctx_id=' + options.context.id,
+                                itemID = 'itemid=' + options.itemid,
+                                fileName = 'filename=' + file,
+                                sessKey = 'sesskey=' + M.cfg.sesskey,
+                                importParams = contextID + '&' + itemID + '&' + fileName + '&' + sessKey,
+                                phpImportURL = '/lib/editor/atto/plugins/wordimport/import.php?';
+                            xhr.open("POST", M.cfg.wwwroot + phpImportURL + importParams, true);
+                            xhr.send();
+                            Y.log('WordImport: _handleWordFileDragDrop sent conversion request for ' + fileName);
+                            self.markUpdated();
+                        }
+                    } else {
+                        Y.use('moodle-core-notification-alert', function() {
+                            new M.core.alert({message: M.util.get_string('servererror', 'moodle')});
+                        });
+                        if (placeholder) {
+                            placeholder.remove(true);
+                        }
+                    }
+                }
+            };
+            xhr.open("POST", M.cfg.wwwroot + '/repository/repository_ajax.php?action=upload', true);
+            xhr.send(formData);
+            Y.log('WordImport: File upload request sent');
+        }
+        return false;
+
+    }
+
+
+}, {
+    ATTRS: {
+        disabled: {
+            value: true
+        },
+        area: {
+            value: {}
+        }
+    }
+});
diff --git a/lib/editor/atto/plugins/wordimport/yui/src/button/meta/button.json b/lib/editor/atto/plugins/wordimport/yui/src/button/meta/button.json
new file mode 100644
index 0000000..f455e64
--- /dev/null
+++ b/lib/editor/atto/plugins/wordimport/yui/src/button/meta/button.json
@@ -0,0 +1,7 @@
+{
+    "moodle-atto_wordimport-button": {
+        "requires": [
+            "moodle-editor_atto-plugin"
+        ]
+    }
+}
-- 
1.8.3.1

