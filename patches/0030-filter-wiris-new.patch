From ab2e2597711a3b674846a65fbeca63e4022b1f64 Mon Sep 17 00:00:00 2001
From: Nadav Kavalerchik <nadavkav@gmail.com>
Date: Wed, 11 Oct 2017 21:19:15 +0300
Subject: [PATCH 30/95] filter/wiris (new)

---
 filter/wiris/.travis.yml                           |  71 ++
 filter/wiris/LICENSE                               | 674 ++++++++++++++++
 filter/wiris/README.md                             |  25 +
 filter/wiris/VERSION                               |   1 +
 filter/wiris/classes/configurationupdater.php      | 166 ++++
 filter/wiris/classes/moodledbcache.php             | 131 +++
 filter/wiris/classes/moodledbjsoncache.php         | 184 +++++
 filter/wiris/classes/moodlefilecache.php           |  91 +++
 filter/wiris/classes/paramsprovider.php            |  92 +++
 filter/wiris/classes/pluginwrapper.php             | 205 +++++
 .../classes/pluginwrapperconfigurationupdater.php  |  56 ++
 filter/wiris/configuration.ini.dist                | 202 +++++
 filter/wiris/db/caches.php                         |  32 +
 filter/wiris/db/install.xml                        |  22 +
 filter/wiris/db/upgrade.php                        | 114 +++
 filter/wiris/filter.php                            | 126 +++
 filter/wiris/filtersettings.php                    | 117 +++
 filter/wiris/img/help.gif                          | Bin 0 -> 192 bytes
 filter/wiris/info.php                              | 332 ++++++++
 filter/wiris/integration/cas.php                   |  16 +
 filter/wiris/integration/cleancache.php            |  14 +
 filter/wiris/integration/configurationjs.php       |  15 +
 filter/wiris/integration/configurationjson.php     |  16 +
 filter/wiris/integration/createcasimage.php        |  14 +
 filter/wiris/integration/createimage.php           |  21 +
 filter/wiris/integration/editor.php                |  15 +
 filter/wiris/integration/getmathml.php             |  20 +
 filter/wiris/integration/index.php                 |  11 +
 filter/wiris/integration/isphp.php                 |   3 +
 filter/wiris/integration/lib/Date.class.php        |  67 ++
 filter/wiris/integration/lib/EReg.class.php        |  92 +++
 filter/wiris/integration/lib/Hash.class.php        |  65 ++
 filter/wiris/integration/lib/IntIter.class.php     |  28 +
 filter/wiris/integration/lib/Main.class.php        |   9 +
 filter/wiris/integration/lib/Math.class.php        |  76 ++
 filter/wiris/integration/lib/Reflect.class.php     | 104 +++
 filter/wiris/integration/lib/Std.class.php         |  52 ++
 filter/wiris/integration/lib/StringBuf.class.php   |  39 +
 filter/wiris/integration/lib/StringTools.class.php |  61 ++
 filter/wiris/integration/lib/Sys.class.php         | 117 +++
 filter/wiris/integration/lib/Type.class.php        | 298 +++++++
 filter/wiris/integration/lib/VERSION               |   1 +
 filter/wiris/integration/lib/ValueType.enum.php    |  21 +
 filter/wiris/integration/lib/cas.png               | Bin 0 -> 12579 bytes
 .../lib/com/wiris/common/WInteger.class.php        |  62 ++
 .../lib/com/wiris/plugin/api/Cas.interface.php     |   7 +
 .../com/wiris/plugin/api/CleanCache.interface.php  |   7 +
 .../wiris/plugin/api/Configuration.interface.php   |  11 +
 .../wiris/plugin/api/ConfigurationKeys.class.php   |  85 ++
 .../lib/com/wiris/plugin/api/Editor.interface.php  |   5 +
 .../plugin/api/ImageFormatController.interface.php |   6 +
 .../wiris/plugin/api/ParamsProvider.interface.php  |   9 +
 .../com/wiris/plugin/api/PluginBuilder.class.php   |  76 ++
 .../lib/com/wiris/plugin/api/Render.interface.php  |  10 +
 .../plugin/api/ServiceResourceLoader.interface.php |   6 +
 .../lib/com/wiris/plugin/api/Test.interface.php    |   5 +
 .../com/wiris/plugin/api/TextService.interface.php |  10 +
 .../plugin/asyncapi/AsyncRender.interface.php      |   7 +
 .../plugin/asyncapi/AsyncTextService.interface.php |   6 +
 .../plugin/asyncapi/BytesCallback.interface.php    |   6 +
 .../plugin/asyncapi/StringCallback.interface.php   |   6 +
 .../plugin/asyncimpl/AsyncRenderImpl.class.php     | 124 +++
 .../asyncimpl/AsyncTextServiceImpl.class.php       |  74 ++
 .../wiris/plugin/asyncimpl/CallbackImpl.class.php  |  51 ++
 .../plugin/asyncimpl/CreateImageMethod.class.php   |  91 +++
 .../plugin/asyncimpl/HttpPostAndContinue.class.php |  42 +
 .../ConfigurationUpdater.interface.php             |   6 +
 .../wiris/plugin/impl/CacheFormulaImpl.class.php   |   9 +
 .../lib/com/wiris/plugin/impl/CacheImpl.class.php  | 122 +++
 .../lib/com/wiris/plugin/impl/CasImpl.class.php    | 155 ++++
 .../com/wiris/plugin/impl/CleanCacheImpl.class.php | 114 +++
 .../wiris/plugin/impl/ConfigurationImpl.class.php  | 192 +++++
 .../impl/CustomConfigurationUpdater.class.php      |  42 +
 .../impl/DefaultConfigurationUpdater.class.php     |  24 +
 .../lib/com/wiris/plugin/impl/EditorImpl.class.php |  91 +++
 .../plugin/impl/FileConfigurationUpdater.class.php |  28 +
 .../plugin/impl/FileStorageAndCache.class.php      |  62 ++
 .../impl/FolderTreeStorageAndCache.class.php       |  88 ++
 .../impl/GenericParamsProviderImpl.class.php       |  70 ++
 .../lib/com/wiris/plugin/impl/HttpImpl.class.php   |  72 ++
 .../wiris/plugin/impl/HttpListener.interface.php   |   6 +
 .../plugin/impl/ImageFormatControllerPng.class.php |  69 ++
 .../plugin/impl/ImageFormatControllerSvg.class.php |  34 +
 .../wiris/plugin/impl/PluginBuilderImpl.class.php  | 278 +++++++
 .../lib/com/wiris/plugin/impl/RenderImpl.class.php | 346 ++++++++
 .../impl/RenderImplIntegratedServices.class.php    | 130 +++
 .../impl/ServiceResourceLoaderImpl.class.php       |  46 ++
 .../lib/com/wiris/plugin/impl/TestImpl.class.php   | 223 +++++
 .../lib/com/wiris/plugin/impl/TextFilter.class.php | 254 ++++++
 .../com/wiris/plugin/impl/TextFilterTags.class.php |  97 +++
 .../wiris/plugin/impl/TextServiceImpl.class.php    | 193 +++++
 .../TextServiceImplIntegratedServices.class.php    | 121 +++
 .../plugin/storage/StorageAndCache.interface.php   |  10 +
 .../plugin/web/PhpConfigurationUpdater.class.php   |  68 ++
 .../lib/com/wiris/std/system/HttpProxy.class.php   |  32 +
 .../com/wiris/std/system/HttpProxyAuth.class.php   |  20 +
 .../lib/com/wiris/system/ArrayEx.class.php         |  30 +
 .../lib/com/wiris/system/Base64.class.php          |  20 +
 .../lib/com/wiris/system/CallWrapper.class.php     | 111 +++
 .../lib/com/wiris/system/Exception.class.php       |  23 +
 .../lib/com/wiris/system/InputEx.class.php         |  21 +
 .../lib/com/wiris/system/Md5Tools.class.php        |  12 +
 .../lib/com/wiris/system/PropertiesTools.class.php |  40 +
 .../lib/com/wiris/system/Storage.class.php         | 146 ++++
 .../lib/com/wiris/system/StringEx.class.php        |  21 +
 .../lib/com/wiris/system/System.class.php          |  14 +
 .../lib/com/wiris/system/TypeTools.class.php       |  37 +
 .../lib/com/wiris/system/Utf8.class.php            |  41 +
 .../wiris/system/_Utf8/StringIterator.class.php    |  48 ++
 .../com/wiris/system/service/HttpRequest.class.php |  65 ++
 .../wiris/system/service/HttpResponse.class.php    | 170 ++++
 .../lib/com/wiris/util/json/JSon.class.php         | 596 ++++++++++++++
 .../wiris/util/json/JSonIntegerFormat.class.php    |  29 +
 .../com/wiris/util/json/JsonAPIResponse.class.php  |  76 ++
 .../lib/com/wiris/util/json/StringParser.class.php |  75 ++
 .../lib/com/wiris/util/net/UserAgent.class.php     |  27 +
 .../lib/com/wiris/util/sys/Cache.interface.php     |   8 +
 .../lib/com/wiris/util/sys/IniFile.class.php       | 179 ++++
 .../lib/com/wiris/util/sys/Store.class.php         | 184 +++++
 .../lib/com/wiris/util/type/UrlUtils.class.php     |  56 ++
 .../com/wiris/util/xml/WCharacterBase.class.php    | 898 +++++++++++++++++++++
 .../integration/lib/default-configuration.ini      |  46 ++
 .../wiris/integration/lib/haxe/BaseCode.class.php  | 118 +++
 filter/wiris/integration/lib/haxe/Http.class.php   | 544 +++++++++++++
 filter/wiris/integration/lib/haxe/Int32.class.php  |  92 +++
 filter/wiris/integration/lib/haxe/Int64.class.php  | 347 ++++++++
 filter/wiris/integration/lib/haxe/Log.class.php    |  21 +
 filter/wiris/integration/lib/haxe/Md5.class.php    |   9 +
 filter/wiris/integration/lib/haxe/Utf8.class.php   |  66 ++
 .../wiris/integration/lib/haxe/io/Bytes.class.php  |  88 ++
 .../integration/lib/haxe/io/BytesBuffer.class.php  |  37 +
 .../integration/lib/haxe/io/BytesInput.class.php   |  56 ++
 .../integration/lib/haxe/io/BytesOutput.class.php  |  36 +
 filter/wiris/integration/lib/haxe/io/Eof.class.php |  10 +
 .../wiris/integration/lib/haxe/io/Error.enum.php   |  12 +
 .../wiris/integration/lib/haxe/io/Input.class.php  | 254 ++++++
 .../wiris/integration/lib/haxe/io/Output.class.php | 267 ++++++
 filter/wiris/integration/lib/php/Boot.class.php    | 894 ++++++++++++++++++++
 filter/wiris/integration/lib/php/Lib.class.php     | 119 +++
 .../integration/lib/php/net/SslSocket.class.php    |  17 +
 .../wiris/integration/lib/sys/FileSystem.class.php |  59 ++
 .../lib/sys/_FileSystem/FileKind.enum.php          |  10 +
 filter/wiris/integration/lib/sys/io/File.class.php |  41 +
 .../integration/lib/sys/io/FileInput.class.php     | 103 +++
 .../integration/lib/sys/io/FileOutput.class.php    |  88 ++
 .../wiris/integration/lib/sys/io/FileSeek.enum.php |  11 +
 .../wiris/integration/lib/sys/net/Host.class.php   |  42 +
 .../wiris/integration/lib/sys/net/Socket.class.php | 135 ++++
 filter/wiris/integration/lib/tech.txt              |   1 +
 filter/wiris/integration/lib/wirisplugin.css       |  43 +
 filter/wiris/integration/moodleparamsprovider.php  |  76 ++
 filter/wiris/integration/phpparamsprovider.php     |  53 ++
 filter/wiris/integration/plugin.php                |   5 +
 filter/wiris/integration/pluginbuilder.php         |  61 ++
 filter/wiris/integration/resource.php              |  10 +
 filter/wiris/integration/service.php               |  25 +
 filter/wiris/integration/showcasimage.php          |  16 +
 filter/wiris/integration/showimage.php             |  48 ++
 filter/wiris/integration/test.php                  |  12 +
 filter/wiris/integration/testfilter.php            |  18 +
 filter/wiris/integration/update.php                |  34 +
 filter/wiris/lang/en/filter_wiris.php              |  71 ++
 filter/wiris/lib.php                               | 176 ++++
 filter/wiris/pix/icon.png                          | Bin 0 -> 406 bytes
 filter/wiris/settings.php                          | 117 +++
 filter/wiris/styles.css                            |  23 +
 filter/wiris/test.html                             | 163 ++++
 filter/wiris/tests/filter_performance_png_test.php |  79 ++
 filter/wiris/tests/filter_performance_svg_test.php | 114 +++
 .../tests/filter_without_performance_png_test.php  |  88 ++
 .../tests/filter_without_performance_svg_test.php  |  77 ++
 filter/wiris/thirdpartylibs.xml                    |  10 +
 filter/wiris/version.php                           |  33 +
 173 files changed, 15326 insertions(+)
 create mode 100644 filter/wiris/.travis.yml
 create mode 100644 filter/wiris/LICENSE
 create mode 100644 filter/wiris/README.md
 create mode 100644 filter/wiris/VERSION
 create mode 100644 filter/wiris/classes/configurationupdater.php
 create mode 100644 filter/wiris/classes/moodledbcache.php
 create mode 100644 filter/wiris/classes/moodledbjsoncache.php
 create mode 100644 filter/wiris/classes/moodlefilecache.php
 create mode 100644 filter/wiris/classes/paramsprovider.php
 create mode 100644 filter/wiris/classes/pluginwrapper.php
 create mode 100644 filter/wiris/classes/pluginwrapperconfigurationupdater.php
 create mode 100644 filter/wiris/configuration.ini.dist
 create mode 100644 filter/wiris/db/caches.php
 create mode 100644 filter/wiris/db/install.xml
 create mode 100644 filter/wiris/db/upgrade.php
 create mode 100644 filter/wiris/filter.php
 create mode 100644 filter/wiris/filtersettings.php
 create mode 100644 filter/wiris/img/help.gif
 create mode 100644 filter/wiris/info.php
 create mode 100644 filter/wiris/integration/cas.php
 create mode 100644 filter/wiris/integration/cleancache.php
 create mode 100644 filter/wiris/integration/configurationjs.php
 create mode 100644 filter/wiris/integration/configurationjson.php
 create mode 100644 filter/wiris/integration/createcasimage.php
 create mode 100644 filter/wiris/integration/createimage.php
 create mode 100644 filter/wiris/integration/editor.php
 create mode 100644 filter/wiris/integration/getmathml.php
 create mode 100644 filter/wiris/integration/index.php
 create mode 100644 filter/wiris/integration/isphp.php
 create mode 100644 filter/wiris/integration/lib/Date.class.php
 create mode 100644 filter/wiris/integration/lib/EReg.class.php
 create mode 100644 filter/wiris/integration/lib/Hash.class.php
 create mode 100644 filter/wiris/integration/lib/IntIter.class.php
 create mode 100644 filter/wiris/integration/lib/Main.class.php
 create mode 100644 filter/wiris/integration/lib/Math.class.php
 create mode 100644 filter/wiris/integration/lib/Reflect.class.php
 create mode 100644 filter/wiris/integration/lib/Std.class.php
 create mode 100644 filter/wiris/integration/lib/StringBuf.class.php
 create mode 100644 filter/wiris/integration/lib/StringTools.class.php
 create mode 100644 filter/wiris/integration/lib/Sys.class.php
 create mode 100644 filter/wiris/integration/lib/Type.class.php
 create mode 100644 filter/wiris/integration/lib/VERSION
 create mode 100644 filter/wiris/integration/lib/ValueType.enum.php
 create mode 100644 filter/wiris/integration/lib/cas.png
 create mode 100644 filter/wiris/integration/lib/com/wiris/common/WInteger.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/Cas.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/CleanCache.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/Configuration.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/ConfigurationKeys.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/Editor.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/ImageFormatController.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/ParamsProvider.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/PluginBuilder.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/Render.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/ServiceResourceLoader.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/Test.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/api/TextService.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/asyncapi/AsyncRender.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/asyncapi/AsyncTextService.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/asyncapi/BytesCallback.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/asyncapi/StringCallback.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/AsyncRenderImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/AsyncTextServiceImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/CallbackImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/CreateImageMethod.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/HttpPostAndContinue.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/configuration/ConfigurationUpdater.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/CacheFormulaImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/CacheImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/CasImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/CleanCacheImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/ConfigurationImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/CustomConfigurationUpdater.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/DefaultConfigurationUpdater.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/EditorImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/FileConfigurationUpdater.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/FileStorageAndCache.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/FolderTreeStorageAndCache.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/GenericParamsProviderImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/HttpImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/HttpListener.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/ImageFormatControllerPng.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/ImageFormatControllerSvg.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/PluginBuilderImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/RenderImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/RenderImplIntegratedServices.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/ServiceResourceLoaderImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/TestImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/TextFilter.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/TextFilterTags.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/TextServiceImpl.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/impl/TextServiceImplIntegratedServices.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/storage/StorageAndCache.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/plugin/web/PhpConfigurationUpdater.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/std/system/HttpProxy.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/std/system/HttpProxyAuth.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/ArrayEx.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/Base64.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/CallWrapper.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/Exception.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/InputEx.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/Md5Tools.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/PropertiesTools.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/Storage.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/StringEx.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/System.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/TypeTools.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/Utf8.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/_Utf8/StringIterator.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/service/HttpRequest.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/system/service/HttpResponse.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/util/json/JSon.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/util/json/JSonIntegerFormat.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/util/json/JsonAPIResponse.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/util/json/StringParser.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/util/net/UserAgent.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/util/sys/Cache.interface.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/util/sys/IniFile.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/util/sys/Store.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/util/type/UrlUtils.class.php
 create mode 100644 filter/wiris/integration/lib/com/wiris/util/xml/WCharacterBase.class.php
 create mode 100644 filter/wiris/integration/lib/default-configuration.ini
 create mode 100644 filter/wiris/integration/lib/haxe/BaseCode.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/Http.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/Int32.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/Int64.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/Log.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/Md5.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/Utf8.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/io/Bytes.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/io/BytesBuffer.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/io/BytesInput.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/io/BytesOutput.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/io/Eof.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/io/Error.enum.php
 create mode 100644 filter/wiris/integration/lib/haxe/io/Input.class.php
 create mode 100644 filter/wiris/integration/lib/haxe/io/Output.class.php
 create mode 100644 filter/wiris/integration/lib/php/Boot.class.php
 create mode 100644 filter/wiris/integration/lib/php/Lib.class.php
 create mode 100644 filter/wiris/integration/lib/php/net/SslSocket.class.php
 create mode 100644 filter/wiris/integration/lib/sys/FileSystem.class.php
 create mode 100644 filter/wiris/integration/lib/sys/_FileSystem/FileKind.enum.php
 create mode 100644 filter/wiris/integration/lib/sys/io/File.class.php
 create mode 100644 filter/wiris/integration/lib/sys/io/FileInput.class.php
 create mode 100644 filter/wiris/integration/lib/sys/io/FileOutput.class.php
 create mode 100644 filter/wiris/integration/lib/sys/io/FileSeek.enum.php
 create mode 100644 filter/wiris/integration/lib/sys/net/Host.class.php
 create mode 100644 filter/wiris/integration/lib/sys/net/Socket.class.php
 create mode 100644 filter/wiris/integration/lib/tech.txt
 create mode 100644 filter/wiris/integration/lib/wirisplugin.css
 create mode 100644 filter/wiris/integration/moodleparamsprovider.php
 create mode 100644 filter/wiris/integration/phpparamsprovider.php
 create mode 100644 filter/wiris/integration/plugin.php
 create mode 100644 filter/wiris/integration/pluginbuilder.php
 create mode 100644 filter/wiris/integration/resource.php
 create mode 100644 filter/wiris/integration/service.php
 create mode 100644 filter/wiris/integration/showcasimage.php
 create mode 100644 filter/wiris/integration/showimage.php
 create mode 100644 filter/wiris/integration/test.php
 create mode 100644 filter/wiris/integration/testfilter.php
 create mode 100644 filter/wiris/integration/update.php
 create mode 100644 filter/wiris/lang/en/filter_wiris.php
 create mode 100644 filter/wiris/lib.php
 create mode 100644 filter/wiris/pix/icon.png
 create mode 100644 filter/wiris/settings.php
 create mode 100644 filter/wiris/styles.css
 create mode 100644 filter/wiris/test.html
 create mode 100644 filter/wiris/tests/filter_performance_png_test.php
 create mode 100644 filter/wiris/tests/filter_performance_svg_test.php
 create mode 100644 filter/wiris/tests/filter_without_performance_png_test.php
 create mode 100644 filter/wiris/tests/filter_without_performance_svg_test.php
 create mode 100644 filter/wiris/thirdpartylibs.xml
 create mode 100644 filter/wiris/version.php

diff --git a/filter/wiris/.travis.yml b/filter/wiris/.travis.yml
new file mode 100644
index 0000000..f36782d
--- /dev/null
+++ b/filter/wiris/.travis.yml
@@ -0,0 +1,71 @@
+language: php
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.composer/cache
+
+php:
+ - 5.6
+ - 7.0
+
+env:
+  - MOODLE_BRANCH=MOODLE_33_STABLE DB=mysqli IGNORE_PATHS=integration
+  - MOODLE_BRANCH=MOODLE_32_STABLE DB=mysqli IGNORE_PATHS=integration
+  - MOODLE_BRANCH=MOODLE_31_STABLE DB=mysqli IGNORE_PATHS=integration
+  - MOODLE_BRANCH=MOODLE_30_STABLE DB=pgsql  IGNORE_PATHS=integration
+  - MOODLE_BRANCH=MOODLE_29_STABLE DB=mysqli IGNORE_PATHS=integration
+  - MOODLE_BRANCH=MOODLE_28_STABLE DB=pgsql  IGNORE_PATHS=integration
+  - MOODLE_BRANCH=MOODLE_27_STABLE DB=mysqli IGNORE_PATHS=integration
+
+matrix:
+  exclude:
+    - php: 7.0
+      env: MOODLE_BRANCH=MOODLE_29_STABLE DB=mysqli IGNORE_PATHS=integration
+    - php: 7.0
+      env: MOODLE_BRANCH=MOODLE_28_STABLE DB=pgsql  IGNORE_PATHS=integration
+    - php: 7.0
+      env: MOODLE_BRANCH=MOODLE_27_STABLE DB=mysqli IGNORE_PATHS=integration
+    - php: 5.6
+      env: MOODLE_BRANCH=MOODLE_31_STABLE DB=mysqli IGNORE_PATHS=integration
+    - php: 5.6
+      env: MOODLE_BRANCH=MOODLE_30_STABLE DB=pgsql  IGNORE_PATHS=integration
+    - php: 5.6
+      env: MOODLE_BRANCH=MOODLE_29_STABLE DB=mysqli IGNORE_PATHS=integration
+    - php: 5.6
+      env: MOODLE_BRANCH=MOODLE_28_STABLE DB=pgsql  IGNORE_PATHS=integration
+    - php: 5.6
+      env: MOODLE_BRANCH=MOODLE_27_STABLE DB=mysqli IGNORE_PATHS=integration
+    - php: 5.4
+      env: MOODLE_BRANCH=MOODLE_32_STABLE DB=mysqli IGNORE_PATHS=integration
+    - php: 5.4
+      env: MOODLE_BRANCH=MOODLE_33_STABLE DB=mysqli IGNORE_PATHS=integration
+  include:
+    - php: 5.4
+      env: MOODLE_BRANCH=MOODLE_31_STABLE DB=mysqli IGNORE_PATHS=integration
+    - php: 5.4
+      env: MOODLE_BRANCH=MOODLE_30_STABLE DB=pgsql  IGNORE_PATHS=integration
+    - php: 5.4
+      env: MOODLE_BRANCH=MOODLE_29_STABLE DB=mysqli IGNORE_PATHS=integration
+    - php: 5.4
+      env: MOODLE_BRANCH=MOODLE_28_STABLE DB=pgsql  IGNORE_PATHS=integration
+    - php: 5.4
+      env: MOODLE_BRANCH=MOODLE_27_STABLE DB=mysqli IGNORE_PATHS=integration
+
+before_install:
+  - phpenv config-rm xdebug.ini
+  - cd ../..
+  - composer selfupdate
+  - composer create-project -n --no-dev --prefer-dist moodlerooms/moodle-plugin-ci ci ^1
+  - export PATH="$(cd ci/bin; pwd):$(cd ci/vendor/bin; pwd):$PATH"
+
+install:
+  - moodle-plugin-ci install
+script:
+  - moodle-plugin-ci phplint
+  - moodle-plugin-ci phpcpd
+  - moodle-plugin-ci phpmd
+  - moodle-plugin-ci codechecker
+  - moodle-plugin-ci validate
+  - moodle-plugin-ci behat
\ No newline at end of file
diff --git a/filter/wiris/LICENSE b/filter/wiris/LICENSE
new file mode 100644
index 0000000..30ace6a
--- /dev/null
+++ b/filter/wiris/LICENSE
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    {one line to give the program's name and a brief idea of what it does.}
+    Copyright (C) {year}  {name of author}
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    {project}  Copyright (C) {year}  {fullname}
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
\ No newline at end of file
diff --git a/filter/wiris/README.md b/filter/wiris/README.md
new file mode 100644
index 0000000..749b6be
--- /dev/null
+++ b/filter/wiris/README.md
@@ -0,0 +1,25 @@
+WIRIS plugin for Moodle
+==========
+### Master Build Status
+[![Build Status](https://travis-ci.org/wiris/moodle-filter_wiris.svg?branch=master)](https://travis-ci.org/wiris/moodle-atto_wiris)
+### Development Build Status
+[![Build Status](https://travis-ci.org/wiris/moodle-filter_wiris.svg?branch=development)](https://travis-ci.org/wiris/moodle-atto_wiris)
+
+Add a fully WYSIWYG editor for scientific expressions ([WIRIS EDITOR](http://www.wiris.com/editor)) and, optionally, an advanced calculator tool ([WIRIS CAS](http://www.wiris.com/cas)). Enabled editing to STEM related topics (Science, Technology, Engineering and Mathematics). 
+
+[WIRIS EDITOR](http://www.wiris.com/editor) is a mathematical **visual (WYSIWYG) editor**. You can use a large collection of icons nicely organized in thematic tabs in order to create formulas or equations for any web content. You can create and edit your formulas in a visual environment, just click on the WIRIS editor icon for creation or double-click on the formula for edition. It is based on JavaScript and compatible with HTML 5.
+
+WIRIS EDITOR offers a **chemistry** toolbar. The maths and the chemistry palette are available from different icons in the rich text editor.
+
+[WIRIS CAS](http://www.wiris.com/cas) is an online platform for **mathematical calculations** designed for education. You can access a powerful calculation toolbar through an HTML page that includes integrals and limits calculation, function graphing in 2D or 3D and symbolic matrices manipulation, among others. WIRIS cas covers **all mathematical topics** from primary school to university level (Calculus, Algebra, Geometry, Differential Equations...).
+
+WIRIS tools can be used for **free** up to a certain level of use per natural year. Please read **license** conditions and prices at [WIRIS store](http://www.wiris.com/store).
+
+In order to use WIRIS tools for editing you need to combine **[WIRIS filter](https://github.com/wiris/moodle-filter_wiris)** with **[WIRIS plugin for Atto](https://github.com/wiris/mooodle-atto_wiris)** and/or **[WIRIS plugin for TinyMCE](https://github.com/wiris/moodle-tinymce_tiny_mce_wiris)**.
+
+###### More than editing, better quizzes
+Interested in mathematical quizzes with random parameters and automated evaluation?
+Must check our new STEM question types at WIRIS quizzes plugin.
+
+###### Previous version of Moodle?
+Running a **previous version** of Moodle? You can download the components from [wiris.com](http://www.wiris.com/plugins/moodle/download) 
\ No newline at end of file
diff --git a/filter/wiris/VERSION b/filter/wiris/VERSION
new file mode 100644
index 0000000..9f2124c
--- /dev/null
+++ b/filter/wiris/VERSION
@@ -0,0 +1 @@
+4.7.0.1374
\ No newline at end of file
diff --git a/filter/wiris/classes/configurationupdater.php b/filter/wiris/classes/configurationupdater.php
new file mode 100644
index 0000000..45cc1c3
--- /dev/null
+++ b/filter/wiris/classes/configurationupdater.php
@@ -0,0 +1,166 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+//
+
+/**
+ * This class implements WIRIS com_wiris_plugin_configuration_ConfigurationUpdater interface
+ * to use a custom Moodle configuration.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->dirroot . '/filter/wiris/integration/lib/com/wiris/plugin/configuration/ConfigurationUpdater.interface.php');
+
+class filter_wiris_configurationupdater implements com_wiris_plugin_configuration_ConfigurationUpdater {
+
+    public $waseditorenabled;
+    public $wascasenabled;
+    public $waschemeditorenabled;
+    private $oldconfiguration;
+
+    public $editorplugin;
+
+    public function __construct() {
+        $scriptname = explode('/', $_SERVER["SCRIPT_FILENAME"]);
+        $scriptname = array_pop($scriptname);
+
+        if ($scriptname == 'showimage.php') {
+            return;
+        }
+
+        global $CFG;
+
+        $this->editorplugin = filter_wiris_pluginwrapper::get_wiris_plugin();
+        $this->oldconfiguration = filter_wiris_pluginwrapper::get_old_configuration();
+
+    }
+
+    public function init($obj) {
+    }
+
+    private function get_latex_status() {
+        global $CFG;
+
+        $filters = filter_get_globally_enabled();
+        // Since Moodle 2.5 key is 'tex' not 'filter/tex'.
+        $status = ($CFG->version >= 2013051400) ? array_key_exists('tex', $filters) : array_key_exists('filter/tex', $filters);
+        return $status;
+    }
+
+    private function eval_parameter($param) {
+        return ($param == 1 || $param == "true");
+    }
+
+    // @codingStandardsIgnoreStart
+    // Can't change implemented interface method name.
+    public function updateConfiguration(&$configuration) {
+    // @codingStandardsIgnoreEnd
+        global $CFG;
+
+        // Old configuration.ini.
+        if ($this->oldconfiguration) {
+            $configuration['wirisconfigurationpath'] = $this->editorplugin->path;
+        }
+
+        $scriptname = explode('/', $_SERVER["SCRIPT_FILENAME"]);
+        $scriptname = array_pop($scriptname);
+
+        com_wiris_system_CallWrapper::getInstance()->stop();
+        if ($scriptname == 'showimage.php') { // Minimal conf showing images.
+            if (optional_param('refererquery', null, PARAM_RAW) != null) {
+                $refererquery = implode('&', explode('/', optional_param('refererquery', null, PARAM_RAW)));
+                $configuration['wirisreferer'] = $CFG->wwwroot . $refererquery;
+            }
+            com_wiris_system_CallWrapper::getInstance()->start();
+            return;
+        }
+
+        // Enable LaTeX.
+        if ($this->get_latex_status()) {
+            $configuration['wiriseditorparselatex'] = false;
+        }
+        // WIRIS editor.
+        $filterenabled = filter_is_enabled('filter/wiris');
+        $this->waseditorenabled = $this->eval_parameter($configuration['wiriseditorenabled']);
+        if (isset($CFG->filter_wiris_editor_enable)) {
+            // We need to convert all boolean values to text because $configuration object expects as values
+            // the same objects as configuration.ini (i.e strings). This is mandatory due to cross-technology.
+            $wiriseditorenabled = ($this->waseditorenabled &&
+                                   $this->eval_parameter($CFG->filter_wiris_editor_enable) &&
+                                   $filterenabled) ? "true" : "false";
+            $configuration['wiriseditorenabled'] = $wiriseditorenabled;
+        } else {
+            $configuration['wiriseditorenabled'] = "false";
+        }
+        // WIRIS cas.
+        $this->wascasenabled = $this->eval_parameter($configuration['wiriscasenabled']);
+        if (isset($CFG->filter_wiris_cas_enable)) {
+            $wiriscasenabled = ($this->wascasenabled && $this->eval_parameter($CFG->filter_wiris_cas_enable) && $filterenabled) ? "true" : "false";
+            $configuration['wiriscasenabled'] = $wiriscasenabled;
+        } else {
+            $configuration['wiriscasenabled'] = false;
+        }
+
+        // WIRIS Chem editor.
+        $this->waschemeditorenabled = $this->eval_parameter($configuration['wirischemeditorenabled']);
+        if (isset($CFG->filter_wiris_chem_editor_enable)) {
+            $wirischemeditorenabled = $this->waschemeditorenabled &&
+                                      $this->eval_parameter($CFG->filter_wiris_chem_editor_enable) &&
+                                      $filterenabled ? "true" : "false";
+            $configuration['wirischemeditorenabled'] = $wirischemeditorenabled;
+        } else {
+            $configuration['wirischemeditorenabled'] = false;
+        }
+
+        // Where is the plugin.
+        $configuration['wiriscontextpath'] = $CFG->wwwroot . '/filter/wiris/';
+        // Encoded XML.
+        $configuration['wiriseditorsavemode'] = 'safeXml';
+        $configuration['wirishostplatform'] = 'Moodle';
+        $configuration['wirisversionplatform'] = $CFG->version;
+        // Referer.
+        global $COURSE;
+        $query = '';
+        if (isset($COURSE->id)) {
+            $query .= '?course=' . $COURSE->id;
+        }
+        if (isset($COURSE->category)) {
+            $query .= empty($query) ? '?' : '&';
+            $query .= 'category=' . $COURSE->category;
+        }
+
+        $configuration['wirisreferer'] = $CFG->wwwroot . $query;
+
+        $moodleproxyenabled = !empty($CFG->proxyhost);
+        $proxyportenabled = !empty($CFG->proxyport);
+        $proxyuserenabled = !empty($CFG->proxyuser);
+        $proxypassenabled = !empty($CFG->proxypassword);
+
+        if ($moodleproxyenabled) {
+            $configuration['wirisproxy'] = "true";
+            $configuration['wirisproxy_host'] = $CFG->proxyhost;
+            $configuration['wirisproxy_port'] = $proxyportenabled ? $CFG->proxyport : null;
+            $configuration['wirisproxy_user'] = $proxyuserenabled ? $CFG->proxyuser : null;
+            $configuration['wirisproxy_password'] = $proxypassenabled ? $CFG->proxypassword : null;
+        }
+        com_wiris_system_CallWrapper::getInstance()->start();
+    }
+}
diff --git a/filter/wiris/classes/moodledbcache.php b/filter/wiris/classes/moodledbcache.php
new file mode 100644
index 0000000..41837db
--- /dev/null
+++ b/filter/wiris/classes/moodledbcache.php
@@ -0,0 +1,131 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This class implements WIRIS cache interface
+ * to store WIRIS cache on Moodle database.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+class moodledbcache {
+
+    private $cachetable;
+    private $keyfield;
+    private $valuefield;
+    private $timecreatedfield;
+
+    /**
+     * Constructor for db cache class.
+     * @param String $tablename  Cache table name.
+     * @param String $keyfield   "key" field.
+     * @param String $valuefield "value" field.
+     */
+    public function __construct($tablename, $keyfield, $valuefield) {
+        $this->cachetable = $tablename;
+        $this->keyfield = $keyfield;
+        $this->valuefield = $valuefield;
+        $this->timecreatedfield = 'timecreated';
+    }
+
+    /**
+     * Delete the given key from the cache
+     * @param key The key to delete.
+     * @throw Error On unexpected exception.
+     */
+    public function delete($key) {
+    }
+
+    /**
+     * Deletes all the data in the cache.
+     * @throw Error on unexpected exception.
+     */
+    // @codingStandardsIgnoreStart
+    public function deleteAll() {
+    // @codingStandardsIgnoreEnd
+        global $DB;
+        $DB->delete_records($this->cachetable, null);
+    }
+
+    /**
+     * Retrieves the value for the given key for the cache.
+     * @param key The key for for the data being requested.
+     * @return Bytes The data retrieved from the cache. Returns null on cache miss or error.
+     */
+    public function get($key) {
+
+        $parsedkey = $this->parse_key($key);
+
+        global $DB;
+        if ($DB->record_exists($this->cachetable, array($this->keyfield => $parsedkey))) {
+            $record = $DB->get_record($this->cachetable, array($this->keyfield => $parsedkey));
+            // Cache interface returns an array of Bytes. When we are using the database to
+            // store cache the data should be converted to a Bytes object.
+            $valuefield = $this->valuefield;
+            return haxe_io_Bytes::ofData(com_wiris_system_Utf8::toBytes($record->$valuefield));
+        } else {
+            return null;
+        }
+
+    }
+
+    /**
+     * Retrieves the name of the key for the cache without the extension.
+     * @key The key with a extension.
+     */
+    private function parse_key($key) {
+        $separatedkey = explode(".", $key);
+        return $separatedkey[0];
+    }
+
+    /**
+     * Stores a (key, value) pair to the cache. If the key exists, updates the value.
+     * @param key The key for the data being requested.
+     * @param value The data to set against the key.
+     * @throw Error On unexpected exception storing the value.
+     */
+    public function set($key, $value) {
+
+        $parsedkey = $this->parse_key($key);
+
+        global $DB;
+        if (!$DB->record_exists($this->cachetable, array($this->keyfield => $parsedkey))) {
+            // Variable $value is a a array of bytes, we need the content of the array.
+            try {
+                $DB->insert_record($this->cachetable, array($this->keyfield => $parsedkey, $this->valuefield => $value->b,
+                                    $this->timecreatedfield => time()));
+            } catch (dml_exception $ex) {
+                // Concurrent write access to the same - unexisting - md5
+                // are possible in some scenarios (like a quiz)
+                // if a write_exception occurs, formula has been created
+                // is not a real exception.
+                if ($ex instanceof dml_write_exception) {
+                    return;
+                }
+                throw $ex;
+            }
+        } else {
+            $record = $DB->get_record($this->cachetable, array($this->keyfield => $parsedkey));
+            $record->value = $value->b;
+            $DB->update_record($this->cachetable, $record);
+        }
+    }
+}
diff --git a/filter/wiris/classes/moodledbjsoncache.php b/filter/wiris/classes/moodledbjsoncache.php
new file mode 100644
index 0000000..d226910
--- /dev/null
+++ b/filter/wiris/classes/moodledbjsoncache.php
@@ -0,0 +1,184 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This class implements WIRIS StorageAndCache interface
+ * to store WIRIS data on MUC and Moodle database.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+class moodledbjsoncache {
+
+    private $cachetable;
+    private $keyfield;
+    private $jsonfield;
+    private $timecreatedfield;
+
+    /**
+     * Constructores for WIRIS file cache.
+     * @param String $area   cache area.
+     * @param String $module cache definition.
+     */
+    public function __construct($tablename, $keyfield, $jsonfield) {
+        $this->cachetable = $tablename;
+        $this->keyfield = $keyfield;
+        $this->jsonfield = $jsonfield;
+        $this->timecreatedfield = 'timecreated';
+    }
+
+    /**
+     * Delete the given key from the cache
+     * @param key The key to delete.
+     * @throw Error On unexpected exception.
+     */
+    public function delete($key) {
+    }
+
+    /**
+     * Deletes all the data in the cache.
+     * @throw moodle_exception failing purgue the cache.
+     */
+    // @codingStandardsIgnoreStart
+    public function deleteAll() {
+    // @codingStandardsIgnoreEnd
+        global $DB;
+        $DB->delete_records($this->cachetable, null);
+    }
+
+    /**
+     * Retrieves the value for the given key for the cache.
+     * @param key The key for for the data being requested.
+     * @return Bytes The data retrieved from the cache. Returns null on cache miss or error.
+     */
+    public function get($key) {
+
+        $parsedkey = $this->parse_key($key);
+
+        global $DB;
+
+        $jsonfield = $this->jsonfield;
+
+        if ($DB->record_exists($this->cachetable, array($this->keyfield => $parsedkey))) {
+
+            $record = $DB->get_record($this->cachetable, array($this->keyfield => $parsedkey));
+            if (strpos($key, '.svg') !== false) {
+                return haxe_io_Bytes::ofData(com_wiris_system_Utf8::toBytes($record->$jsonfield));
+            } else if (strpos($key, '.txt') !== false) {
+                return haxe_io_Bytes::ofData(com_wiris_system_Utf8::toBytes($record->alt));
+            } else {
+                return null;
+            }
+            if (isset($record->$jsonfield) && $record->$jsonfield != '') {
+
+                $base64decoder = new com_wiris_system_Base64();
+                if (strpos($key, '.png') !== false) {
+                    $jsonfield = $this->jsonfield;
+                    $json = com_wiris_util_json_JSon::decode($record->$jsonfield, true)->get('result')->get('content');
+
+                    // Cache interface returns an array of Bytes. When we are using the database to
+                    // store cache the data should be converted to a Bytes object.
+                    $jsontodecode = new StdClass();
+                    $jsontodecode->b = $json;
+
+                    return '' != $jsontodecode;
+                } else {
+                    $jsonfield = $this->jsonfield;
+                    $json = com_wiris_util_json_JSon::decode($record->$jsonfield, true)->get('result')->get('alt');
+                    $jsontodecode = new StdClass();
+                    $jsontodecode->b = $json;
+
+                    return '' != $jsontodecode;
+                }
+
+            } else {
+                return null;
+            }
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Retrieves the name of the key for the cache without the extension.
+     * @key The key with a extension.
+     */
+    private function parse_key($key) {
+        $separatedkey = explode(".", $key);
+        return $separatedkey[0];
+    }
+
+    /**
+     * Stores a (key, value) pair to the cache. If the key exists, updates the value.
+     * @param key The key for the data being requested.
+     * @param value The data to set against the key.
+     * @throw Error On unexpected exception storing the value.
+     */
+    public function set($key, $value) {
+
+        $jsonhash = new Hash();
+        $jsonhash->set('status', 'ok');
+        $innerhash = new Hash();
+        $innerhash->set('content', '');
+        $innerhash->set('alt', '');
+        $jsonhash->set('result', $innerhash);
+        $parsedkey = $this->parse_key($key);
+        $bytevalue = com_wiris_system_Utf8::toBytes($value)->b;
+        global $DB;
+        if (!$DB->record_exists($this->cachetable, array($this->keyfield => $parsedkey))) {
+
+            // Variable $value is an array of bytes, we need the content of the array.
+            try {
+                // Accesibility (alt field).
+                if (strpos($key, '.txt') === false) {
+                    $DB->insert_record($this->cachetable, array($this->keyfield => $parsedkey, $this->alt => $bytevalue,
+                                         $this->timecreatedfield => time()));
+                } else {
+                    // Image (svg or base64 format).
+                    $DB->insert_record($this->cachetable, array($this->keyfield => $parsedkey, $this->jsonfield => $bytevalue,
+                                         $this->timecreatedfield => time()));
+                }
+            } catch (dml_exception $ex) {
+                // Concurrent write access to the same - unexisting - md5
+                // are possible in some scenarios (like a quiz)
+                // if a write_exception occurs, formula has been created
+                // is not a real exception.
+                if ($ex instanceof dml_write_exception) {
+                    return;
+                }
+                throw $ex;
+            }
+
+        } else { // Exists the row in db.
+
+            $jsonfield = $this->jsonfield;
+            $record = $DB->get_record($this->cachetable, array($this->keyfield => $parsedkey));
+
+            if (strpos($key, '.txt') === false) {
+                $record->$jsonfield = $bytevalue;
+                $DB->update_record($this->cachetable, $record);
+            } else {  // ... .txt otherwise.
+                $record->alt = $bytevalue;
+                $DB->update_record($this->cachetable, $record);
+            }
+        }
+    }
+}
diff --git a/filter/wiris/classes/moodlefilecache.php b/filter/wiris/classes/moodlefilecache.php
new file mode 100644
index 0000000..f2bc69c
--- /dev/null
+++ b/filter/wiris/classes/moodlefilecache.php
@@ -0,0 +1,91 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This class implements WIRIS StorageAndCache interface
+ * to store WIRIS data on MUC and Moodle database.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+class moodlefilecache {
+
+    private $cache;
+    public $area;
+    public $module;
+
+    /**
+     * Constructores for WIRIS file cache.
+     * @param String $area   cache area.
+     * @param String $module cache definition.
+     */
+    public function __construct($area, $module) {
+        $this->area = $area;
+        $this->module = $module;
+        $this->cache = cache::make($area, $module);
+    }
+
+    /**
+     * Delete the given key from the cache
+     * @param key The key to delete.
+     * @throw Error On unexpected exception.
+     */
+    public function delete($key) {
+    }
+
+    /**
+     * Deletes all the data in the cache.
+     * @throw moodle_exception failing purgue the cache.
+     */
+    // @codingStandardsIgnoreStart
+    public function deleteAll() {
+    // @codingStandardsIgnoreEnd
+        if (!$this->cache->purgue()) {
+            throw new moodle_exception(get_string('errordeletingcache', 'filter_wiris', $this->area), $this->module);
+        }
+
+    }
+
+    /**
+     * Retrieves the value for the given key for the cache.
+     * @param key The key for for the data being requested.
+     * @return Bytes The data retrieved from the cache. Returns null on cache miss or error.
+     */
+    public function get($key) {
+        if ($data = $this->cache->get($key)) {
+            return $data;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Stores a (key, value) pair to the cache.
+     * @param key The key for the data being requested.
+     * @param value The data to set against the key.
+     * @throw moodle_exception when the data can't be written to the cache.
+     */
+    public function set($key, $value) {
+        if (!$this->cache->set($key, $value)) {
+            throw new moodle_exception(get_string('errorsavingcache', 'filter_wiris', $this->area), $this->module);
+        }
+    }
+}
diff --git a/filter/wiris/classes/paramsprovider.php b/filter/wiris/classes/paramsprovider.php
new file mode 100644
index 0000000..171294e
--- /dev/null
+++ b/filter/wiris/classes/paramsprovider.php
@@ -0,0 +1,92 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This class implements com_wiris_plugin_api_ParamsProvider interface
+ * o use optional_param and required_param methods instead of
+ * access directly $_GET nad $_POST variables.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+global $CFG;
+
+require_once($CFG->dirroot . '/lib/moodlelib.php');
+require_once($CFG->dirroot . '/filter/wiris/integration/lib/com/wiris/plugin/api/ParamsProvider.interface.php');
+
+class filter_wiris_paramsprovider implements com_wiris_plugin_api_ParamsProvider {
+
+    private $parameters = array();
+    private $serviceparamlist = array('mml', 'lang', 'service', 'latex');
+    private $wrap;
+
+    public function __construct() {
+        $this->wrap = com_wiris_system_CallWrapper::getInstance();
+    }
+
+    public function getrequiredparameter($paramname) {
+        $this->wrap->stop();
+        $param = required_param($paramname, PARAM_RAW);
+        $this->wrap->start();
+        return $param;
+    }
+
+    public function getparameter($paramname, $dflt) {
+        $this->wrap->stop();
+        $param = optional_param($paramname, $dflt, PARAM_RAW);
+        $this->wrap->start();
+        return $param;
+    }
+
+    public function getparameters() {
+        return $this->parameters;
+    }
+
+    public function getserviceparameters() {
+        $this->wrap->stop();
+        $serviceparams = array();
+        foreach ($this->serviceparamlist as $key) {
+            if ($serviceparam = optional_param($key, false, PARAM_RAW)) {
+                $serviceparams[$key] = $serviceparam;
+            }
+        }
+        $this->wrap->start();
+        return $serviceparams;
+
+    }
+
+    public function getrenderparameters($configuration) {
+        $this->wrap->stop();
+        $renderparams = array();
+        // Can't change EDITOR_PARAMETER_LIST variable name so at this point condingStandars should be disabled.
+        // @codingStandardsIgnoreStart
+        $renderparameterlist = explode(",", $configuration->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_LIST, com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_DEFAULT_LIST));
+        // @codingStandardsIgnoreEnd
+        $i = null;
+        foreach ($renderparameterlist as $key) {
+            if ($renderparam = optional_param($key, false, PARAM_RAW)) {
+                $renderparams[$key] = $renderparam;
+            }
+        }
+        $this->wrap->start();
+        return $renderparams;
+    }
+}
diff --git a/filter/wiris/classes/pluginwrapper.php b/filter/wiris/classes/pluginwrapper.php
new file mode 100644
index 0000000..9a9a05b
--- /dev/null
+++ b/filter/wiris/classes/pluginwrapper.php
@@ -0,0 +1,205 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This class loads the environment that WIRIS filter needs to work.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+// This classes are shared between WIRIS Quizzes and WIRIS Plugins
+// Avoid loading twice.
+if (!class_exists('moodlefilecache')) {
+    require_once($CFG->dirroot . '/filter/wiris/classes/moodlefilecache.php');
+}
+
+if (!class_exists('moodledbjsoncache')) {
+    require_once($CFG->dirroot . '/filter/wiris/classes/moodledbjsoncache.php');
+}
+
+if (!class_exists('moodledbcache')) {
+    require_once($CFG->dirroot . '/filter/wiris/classes/moodledbcache.php');
+}
+
+class filter_wiris_pluginwrapper {
+    private $isinit = false;
+    private $installed = false;
+    private $moodleconfig;
+    private $instance;
+    private static $pluginwrapperconfig;
+
+    public static function set_configuration($config) {
+        self::$pluginwrapperconfig = $config;
+    }
+
+    public function __construct() {
+        $this->init();
+    }
+
+    public function begin() {
+        com_wiris_system_CallWrapper::getInstance()->start();
+    }
+
+    public function end() {
+        com_wiris_system_CallWrapper::getInstance()->stop();
+    }
+
+    public function is_installed() {
+        $editorplugin = self::get_wiris_plugin();
+        return !empty($editorplugin);
+    }
+
+    private function init() {
+        if (!$this->isinit) {
+
+            $this->isinit = true;
+
+            global $CFG;
+            // Init haxe environment.
+            if (!class_exists('com_wiris_system_CallWrapper')) {
+                require_once($CFG->dirroot . '/filter/wiris/integration/lib/com/wiris/system/CallWrapper.class.php');
+            }
+            com_wiris_system_CallWrapper::getInstance()->init($CFG->dirroot . '/filter/wiris/integration');
+
+            // Start haxe environment.
+            $this->begin();
+            // Create PluginBuilder with Moodle specific configuration.
+            $this->moodleConfig = new filter_wiris_configurationupdater();
+            $this->instance = com_wiris_plugin_api_PluginBuilder::getInstance();
+            $this->instance->addConfigurationUpdater($this->moodleConfig);
+            $this->instance->addConfigurationUpdater(new com_wiris_plugin_web_PhpConfigurationUpdater());
+            $this->instance->addConfigurationUpdater(new filter_wiris_pluginwrapperconfigurationupdater(self::$pluginwrapperconfig));
+
+            // Class to manage file cache.
+            if ($this->get_instance()->getConfiguration()->getProperty('wirispluginperformance', 'false') == 'false' ||
+                $this->get_instance()->getConfiguration()->getProperty('wirisimageformat', 'png') == 'png') {
+                $cachefile = new moodlefilecache('filter_wiris', 'images');
+            } else {
+                $cachefile = new moodledbjsoncache('filter_wiris_formulas', 'md5', 'jsoncontent');
+            }
+            $this->instance->setStorageAndCacheCacheObject($cachefile);
+            // Class to manage formulas (i.e plain text) cache.
+            $cachedb = new moodledbcache('filter_wiris_formulas', 'md5', 'content');
+            $this->instance->setStorageAndCacheCacheFormulaObject($cachedb);
+            // Stop haxe environment.
+            $this->end();
+        }
+    }
+
+    public function get_instance() {
+        $this->init();
+        return $this->instance;
+    }
+
+    public function was_cas_enabled() {
+        // Force configuration load.
+        $this->get_instance()->getConfiguration()->getProperty('wiriscasenabled', null);
+        return $this->moodleConfig->wascasenabled;
+    }
+
+    public function was_editor_enabled() {
+        // Force configuration load.
+        $this->get_instance()->getConfiguration()->getProperty('wiriseditorenabled', null);
+        return $this->moodleConfig->waseditorenabled;
+    }
+
+    public function was_chem_editor_enabled() {
+        // Force configuration load.
+        $this->get_instance()->getConfiguration()->getProperty('wirischemeditorenabled', null);
+        return $this->moodleConfig->waschemeditorenabled;
+    }
+
+    /**
+     * Returns WIRIS plugin data from the plugin installed in the default Moodle
+     * HTML editor (or the first available), or false if none found.
+     *
+     * Needs the Moodle to be started with $CFG variable defined.
+     *
+     * @return object
+     *   An object with the following properties:
+     *     - url: base url of the WIRIS plugin.
+     *     - path: base path of the WIRIS plugin.
+     *     - version: version of the WIRIS plugin.
+     * */
+    public static function get_wiris_plugin() {
+        global $CFG;
+        // Loop over atto, tinymce in the order defined by the configuration.
+        $editors = explode(',', $CFG->texteditors);
+        if (!in_array('atto', $editors)) {
+            $editors[] = 'atto';
+        }
+        if (!in_array('tinymce', $editors)) {
+            $editors[] = 'tinymce';
+        }
+        foreach ($editors as $editor) {
+            if ($editor == 'atto') {
+                $relativepath = '/lib/editor/atto/plugins/wiris';
+                if (file_exists($CFG->dirroot . $relativepath . '/version.php')) {
+                    $plugin = new stdClass();
+                    $plugin->url = $CFG->wwwroot . $relativepath;
+                    $plugin->path = $CFG->dirroot . $relativepath;
+                    $plugin->version = get_config('atto_atto_wiris', 'version');
+                    return $plugin;
+                }
+            } else if ($editor == 'tinymce') {
+                require_once($CFG->dirroot . '/lib/editor/tinymce/lib.php');
+                $tiny = new tinymce_texteditor();
+                $tinyversion = $tiny->version;
+                if ($CFG->version >= 2012120300) { // Location for Moodle 2.4 onwards .
+                    $relativepath = '/lib/editor/tinymce/plugins/tiny_mce_wiris/tinymce';
+                } else { // Location for Moodle < 2.4 .
+                    $relativepath = '/lib/editor/tinymce/tiny_mce/' . $tinyversion . '/plugins/tiny_mce_wiris';
+                }
+                if (!file_exists($CFG->dirroot . $relativepath . '/core')) {
+                    // WIRIS plugin  >= 3.50 not installed.
+                    continue;
+                }
+                $plugin = new stdClass();
+                $plugin->url = $CFG->wwwroot . $relativepath;
+                $plugin->path = $CFG->dirroot . $relativepath;
+                $plugin->version = get_config('tinymce_tiny_mce_wiris', 'version');
+                return $plugin;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Since version 2016030200 configuration.ini file is
+     * has been moved from editor plugin folder to filte folder.
+     * This method detects if a configuration.ini file is on the old location.
+     * @return [type] [description]
+     */
+    public static function get_old_configuration() {
+        global $CFG;
+        if (file_exists($CFG->dirroot . '/filter/wiris/configuration.ini')) {
+            return false;
+        }
+        if ($plugin = self::get_wiris_plugin()) {
+            if (file_exists($plugin->path . '/configuration.ini')) {
+                return $plugin->path . '/configuration.ini';
+            } else {
+                return false;
+            }
+        }
+        return false;
+    }
+}
diff --git a/filter/wiris/classes/pluginwrapperconfigurationupdater.php b/filter/wiris/classes/pluginwrapperconfigurationupdater.php
new file mode 100644
index 0000000..47a5587
--- /dev/null
+++ b/filter/wiris/classes/pluginwrapperconfigurationupdater.php
@@ -0,0 +1,56 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+//
+
+/**
+ * This class implements WIRIS com_wiris_plugin_configuration_ConfigurationUpdater interface
+ * to use a custom Moodle configuration.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->dirroot . '/filter/wiris/integration/lib/com/wiris/plugin/configuration/ConfigurationUpdater.interface.php');
+
+class filter_wiris_pluginwrapperconfigurationupdater implements com_wiris_plugin_configuration_ConfigurationUpdater{
+
+    private $customconfig;
+
+    public function __construct($config) {
+        $this->customconfig = $config;
+    }
+
+    // @codingStandardsIgnoreStart
+    // Can't change implemented interface method name.
+    public function updateConfiguration(&$configuration) {
+        if (isset($this->customconfig)) {
+            foreach ($this->customconfig as $key => $value) {
+                $configuration[$key] = $value;
+            }
+        }
+
+        if ($configuration['wirisimageformat'] == 'png') {
+            $configuration['wirispluginperformance'] = 'false';
+        }
+
+    }
+    public function init($obj) {
+    }
+}
diff --git a/filter/wiris/configuration.ini.dist b/filter/wiris/configuration.ini.dist
new file mode 100644
index 0000000..73dfb4e
--- /dev/null
+++ b/filter/wiris/configuration.ini.dist
@@ -0,0 +1,202 @@
+#################################################################################################
+# This is a sample configuration file                                                           #
+# You can uncomment any line and rename this file to configuration.ini                          #
+# For further information go to http://www.wiris.com/plugins/docs/resources/configuration-table #
+#################################################################################################
+
+#########################
+# Connection properties #
+#########################
+
+## Specifies formula image server host.
+
+#wirisimageservicehost = www.wiris.net
+
+## Specifies formula image server path.
+
+#wirisimageservicepath = /demo/editor/render
+
+## Specifies formula image server port. If left blank, it is computed automatically.
+
+#wirisimageserviceport = 80
+
+## Specifies formula image server protocol. If left blank, it is computed automatically.
+
+#wirisimageserviceprotocol = http
+
+#######################
+# Proxy configuration #
+#######################
+
+## Specifies if your server is using a proxy connection or not. false by default.
+
+#wirisproxy = false
+
+## If wirisproxy is true, this value specifies the proxy host..
+
+#wirisproxy_host =
+
+## If wirisproxy is true, this value specifies the proxy port.
+
+#wirisproxy_port =
+
+############################################
+# Basic authentication proxy configuration #
+############################################
+
+#wirisproxy_user =
+#wirisproxy_password =
+
+#####################
+# Folder properties #
+#####################
+
+## Place to store the cached images.
+
+#wiriscachedirectory = /var/cache
+
+## Place to store the formulas.
+
+#wirisformuladirectory = /var/formulas
+
+######################
+# Class overridables #
+######################
+
+## Name of the class that manages the storage of formulas.
+
+#wirisstorageclass = com.wiris.plugin.storage.FileStorageAndCache
+
+## Name of the class that updates the loaded configuration.
+
+#wirisconfigurationclass =
+
+
+####################
+# Editor behaviour #
+####################
+
+## Specifies if WIRIS Editor is enabled.
+
+#wiriseditorenabled = true
+
+## Specifies the image attribute to store mathml content.
+
+#wiriseditormathmlattribute = data-mathml
+
+## Specifies how formulas are stored in the database. MathML by default. http://www.wiris.com/en/plugins/docs/full-mathml-mode
+
+#wiriseditorsavemode = xml
+
+## Specifies if in base64 save mode, images should be stored as a base64 string  or as an image.
+
+#wiriseditoreditmode = default
+
+## Specifies if LaTeX content generated with WIRIS Editor should be shown as an image outside editing areas.
+
+#wiriseditorparselatex = true
+
+## Specifies if mathml should be parsed on non-mathml modes (image or base64).
+
+#wiriseditorparsexml = false
+
+## Specifies WIRIS Editor size attributes.
+
+#wiriseditorwindowattributes = width=570, height=450, scroll=no, resizable=yes
+
+## On image mode specifies if the vertical align of the image should be calculated instead of add extra space to vertically center the image.
+
+#wiriseditorsetsize = false
+
+## Specifies if WIRIS Editor should be opened on a modal window or in a pop-up window. true by default.
+
+#wiriseditormodalwindow = true
+
+## Specifies if the modal window should be opened in full-screen mode. false by default.
+
+#wiriseditormodalwindowfullscreen = false
+
+## Specifies if chemistry editor is enabled. true by default.
+
+#wirischemeditorenabled = true
+
+## Specifies image format (svg or png). svg by default.
+
+#wirisimageformat = svg
+
+###############################################################################################
+# Editor inherit parameters                                                                   #
+# The format is a JSON containing WIRIS Editor parameters defined on the following page:      #
+# http://www.wiris.com/editor/docs/reference/parameters                                       #
+# Editor parameter key should be the JSON key and the corresponnding value is the JSON value. #
+###############################################################################################
+
+#wiriseditorparameters = {}
+
+#################
+# Accessibility #
+#################
+
+## Specifies if the accesibility should be included in generated images as "alt" attribute. true by default.
+
+#wirisaccessibilityenabled = true
+
+#########################
+# Cross-Domain policies #
+#########################
+
+## Enables CORS domains policies. false by default.
+wiriscorsenabled = false
+
+###################
+# External plugin #
+###################
+
+## Specifies if the plugin is an external plugin. false by default.
+
+#wirisexternalplugin = false
+
+########################
+# Performance settings #
+########################
+
+## Specifies if the response should be a JSON instead of a binary which allows requests be cached. true by default.
+
+#wirispluginperformance = true
+
+##############################################################################################################################
+# Clean cache  service parameters. For further information go to http://www.wiris.com/en/plugins/docs/resources/clean-backup #
+##############################################################################################################################
+
+## Specifies if the delete cache gui is enabled. false by default.
+
+# wiriscleancachegui = false
+
+## Token needed to delete cache.
+
+# wiriscleancachetoken = token
+
+##############################################################################################
+# Deprecated. Editor parameters should be parsed as a Json on wiriseditorparameters variale. #
+##############################################################################################
+
+#wiristransparency = true
+#wirisfontfamily = Arial
+#wirisimagecolor = #000000
+#wirisimagebackgroundcolor = #ffffff
+#wirisimagefontsize = 16px
+#wirisimagedpi = 96
+#wiriseditortoolbar = quizzes
+#wirisrtllanguages = ar
+#wirisltrlanguages = ar_ma
+#wirisarabicindiclanguages = ar_eg, ar_sd, ar_sa
+#wiriseasternarabicindiclanguages = fa, ps, ur
+#wiriseuropeanlanguages =
+
+###############################################################################################
+# Debug mode to show extra information on test page. Don't enable in production environments. #
+###############################################################################################
+
+#wirisdebug = false
+
+## End of file
diff --git a/filter/wiris/db/caches.php b/filter/wiris/db/caches.php
new file mode 100644
index 0000000..41f3734
--- /dev/null
+++ b/filter/wiris/db/caches.php
@@ -0,0 +1,32 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Cache definition for WIRIS plugin.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+$definitions = array(
+    'images' => array(
+        'mode' => cache_store::MODE_APPLICATION
+    )
+);
diff --git a/filter/wiris/db/install.xml b/filter/wiris/db/install.xml
new file mode 100644
index 0000000..24f05de
--- /dev/null
+++ b/filter/wiris/db/install.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<XMLDB PATH="filter/wiris/db" VERSION="20170413" COMMENT="XMLDB file for Moodle filter/wiris"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:noNamespaceSchemaLocation="../../../lib/xmldb/xmldb.xsd"
+>
+  <TABLES>
+    <TABLE NAME="filter_wiris_formulas" COMMENT="Default comment for filter_wiris, please edit me">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true" NEXT="md5"/>
+        <FIELD NAME="md5" TYPE="char" LENGTH="128" NOTNULL="true" SEQUENCE="false" PREVIOUS="id" NEXT="content"/>
+        <FIELD NAME="content" TYPE="text" NOTNULL="true" SEQUENCE="false" PREVIOUS="md5" NEXT="jsoncontent"/>
+        <FIELD NAME="jsoncontent" TYPE="text" NOTNULL="false" SEQUENCE="false" COMMENT="Field to keep json requests." PREVIOUS="content" NEXT="alt"/>
+        <FIELD NAME="alt" TYPE="text" NOTNULL="false" SEQUENCE="false" PREVIOUS="jsoncontent" NEXT="timecreated"/>
+        <FIELD NAME="timecreated" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="The time when the formula was added" PREVIOUS="alt"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id" NEXT="md5"/>
+        <KEY NAME="md5" TYPE="unique" FIELDS="md5" PREVIOUS="primary"/>
+      </KEYS>
+    </TABLE>
+  </TABLES>
+</XMLDB>
\ No newline at end of file
diff --git a/filter/wiris/db/upgrade.php b/filter/wiris/db/upgrade.php
new file mode 100644
index 0000000..b8e04f2
--- /dev/null
+++ b/filter/wiris/db/upgrade.php
@@ -0,0 +1,114 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Database upgrade for WIRIS plugin.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+function xmldb_filter_wiris_upgrade($oldversion) {
+    global $DB, $CFG;
+
+    $dbman = $DB->get_manager();
+
+    if ($oldversion <= 2016101700) {
+         // Define table filter_wiris to be created.
+        $table = new xmldb_table('filter_wiris_formulas');
+
+        // Adding fields to table filter_wiris.
+        $table->add_field('id', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
+        $table->add_field('md5', XMLDB_TYPE_CHAR, '255', null, XMLDB_NOTNULL, null, null, 'id');
+        $table->add_field('content', XMLDB_TYPE_TEXT, null, null, XMLDB_NOTNULL, null, null, 'md5');
+
+        // Adding keys to table filter_wiris.
+        $table->add_key('primary', XMLDB_KEY_PRIMARY, array('id'));
+        $table->add_key('md5', XMLDB_KEY_UNIQUE, array('md5'));
+
+        // Conditionally launch create table for filter_wiris.
+        if (!$dbman->table_exists($table)) {
+            $dbman->create_table($table);
+        }
+
+        // Wiris savepoint reached.
+        upgrade_plugin_savepoint(true, 2016101701, 'filter', 'wiris');
+
+    }
+
+    if ($oldversion < 2017030100) {
+
+        // Define field jsoncontent to be added to filter_wiris_formulas.
+        $table = new xmldb_table('filter_wiris_formulas');
+        $field = new xmldb_field('jsoncontent', XMLDB_TYPE_TEXT, null, null, null, null, null, 'content');
+
+        // Conditionally launch add field jsoncontent.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        $field = new xmldb_field('alt', XMLDB_TYPE_TEXT, null, null, null, null, null, 'jsoncontent');
+
+        // Conditionally launch add field alt.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        // Wiris savepoint reached.
+        upgrade_plugin_savepoint(true, 2017030100, 'filter', 'wiris');
+    }
+
+    if ($oldversion < 2017050800) {
+
+        // Define field timecreated to be added to filter_wiris_formulas.
+        $table = new xmldb_table('filter_wiris_formulas');
+        $field = new xmldb_field('timecreated', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, '0', 'alt');
+
+        // Conditionally launch add field timecreated.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        // Keys with utf8mb4 collation have a maxium of 191 characters
+        // This collation is recommended in Moodle 3.3 and upcoming versions: https://tracker.moodle.org/browse/MDL-54901.
+
+        // Define key md5 (unique) to be dropped form filter_wiris_formulas.
+        $table = new xmldb_table('filter_wiris_formulas');
+        $index = new xmldb_index('md5', XMLDB_INDEX_UNIQUE, array('md5'));
+
+        $dbman->drop_index($table, $index);
+
+        $table = new xmldb_table('filter_wiris_formulas');
+        $field = new xmldb_field('md5', XMLDB_TYPE_CHAR, '128', null, XMLDB_NOTNULL, null, null, 'id');
+
+        // Launch change of precision for field md5.
+        $dbman->change_field_precision($table, $field);
+
+        $key = new xmldb_key('md5', XMLDB_KEY_UNIQUE, array('md5'));
+
+        // Launch add key md5.
+        $dbman->add_key($table, $key);
+
+        // Wiris savepoint reached.
+        upgrade_plugin_savepoint(true, 2017050800, 'filter', 'wiris');
+    }
+
+    return true;
+}
diff --git a/filter/wiris/filter.php b/filter/wiris/filter.php
new file mode 100644
index 0000000..d0ab6fa
--- /dev/null
+++ b/filter/wiris/filter.php
@@ -0,0 +1,126 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+//
+
+/**
+ * It is a filter that allows to visualize applets that use WIRIS CAS and
+ * images (of formulas) generated through the WIRIS Formula Image Service.
+ *
+ * Replaces all substrings  'applet ... /applet' and '<applet ... </applet>'
+ * generated  with WIRIS CAS by the corresponding WIRIS
+ * applet image.
+ * Replaces all substrings 'math ... /math' '<math ... </math>'
+ * generated with WIRIS Editor by the corresponding image.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+/* ---------------------------------------------------------------------------- */
+// General description:                                                         //
+// Applet: An applet is a Java program designed to be executed in a web page    //
+// through a navigator who supports Java. All the last versions of Netscape or  //
+// Microsoft Internet Explorer include it by defect.                            //
+// WIRIS CAS (Computer Algebra System): mathematical calculation Tool that      //
+// works through an applet.                                                     //
+// Web Service: A web service is a component of software that can describe      //
+// itself and provides certain functionality to other applications, through an  //
+// Internet connection.                                                         //
+// WIRIS EDITOR: Formulas publisher who allows to generate images of these      //
+// formulas through a Web Service.                                              //
+// Regular expression: A regular expression is a model or a form to compare     //
+// with a chain of characters.                                                  //
+/*                                                                              */
+// Wiris Filter Description:                                                    //
+// It is a filter that allows to visualize applets that use WIRIS CAS and       //
+// images (of formulas) generated through the WIRIS Formula Image Service.      //
+/*                                                                              */
+// Replaces all substrings ''applet ... /applet' by the corresponding WIRIS  //
+// applet code: '<applet ... </applet>'                                         //
+// Replaces all substrings 'math ... /math' by the corresponding MathML      //
+// code: '<math ... </math>'                                                    //
+/* ---------------------------------------------------------------------------- */
+
+
+
+class filter_wiris extends moodle_text_filter {
+
+    public function filter($text, array $options = array()) {
+
+        global $CFG, $DB;
+
+        $n0 = stripos($text, 'math');
+        $n1 = stripos($text, '<math');
+        $n2 = stripos($text, 'applet');
+
+        if ($n0 === false && $n1 === false && $n2 === false) {
+            // Nothing to do.
+            return $text;
+        }
+
+        require_once("$CFG->dirroot/filter/wiris/lib.php");
+
+        // Automatic class loading not avaliable for Moodle 2.4 and 2.5.
+        wrs_loadclasses();
+
+        // MathJax and MathML
+        // Not filter if MathJax filter order < WIRIS filter order.
+        if ($n1 !== false && $wirisfilter = $DB->get_record('filter_active', array('filter' => 'wiris'))) {
+            if ($mathjaxfilter = $DB->get_record('filter_active', array('filter' => 'mathjaxloader', 'active' => '1'))) {
+                if ($mathjaxfilter->sortorder < $wirisfilter->sortorder) {
+                    return $text;
+                }
+            }
+        }
+
+        $wirispluginwrapper = new filter_wiris_pluginwrapper();
+
+        $wirispluginwrapper->begin();
+        $textservice = $wirispluginwrapper->get_instance()->newTextService();
+
+        $query = '';
+
+        global $COURSE;
+
+        if (isset($COURSE->id)) {
+            $query .= '?course=' . $COURSE->id;
+        }
+        if (isset($COURSE->category)) {
+            $query .= empty($query) ? '?' : '/';
+            $query .= 'category=' . $COURSE->category;
+        }
+
+        $prop['refererquery'] = $query;
+        $prop['lang'] = current_language();
+        $prop['savemode'] = 'safeXml'; // ...safeXml filtering.
+        $text = $textservice->filter($text, $prop);
+        $prop['savemode'] = 'xml'; // ...xml filtering.
+        $text = $textservice->filter($text, $prop);
+        $wirispluginwrapper->end();
+
+        // If a CAS session has been filtered.
+        // We need to create a JNLP link for browsers non supporting JAVA.
+        if ($n2) {
+            $text = wrs_filterapplettojnlp($text);
+        }
+
+        return $text;
+    }
+}
diff --git a/filter/wiris/filtersettings.php b/filter/wiris/filtersettings.php
new file mode 100644
index 0000000..4378cd3
--- /dev/null
+++ b/filter/wiris/filtersettings.php
@@ -0,0 +1,117 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * WIRIS Filter settings.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+if ($ADMIN->fulltree) {
+    global $CFG;
+    global $wirisconfigurationclass;
+
+    require_once("$CFG->dirroot/filter/wiris/lib.php");
+    // Automatic class loading not avaliable for Moodle 2.4 and 2.5.
+    wrs_loadclasses();
+    $wirisplugin = new filter_wiris_pluginwrapper();
+
+    $editorplugininstalled = filter_wiris_pluginwrapper::get_wiris_plugin();
+    if (!empty($editorplugininstalled)) {
+        // Editor checkbox.
+        $output = '';
+        $wirisplugin->begin();
+        $waseditorenabled = $wirisplugin->was_editor_enabled();
+        $waschemeditorenabled = $wirisplugin->was_chem_editor_enabled();
+        $conf = $wirisplugin->get_instance()->getConfiguration();
+        $wirisplugin->end();
+
+        // Backwards compatibility: some old installations could have the configuration
+        // file into the editor plugin inestad of filter. Show a notification to advise
+        // users to copy the file from the older location to the new one.
+        if ($oldconfile = filter_wiris_pluginwrapper::get_old_configuration()) {
+            $warningoutput = get_string('oldconfiguration', 'filter_wiris', $oldconfile);
+
+            \core\notification::warning($warningoutput);
+            $settings->add(new admin_setting_heading('filter_wiris_old_configuration', '', $warningoutput));
+        }
+
+        if ($waseditorenabled) {
+            $settings->add(new admin_setting_configcheckbox('filter_wiris_editor_enable',
+                                                            get_string('wirismatheditor', 'filter_wiris'), '', '1'));
+        }
+
+        if ($waschemeditorenabled) {
+            $settings->add(new admin_setting_configcheckbox('filter_wiris_chem_editor_enable',
+                                                            get_string('wirischemeditor', 'filter_wiris'), '', '0'));
+        }
+
+        // Allow WIRIS Editor plugin be enabled despite of the filter is disabled on a course.
+        $settings->add(new admin_setting_configcheckbox('filter_wiris/allow_editorplugin_active_course',
+                                                            get_string('alloweditorpluginactive', 'filter_wiris'),
+                                                            get_string('alloweditorpluginactive_help', 'filter_wiris'), '0'));
+
+    } else {
+        if (!get_config('filter_wiris', 'filter_standalone')) {
+
+            // Moodle notification API since Moodel 3.1.
+            if ($CFG->version >= 2016052300) {
+                // Due to Moodle doesn't support circular dependencies between plugins, if any editor plugin is installed
+                // a warning message is shown as a notification.
+                $message = '';
+                $tinyurl = 'https://moodle.org/plugins/tinymce_tiny_mce_wiris';
+                $attourl = 'https://moodle.org/plugins/atto_wiris';
+                $linkattributes = array('target' => '_blank');
+                $message .= html_writer::link($attourl, get_string('wirispluginforatto', 'filter_wiris'), $attributes);
+                $message .= get_string('or', 'filter_wiris');
+                $message .= html_writer::link($tinyurl, get_string('wirispluginfortinymce', 'filter_wiris'), $attributes);
+                $message .= get_string('arenotinstalled', 'filter_wiris');
+                $message .= get_string('furtherinformation', 'filter_wiris');
+
+                $imageurl = "https://www.wiris.com/system/files/attachments/1689/WIRIS_manual_icon_17_17.png";
+                $image = html_writer::empty_tag('img', array('src' => $imageurl, 'style' => 'vertical-align:-3px;'));
+                $troubleshootingurl = 'http://www.wiris.com/plugins/docs/moodle/troubleshooting';
+                $imagelink = html_writer::link($troubleshootingurl, $image, $linkattributes);
+
+                $message .= $imagelink;
+
+                // Moodle notification API: https://docs.moodle.org/dev/Notifications.
+                \core\notification::warning($message);
+            }
+
+        }
+        $settings->add(new admin_setting_configcheckbox('filter_wiris/filter_standalone',
+                                                        get_string('filter_standalone',
+                                                        'filter_wiris'),
+                                                        get_string('filter_standalonedesc',
+                                                        'filter_wiris'), false, true, false));
+    }
+
+    $wirisquizzes = dirname(__FILE__) . '/../../question/type/wq/';
+    $quizzesinstalled = file_exists($wirisquizzes);
+
+    if ($quizzesinstalled) {
+        $url = $CFG->wwwroot . '/admin/settings.php?section=qtypesettingwq';
+        $url = '<a href="' . $url . '">WIRIS quizzes settings</a>';
+        $settings->add(new admin_setting_heading('filter_wirisquizzesheading', $url, ''));
+    }
+
+}
diff --git a/filter/wiris/img/help.gif b/filter/wiris/img/help.gif
new file mode 100644
index 0000000000000000000000000000000000000000..af9e5bc7e7ab07b15a3bcc323639ecdd3f187f99
GIT binary patch
literal 192
zcmZ?wbhEHb6l4%&_$<Ki|NqSY|I_}Tnfd<=kTm{3)A-C8<1;{VCd15`#xv85(?EzJ
z&6vU1m;neBf3mPLFbFW{fH)vC99VM|RQggZ?U)w|9sjJ6oqg`JGSA^hc4vM~=oeLd
z7$LyJeq{X<A%;23;-A%2EaW)nYecM-OF6*)$a>l(1?%Fsk{%BWP75nMO)!aJ5B+md
mOh~>`$6LcmmrvWH+KGq1T`NI7o{d$<le17QbB2;4gEau3GDHIa

literal 0
HcmV?d00001

diff --git a/filter/wiris/info.php b/filter/wiris/info.php
new file mode 100644
index 0000000..c6f0715
--- /dev/null
+++ b/filter/wiris/info.php
@@ -0,0 +1,332 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * WIRIS filter test page.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+require_once('../../config.php');
+require_once($CFG->dirroot . '/lib/editor/tinymce/lib.php');
+require_once($CFG->dirroot . '/filter/wiris/classes/pluginwrapper.php');
+
+// BEGIN HELPERS FUNCTIONS.
+function wrs_assert($condition, $reporttext, $solutionlink) {
+    if ($condition) {
+        return $reporttext;
+    } else {
+        $result = html_writer::tag('span', $reporttext);
+        $imageurl = "https://www.wiris.com/system/files/attachments/1689/WIRIS_manual_icon_17_17.png";
+        $image = html_writer::empty_tag('img', array('src' => 'img/help.gif', 'class' => 'wrs_plugin wrs_filter'));
+        $result .= html_writer::link($solutionlink, $image, array('target' => '_blank'));
+        return $result;
+    }
+}
+
+function wrs_getstatus($condition) {
+    $statustext = '';
+    if ($condition) {
+        $text = get_string('ok', 'filter_wiris');
+        $statustext .= html_writer::tag('span', $text, array('class' => 'wrs_ok wrs_plugin wrs_filter'));
+        return $statustext;
+    } else {
+        $text = get_string('error', 'filter_wiris');
+        $statustext .= html_writer::tag('span', $text, array('class' => 'wrs_error wrs_plugin wrs_filter'));
+        return $statustext;
+    }
+}
+
+function wrs_createtablerow($testname, $reporttext, $solutionlink, $condition) {
+    $output = html_writer::tag('td', $testname, array('class' => 'wrs_plugin wrs_filter'));
+    $output .= html_writer::tag('td', wrs_assert($condition, $reporttext, $solutionlink), array('class' => 'wrs_plugin wrs_filter'));
+    $output .= html_writer::tag('td',  wrs_getstatus($condition), array('class' => 'wrs_plugin wrs_filter'));
+    return $output;
+}
+
+function get_current_editor_data() {
+    global $CFG;
+    $data = array();
+
+    $tinyeditor = new tinymce_texteditor();
+
+    if ($CFG->version < 2012120300) {
+        $data['plugin_path'] = '../../lib/editor/tinymce/tiny_mce/' . $tinyeditor->version . '/plugins/tiny_mce_wiris';
+        $data['plugin_name'] = get_string('tinymce', 'filter_wiris');
+        return $data;
+    }
+
+    if ($CFG->version >= 2012120300 && $CFG->version < 2014051200) {
+        $data['plugin_path'] = '../../lib/editor/tinymce/plugins/tiny_mce_wiris/tinymce';
+        $data['plugin_name'] = get_string('tinymce', 'filter_wiris');
+        return $data;
+    }
+
+    if ($CFG->version >= 2014051200) {
+        $editors = array_flip(explode(',', $CFG->texteditors));
+        if (count($editors) <= 0) {
+            throw new Exception(get_string('noteditorspluginsinstalled', 'filter_wiris'), 1);
+        }
+        if (count($editors) == 1) {
+            if (array_key_exists('textarea', $editors)) {
+                throw new Exception(get_string('onlytextareaeditorinstalled', 'filter_wiris'), 1);
+            }
+        }
+
+        foreach ($editors as $editor => $value) {
+            switch ($editor) {
+                case 'atto':
+                    $data['plugin_path'] = '../../lib/editor/atto/plugins/wiris';
+                    $data['plugin_name'] = get_string('atto', 'filter_wiris');
+                return $data;
+                case 'tinymce':
+                    $data['plugin_path'] = '../../lib/editor/tinymce/plugins/tiny_mce_wiris/tinymce';
+                    $data['plugin_name'] = get_string('tinymce', 'filter_wiris');
+                return $data;
+            }
+        }
+    }
+
+    return $data;
+}
+
+function check_if_wiris_button_are_in_toolbar($editor = null) {
+    if ( is_null($editor) ) {
+        throw new Exception(get_string('editornameexpected', 'filter_wiris'), 1);
+    }
+
+    switch ($editor) {
+        case 'Atto':
+            return check_if_wiris_button_are_in_atto_toolbar();
+        case 'TinyMCE':
+            return check_if_wiris_button_are_in_tinymce_toolbar();
+        default:
+            throw new Exception($editor . get_string('notsupportededitor', 'filter_wiris', 1));
+    }
+}
+
+function check_if_wiris_button_are_in_atto_toolbar() {
+    $configvalue = get_config('editor_atto', 'toolbar');
+    return (strpos($configvalue, 'wiris') !== false);
+}
+
+function check_if_wiris_button_are_in_tinymce_toolbar() {
+    $configvalue = get_config('editor_tinymce', 'disabledsubplugins');
+    return (strpos($configvalue, 'tiny_mce_wiris') === false);
+}
+
+
+// Page prologue
+$PAGE->set_context(context_system::instance());
+$PAGE->set_title(get_string('title', 'filter_wiris'));
+$PAGE->set_url('/filter/wiris/info.php', array());
+echo $OUTPUT->header();
+
+$output = '';
+$output .= html_writer::start_tag('h1');
+$output .= get_string('title', 'filter_wiris');
+$output .= html_writer::end_tag('h1');
+
+$output .= html_writer::start_tag('table', array('id' => 'wrs_filter_info_table', 'class' => 'wrs_plugin wrs_filter'));
+
+$output .= html_writer::start_tag('tr', array('class' => 'wrs_plugin wrs_filter'));
+$output .= html_writer::start_tag('th', array('class' => 'wrs_plugin wrs_filter'));
+$output .= "Test";
+$output .= html_writer::end_tag('th');
+$output .= html_writer::start_tag('th', array('class' => 'wrs_plugin wrs_filter'));
+$output .= "Report";
+$output .= html_writer::end_tag('th');
+$output .= html_writer::start_tag('th', array('class' => 'wrs_plugin wrs_filter'));
+$output .= "Status";
+$output .= html_writer::end_tag('th');
+$output .= html_writer::end_tag('tr');
+echo $output;
+
+// Get editor data for tests.
+$currenteditordata = get_current_editor_data();
+
+// Looking for correct folder test.
+$output = '';
+$output .= html_writer::start_tag('tr', array('class' => 'wrs_plugin wrs_filter'));
+$testname = get_string('lookingforcorrectfolder', 'filter_wiris');
+$reporttext = get_string('filtermustbeinstalled', 'filter_wiris');
+$solutionlink = 'http://www.wiris.com/plugins/docs/moodle/moodle-2.0';
+$actualfolder = realpath(dirname(__FILE__));
+$correctfolder = realpath($CFG->dirroot . '/filter/wiris');
+echo wrs_createtablerow($testname, $reporttext, $solutionlink, $actualfolder == $correctfolder);
+$output .= html_writer::end_tag('tr');
+echo $output;
+
+
+// Filter files tests.
+$output = '';
+$output .= html_writer::start_tag('tr', array('class' => 'wrs_plugin wrs_filter'));
+$testname = get_string('lookingforfilterfiles', 'filter_wiris');
+$reporttext = get_string('wirispluginfiltermustbeinstalled', 'filter_wiris');
+$solutionlink = 'http://www.wiris.com/plugins/moodle/download';
+$filterfiles = Array('filter.php', 'version.php');
+$exist = true;
+foreach ($filterfiles as $value) {
+    $condition = file_exists($value);
+    if (!$condition) {
+        $exist = false;
+    }
+}
+echo wrs_createtablerow($testname, $reporttext, $solutionlink, $exist);
+$output .= html_writer::end_tag('tr');
+echo $output;
+
+// Filter version existance test.
+$output .= html_writer::start_tag('tr', array('class' => 'wrs_plugin wrs_filter'));
+$output = '';
+$plugin = new stdClass();
+require($CFG->dirroot . '/filter/wiris/version.php');
+$testname = get_string('lookingforwirisfilterversion', 'filter_wiris');
+if (isset($plugin->version)) {
+    $reporttext = '<span>' . $plugin->version . '</span>';
+    $condition = true;
+} else {
+    $reporttext = get_string('impossibletofindwirisfilterversion', 'filter_wiris');
+    $condition = false;
+}
+$solutionlink = 'http://www.wiris.com/plugins/moodle/download';
+echo wrs_createtablerow($testname, $reporttext, $solutionlink, $condition);
+$output .= html_writer::end_tag('tr');
+echo $output;
+
+// Wiris filter enabled
+$output = '';
+$output .= html_writer::start_tag('tr', array('class' => 'wrs_plugin wrs_filter'));
+$testname = get_string('pluginname', 'filter_wiris');
+$solutionlink = 'http://www.wiris.com/plugins/docs/moodle/moodle-2.0';
+$filterenabled = filter_is_enabled('filter/wiris');
+if ($filterenabled) {
+    $reporttext = get_string('enabled', 'filter_wiris');
+} else {
+    $reporttext = get_string('disabled', 'filter_wiris');
+}
+echo wrs_createtablerow($testname, $reporttext, $solutionlink, $filterenabled);
+$output .= html_writer::end_tag('tr');
+
+$output .= html_writer::start_tag('tr', array('class' => 'wrs_plugin wrs_filter'));
+echo $output;
+
+$output = '';
+$testname = get_string('lookingforwirisplugin', 'filter_wiris') . $currenteditordata['plugin_name'];
+$reporttext = get_string('wirispluginfor', 'filter_wiris') . $currenteditordata['plugin_name'] . get_string('mustbeinstalled', 'filter_wiris');
+$solutionlink = 'http://www.wiris.com/plugins/moodle/download';
+$wirisplugin = $currenteditordata['plugin_path'] . '/core';
+$condition = file_exists($wirisplugin);
+if (!$condition) {
+    $wirisplugin = '../../lib/editor/tinymce/plugins/tiny_mce_wiris/core';
+    $condition = file_exists($wirisplugin);
+}
+echo wrs_createtablerow($testname, $reporttext, $solutionlink, $condition);
+$output .= html_writer::end_tag('tr');
+echo $output;
+
+// Version compatibility test.
+$output = '';
+$output .= html_writer::start_tag('tr', array('class' => 'wrs_plugin wrs_filter'));
+$wirisplugin = filter_wiris_pluginwrapper::get_wiris_plugin();
+$testname = get_string('wirispluginfilterfor', 'filter_wiris') . $currenteditordata['plugin_name'] . ' versions';
+
+if (isset($plugin->version)) {
+    $filterversion = $plugin->version;
+}
+
+// Using version.php to check release number.
+if (strtolower($currenteditordata['plugin_name']) == 'tinymce') {
+    require($currenteditordata['plugin_path'] . '/../version.php');
+} else {
+    require($currenteditordata['plugin_path'] . '/version.php');
+}
+
+if (isset($plugin->version)) {
+    $pluginversion = $plugin->version;
+} else {
+    $pluginversion = "";
+}
+
+if ($filterversion == $pluginversion) {
+    $reporttext = get_string('wirispluginfilterfor', 'filter_wiris'). $currenteditordata['plugin_name'] . get_string('havesameversion', 'filter_wiris');
+    $condition = true;
+} else {
+    $reporttext = get_string('wirispluginfilterfor', 'filter_wiris'). $currenteditordata['plugin_name'] .get_string('versionsdontmatch', 'filter_wiris');
+    $reporttext .= "<br>" . get_string('wirisfilterversion', 'filter_wiris') . $filterversion;
+    $reporttext .= "<br>" . get_string('wirispluginfor', 'filter_wiris') .  $currenteditordata['plugin_name'] . ' ' . get_string('version', 'filter_wiris'). ' = ' . $pluginversion;
+    $condition = false;
+}
+
+$solutionlink = 'http://www.wiris.com/plugins/moodle/download';
+echo wrs_createtablerow($testname, $reporttext, $solutionlink, $condition);
+$output .= html_writer::end_tag('tr');
+echo $output;
+
+// Wiris plugin enabled test.
+$output = '';
+$output .= html_writer::start_tag('tr', array('class' => 'wrs_plugin wrs_filter'));
+
+$testname = get_string('lookingforwirispluginenabled', 'filter_wiris') . $currenteditordata['plugin_name'];
+try {
+    $condition = check_if_wiris_button_are_in_toolbar($currenteditordata['plugin_name']);
+    $reporttext = ($condition) ? get_string('enabled', 'filter_wiris') : get_string('disabled', 'filter_wiris');
+} catch (Exception $e) {
+    $condition = false;
+    $reporttext = $e->getMessage();
+}
+
+echo wrs_createtablerow($testname, $reporttext, $solutionlink, $condition);
+$output .= html_writer::end_tag('tr');
+// END TEST 7.
+
+// START PAGE EPILOGUE.
+$output .= html_writer::end_tag('table');
+
+$output .= html_writer::start_tag('p');
+$output .= html_writer::start_tag('br');
+echo $output;
+$output = '';
+echo get_string('clickwirisplugincorrectlyinstalled', 'filter_wiris') . "<br/>";
+$link = 'integration/test.php';
+$input = '<input type="button" value="' . get_string('button1', 'filter_wiris');
+$input .= '" onClick="javascript:window.open(\'' . $link . '\');" /><br/>';
+echo $input;
+
+$wqversion = get_config('qtype_wq', 'version');
+if (!empty($wqversion)) {
+    echo get_string('clickwirisquizzescorrectlyinstalled', 'filter_wiris') . "<br/>";
+    $link = '../../question/type/wq/info.php';
+    $input = '<input type="button" value="' . get_string('button2', 'filter_wiris');
+    $input .= '" onClick="javascript:window.open(\'' . $link . '\');" /><br/>';
+    echo $input;
+}
+$output .= html_writer::end_tag('br');
+$output .= html_writer::end_tag('p');
+
+$output .= html_writer::start_tag('p');
+$output .= html_writer::start_tag('br');
+$output .= html_writer::start_tag('span', array('style' => 'font-size:14px; font-weight:normal;'));
+$output .= get_string('contact', 'filter_wiris');
+$output .= " (<a href=\"mailto:support@wiris.com\">support@wiris.com</a>)";
+$output .= html_writer::end_tag('span');
+$output .= html_writer::end_tag('br');
+$output .= html_writer::end_tag('p');
+
+echo $output;
diff --git a/filter/wiris/integration/cas.php b/filter/wiris/integration/cas.php
new file mode 100644
index 0000000..961a3bd
--- /dev/null
+++ b/filter/wiris/integration/cas.php
@@ -0,0 +1,16 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+$provider = $pluginBuilder->getCustomParamsProvider();
+$lang = $provider->getParameter('lang', 'en');
+$mode = $provider->getParameter('mode', null);
+
+// Adding - if necessary - CORS headers
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+$cas = $pluginBuilder->newCas();
+echo $cas->cas($mode, $lang);
diff --git a/filter/wiris/integration/cleancache.php b/filter/wiris/integration/cleancache.php
new file mode 100644
index 0000000..d903966
--- /dev/null
+++ b/filter/wiris/integration/cleancache.php
@@ -0,0 +1,14 @@
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+// Adding - if necessary - CORS headers
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+
+$pluginBuilder->addCorsHeaders($res, $origin);
+$provider = $pluginBuilder->getCustomParamsProvider();
+
+$cleanCache = $pluginBuilder->newCleanCache();
+$cleanCache->init($provider);
+echo $cleanCache->getCacheOutput();
diff --git a/filter/wiris/integration/configurationjs.php b/filter/wiris/integration/configurationjs.php
new file mode 100644
index 0000000..25d47e3
--- /dev/null
+++ b/filter/wiris/integration/configurationjs.php
@@ -0,0 +1,15 @@
+<?php
+// ${license.statement}
+
+// Loaded from configuration
+require_once ('pluginbuilder.php');
+
+// Adding - if necessary - CORS headers
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+header('Content-Type: application/json');
+
+$conf = $pluginBuilder->getConfiguration();
+echo $conf->getJavaScriptConfigurationJson();
diff --git a/filter/wiris/integration/configurationjson.php b/filter/wiris/integration/configurationjson.php
new file mode 100644
index 0000000..ec2eb4a
--- /dev/null
+++ b/filter/wiris/integration/configurationjson.php
@@ -0,0 +1,16 @@
+<?php
+
+// Loaded from configuration
+require_once ('pluginbuilder.php');
+
+$provider = $pluginBuilder->getCustomParamsProvider();
+$variablekeys = $provider->getRequiredParameter('variablekeys');
+
+// Adding - if necessary - CORS headers
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+header('Content-Type: application/json');
+
+echo $pluginBuilder->getConfiguration()->getJsonConfiguration($variablekeys);
diff --git a/filter/wiris/integration/createcasimage.php b/filter/wiris/integration/createcasimage.php
new file mode 100644
index 0000000..33af7a9
--- /dev/null
+++ b/filter/wiris/integration/createcasimage.php
@@ -0,0 +1,14 @@
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+$provider = $pluginBuilder->getCustomParamsProvider();
+$image = $provider->getRequiredParameter('image');
+// Adding - if necessary - CORS headers.
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+$cas = $pluginBuilder->newCas();
+$outp = array();
+echo $cas->createCasImage($image);
diff --git a/filter/wiris/integration/createimage.php b/filter/wiris/integration/createimage.php
new file mode 100644
index 0000000..7dca895
--- /dev/null
+++ b/filter/wiris/integration/createimage.php
@@ -0,0 +1,21 @@
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+$provider = $pluginBuilder->getCustomParamsProvider();
+
+$mml = $provider->getRequiredParameter('mml');
+$render = $pluginBuilder->newRender();
+
+$outp = null;
+
+if (get_magic_quotes_gpc() == 1) {
+    $PARAMS = array_map('stripslashes', $PARAMS);
+}
+
+// Adding - if necessary - CORS headers.
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+echo $render->createImage($mml, $provider, $outp);
diff --git a/filter/wiris/integration/editor.php b/filter/wiris/integration/editor.php
new file mode 100644
index 0000000..625cd8f
--- /dev/null
+++ b/filter/wiris/integration/editor.php
@@ -0,0 +1,15 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+$provider = $pluginBuilder->getCustomParamsProvider();
+$lang = $provider->getParameter('lang', 'en');
+
+// Adding - if necessary - CORS headers
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+$render = $pluginBuilder->newEditor();
+echo $render->editor($lang, $provider);
diff --git a/filter/wiris/integration/getmathml.php b/filter/wiris/integration/getmathml.php
new file mode 100644
index 0000000..40e281c
--- /dev/null
+++ b/filter/wiris/integration/getmathml.php
@@ -0,0 +1,20 @@
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+$provider = $pluginBuilder->getCustomParamsProvider();
+
+$digest = $provider->getParameter('digest', null);
+if ($digest == null) {
+    $digest = $provider->getParameter('md5', null);
+}
+
+$latex = $provider->getParameter('latex', null);
+
+// Adding - if necessary - CORS headers
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+$render = $pluginBuilder->newTextService();
+echo $render->getMathML($digest, $latex);
diff --git a/filter/wiris/integration/index.php b/filter/wiris/integration/index.php
new file mode 100644
index 0000000..e986d30
--- /dev/null
+++ b/filter/wiris/integration/index.php
@@ -0,0 +1,11 @@
+<?php
+
+if(version_compare(PHP_VERSION, '5.1.0', '<')) {
+    exit('Your current PHP version is: ' . PHP_VERSION . '. Haxe/PHP generates code for version 5.1.0 or later');
+}
+;
+require_once dirname(__FILE__).'/lib/php/Boot.class.php';
+
+Main::main();
+
+?>
diff --git a/filter/wiris/integration/isphp.php b/filter/wiris/integration/isphp.php
new file mode 100644
index 0000000..a8f6272
--- /dev/null
+++ b/filter/wiris/integration/isphp.php
@@ -0,0 +1,3 @@
+<?php
+echo "true";
+?>
diff --git a/filter/wiris/integration/lib/Date.class.php b/filter/wiris/integration/lib/Date.class.php
new file mode 100644
index 0000000..44f54e5
--- /dev/null
+++ b/filter/wiris/integration/lib/Date.class.php
@@ -0,0 +1,67 @@
+<?php
+
+class Date {
+	public function __construct($year, $month, $day, $hour, $min, $sec) {
+		if(!php_Boot::$skip_constructor) {
+		$this->__t = mktime($hour, $min, $sec, $month + 1, $day, $year);
+	}}
+	public function toString() {
+		return date("Y-m-d H:i:s", $this->__t);
+	}
+	public function getDay() {
+		return intval(date("w", $this->__t));
+	}
+	public function getSeconds() {
+		return intval(date("s", $this->__t));
+	}
+	public function getMinutes() {
+		return intval(date("i", $this->__t));
+	}
+	public function getHours() {
+		return intval(date("G", $this->__t));
+	}
+	public function getDate() {
+		return intval(date("j", $this->__t));
+	}
+	public function getMonth() {
+		$m = intval(date("n", $this->__t));
+		return -1 + $m;
+	}
+	public function getFullYear() {
+		return intval(date("Y", $this->__t));
+	}
+	public function getPhpTime() {
+		return $this->__t;
+	}
+	public function getTime() {
+		return $this->__t * 1000;
+	}
+	public $__t;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function now() {
+		return Date::fromPhpTime(round(microtime(true), 3));
+	}
+	static function fromPhpTime($t) {
+		$d = new Date(2000, 1, 1, 0, 0, 0);
+		$d->__t = $t;
+		return $d;
+	}
+	static function fromTime($t) {
+		$d = new Date(2000, 1, 1, 0, 0, 0);
+		$d->__t = $t / 1000;
+		return $d;
+	}
+	static function fromString($s) {
+		return Date::fromPhpTime(strtotime($s));
+	}
+	function __toString() { return $this->toString(); }
+}
diff --git a/filter/wiris/integration/lib/EReg.class.php b/filter/wiris/integration/lib/EReg.class.php
new file mode 100644
index 0000000..af36248
--- /dev/null
+++ b/filter/wiris/integration/lib/EReg.class.php
@@ -0,0 +1,92 @@
+<?php
+
+class EReg {
+	public function __construct($r, $opt) {
+		if(!php_Boot::$skip_constructor) {
+		$this->pattern = $r;
+		$a = _hx_explode("g", $opt);
+		$this->hglobal = $a->length > 1;
+		if($this->hglobal) {
+			$opt = $a->join("");
+		}
+		$this->options = $opt;
+		$this->re = '"' . str_replace('"','\\"',$r) . '"' . $opt;
+	}}
+	public function customReplace($s, $f) {
+		$buf = "";
+		while(true) {
+			if(!$this->match($s)) {
+				break;
+			}
+			$buf .= $this->matchedLeft();
+			$buf .= call_user_func_array($f, array($this));
+			$s = $this->matchedRight();
+		}
+		$buf .= $s;
+		return $buf;
+	}
+	public function replace($s, $by) {
+		$by = str_replace("\\\$", "\\\\\$", $by);
+		$by = str_replace("\$\$", "\\\$", $by);
+		if(!preg_match('/\\([^?].+?\\)/', $this->re)) $by = preg_replace('/\$(\d+)/', '\\\$\1', $by);
+		return preg_replace($this->re, $by, $s, (($this->hglobal) ? -1 : 1));
+	}
+	public function split($s) {
+		return new _hx_array(preg_split($this->re, $s, $this->hglobal ? -1 : 2));
+	}
+	public function matchedPos() {
+		return _hx_anonymous(array("pos" => $this->matches[0][1], "len" => strlen($this->matches[0][0])));
+	}
+	public function matchedRight() {
+		if(count($this->matches) === 0) {
+			throw new HException("No string matched");
+		}
+		$x = $this->matches[0][1] + strlen($this->matches[0][0]);
+		return _hx_substr($this->last, $x, null);
+	}
+	public function matchedLeft() {
+		if(count($this->matches) === 0) {
+			throw new HException("No string matched");
+		}
+		return _hx_substr($this->last, 0, $this->matches[0][1]);
+	}
+	public function matched($n) {
+		if($n < 0) {
+			throw new HException("EReg::matched");
+		}
+		if($n >= count($this->matches)) {
+			return null;
+		}
+		if($this->matches[$n][1] < 0) {
+			return null;
+		}
+		return $this->matches[$n][0];
+	}
+	public function match($s) {
+		$p = preg_match($this->re, $s, $this->matches, PREG_OFFSET_CAPTURE);
+		if($p > 0) {
+			$this->last = $s;
+		} else {
+			$this->last = null;
+		}
+		return $p > 0;
+	}
+	public $matches;
+	public $re;
+	public $options;
+	public $pattern;
+	public $hglobal;
+	public $last;
+	public $r;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'EReg'; }
+}
diff --git a/filter/wiris/integration/lib/Hash.class.php b/filter/wiris/integration/lib/Hash.class.php
new file mode 100644
index 0000000..ab87ed7
--- /dev/null
+++ b/filter/wiris/integration/lib/Hash.class.php
@@ -0,0 +1,65 @@
+<?php
+
+class Hash implements IteratorAggregate{
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		$this->h = array();
+	}}
+	public function getIterator() {
+		return $this->iterator();
+	}
+	public function toString() {
+		$s = "{";
+		$it = $this->keys();
+		$it = $it;
+		while($it->hasNext()) {
+			$i = $it->next();
+			$s .= $i;
+			$s .= " => ";
+			$s .= Std::string($this->get($i));
+			if($it->hasNext()) {
+				$s .= ", ";
+			}
+		}
+		return $s . "}";
+	}
+	public function iterator() {
+		return new _hx_array_iterator(array_values($this->h));
+	}
+	public function keys() {
+		return new _hx_array_iterator(array_keys($this->h));
+	}
+	public function remove($key) {
+		if(array_key_exists($key, $this->h)) {
+			unset($this->h[$key]);
+			return true;
+		} else {
+			return false;
+		}
+	}
+	public function exists($key) {
+		return array_key_exists($key, $this->h);
+	}
+	public function get($key) {
+		if(array_key_exists($key, $this->h)) {
+			return $this->h[$key];
+		} else {
+			return null;
+		}
+	}
+	public function set($key, $value) {
+		$this->h[$key] = $value;
+	}
+	public $h;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return $this->toString(); }
+}
diff --git a/filter/wiris/integration/lib/IntIter.class.php b/filter/wiris/integration/lib/IntIter.class.php
new file mode 100644
index 0000000..76457a6
--- /dev/null
+++ b/filter/wiris/integration/lib/IntIter.class.php
@@ -0,0 +1,28 @@
+<?php
+
+class IntIter {
+	public function __construct($min, $max) {
+		if(!php_Boot::$skip_constructor) {
+		$this->min = $min;
+		$this->max = $max;
+	}}
+	public function next() {
+		return $this->min++;
+	}
+	public function hasNext() {
+		return $this->min < $this->max;
+	}
+	public $max;
+	public $min;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'IntIter'; }
+}
diff --git a/filter/wiris/integration/lib/Main.class.php b/filter/wiris/integration/lib/Main.class.php
new file mode 100644
index 0000000..17855a7
--- /dev/null
+++ b/filter/wiris/integration/lib/Main.class.php
@@ -0,0 +1,9 @@
+<?php
+
+class Main {
+	public function __construct(){}
+	static function main() {
+		haxe_Log::trace("Hello World !", _hx_anonymous(array("fileName" => "Main.hx", "lineNumber" => 5, "className" => "Main", "methodName" => "main")));
+	}
+	function __toString() { return 'Main'; }
+}
diff --git a/filter/wiris/integration/lib/Math.class.php b/filter/wiris/integration/lib/Math.class.php
new file mode 100644
index 0000000..eeff37f
--- /dev/null
+++ b/filter/wiris/integration/lib/Math.class.php
@@ -0,0 +1,76 @@
+<?php
+
+class Math {
+	public function __construct(){}
+	static $PI;
+	static $NaN;
+	static $POSITIVE_INFINITY;
+	static $NEGATIVE_INFINITY;
+	static function abs($v) {
+		return abs($v);
+	}
+	static function min($a, $b) {
+		return min($a, $b);
+	}
+	static function max($a, $b) {
+		return max($a, $b);
+	}
+	static function sin($v) {
+		return sin($v);
+	}
+	static function cos($v) {
+		return cos($v);
+	}
+	static function atan2($y, $x) {
+		return atan2($y, $x);
+	}
+	static function tan($v) {
+		return tan($v);
+	}
+	static function exp($v) {
+		return exp($v);
+	}
+	static function log($v) {
+		return log($v);
+	}
+	static function sqrt($v) {
+		return sqrt($v);
+	}
+	static function round($v) {
+		return (int) floor($v + 0.5);
+	}
+	static function floor($v) {
+		return (int) floor($v);
+	}
+	static function ceil($v) {
+		return (int) ceil($v);
+	}
+	static function atan($v) {
+		return atan($v);
+	}
+	static function asin($v) {
+		return asin($v);
+	}
+	static function acos($v) {
+		return acos($v);
+	}
+	static function pow($v, $exp) {
+		return pow($v, $exp);
+	}
+	static function random() {
+		return mt_rand() / mt_getrandmax();
+	}
+	static function isNaN($f) {
+		return is_nan($f);
+	}
+	static function isFinite($f) {
+		return is_finite($f);
+	}
+	function __toString() { return 'Math'; }
+}
+{
+	Math::$PI = M_PI;
+	Math::$NaN = acos(1.01);
+	Math::$NEGATIVE_INFINITY = log(0);
+	Math::$POSITIVE_INFINITY = -Math::$NEGATIVE_INFINITY;
+}
diff --git a/filter/wiris/integration/lib/Reflect.class.php b/filter/wiris/integration/lib/Reflect.class.php
new file mode 100644
index 0000000..553aafe
--- /dev/null
+++ b/filter/wiris/integration/lib/Reflect.class.php
@@ -0,0 +1,104 @@
+<?php
+
+class Reflect {
+	public function __construct(){}
+	static function hasField($o, $field) {
+		return _hx_has_field($o, $field);
+	}
+	static function field($o, $field) {
+		return _hx_field($o, $field);
+	}
+	static function setField($o, $field, $value) {
+		$o->{$field} = $value;
+	}
+	static function getProperty($o, $field) {
+		if(null === $o) {
+			return null;
+		}
+		$cls = ((Std::is($o, _hx_qtype("Class"))) ? $o->__tname__ : get_class($o));
+		$cls_vars = get_class_vars($cls);
+		if(isset($cls_vars['__properties__']) && isset($cls_vars['__properties__']['get_'.$field]) && ($field = $cls_vars['__properties__']['get_'.$field])) {
+			return $o->$field();
+		} else {
+			return $o->$field;
+		}
+	}
+	static function setProperty($o, $field, $value) {
+		if(null === $o) {
+			null;
+			return;
+		}
+		$cls = ((Std::is($o, _hx_qtype("Class"))) ? $o->__tname__ : get_class($o));
+		$cls_vars = get_class_vars($cls);
+		if(isset($cls_vars['__properties__']) && isset($cls_vars['__properties__']['set_'.$field]) && ($field = $cls_vars['__properties__']['set_'.$field])) {
+			$o->$field($value);
+			return;
+		} else {
+			$o->$field = $value;
+			return;
+		}
+	}
+	static function callMethod($o, $func, $args) {
+		if(is_string($o) && !is_array($func)) {
+			return call_user_func_array(Reflect::field($o, $func), $args->a);
+		}
+		return call_user_func_array(((is_callable($func)) ? $func : array($o, $func)), ((null === $args) ? array() : $args->a));
+	}
+	static function fields($o) {
+		if($o === null) {
+			return new _hx_array(array());
+		}
+		return (($o instanceof _hx_array) ? new _hx_array(array('concat','copy','insert','iterator','length','join','pop','push','remove','reverse','shift','slice','sort','splice','toString','unshift')) : ((is_string($o)) ? new _hx_array(array('charAt','charCodeAt','indexOf','lastIndexOf','length','split','substr','toLowerCase','toString','toUpperCase')) : new _hx_array(_hx_get_object_vars($o))));
+	}
+	static function isFunction($f) {
+		return (is_array($f) && is_callable($f)) || _hx_is_lambda($f) || is_array($f) && _hx_has_field($f[0], $f[1]) && $f[1] !== "length";
+	}
+	static function compare($a, $b) {
+		return (($a == $b) ? 0 : (($a > $b) ? 1 : -1));
+	}
+	static function compareMethods($f1, $f2) {
+		if(is_array($f1) && is_array($f1)) {
+			return $f1[0] === $f2[0] && $f1[1] == $f2[1];
+		}
+		if(is_string($f1) && is_string($f2)) {
+			return _hx_equal($f1, $f2);
+		}
+		return false;
+	}
+	static function isObject($v) {
+		if($v === null) {
+			return false;
+		}
+		if(is_object($v)) {
+			return $v instanceof _hx_anonymous || Type::getClass($v) !== null;
+		}
+		return is_string($v) && !_hx_is_lambda($v);
+	}
+	static function deleteField($o, $f) {
+		if(!_hx_has_field($o, $f)) {
+			return false;
+		}
+		if(isset($o->dynamics[$f])) unset($o->dynamics[$f]); else if($o instanceof _hx_anonymous) unset($o->$f); else $o->$f = null;
+		return true;
+	}
+	static function copy($o) {
+		if(is_string($o)) {
+			return $o;
+		}
+		$o2 = _hx_anonymous(array());
+		{
+			$_g = 0; $_g1 = Reflect::fields($o);
+			while($_g < $_g1->length) {
+				$f = $_g1[$_g];
+				++$_g;
+				$o2->{$f} = Reflect::field($o, $f);
+				unset($f);
+			}
+		}
+		return $o2;
+	}
+	static function makeVarArgs($f) {
+		return array(new _hx_lambda(array(&$f), '_hx_make_var_args'), 'execute');
+	}
+	function __toString() { return 'Reflect'; }
+}
diff --git a/filter/wiris/integration/lib/Std.class.php b/filter/wiris/integration/lib/Std.class.php
new file mode 100644
index 0000000..002e69a
--- /dev/null
+++ b/filter/wiris/integration/lib/Std.class.php
@@ -0,0 +1,52 @@
+<?php
+
+class Std {
+	public function __construct(){}
+	static function is($v, $t) {
+		return _hx_instanceof($v, $t);
+	}
+	static function string($s) {
+		return _hx_string_rec($s, "");
+	}
+	static function int($x) {
+		return intval($x);
+	}
+	static function parseInt($x) {
+		$x = ltrim($x);
+		$firstCharIndex = ((_hx_char_at($x, 0) === "-") ? 1 : 0);
+		$firstCharCode = _hx_char_code_at($x, $firstCharIndex);
+		if(!($firstCharCode !== null && $firstCharCode >= 48 && $firstCharCode <= 57)) {
+			return null;
+		}
+		$secondChar = _hx_char_at($x, $firstCharIndex + 1);
+		if($secondChar === "x" || $secondChar === "X") {
+			return intval($x, 0);
+		} else {
+			return intval($x, 10);
+		}
+	}
+	static function parseFloat($x) {
+		$result = floatval($x);
+		if($result != 0) {
+			return $result;
+		}
+		$x = ltrim($x);
+		$firstCharIndex = ((_hx_char_at($x, 0) === "-") ? 1 : 0);
+		$charCode = _hx_char_code_at($x, $firstCharIndex);
+		if($charCode === 46) {
+			$charCode = _hx_char_code_at($x, $firstCharIndex + 1);
+		}
+		if($charCode !== null && $charCode >= 48 && $charCode <= 57) {
+			return 0.0;
+		} else {
+			return Math::$NaN;
+		}
+	}
+	static function random($x) {
+		return mt_rand(0, $x - 1);
+	}
+	static function isDigitCode($charCode) {
+		return $charCode !== null && $charCode >= 48 && $charCode <= 57;
+	}
+	function __toString() { return 'Std'; }
+}
diff --git a/filter/wiris/integration/lib/StringBuf.class.php b/filter/wiris/integration/lib/StringBuf.class.php
new file mode 100644
index 0000000..4f95767
--- /dev/null
+++ b/filter/wiris/integration/lib/StringBuf.class.php
@@ -0,0 +1,39 @@
+<?php
+
+class StringBuf {
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		$this->b = "";
+	}}
+	public function toString() {
+		return $this->b;
+	}
+	public function addChar($c) {
+		$this->b .= chr($c);
+	}
+	public function addSub($s, $pos, $len = null) {
+		$this->b .= _hx_substr($s, $pos, $len);
+	}
+	public function add($x) {
+		if(is_null($x)) {
+			$x = "null";
+		} else {
+			if(is_bool($x)) {
+				$x = (($x) ? "true" : "false");
+			}
+		}
+		$this->b .= Std::string($x);
+	}
+	public $b;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return $this->toString(); }
+}
diff --git a/filter/wiris/integration/lib/StringTools.class.php b/filter/wiris/integration/lib/StringTools.class.php
new file mode 100644
index 0000000..c551ff9
--- /dev/null
+++ b/filter/wiris/integration/lib/StringTools.class.php
@@ -0,0 +1,61 @@
+<?php
+
+class StringTools {
+	public function __construct(){}
+	static function urlEncode($s) {
+		return rawurlencode($s);
+	}
+	static function urlDecode($s) {
+		return urldecode($s);
+	}
+	static function htmlEscape($s) {
+		return _hx_explode(">", _hx_explode("<", _hx_explode("&", $s)->join("&amp;"))->join("&lt;"))->join("&gt;");
+	}
+	static function htmlUnescape($s) {
+		return htmlspecialchars_decode($s);
+	}
+	static function startsWith($s, $start) {
+		return strlen($s) >= strlen($start) && _hx_substr($s, 0, strlen($start)) === $start;
+	}
+	static function endsWith($s, $end) {
+		$elen = strlen($end);
+		$slen = strlen($s);
+		return $slen >= $elen && _hx_substr($s, $slen - $elen, $elen) === $end;
+	}
+	static function isSpace($s, $pos) {
+		$c = _hx_char_code_at($s, $pos);
+		return $c >= 9 && $c <= 13 || $c === 32;
+	}
+	static function ltrim($s) {
+		return ltrim($s);
+	}
+	static function rtrim($s) {
+		return rtrim($s);
+	}
+	static function trim($s) {
+		return trim($s);
+	}
+	static function rpad($s, $c, $l) {
+		return str_pad($s, $l, $c, STR_PAD_RIGHT);
+	}
+	static function lpad($s, $c, $l) {
+		return str_pad($s, $l, $c, STR_PAD_LEFT);
+	}
+	static function replace($s, $sub, $by) {
+		return str_replace($sub, $by, $s);
+	}
+	static function hex($n, $digits = null) {
+		$s = dechex($n);
+		if($digits !== null) {
+			$s = str_pad($s, $digits, "0", STR_PAD_LEFT);
+		}
+		return strtoupper($s);
+	}
+	static function fastCodeAt($s, $index) {
+		return ord(substr($s,$index,1));
+	}
+	static function isEOF($c) {
+		return ($c === 0);
+	}
+	function __toString() { return 'StringTools'; }
+}
diff --git a/filter/wiris/integration/lib/Sys.class.php b/filter/wiris/integration/lib/Sys.class.php
new file mode 100644
index 0000000..953e0b6
--- /dev/null
+++ b/filter/wiris/integration/lib/Sys.class.php
@@ -0,0 +1,117 @@
+<?php
+
+class Sys {
+	public function __construct(){}
+	static function hprint($v) {
+		echo(Std::string($v));
+	}
+	static function println($v) {
+		Sys::hprint($v);
+		Sys::hprint("\x0A");
+	}
+	static function args() {
+		return ((array_key_exists("argv", $_SERVER)) ? new _hx_array(array_slice($_SERVER["argv"], 1)) : new _hx_array(array()));
+	}
+	static function getEnv($s) {
+		return getenv($s);
+	}
+	static function putEnv($s, $v) {
+		putenv($s . "=" . $v);
+		return;
+	}
+	static function sleep($seconds) {
+		usleep($seconds * 1000000);
+		return;
+	}
+	static function setTimeLocale($loc) {
+		return setlocale(LC_TIME, $loc) !== false;
+	}
+	static function getCwd() {
+		$cwd = getcwd();
+		$l = _hx_substr($cwd, -1, null);
+		return $cwd . ((($l === "/" || $l === "\\") ? "" : "/"));
+	}
+	static function setCwd($s) {
+		chdir($s);
+	}
+	static function systemName() {
+		$s = php_uname("s");
+		$p = null;
+		if(($p = _hx_index_of($s, " ", null)) >= 0) {
+			return _hx_substr($s, 0, $p);
+		} else {
+			return $s;
+		}
+	}
+	static function escapeArgument($arg) {
+		$ok = true;
+		{
+			$_g1 = 0; $_g = strlen($arg);
+			while($_g1 < $_g) {
+				$i = $_g1++;
+				switch(_hx_char_code_at($arg, $i)) {
+				case 32:case 34:{
+					$ok = false;
+				}break;
+				case 0:case 13:case 10:{
+					$arg = _hx_substr($arg, 0, $i);
+				}break;
+				}
+				unset($i);
+			}
+		}
+		if($ok) {
+			return $arg;
+		}
+		return "\"" . _hx_explode("\"", $arg)->join("\\\"") . "\"";
+	}
+	static function command($cmd, $args = null) {
+		if($args !== null) {
+			$cmd = Sys::escapeArgument($cmd);
+			{
+				$_g = 0;
+				while($_g < $args->length) {
+					$a = $args[$_g];
+					++$_g;
+					$cmd .= " " . Sys::escapeArgument($a);
+					unset($a);
+				}
+			}
+		}
+		$result = 0;
+		system($cmd, $result);
+		return $result;
+	}
+	static function hexit($code) {
+		exit($code);
+	}
+	static function time() {
+		return microtime(true);
+	}
+	static function cpuTime() {
+		return microtime(true) - $_SERVER['REQUEST_TIME'];
+	}
+	static function executablePath() {
+		return $_SERVER['SCRIPT_FILENAME'];
+	}
+	static function environment() {
+		return php_Lib::hashOfAssociativeArray($_SERVER);
+	}
+	static function stdin() {
+		return new sys_io_FileInput(fopen("php://stdin", "r"));
+	}
+	static function stdout() {
+		return new sys_io_FileOutput(fopen("php://stdout", "w"));
+	}
+	static function stderr() {
+		return new sys_io_FileOutput(fopen("php://stderr", "w"));
+	}
+	static function getChar($echo) {
+		$v = fgetc(STDIN);
+		if($echo) {
+			echo($v);
+		}
+		return $v;
+	}
+	function __toString() { return 'Sys'; }
+}
diff --git a/filter/wiris/integration/lib/Type.class.php b/filter/wiris/integration/lib/Type.class.php
new file mode 100644
index 0000000..f98e3d8
--- /dev/null
+++ b/filter/wiris/integration/lib/Type.class.php
@@ -0,0 +1,298 @@
+<?php
+
+class Type {
+	public function __construct(){}
+	static function getClass($o) {
+		if($o === null) {
+			return null;
+		}
+		if(is_array($o)) {
+			if(count($o) === 2 && is_callable($o)) {
+				return null;
+			}
+			return _hx_ttype("Array");
+		}
+		if(is_string($o)) {
+			if(_hx_is_lambda($o)) {
+				return null;
+			}
+			return _hx_ttype("String");
+		}
+		if(!is_object($o)) {
+			return null;
+		}
+		$c = get_class($o);
+		if($c === false || $c === "_hx_anonymous" || is_subclass_of($c, "enum")) {
+			return null;
+		} else {
+			return _hx_ttype($c);
+		}
+	}
+	static function getEnum($o) {
+		if(!$o instanceof Enum) {
+			return null;
+		} else {
+			return _hx_ttype(get_class($o));
+		}
+	}
+	static function getSuperClass($c) {
+		$s = get_parent_class($c->__tname__);
+		if($s === false) {
+			return null;
+		} else {
+			return _hx_ttype($s);
+		}
+	}
+	static function getClassName($c) {
+		if($c === null) {
+			return null;
+		}
+		return $c->__qname__;
+	}
+	static function getEnumName($e) {
+		return $e->__qname__;
+	}
+	static function resolveClass($name) {
+		$c = _hx_qtype($name);
+		if($c instanceof _hx_class || $c instanceof _hx_interface) {
+			return $c;
+		} else {
+			return null;
+		}
+	}
+	static function resolveEnum($name) {
+		$e = _hx_qtype($name);
+		if($e instanceof _hx_enum) {
+			return $e;
+		} else {
+			return null;
+		}
+	}
+	static function createInstance($cl, $args) {
+		if($cl->__qname__ === "Array") {
+			return new _hx_array(array());
+		}
+		if($cl->__qname__ === "String") {
+			return $args[0];
+		}
+		$c = $cl->__rfl__();
+		if($c === null) {
+			return null;
+		}
+		return $inst = $c->getConstructor() ? $c->newInstanceArgs($args->a) : $c->newInstanceArgs();
+	}
+	static function createEmptyInstance($cl) {
+		if($cl->__qname__ === "Array") {
+			return new _hx_array(array());
+		}
+		if($cl->__qname__ === "String") {
+			return "";
+		}
+		try {
+			php_Boot::$skip_constructor = true;
+			$rfl = $cl->__rfl__();
+			if($rfl === null) {
+				return null;
+			}
+			$m = $rfl->getConstructor();
+			$nargs = $m->getNumberOfRequiredParameters();
+			$i = null;
+			if($nargs > 0) {
+				$args = array_fill(0, $m->getNumberOfRequiredParameters(), null);
+				$i = $rfl->newInstanceArgs($args);
+			} else {
+				$i = $rfl->newInstanceArgs(array());
+			}
+			php_Boot::$skip_constructor = false;
+			return $i;
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+				php_Boot::$skip_constructor = false;
+				throw new HException("Unable to instantiate " . Std::string($cl));
+			}
+		}
+		return null;
+	}
+	static function createEnum($e, $constr, $params = null) {
+		$f = Reflect::field($e, $constr);
+		if($f === null) {
+			throw new HException("No such constructor " . $constr);
+		}
+		if(Reflect::isFunction($f)) {
+			if($params === null) {
+				throw new HException("Constructor " . $constr . " need parameters");
+			}
+			return Reflect::callMethod($e, $f, $params);
+		}
+		if($params !== null && $params->length !== 0) {
+			throw new HException("Constructor " . $constr . " does not need parameters");
+		}
+		return $f;
+	}
+	static function createEnumIndex($e, $index, $params = null) {
+		$c = _hx_array_get(Type::getEnumConstructs($e), $index);
+		if($c === null) {
+			throw new HException(_hx_string_rec($index, "") . " is not a valid enum constructor index");
+		}
+		return Type::createEnum($e, $c, $params);
+	}
+	static function getInstanceFields($c) {
+		if($c->__qname__ === "String") {
+			return new _hx_array(array("substr", "charAt", "charCodeAt", "indexOf", "lastIndexOf", "split", "toLowerCase", "toUpperCase", "toString", "length"));
+		}
+		if($c->__qname__ === "Array") {
+			return new _hx_array(array("push", "concat", "join", "pop", "reverse", "shift", "slice", "sort", "splice", "toString", "copy", "unshift", "insert", "remove", "iterator", "length"));
+		}
+		
+		$rfl = $c->__rfl__();
+		if($rfl === null) return new _hx_array(array());
+		$r = array();
+		$internals = array('__construct', '__call', '__get', '__set', '__isset', '__unset', '__toString');
+		$ms = $rfl->getMethods();
+		while(list(, $m) = each($ms)) {
+			$n = $m->getName();
+			if(!$m->isStatic() && ! in_array($n, $internals)) $r[] = $n;
+		}
+		$ps = $rfl->getProperties();
+		while(list(, $p) = each($ps))
+			if(!$p->isStatic()) $r[] = $p->getName();
+		return new _hx_array(array_values(array_unique($r)));
+	}
+	static function getClassFields($c) {
+		if($c->__qname__ === "String") {
+			return new _hx_array(array("fromCharCode"));
+		}
+		if($c->__qname__ === "Array") {
+			return new _hx_array(array());
+		}
+		
+		$rfl = $c->__rfl__();
+		if($rfl === null) return new _hx_array(array());
+		$ms = $rfl->getMethods();
+		$r = array();
+		while(list(, $m) = each($ms))
+			if($m->isStatic()) $r[] = $m->getName();
+		$ps = $rfl->getProperties();
+		while(list(, $p) = each($ps))
+			if($p->isStatic()) $r[] = $p->getName();
+		;
+		return new _hx_array(array_unique($r));
+	}
+	static function getEnumConstructs($e) {
+		if($e->__tname__ == 'Bool') {
+			return new _hx_array(array("true", "false"));
+		}
+		if($e->__tname__ == 'Void') {
+			return new _hx_array(array());
+		}
+		return new _hx_array($e->__constructors);
+	}
+	static function typeof($v) {
+		if($v === null) {
+			return ValueType::$TNull;
+		}
+		if(is_array($v)) {
+			if(is_callable($v)) {
+				return ValueType::$TFunction;
+			}
+			return ValueType::TClass(_hx_qtype("Array"));
+		}
+		if(is_string($v)) {
+			if(_hx_is_lambda($v)) {
+				return ValueType::$TFunction;
+			}
+			return ValueType::TClass(_hx_qtype("String"));
+		}
+		if(is_bool($v)) {
+			return ValueType::$TBool;
+		}
+		if(is_int($v)) {
+			return ValueType::$TInt;
+		}
+		if(is_float($v)) {
+			return ValueType::$TFloat;
+		}
+		if($v instanceof _hx_anonymous) {
+			return ValueType::$TObject;
+		}
+		if($v instanceof _hx_enum) {
+			return ValueType::$TObject;
+		}
+		if($v instanceof _hx_class) {
+			return ValueType::$TObject;
+		}
+		$c = _hx_ttype(get_class($v));
+		if($c instanceof _hx_enum) {
+			return ValueType::TEnum($c);
+		}
+		if($c instanceof _hx_class) {
+			return ValueType::TClass($c);
+		}
+		return ValueType::$TUnknown;
+	}
+	static function enumEq($a, $b) {
+		if($a == $b) {
+			return true;
+		}
+		try {
+			if(!_hx_equal($a->index, $b->index)) {
+				return false;
+			}
+			{
+				$_g1 = 0; $_g = count($a->params);
+				while($_g1 < $_g) {
+					$i = $_g1++;
+					if(Type::getEnum($a->params[$i]) !== null) {
+						if(!Type::enumEq($a->params[$i], $b->params[$i])) {
+							return false;
+						}
+					} else {
+						if(!_hx_equal($a->params[$i], $b->params[$i])) {
+							return false;
+						}
+					}
+					unset($i);
+				}
+			}
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+				return false;
+			}
+		}
+		return true;
+	}
+	static function enumConstructor($e) {
+		return $e->tag;
+	}
+	static function enumParameters($e) {
+		if(_hx_field($e, "params") === null) {
+			return new _hx_array(array());
+		} else {
+			return new _hx_array($e->params);
+		}
+	}
+	static function enumIndex($e) {
+		return $e->index;
+	}
+	static function allEnums($e) {
+		$all = new _hx_array(array());
+		{
+			$_g = 0; $_g1 = Type::getEnumConstructs($e);
+			while($_g < $_g1->length) {
+				$c = $_g1[$_g];
+				++$_g;
+				$v = Reflect::field($e, $c);
+				if(!Reflect::isFunction($v)) {
+					$all->push($v);
+				}
+				unset($v,$c);
+			}
+		}
+		return $all;
+	}
+	function __toString() { return 'Type'; }
+}
diff --git a/filter/wiris/integration/lib/VERSION b/filter/wiris/integration/lib/VERSION
new file mode 100644
index 0000000..9f2124c
--- /dev/null
+++ b/filter/wiris/integration/lib/VERSION
@@ -0,0 +1 @@
+4.7.0.1374
\ No newline at end of file
diff --git a/filter/wiris/integration/lib/ValueType.enum.php b/filter/wiris/integration/lib/ValueType.enum.php
new file mode 100644
index 0000000..8fa27ea
--- /dev/null
+++ b/filter/wiris/integration/lib/ValueType.enum.php
@@ -0,0 +1,21 @@
+<?php
+
+class ValueType extends Enum {
+	public static $TBool;
+	public static function TClass($c) { return new ValueType("TClass", 6, array($c)); }
+	public static function TEnum($e) { return new ValueType("TEnum", 7, array($e)); }
+	public static $TFloat;
+	public static $TFunction;
+	public static $TInt;
+	public static $TNull;
+	public static $TObject;
+	public static $TUnknown;
+	public static $__constructors = array(3 => 'TBool', 6 => 'TClass', 7 => 'TEnum', 2 => 'TFloat', 5 => 'TFunction', 1 => 'TInt', 0 => 'TNull', 4 => 'TObject', 8 => 'TUnknown');
+	}
+ValueType::$TBool = new ValueType("TBool", 3);
+ValueType::$TFloat = new ValueType("TFloat", 2);
+ValueType::$TFunction = new ValueType("TFunction", 5);
+ValueType::$TInt = new ValueType("TInt", 1);
+ValueType::$TNull = new ValueType("TNull", 0);
+ValueType::$TObject = new ValueType("TObject", 4);
+ValueType::$TUnknown = new ValueType("TUnknown", 8);
diff --git a/filter/wiris/integration/lib/cas.png b/filter/wiris/integration/lib/cas.png
new file mode 100644
index 0000000000000000000000000000000000000000..a6fd5df02bd510474c7f5ecf8643ba0104ec8403
GIT binary patch
literal 12579
zcmd^mdpOho|F=*`vXV~1D2Eb0lyg`p=d&!QRwTy}!bfcT>_bdW$+4W8k|ea)7_kn^
zY2~~*Y@=jW*eb_tw%x1m_xrnkzx%rH>poxCeP8z<F4taO@8|LLdOjb|$9po}Tx?}_
z9^NS;A|hjNXX7CvvW+PGxg)tlxbg=Gz!(177UyAWCDJ%><g4(5c*t4jvmzpxJn5|~
z+l8N{uG{&<iHPhLKDC>;tw?LPf^hNBjdK@oSVu#l!BICvtYd?(+z7r3Obojb3beI%
zb^{}K9}o&Ju(vtu_2(rPJ>q>Z7&a4=CH}~v=0KfHv?^NEL%#5d>cu^%OAj7+Lo3Ad
z_txQCjz9WaUE8i@+n!g(=tnK~4ebZZ{MrtCWq&?MYZuQrn7r#TE+jkPj1uIJ&sVyy
zT|1*h{ity8Tce=TCu8jylMt2MgdLn_ra)3|4ES(g=p<LInI&5?lPXUQ2wr8h-)B!C
z=vOO^;Sac@uCO+)k>FDS-I2e^pszsI7!~|s!B_s2W78LN);U2kh0l@Jkv9E2S+&5U
z&A@^-IODu}Hc=7$^z$|mstxIZ9tV`NG%R<aw=0UziKi<gW~<q>jjpB*TV^L%jij^n
z-8R7<di1IwIl3J!`&O`8DcvD$vB_f3Iw~(%aPBE@Dl5aTXCy+}QleAF73n@r9G=C#
zp4_;IIzy@CBh2Xo`QarO!3d9d)bXj}sj7?P2g!HC>o0<pJ>yX|d4#3}I7^bKz~8Dq
zOH+g|%sSr8V4G23T(h3U{N-rHE~DeP&LsgNASP*}AIuBfxTTf1+Ss;?WRH+`H>GS<
zr)nv4CeRkAnJ!abmrEQW{4X>f-PKZ1`!pvm!lWnWIBZWGd(eN%uq2`7G}B@L55<xP
znl1qQ|Bj~r88%)q0k*+m%!*)rwL8PUe0sQHbd+0i^AfkL>1!085enI`)?l+MjBobn
zY|JFD1S;aWoTAi3)}jt!X@H$H2pc%|nReeiw`}Nu9+UsR1{$aI(088J<E$W<+Qc3O
zU}a*TX#p5Je{l1r$IUmtL+PFxUBl+<uLO(ARi^Nujk)2)<Qc-Z2>NH+F4N>ZICn}>
z$>Ptoez8P&odEv{BZi=4%$=(G@mV3pDtf9cZh&{skvf0oJoY_4ugs8-U8%PR_N#5=
z2Wi~T=Q)}SR+$1HWt8DA=pXG!%@&dSS_-JVBU8;s0Z`3$<iyQ#zviA8IgaW)tqR`)
z9SHIwm2=y|K3j4@Td9_3T3y-6-w+QDO%ldF@2Hk}t6WZ_N>n3?j1%kJT3%}+f3}>e
zwCFQ#y_WY`ef8XXyk%S%wY=v^vB^fvXg8t(`SYvv;Makhn_0<Gcx6<BWl}G{rm}?p
zwj{wa<)@u;x*>pTNGG&1A;$;qDcm*$XdCULgZw!fXOfQ?p>+fQGvCl#FHF?#F^VH@
ziw(<IkpkEffnUlTu|k<jmH;qR|H{v1-IUk2_k*zbwOtLP1Ya-fA3ymQfH);4WhsW1
z)`c?J2+@I-tsErlGcBT~e%6W(-`*aS01Q9-gf&6`Wb%za$dio-h%)x!n<kjE+>frc
zA=}zbPhU0LIN^RNVw;!e2h(bBR;`%3LWm0Mde~y2Cf)WcXC%)J@+^M!?Nf5q5Zr^C
zryV_sqa_sK&ZbRW>9f#=CPf%51b~&})(?c2Q6EpS!fO)Xb;#0=qa;~k$8N>xvpdFh
zM}IE9!xh}5fm)#XP;aQ2;_da@!|4xUErZ&A^Tkvq{9Z@px@k)zWWLz(U^~NbAN}$T
zv0-JoN%h)iHec6k7O6(HIHw7oGd&M&#mndL3`2vv?z3{S+O<xn9>LHFk_dzWx2pbp
z#o|KHK$jIXVzSXY5E)vteDW}g-;DvbY=LM9rcvS@<QnOu&$W_{Je@?C<3c`YiQu*J
zF`!<T(#v7XKTPR6Z-;-0<F-H(Nzi+c#)fYM3Z>6yybA|y`4kGVgwJ#-9s@A^9$R<&
zB(p3y!Dt3spFl&fbvGt|TL|R|D^#v_9EoO2pjouWmT;|j!?+dFQiR{*&Rla}euNeU
z=XUQ*JB?8n>o>0zmH|<kB6vqtbuiemiT65ah=yOAB0`n1H|OxdBr67**+|1pj`JVF
zq9*lQX%^#3^tCPh#Cv}GeJkZq-kQ|=60;v#>0PO;zevU0#Wtaws<Bh20d!mk!vYF}
z1|ZBEPF`T+Mq!H5Hc<bibzl7YRKN^^U9!o*Icdpi|HJY*wl4M(d)X~16t6p0HN@Yt
zb<`?h@*@Ozzj;Tjv(}1mJ9~Mkz3Xm5n-w>&D5J6?uh?5>kT<?Aly`Wvr<~)#;Kzca
zs5BU!6u5{Fj=~e(TO>j{7B>g2No5k%ICKZ5Tb8KM1t;wuxlVA>YHi}#=8Ubh5LQb%
z*ys-K_vWh#8`$fqBNo2sSgn>W!IbuRzXt=?u*@yA>R*a0p{W+bBR((PW!-|zTg;zH
zBsq{6ctYi1mkBl)Z5msQZ(+di!5WI*6$_(|q25wr#g*V_7K2HwUmi%4_xK5&j-_7N
z2qw|T;dnv?q|v;@77`jzf~$;nQnn^Fl*cA2cU`3V3vCyk$5vV~erv6T>FeVHe7t<}
z5Xw91k9M;ZstI8Rw$=?Zv-`}`Z=iLpD;s#^iKlY4J&i6~H8JplDTqd`Fj17zeg~4;
z)*MzD#Tx`T6R<IqUW+ZEv@du+!$)VluGw2!!SY!tY<&csCJb#cu2HL{LUOIA>C|dy
z7y}(|)dZ`<g$Z4=A~m?-HN!IeD*Z}uUF)=&ft^rh$t~OgET`1h(o4x#CmpA~*4{!x
zu!<uFu`i}J<z;LfshAEL{gdA`JfW2tVYCFy*&uDjCPhKGd57zmO<UxUr%25uej0?W
zvms0_-xT-0xFZjKPZ*?0COZOebz^*^>F}*pFsH(70PeGdUH4bA{^yagw@fcTh30iI
zmd{|}3-RoAZx=)h6YlebW+AJ+G9FWu9UqE-<2%l@H0qA+-b1ww^>M+kzr0}venNXn
zw-v-cr9s#`vDz)pPjm!WKb=8rtROzroQ3z^->+-g)B<b~7QxumVeJjEAA?QP&8erS
znYzt`JX<bJV~r@PXR}^gG?*!4r43L{`r<Yd4K2T=*gQ0`8O)Ag;kjRQ5=pdJ0iHk$
znJI@Sg(~>5brT_^I7H_JCrVghh36xdBbOWn`Q>iWiH%!R>Q@y?{Mb!QOU@!Uxa*>s
zO{6k9*f)tCN77vxkH6L5fQF5&EBKA;%9<zMn%eIR(JIk*)M_21+k(S?SzWx7coE>6
zDyB!2C2BQpWz9cQl1e9+gzNW#!Wqr+ru!IGD$+&(Y>a(AKZ3CsI8#3LqS!a*Z9AtR
z=y%CxI8<21u|Io3%K{tgDj;OBAI{N95gT}|uA%a=6{D&(BMzugmlFAueBtxgzY6&d
zgpBOw@&~?~ruLSPO+%g)e}10JpS%CNSDM5QRGDmGE>N%f`%jr-wN(MSn>5A;dvhuP
zRV-tJKNl&i@Fg{vXcy?@-Vgu2s}*!3_8>I{nVX|koh`rGVzV<c6c0u<^xzHti#^L(
z4AYG`QjFyPthF31A8TeIpX886CWNIhGV?$5T>H-uGlDlVG|@DTKD}dB!jkiYoo5;2
ze(D9HE`%zES^KYaS;B9)gt-b?mabZsc`TbU7sUIE`{)cfG+Aig%1fq2h?bZ;Cm^oe
zPZ~R@)T6d`E^W#<gP*og)(%C(2Crm?OJS3D!*-Ed?LX^=Gsh1tSIHIk^R+#-jScUu
z`YFhYyt>Yl4|HBPe4L`-QTBe@Wxvq4xr4rnni`wOj@6&+Yg}k`lClvou36tYk>_iE
z&{oEVC6Q}F6T2qnUcXNSXV2QapoG2o$3P>f5ZUwtdx6UwYjN0ixooTwB1JSj)_klZ
zLA*Kv6#El7q1;ly-FCU2TnV}7N4*mR-HTc#aOUvbnZqKN6|j;v4NBQZKcAQ+p9Ihm
zA>ty`C+C3SYnP840*l6c8nFBpK)2R_uPW;e4H)LFm2<jUK7)Wdso7e{w(AGVH+GB0
zs8Y{R;ug3gxnjt+UHXks(I45haYO1>K$i^AF+fJ?2|(V<Pq(rjtpzJy^#>#B9?x%U
zMn2(v+#3)3PHWvLNX6}nhpt>4to!C@wp&}&z25c>qidz|z>U>TL@jrK3wdD5e|^ez
zb7;ow-I;NU+zVx>z}l`1+x09pJ7N?xMzIc9AANy4$!OL2S;OwRw6d!B$jPr&zE#F^
zJRto2MP2%DtA|tp*!V!?lUrzozk4j!WyfqgatY7|w?e}Rn2*Gv@k#MnE%>L`>}&$L
zj+Az?AigEo+9?2{^;`BiE6v(xYOP(x@ye43$HX~G8K>uA;>^obT-P<BhJdgc1}`X#
zbZ)@(evM*AyhPw1yIdt8w`I;Flntz6B1AC)M}z*G_YZV!b<njS$sPgocjK=HKz%Zg
zFE&T7mm9(Q+V>+%*QwDKQ+ajY4k5S_bUahpyLA|V3PwIDig2LFQ<YF?yum&c{EmHF
z*y|G2*I&Ll);AH$McupO_ai3=D(o4mCE_y|GU=MFb9`~!V6m_(>9i*$q_s5<!`X_D
zdv6ZF@^?~0lA^}rtHxKCs*<V+rZ-4Rgm3$jmF5nbQkGvk<c6VeAB5*nSRM-XkO$3}
zy!bc(Y7_YdqL}{XJ5fWB*$){ccpOPCvICx=8KoH>Zx6Pf8EO=|L8bOwgz?)=x_8XV
zy0CYNH^73@)<a12zLAP!5%`6y*2Iv?HS>6%I&_eBYcRtl72#h4RqJU_!_DZ$=SbPG
zj$9`>P|2zQ#QH5=H&Vmca%udIYK2R02+rZD-}r(gijJ=)rOV-@3^5tLcA%p(Wb5L7
zA28Lnw^|G%xPfSYHuk_M;&o9PDJohyXl-+G{@^K-M;7?;%iLnWOJy`2*y5xuhY3eG
za!s#2)9qZkj_|jH51)-sf=-!u#a`N!Br>)KE-bi7zm+>cxXFyr-G{Bx$i+KEDxzBb
z<1p>YAF9P-LP42Te+~!LGwV24=_7s-I@C+tgY|<DBipP#w0Z*pv;6eEUcu+Y%ipwl
z5rlye!)(Px#3tw4YEQy#x3K~A-Ie~<<H*odXC?Zbm8uRBZ@gyy2r3G|p}E~?U1{1|
zyURvJ1#CslxHgP5Uft=ALr^<h0`yQ`u-JGNYIfZqESt=1DhukhxnM=LmHMR+?K0im
z#LY1}LjCcY(cMI&@#aWxl;IB4KMVmiIfJGv+zZ_X=jwx;I?MK<qMlDO`9YzZfMzKh
zW<p)(a@^bRuPu28v@mYZlBhTAfH*7QVWDpUlh-^&F(KAL#0v>JzqKq$l#p~g;x4H7
z3{30D!z*f_2Nh7uIo|kN5lt8UM*iWNJ@QHC?(L8#FNvn2?(_Av?HY++l#-uw*#h%u
zc~t##Gex+DrJyMprV0P#OqW%*coCs2JChVlXh2ZMWK2|o^JocQ8(HrXoA{~Zn>EPZ
zK|rT|M`OwqF1UsUsj(w#EUsT^L$*2@eGNe^Ywe5G8sWts7J#p9nL1Mcxb}<@egWPT
z|3#wS<6k+gV5m{{pnL&7dlP(t4uC1Q!tY}^c~{!nyQ@Hl@8Q(jJ$Whd*h`Bb+I_#r
zK~6qZ^l6Lkg_ZFSde>s@);iON_~GM6mG7j9KTN6jY<x4f{)l_FyQ#TF#=6IMO6}7U
z<j}JAC|!8i6i`uZn@Fa_Kb^O7ls>9LvO;PqwJj%-Stq3&jdo!{V~siudSKKW!J#X+
zak4VV(3Zx*e;rpKAd$lur_apX-^Ux=R}uU>#HN&W(rJ|`!=O+urQada12|=CG`Gc^
zirt9Mj290)Id*Kws@3_OXKTQ-DCW(N%i~RNh6EnY1leE(#|7NtZYiSoHF=b)A_0R?
z>d4Vp+y%4lc>L_&be1Lq!+G+!LG500DXsDbqEhqG^u%JJUQp+aAW^-90q)}blRYR;
zUt6GqTiBJW_Ltj{U(#niWv6SRKHr>MtlG7s`s65X51Zw27I@<7a{p!r8oyZM<O8wq
zEqWI5!5pBGD41p+Resq)h+h!A9QfuJ2I<L;Kd~>oK47L4<aFEz3_yJa?L+HgCGpVk
zroHsbg;mPoi`=>5Co(pzE_*rxPMlq8bOi3`Wi?DFSQl@$zUnS*@A57_ZSQIy<;e;D
zb)VZG$tq(Psf8f_jQH)<DM{z0)viRBwWBoyA?ZK*$XCCzJS;&{HeT44zAJsjtDhbw
zz~W2?C5bOV`!La2{p9;H=N#b;R({~4klf?=fD_;vc6;EDe?MuPAlsD0XK&z=o=Fiu
zS*_Gp*ao}AlMJlI^q9ChwN@wWnw5|%x(tR5Q)@~H@NrI-jE#|`cH%#ule7_yL3sgv
zF_(`VMq&I)W7k3jH*?PP%U9tpWz(*GXdppLux+5RzunBPi_hK!phi^yQbd*T!6r4N
zW*`{49Cv<GE&0b!#VXJ7KHgoYrGz^Fx_0P`{c<S0M87IvJQY;F8)*mJy+_(c%U~u~
ziueVRqo)!|&_2vbdMF;CxsP5Y-Tn8<oEo9)p)*BQblB2ZIG#!p*MNXpYv5j#^_+OM
z{Qcw}@oL&$vXz6Kq{G4PuKW|EKrrG3OsGw~hN5#8Sbah?##CGtX-sSvbMHNHx#js@
z%&US|h0%ArMP0j2%5?^W7l%RjW=Yz7Qa-rxG4wyk4-D^8R6t>L-}eq~Shbqbt9b7y
znRJ~ZEw5JX#&_b?MGD#f(RFK4_o#^QD{5AjX8YJp4#Y-PY%H1=o*of{3=NYQ2yg*5
zN+69DMe{*NR8JE)D|P$RC=;N4%i9lXw*=ByYDa|ao+gMy`$PhLg(DQ>-%0mC9+bAK
zKM(BYi>06ElJqh4XPt#!UQ7X|15k@+fi5BMFIvL4+R0U}%?NK+^2Vi_Mn7v7N0RtS
zm=j^v*X!jE3uI%mCLmou!jKC`0rJZ|Fl{Kl*C#|_56Uu71Fj%mAH4C6l}o$n>B>)f
zE(GoGOEJZNynr?zYiWs(coF~!n{k}3t@#!v8gmhN`!1+JWUW;f4}H4*X&%U{C1oXT
zZmHHgK%0F3Nb%74zI&@!CV@Bq5GF`j)~%j{oSR(pz-_)227p#Bs%JD52u{R<@A*F9
zr0=NSYVzHjxqX;Rh;sa(51_kl7IVW0s~_Y7H{|M@gd&TacEcgqn4E@FX#|2Vm)r}-
zG6(thG&uFvT;E=S!;%0}jlX$=6qN2lT!w4~r&zZ@yN4F8hfyD8|L)Uyh_EtYD3F@5
zqS^`ZB`b_08{-Cn>Eg2wXS#6Q1*YY2rvNIzm~G7PxI!#e+-Ew4(`(*klc+k{pWcOr
zC0JrO;bgK$-`vNI3ku^Crq*dV<qk+rhbwpMsqXZ2MG|Ghn-R3D0>!{R+d6;{q};_}
zO?z5+xpfgv!0?_aZ7t}yuzK)PFC&D+2`v^JUKJ-zoX{Qi!|1-9OEKx;#pjfcfC?XQ
zw|b_jygpq*d&gR^?jjpLoYfx9r%8K1T5^Rm#yRm0*7=~*LVP4NXD{;SQFalkQ#7Ai
z6P-MsA3&nV$L8Ea{elXX-O7Y7587WEvS^BN7STaK&SE+)z!&(KpBcT7C=o;$)tuYu
zMRoDqi*i-!gv+N(T;eUTKYr`Na_0xD)*ia0Olomn_z75xV6-MRlsf`I&FgtX8rpqT
z0Y`<vjYrH<THL+VS%WagMF*(|stDdex|4n(2D%<|Wkhs1z3@ysl3|%x!fk>@;X5vc
z!Xl!Onw%=^@hj@FjqE`1y}B9m8%5%?+T;E-2|83a$v%;}cxha*o!`x_bhMyKpbHf_
z#B(qo<=e3}p?`bghSzIU03U*$b@|3)ZGe@r%at&C^vh2Zxm8lrKa0vbs!}F{>c@k)
zhW|nl1?6C0#h`_NKp<z^WApT4?(cCImlKhT)SRQ#ZfWcSe<65;c1P(ti2fi5rp-7X
zo586W(*h*BD;nNxwz^5;US6syb87+Tyl9Mk$a1s>-WOs<>_T`Z=nSJFMENWC`etxq
zWB;6YT_N=!st3&l*Add=moT_T6&*nXOtl@=>r;qb+T)LKGWQ~Y1841l{OPipm!Fxp
zco#l>b=#tRN(O_o*rqRXaJs_&suZ+Fep+8M0=j`X;H&^foN4)Se9sho2@d;>9+r!m
z%<(4*bYHYBX0xcJpu&1Gc<W7SZP(<}lTFTMi9O|m;(<4*08zb2Ct!ck1Aj#a;FQ+6
z<8kBnz`%Z1{Vtxu?CJ_XXZGX@i5B1UoSR7o*Ebe>7o@&;AHpRIDsxwS)4Ht{s`jE;
zJ?wFf)}y!n4M<!SSg(x=)%x{a?06Kg>^#ozA36?!k;abKpQC;&ZFk_ZDK$CGe%@1!
z<v2ULwX=+u6eVjCPe_v>6cOf-0+83j<SMA8)rqS+T>3FCy5P3Yj6Q4*ZOtQ=Sx*Dj
z@h{zJ!9tRgeej<bZiLIHep?j|T<>dPq!FEF*sl_>bkv(oF~aGn5LPr=)o*P%4F}A(
zs*U09+{Gl+z-8U3*LFc?e0?%Ux;oZEKQ9#*;f~j8@AX(8wn!w=gMED>g|;B>HLY(Q
zzVCNH0p-vZadp>HlOJuRQZRx*o{zc*UwnrkXbf_7r%Hp@9SwM;THKM-vNoGHDt{Yk
zsUm%Rl%n{St?~Ol+;t^s<W8e?w1%HHP5o>SIyuN{XRqi9j|8o<uu7wy!RI?J)*Db9
zy{0ybzkU4`nJ~uUui@@y@nMv2Tf{GBzYfyzvk0<C2tGl$g!vqj-rp3^YdF<)TEEd*
z><4!Prk(Xtr6tz6uU*fCTXzBM$Rseed2<i6wNzj^!??P$>b9&+x8?ZQ&A7<eMKAaz
zrq0R+#CPTn26qLRw>+ijitv$XSkPi6_nCOUXzUHk60i2|`aQdb)Cnidj`N&9XLGf{
z=r&HbaF(o=vGxJ~x^H2JQL&D1dE8jNb!V*>hH6L!^s0u0kPqn<Z!lMOgfj<qn~|6M
zA`lg&DnU^0qcv?@<P-0;qIGj7?|yUcwJ>H1Yt!I#tBwJH?&g{gSL#}G<W+@q{H%zc
zS*xY~uCy;2ad~$hBQ-UiZGAn`68u~I7G*nO%yr1BGGg)lJE0T2W?1vK2io=M3%_ts
zal*iOCBzyA2?w^LE3Knal{#6{JoyLWRgV3vKSQbAy%IT(kw1IU=AlmN84ow6AM02L
z{A=d7&H{}s<X`tuH5wbY@5Y7!9qvBVHZut&xsCseF8H0BmOC~UqA_CsLN<?g+GLNO
z1~AfK9|v^N7|WE6vV)76k^f==u*`9{8LYk1rlgHXXyj86(O8%{(I58)fBs;9e_h6n
z-nQ+PVZAvaecl^-*VaPHrmyiD^3SDLRoh;9M+nirxv!mSRrX>dXp53l@>Js3dEBt5
zJ6uCt1n2WRfZ-~cDIKE2N-Zi&>xKZ?X>3#COaoZt73HZpVG6(2OCSIC#8%pVF8>cN
zv6z#S<13ZiayA&UmIs#DErPosBwxCI#;lvcZ5yQD+F#?Xt{@h?fRtlZ-pBSaUI|Sb
zo$uAV3NO++)S$CV<DOdUlfgf!2;OxGkynOhG0Q*eKq*g?_lo@0a5e4@NL(b+0B>4o
zE4oMIIl0YBT;vrHuubF-q30sIgli(H!X5wZr64b0*SZm;ISZ#GA`)k03c$vSh!m&)
z+p|x1sBV)Ixp?BgU*dnC-ru{P97c(VoRmjOiu`pJC@OL}d$&#1KkPUmbY)_nxT=WA
zj(__rK)Ctf|8Gm6qpk@W9n|%dnvVIY`ozh&4=g&S(X;jK%}9Ts#d85^p)Z7fQ}vs8
zc17>s1xcoPN-yorcQiIBZ&kLlo>lxzpE@vJ8L<&Bq5SELpAd%o80r8#&nA$aGuksw
zxxAS;_Wl@oT2{HUw&Ux4^M#+a{;h)2_QArjj5;(oKIdymuQ@_bR($q_P}}<6s+XSN
z%sRIQJw2;&^EJD~>oeb9U1v<o08Gvr%%{42fXDE)C6H|=6%L{5`ZVHI&o}Kh$t<&n
z0ghkTi!x~qes{;O+2E}k07W_r)FEBFq;j~<bqk%TjSc8KmX(5i>o%uUfA`hlSdxCc
z7H%I>vIT<?jxloXUq*c*72xnu7njhqZp$0-B?>4t%W<tP=>0aBa)*N?HVY&^HSq;>
zlIL?dGVsXq%EK{e+d25D7q`4ZujY1IPUDfK$sJ=SOrkIkbSLwu-9pZ61%3I;=KZZb
z-MzYX*zjbM-l4#NmCS_QdFI#Ru*1lSEGHcQY=d5s%x04NKvBrjheKsQt)r`litLxH
z)691GT4vB(8qIy$KNpTxs<ej3A=c#<sY6od28Qn=OXGqY`@*fen~HuqsIPfLoA5Ie
zCU;JyH_R85ZzK&EM@|Ja=g1Prq_C#PgI?b=**2e2ot^3YF>WVuNFmq`__#Z=*8-~i
z0+(}Sqtl4~pg5}>R{JKwZYKOta$~pp8<m1KErUK>cybm`II>|_nH3OB+)BDw>j83y
zJ-TfZj5<H?NFiB_>Es{edP&O*94Wx8lXnq2GuU+&uY01zoPV5`zSWUE7<0-B&8Ki~
zSYCbK?XW#QcL;MxA>BJP#Shy_hG*;uT-<zg9ucr;oaZ-j8??_lI(5#e-@vue&FzB<
zz|&!7UtM4G-1;N{(>2w1Vt=VgqKv~p2Mv}hA5ma9KV^Jt`Tz#TW!gq=S+^GcL!@|M
zq`w39&#H)63!u(xiumjuIp7BK45t1FMoV+ArQh)MU(|!B8m^Z75rvI5+uRE-mum-d
zO3{`f*_nznUI^Of8fQK_?)3guHRSM9mUhphM+nNk75fF)B@X(^Q`xu%s59{PNZ;|0
zH(3?mF;d$5ud5a0l<ET_(!HKF?!WT!wxUtuRuFV7w?NmR5+4o|&8x6AVI~hcy;76A
z7EZu3L+f#^M+!zj<>3~Y6(wj3St#{x<ON{&?kBn%a;{4@PR@a7DH}6<;F^;>YO=uk
zar}<JzGD|-%e^vPzpHh_f%e;1hhk(|MiB_)j~}fS?JUX=@Ag0Bt(mM_$PQ>6?GAOp
zod6`?EAU(=%1uH}fC9nK;5_lbfOFAHdwM2rD-t|{tT1!dXsrt&ANW3eOelHXn=4;~
zG$yB50T*z(fSifW>-n5x^CwKC5|0~iN)c}c7I=MSsX=+A6PtInHrVHSOAW;r2euyg
z^jo%;wRC=hJBsO1a__J7ecVWTAY|WPhr19xD_&9eqf|}c*7DgM@?3zyqYCRLhi90e
z0*+hhi+X;hsJmBm@>||s6zN5gkkz%9B7POsli!J5Y_^hvtWF5?)2Ddr$=_~u?jcJw
z=Sc(a?NHr4rmgijp*|^MunM3@Y2xpK>m|K7ejg$8*IfpEW%VAZs~=GbY<<7OQQYYR
z=8&m6d-IRgtt0j4sRr0}zr!fc4;ra6Or)tKaeMtC6ebh6cD!rOLCxEBNxU){_*k8<
zQc!2!wSddyq>n7z4NCY7j#4_~?!>$Dx=2ovy{YI&=q5*Ij^LPwU(Eat{Glxi4S<pB
z2hfrBrisiZ=Y*O?zc^Xq#Lvu;dfiqY+^%Nf@X`49J8}Y!y_Cqvo($<LEq3~Xsd`-m
zf1VFx9Uk?DMjNZEEk33+nN$H#rlOcP$Q;<+10CwAy*3&xa{6mu$7a+iwt6L?eRV%b
z=IVU-R!pAr;h-?+*n*Z+`u%Oqv*pPq=)-1t2^F%LE2c?DI$2my3+bsaP^CnQ3>nMb
zJjSt*9Xkiqxwv#pG4`_Ol?$r-yfB8cdbObUEWalo&{D)IV-L9x7x_PlqQ(j5?(Sqy
z;OzU;_ERB!(6$MVHBof<>BxF|kp3}1ZK<oIjUw{m*H@G_jvYB5&Z>!j{!raJa+v}O
zo165kf-gQ@?Hc%<jFxl?t+6Ud`XC!+B4lS8aYjc9RFIm!gBs%1xu9o%Uhb(R)@4TZ
zUX|li!Q-TD+|59=A19?=l-`Z2JqOIS*debjn6S|azZIAT@}f>(cM`G)q5llgGE!0h
zP@z*VMs6~A<52t4@*v=C8lQ1pBW<GL<p}&;;~3q(G5D3N!L<~}83nAysxZhV>OrFJ
zE%#k_5C)})A4c^70d;=m4@K3l2Xdm*Yqrn!qg+{Pa$%uI0t4kb+X?w#pqg^217qvG
zZpf@l|H0IejZ5{oaoV>D&<%3AFa~t*9je7@276Fn$evgAmGrMXw!rpG-Ay*oKlWr>
zw)HQ}@xKXGVDga@@iSj^;7n>q^I%es&VfrXFZvEZs-VF5`F5oVLGW5<%<ryi^ikPY
z4)vE10KE|&a8-bwu+gRMK}p*H12skWNFD_oK!J#E;;Ml2Kpg-Qg_g7dW`q2JqI<0O
zpg;$aZ6Gz|pC6k$#*>+5gWveGKfk9^<7d8hZFR*Zu*MH}2<{h;QH~diR~wov;S(T<
z-}Cn{2R!p`NNlhsv5<%*zP0aa&DcLX{`Hx2eHnLcWv3spt>ftYpaqNhM{D>!R6&D=
z3#$a=|DasREe>tuN;fX#79E+R>UeL+6|@I_kV({@(3w;YOHRcVqqe(7#_sG4^DH<U
z8cP%66SLeH7ht;jcJL4Jm|2Adc%a9p=eVwY{b8x<H!2Io(YiO4&gHthJm{VZ7PBRP
zq+NeEP~a~<oBhse?(Zzi(N5RnvVBtT#x8g}Jj>Pl)VMv6ge%_ZoCdeU2ZHxt?15e-
zmih10GZc2yDqsE`!*JSL=gK>dF@4N-tSi@gQ|eaMEnZzy;fM*6Hw!rzNp-XItyG{)
z1YO1&TT-qp3JKMTBFe;Hm}&l`7?PL4jh!ZgZMk1tJL3Jawp(m=Th#QZcMO&3GaZhH
z&{YDfwt8It^!~DNwZE(I=`gMsdC*iM;}W9?ekTGJh4Q_kDM>t3uZY5kpy)U0iguq8
zZo$2c9_zw+4OHLoUh*a3S6D*#N|PTpK+J3c<vgD0^5+gmfS=5GuGe@y`!<Cc=iJ>%
zoRHAU-zhG9U80wh<Em+A4UL3FjqUW$0+nODP@%27YD>>E+`DXV#^uDG#*t{k4$8OI
zO#hm&*M3@n+R%u)iLw_r^k1~}oj!diEPB>UamsM`&Tg86boz}siXZF8Q*wz1CgGNa
zq!0VxSZP{N(BUaWXtvd7&zrQz#zr2NCA-M-3&}Y_dJ=vIP-xwBqPk#6-d)qi6JlZV
zgCR|3wOn`DUX2JopnuLULlPcKnZ9!fqBAtTg*J*|7uiL^_LOBiG>Ld1-SjVcuGNg)
zF%#=3jYCt8`QO-myEo|x){+8Y87}T)o`13%z2i%m_^haml+B*|TUgL8a(=v--glY7
zyEko4ynj|VWoq+%^tt|K_cXCsFfV({Dl}I4=Gxx!?82K4)E4X4g8{W)NB~SirtjKM
zk2Q`J@*p*D|1JXy;@BCZK$a|A(l|$WZ0$w$Zb-+bT|*kX`(>a4^4kh<>*~d>FQyd6
zcw>q?X+sLehCX9E^C#rry7`)Wt_Gtf^zt%cVdvx)5xEzQ=W^ZIn^5PNDB=PtKyjyN
z401<?T_1VqubIyz_hm*g4OITL!TOeZiDI-1V>H_G><I=t0S(I#y%LHl^vB<#DAv!B
z_LDjKZeQBw>;m5HlJSQ;tGxK6El9yv*SOfTTp{1oL-|*KQw5lxk|ln8^vTJNuQ2SQ
zIfcWpIE?(v3eahFNnwQi<H8CyChD!gCjmj|#dK>*hWP<xo40s%7U-mh7QniowBj!;
zV_oLp{nEJ{MOyUL>at@tlEfl+@NI|WSSyNht(!t1(_UB41v9j3$Dl9+k8&?}xCo0(
z=xtCo&%e>z4Rsi4e8I0rvUB+AETvJDE)`HVWJS%K7_@&ZneWzN6K-_^lLl%DgyzI>
zh2M=iNlV`m7@iWxPWh>BVx)>ZXs)|U7$9{iqMag{e>clr4WJResEIVHODnOwvMJYW
znAxkaI%m#JDD=T(2Hyr`lJ`h2dU&qZ)Li6hC%#Ni@B64_b96rdy`pQlE({GO#(^vx
z4~F(3H68fNj<=T_xvAR>MBSZ+DSB3NNT)YO2wuBlFu%;T!=MH_UXr&p)&w2Z+Lb><
zRCQ<)zY3X3J52?h<_=0JXeBJh^oUzLrwiXn?bo?qt|z=!#O_mMA)|nNypuRKIR7`*
zXL?;*Eao;YSH4Wrf2ww3=+V3*OtkW(jp(9ZU*;$k9)=9vxEDv3D|?l=dQ|^$Ln9yv
zI(l_`k2v%ELg#!Q_-U1}b~*1yonPv&_ZkJA_HB)CA=+FHEAV4$tc__b9k)KVAqL8=
z*)bbFlmA^Rr(mY?A_9x69k@rUpP<PGsc!6STEn~F3@)<*4onmxFD_czp(x0S_J*K$
z>Zi3%+cQ!;2Jd}*yeogCKC84wViqt(4*me_lOdL`c+at2TP%!h7KZ|a?`8~ufO8EG
z!W2=}!G1mc_rwERCp@CRms8_BGwd2Nqp8A6aWd}haa;Sp7-^0Jo6PW}s4*G=2ndN>
z0JU`UGf%Tf+E}sS@L|efkJhT{*7Ch_(9_~BeqdB~=dGF?lD}AtQz)YaeO0j6BM6?}
zcGq~LJ3AmN?(GSwbBF5PzRRIb;Tl0SmFK$P0l44x+1*7`zSc`0s_uIQ%3Wcnoz4Q-
zJ2eJI{_$*W=kVz4!qWqXY+H2=gn;rSS@huu{!><k7JEWYIORuf`#(ZA{Lk<s{{w8s
z|6Ss<6_J0=&ix3`5)pYW^FKfjP3%D}mxRyl5%~)`CZUSJ$%y<l3jURoQ+VUK5R{O7
zy7o`<iTlu6n5O>)?&<&8*#2kyT7vj&W<d{ER73<f>`5=63nXH}tM5i%wYUlYhe5>t
MoQqAP)#bnc6ZtIyCIA2c

literal 0
HcmV?d00001

diff --git a/filter/wiris/integration/lib/com/wiris/common/WInteger.class.php b/filter/wiris/integration/lib/com/wiris/common/WInteger.class.php
new file mode 100644
index 0000000..6cc645c
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/common/WInteger.class.php
@@ -0,0 +1,62 @@
+<?php
+
+class com_wiris_common_WInteger {
+	public function __construct(){}
+	static function max($x, $y) {
+		if($x > $y) {
+			return $x;
+		}
+		return $y;
+	}
+	static function min($x, $y) {
+		if($x < $y) {
+			return $x;
+		}
+		return $y;
+	}
+	static function toHex($x, $digits) {
+		$s = "";
+		while($x !== 0 && $digits > 0) {
+			$digits--;
+			$d = $x & 15;
+			$s = com_wiris_common_WInteger_0($d, $digits, $s, $x) . $s;
+			$x = $x >> 4;
+			unset($d);
+		}
+		while($digits-- > 0) {
+			$s = "0" . $s;
+		}
+		return $s;
+	}
+	static function parseHex($str) {
+		return Std::parseInt("0x" . $str);
+	}
+	static function isInteger($str) {
+		$str = trim($str);
+		$i = 0;
+		$n = strlen($str);
+		if(StringTools::startsWith($str, "-")) {
+			$i++;
+		}
+		if(StringTools::startsWith($str, "+")) {
+			$i++;
+		}
+		$c = null;
+		while($i < $n) {
+			$c = _hx_char_code_at($str, $i);
+			if($c < 48 || $c > 57) {
+				return false;
+			}
+			$i++;
+		}
+		return true;
+	}
+	function __toString() { return 'com.wiris.common.WInteger'; }
+}
+function com_wiris_common_WInteger_0(&$d, &$digits, &$s, &$x) {
+	{
+		$s1 = new haxe_Utf8(null);
+		$s1->addChar($d + ((($d >= 10) ? 55 : 48)));
+		return $s1->toString();
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/Cas.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/api/Cas.interface.php
new file mode 100644
index 0000000..49444f8
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/Cas.interface.php
@@ -0,0 +1,7 @@
+<?php
+
+interface com_wiris_plugin_api_Cas {
+	function cas($mode, $language);
+	function createCasImage($imageParameter);
+	function showCasImage($formula, $provider);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/CleanCache.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/api/CleanCache.interface.php
new file mode 100644
index 0000000..60cf124
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/CleanCache.interface.php
@@ -0,0 +1,7 @@
+<?php
+
+interface com_wiris_plugin_api_CleanCache {
+	function getContentType();
+	function getCacheOutput();
+	function init($provider);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/Configuration.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/api/Configuration.interface.php
new file mode 100644
index 0000000..536999e
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/Configuration.interface.php
@@ -0,0 +1,11 @@
+<?php
+
+interface com_wiris_plugin_api_Configuration {
+	function setConfigurations($configurationKeys, $configurationValues);
+	function getJsonConfiguration($configurationKeys);
+	function setInitObject($context);
+	function setProperty($name, $value);
+	function getProperty($name, $dflt);
+	function getJavaScriptConfigurationJson();
+	function getFullConfiguration();
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/ConfigurationKeys.class.php b/filter/wiris/integration/lib/com/wiris/plugin/api/ConfigurationKeys.class.php
new file mode 100644
index 0000000..59b1632
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/ConfigurationKeys.class.php
@@ -0,0 +1,85 @@
+<?php
+
+class com_wiris_plugin_api_ConfigurationKeys {
+	public function __construct(){}
+	static $DEBUG = "wirisdebug";
+	static $FORMULA_FOLDER = "wirisformuladirectory";
+	static $CACHE_FOLDER = "wiriscachedirectory";
+	static $INTEGRATION_PATH = "wirisintegrationpath";
+	static $EDITOR_PARAMETERS_LIST = "wiriseditorparameterslist";
+	static $STORAGE_CLASS = "wirisstorageclass";
+	static $CONFIGURATION_CLASS = "wirisconfigurationclass";
+	static $CONFIGURATION_PATH = "wirisconfigurationpath";
+	static $CONTEXT_PATH = "wiriscontextpath";
+	static $SERVICE_PROTOCOL = "wirisimageserviceprotocol";
+	static $SERVICE_PORT = "wirisimageserviceport";
+	static $SERVICE_HOST = "wirisimageservicehost";
+	static $SERVICE_PATH = "wirisimageservicepath";
+	static $CAS_LANGUAGES = "wiriscaslanguages";
+	static $CAS_CODEBASE = "wiriscascodebase";
+	static $CAS_ARCHIVE = "wiriscasarchive";
+	static $CAS_CLASS = "wiriscasclass";
+	static $CAS_WIDTH = "wiriscaswidth";
+	static $CAS_HEIGHT = "wiriscasheight";
+	static $SHOWIMAGE_PATH = "wirishowimagepath";
+	static $SHOWCASIMAGE_PATH = "wirishowcasimagepath";
+	static $CLEAN_CACHE_PATH = "wiriscleancachepath";
+	static $RESOURCE_PATH = "wirisresourcespath";
+	static $LATEX_TO_MATHML_URL = "wirislatextomathmlurl";
+	static $SAVE_MODE = "wiriseditorsavemode";
+	static $EDITOR_TOOLBAR = "wiriseditortoolbar";
+	static $HOST_PLATFORM = "wirishostplatform";
+	static $VERSION_PLATFORM = "wirisversionplatform";
+	static $WIRIS_DPI = "wirisimagedpi";
+	static $FONT_FAMILY = "wirisfontfamily";
+	static $FILTER_OUTPUT_MATHML = "wirisfilteroutputmathml";
+	static $EDITOR_MATHML_ATTRIBUTE = "wiriseditormathmlattribute";
+	static $EDITOR_PARAMS = "wiriseditorparameters";
+	static $EDITOR_PARAMETERS_DEFAULT_LIST = "mml,color,centerbaseline,zoom,dpi,fontSize,fontFamily,defaultStretchy,backgroundColor,format";
+	static $EDITOR_PARAMETERS_NOTRENDER_LIST = "toolbar, toolbarHidden, reservedWords, autoformat, mml, language, rtlLanguages, ltrLanguages, arabicIndicLanguages, easternArabicIndicLanguages, europeanLanguages";
+	static $HTTPPROXY = "wirisproxy";
+	static $HTTPPROXY_HOST = "wirisproxy_host";
+	static $HTTPPROXY_PORT = "wirisproxy_port";
+	static $HTTPPROXY_USER = "wirisproxy_user";
+	static $HTTPPROXY_PASS = "wirisproxy_password";
+	static $REFERER = "wirisreferer";
+	static $IMAGE_FORMAT = "wirisimageformat";
+	static $EXTERNAL_PLUGIN = "wirisexternalplugin";
+	static $EXTERNAL_REFERER = "wirisexternalreferer";
+	static $IMPROVE_PERFORMANCE = "wirispluginperformance";
+	static $EDITOR_KEY = "wiriseditorkey";
+	static $CLEAN_CACHE_TOKEN = "wiriscleancachetoken";
+	static $CLEAN_CACHE_GUI = "wiriscleancachegui";
+	static $imageConfigProperties;
+	static $imageConfigPropertiesInv;
+	static $SERVICES_PARAMETERS_LIST = "mml,lang,service,latex";
+	static function computeInverse($dict) {
+		$keys = $dict->keys();
+		$outDict = new Hash();
+		while($keys->hasNext()) {
+			$key = $keys->next();
+			$outDict->set($dict->get($key), $key);
+			unset($key);
+		}
+		return $outDict;
+	}
+	function __toString() { return 'com.wiris.plugin.api.ConfigurationKeys'; }
+}
+{
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties = new Hash();
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("backgroundColor", "wirisimagebackgroundcolor");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("transparency", "wiristransparency");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("fontSize", "wirisimagefontsize");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("version", "wirisimageserviceversion");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("color", "wirisimagecolor");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("dpi", "wirisimagedpi");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("fontFamily", com_wiris_plugin_api_ConfigurationKeys::$FONT_FAMILY);
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("rtlLanguages", "wirisrtllanguages");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("ltrLanguages", "wirisltrlanguages");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("arabicIndicLanguages", "wirisarabicindiclanguages");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("easternArabicIndicLanguages", "wiriseasternarabicindiclanguages");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("europeanLanguages", "wiriseuropeanlanguages");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("defaultStretchy", "wirisimagedefaultstretchy");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->set("parseMemoryLimit", "wirisparsememorylimit");
+	com_wiris_plugin_api_ConfigurationKeys::$imageConfigPropertiesInv = com_wiris_plugin_api_ConfigurationKeys::computeInverse(com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/Editor.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/api/Editor.interface.php
new file mode 100644
index 0000000..8e0e7fb
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/Editor.interface.php
@@ -0,0 +1,5 @@
+<?php
+
+interface com_wiris_plugin_api_Editor {
+	function editor($language, $provider);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/ImageFormatController.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/api/ImageFormatController.interface.php
new file mode 100644
index 0000000..f94abe7
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/ImageFormatController.interface.php
@@ -0,0 +1,6 @@
+<?php
+
+interface com_wiris_plugin_api_ImageFormatController {
+	function getMetrics($bytes, &$output);
+	function getContentType();
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/ParamsProvider.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/api/ParamsProvider.interface.php
new file mode 100644
index 0000000..825b6f7
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/ParamsProvider.interface.php
@@ -0,0 +1,9 @@
+<?php
+
+interface com_wiris_plugin_api_ParamsProvider {
+	function getServiceParameters();
+	function getRenderParameters($configuration);
+	function getParameters();
+	function getRequiredParameter($param);
+	function getParameter($param, $dflt);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/PluginBuilder.class.php b/filter/wiris/integration/lib/com/wiris/plugin/api/PluginBuilder.class.php
new file mode 100644
index 0000000..08e52a1
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/PluginBuilder.class.php
@@ -0,0 +1,76 @@
+<?php
+
+class com_wiris_plugin_api_PluginBuilder {
+	public function __construct() { 
+	}
+	public function getCustomParamsProvider() {
+		return null;
+	}
+	public function setCustomParamsProvider($provider) {
+	}
+	public function newGenericParamsProvider($properties) {
+		return null;
+	}
+	public function getImageFormatController() {
+		return null;
+	}
+	public function isEditorLicensed() {
+		return false;
+	}
+	public function newResourceLoader() {
+		return null;
+	}
+	public function newCleanCache() {
+		return null;
+	}
+	public function addCorsHeaders($response, $origin) {
+	}
+	public function newEditor() {
+		return null;
+	}
+	public function newCas() {
+		return null;
+	}
+	public function newTest() {
+		return null;
+	}
+	public function setStorageAndCacheCacheFormulaObject($cache) {
+	}
+	public function setStorageAndCacheCacheObject($cache) {
+	}
+	public function setStorageAndCacheInitObject($obj) {
+	}
+	public function getStorageAndCache() {
+		return null;
+	}
+	public function getConfiguration() {
+		return null;
+	}
+	public function newAsyncTextService() {
+		return null;
+	}
+	public function newTextService() {
+		return null;
+	}
+	public function newAsyncRender() {
+		return null;
+	}
+	public function newRender() {
+		return null;
+	}
+	public function setStorageAndCache($store) {
+	}
+	public function addConfigurationUpdater($conf) {
+	}
+	static $pb = null;
+	static function getInstance() {
+		if(com_wiris_plugin_api_PluginBuilder::$pb === null) {
+			com_wiris_plugin_api_PluginBuilder::$pb = new com_wiris_plugin_impl_PluginBuilderImpl();
+		}
+		return com_wiris_plugin_api_PluginBuilder::$pb;
+	}
+	static function newInstance() {
+		return new com_wiris_plugin_impl_PluginBuilderImpl();
+	}
+	function __toString() { return 'com.wiris.plugin.api.PluginBuilder'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/Render.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/api/Render.interface.php
new file mode 100644
index 0000000..c60d2ef
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/Render.interface.php
@@ -0,0 +1,10 @@
+<?php
+
+interface com_wiris_plugin_api_Render {
+	function computeDigest($mml, $param);
+	function getMathml($digest);
+	function showImageHash($digest, $lang);
+	function showImageJson($digest, $lang);
+	function showImage($digest, $mml, $provider);
+	function createImage($mml, $param, &$output);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/ServiceResourceLoader.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/api/ServiceResourceLoader.interface.php
new file mode 100644
index 0000000..4cb873c
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/ServiceResourceLoader.interface.php
@@ -0,0 +1,6 @@
+<?php
+
+interface com_wiris_plugin_api_ServiceResourceLoader {
+	function getContentType($name);
+	function getContent($resource);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/Test.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/api/Test.interface.php
new file mode 100644
index 0000000..dc4e532
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/Test.interface.php
@@ -0,0 +1,5 @@
+<?php
+
+interface com_wiris_plugin_api_Test {
+	function getTestPage();
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/api/TextService.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/api/TextService.interface.php
new file mode 100644
index 0000000..ce51cc5
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/api/TextService.interface.php
@@ -0,0 +1,10 @@
+<?php
+
+interface com_wiris_plugin_api_TextService {
+	function filter($str, $prop);
+	function getMathML($digest, $latex);
+	function latex2mathml($mml);
+	function mathml2latex($mml);
+	function mathml2accessible($mml, $lang, $prop);
+	function service($serviceName, $provider);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/AsyncRender.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/AsyncRender.interface.php
new file mode 100644
index 0000000..102f44a
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/AsyncRender.interface.php
@@ -0,0 +1,7 @@
+<?php
+
+interface com_wiris_plugin_asyncapi_AsyncRender {
+	function getMathml($digest, $call);
+	function showImage($digest, $mml, $param, $call);
+	function createImage($mml, $param, &$output, $call);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/AsyncTextService.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/AsyncTextService.interface.php
new file mode 100644
index 0000000..ff70bf4
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/AsyncTextService.interface.php
@@ -0,0 +1,6 @@
+<?php
+
+interface com_wiris_plugin_asyncapi_AsyncTextService {
+	function mathml2accessible($mml, $lang, $prop, $response);
+	function service($serviceName, $provider, $response);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/BytesCallback.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/BytesCallback.interface.php
new file mode 100644
index 0000000..deb53c5
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/BytesCallback.interface.php
@@ -0,0 +1,6 @@
+<?php
+
+interface com_wiris_plugin_asyncapi_BytesCallback {
+	function error($msg);
+	function returnBytes($bs);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/StringCallback.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/StringCallback.interface.php
new file mode 100644
index 0000000..97564a9
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/asyncapi/StringCallback.interface.php
@@ -0,0 +1,6 @@
+<?php
+
+interface com_wiris_plugin_asyncapi_StringCallback {
+	function error($msg);
+	function returnString($str);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/AsyncRenderImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/AsyncRenderImpl.class.php
new file mode 100644
index 0000000..db677c7
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/AsyncRenderImpl.class.php
@@ -0,0 +1,124 @@
+<?php
+
+class com_wiris_plugin_asyncimpl_AsyncRenderImpl implements com_wiris_plugin_asyncapi_AsyncRender{
+	public function __construct($plugin) {
+		if(!php_Boot::$skip_constructor) {
+		$this->render = new com_wiris_plugin_impl_RenderImpl($plugin);
+		$this->plugin = $plugin;
+	}}
+	public function getMathml($digest, $call) {
+		$s = $this->render->getMathml($digest);
+		$call->returnString($s);
+	}
+	public function onError($msg) {
+		$this->call->error($msg);
+	}
+	public function onData($data) {
+		$b = com_wiris_system_TypeTools::string2ByteData_iso8859_1($data);
+		$store = $this->plugin->getStorageAndCache();
+		$store->storeData($this->digest, "png", $b->b);
+		$bs = $b->b;
+		$this->call->returnBytes($bs);
+	}
+	public function showImage($digest, $mml, $param, $call) {
+		if($digest === null && $mml === null) {
+			throw new HException("Missing parameters 'formula' or 'mml'.");
+		}
+		if($digest !== null && $mml !== null) {
+			throw new HException("Only one parameter 'formula' or 'mml' is valid.");
+		}
+		$atts = false;
+		if($digest === null && $mml !== null) {
+			$digest = $this->render->computeDigest($mml, $param);
+		}
+		$formula = $this->plugin->getStorageAndCache()->decodeDigest($digest);
+		if($formula === null) {
+			throw new HException("Formula associated to digest not found.");
+		}
+		if(StringTools::startsWith($formula, "<")) {
+			throw new HException("Not implemented.");
+		}
+		$iniFile = com_wiris_util_sys_IniFile::newIniFileFromString($formula);
+		$renderParams = $iniFile->getProperties();
+		$i = null;
+		$ss = $this->render->getEditorParametersList();
+		if($param !== null) {
+			$_g1 = 0; $_g = $ss->length;
+			while($_g1 < $_g) {
+				$i1 = $_g1++;
+				$key = $ss[$i1];
+				$value = com_wiris_system_PropertiesTools::getProperty($param, $key, null);
+				if($value !== null) {
+					$atts = true;
+					$renderParams->set($key, $value);
+				}
+				unset($value,$key,$i1);
+			}
+		}
+		if($atts) {
+			if($mml !== null) {
+				$digest = $this->render->computeDigest($mml, com_wiris_system_PropertiesTools::toProperties($renderParams));
+			} else {
+				$digest = $this->render->computeDigest($renderParams->get("mml"), com_wiris_system_PropertiesTools::toProperties($renderParams));
+			}
+		}
+		$store = $this->plugin->getStorageAndCache();
+		$bs = null;
+		$bs = $store->retreiveData($digest, "png");
+		if($bs === null) {
+			{
+				$_g1 = 0; $_g = $ss->length;
+				while($_g1 < $_g) {
+					$i1 = $_g1++;
+					$key = $ss[$i1];
+					if(!$renderParams->exists($key)) {
+						$confKey = com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->get($key);
+						if($confKey !== null) {
+							$value = $this->plugin->getConfiguration()->getProperty($confKey, null);
+							if($value !== null) {
+								$renderParams->set($key, $value);
+							}
+							unset($value);
+						}
+						unset($confKey);
+					}
+					unset($key,$i1);
+				}
+			}
+			$h = new com_wiris_plugin_impl_HttpImpl($this->plugin->getImageServiceURL(null, true), null);
+			$h->setHeader("Content-Type", "application/x-www-form-urlencoded");
+			$this->plugin->addReferer($h);
+			$this->plugin->addProxy($h);
+			$iter = $renderParams->keys();
+			while($iter->hasNext()) {
+				$key = $iter->next();
+				$h->setParameter($key, $renderParams->get($key));
+				unset($key);
+			}
+			$this->digest = $digest;
+			$this->call = $call;
+			com_wiris_plugin_asyncimpl_HttpPostAndContinue::doPost($h, $this, "onData");
+		} else {
+			$call->returnBytes($bs);
+		}
+	}
+	public function createImage($mml, $param, &$output, $call) {
+		$output = $output;
+		new com_wiris_plugin_asyncimpl_CreateImageMethod($this, $mml, $param, $output, $call);
+	}
+	public $call;
+	public $digest;
+	public $plugin;
+	public $render;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.asyncimpl.AsyncRenderImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/AsyncTextServiceImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/AsyncTextServiceImpl.class.php
new file mode 100644
index 0000000..efbeedd
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/AsyncTextServiceImpl.class.php
@@ -0,0 +1,74 @@
+<?php
+
+class com_wiris_plugin_asyncimpl_AsyncTextServiceImpl implements com_wiris_plugin_impl_HttpListener, com_wiris_plugin_asyncapi_AsyncTextService{
+	public function __construct($plugin) {
+		if(!php_Boot::$skip_constructor) {
+		$this->plugin = $plugin;
+	}}
+	public function onError($msg) {
+		$this->response->error($msg);
+	}
+	public function onData($data) {
+		if($this->digest !== null) {
+			$store = $this->plugin->getStorageAndCache();
+			$ext = com_wiris_plugin_impl_TextServiceImpl::getDigestExtension($this->serviceName, $this->provider);
+			$store->storeData($this->digest, $ext, com_wiris_system_Utf8::toBytes($data));
+		}
+		$this->response->returnString($data);
+	}
+	public function mathml2accessible($mml, $lang, $param, $response) {
+		if($lang !== null) {
+			$param["lang"] = $lang;
+		}
+		$param["mml"] = $mml;
+		$provider = $this->plugin->newGenericParamsProvider($param);
+		$this->service("mathml2accessible", $provider, $response);
+	}
+	public function service($serviceName, $provider, $response) {
+		$this->serviceName = $serviceName;
+		$this->provider = $provider;
+		$this->response = $response;
+		$this->digest = null;
+		if(com_wiris_plugin_impl_TextServiceImpl::hasCache($serviceName)) {
+			$this->digest = $this->plugin->newRender()->computeDigest(null, $provider->getRenderParameters($this->plugin->getConfiguration()));
+			$store = $this->plugin->getStorageAndCache();
+			$ext = com_wiris_plugin_impl_TextServiceImpl::getDigestExtension($serviceName, $this->provider);
+			$s = $store->retreiveData($this->digest, $ext);
+			if($s !== null) {
+				$response->returnString(com_wiris_system_Utf8::fromBytes($s));
+				return;
+			}
+		}
+		$url = $this->plugin->getImageServiceURL($serviceName, true);
+		$h = new com_wiris_plugin_impl_HttpImpl($url, $this);
+		$this->plugin->addReferer($h);
+		$this->plugin->addProxy($h);
+		if($this->param !== null) {
+			$ha = com_wiris_system_PropertiesTools::fromProperties($this->param);
+			$iter = $ha->keys();
+			while($iter->hasNext()) {
+				$k = $iter->next();
+				$h->setParameter($k, $ha->get($k));
+				unset($k);
+			}
+		}
+		$h->request(true);
+	}
+	public $response;
+	public $provider;
+	public $param;
+	public $serviceName;
+	public $digest;
+	public $plugin;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.asyncimpl.AsyncTextServiceImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/CallbackImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/CallbackImpl.class.php
new file mode 100644
index 0000000..e3c65c0
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/CallbackImpl.class.php
@@ -0,0 +1,51 @@
+<?php
+
+class com_wiris_plugin_asyncimpl_CallbackImpl implements com_wiris_plugin_asyncapi_StringCallback, com_wiris_plugin_asyncapi_BytesCallback{
+	public function __construct($obj, $name, $errorName) {
+		if(!php_Boot::$skip_constructor) {
+		$this->method = Reflect::field($obj, $name);
+		if(_hx_field($this, "method") === null) {
+			throw new HException("Method not found: " . $name);
+		}
+		$this->errorMethod = Reflect::field($obj, $errorName);
+		if(_hx_field($this, "errorMethod") === null) {
+			throw new HException("Method not found: " . $errorName);
+		}
+		$this->obj = $obj;
+	}}
+	public function error($msg) {
+		$args = new _hx_array(array());
+		$args->push($msg);
+		Reflect::callMethod($this->obj, $this->errorMethod, $args);
+	}
+	public function returnString($str) {
+		$args = new _hx_array(array());
+		$args->push($str);
+		Reflect::callMethod($this->obj, $this->method, $args);
+	}
+	public function returnBytes($bs) {
+		$args = new _hx_array(array());
+		$args->push($bs);
+		Reflect::callMethod($this->obj, $this->method, $args);
+	}
+	public $obj;
+	public $errorMethod;
+	public $method;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function newBytes($obj, $name, $errorName) {
+		return new com_wiris_plugin_asyncimpl_CallbackImpl($obj, $name, $errorName);
+	}
+	static function newString($obj, $name, $errorName) {
+		return new com_wiris_plugin_asyncimpl_CallbackImpl($obj, $name, $errorName);
+	}
+	function __toString() { return 'com.wiris.plugin.asyncimpl.CallbackImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/CreateImageMethod.class.php b/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/CreateImageMethod.class.php
new file mode 100644
index 0000000..fd00099
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/CreateImageMethod.class.php
@@ -0,0 +1,91 @@
+<?php
+
+class com_wiris_plugin_asyncimpl_CreateImageMethod {
+	public function __construct($render, $mml, $param, &$output, $call) {
+		if(!php_Boot::$skip_constructor) {
+		$this->output = $output;
+		$this->step1_getMetrics_ = com_wiris_plugin_asyncimpl_CallbackImpl::newBytes($this, "step1_getMetrics", "step1_getMetrics_error");
+		$this->step2_getAccessibility_step2_ = com_wiris_plugin_asyncimpl_CallbackImpl::newString($this, "step2_getAccessibility_step2", "step2_getAccessibility_step2_error");
+		if($mml === null) {
+			throw new HException("Missing parameter 'mml'.");
+		}
+		$this->render = $render;
+		$this->digest = $render->render->computeDigest($mml, $param);
+		$this->metrics = "";
+		$this->accessibility = "";
+		$this->mml = $mml;
+		$this->param = $param;
+		$this->call = $call;
+		$this->step1();
+	}}
+	public function step3() {
+		$contextPath = $this->render->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CONTEXT_PATH, "/");
+		$showImagePath = $this->render->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SHOWIMAGE_PATH, null);
+		$this->call->returnString(com_wiris_plugin_impl_RenderImpl::concatPath($contextPath, $showImagePath) . rawurlencode($this->digest) . $this->metrics . $this->accessibility);
+	}
+	public function step2_getAccessibility_step2_error($msg) {
+		$this->step3();
+	}
+	public function step2_getAccessibility_step2($text) {
+		if($this->output === null) {
+			$this->accessibility = "&text=" . rawurlencode($text);
+		} else {
+			$this->output["alt"] = $text;
+		}
+		$this->step3();
+	}
+	public function step2_getAccessibility_step1() {
+		$lang = com_wiris_system_PropertiesTools::getProperty($this->param, "lang", "en");
+		try {
+			$this->render->plugin->newAsyncTextService()->mathml2accessible($this->mml, $lang, $this->param, $this->step2_getAccessibility_step2_);
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$ex = $_ex_;
+			{
+				$this->step3();
+			}
+		}
+	}
+	public function step2() {
+		if($this->param !== null && com_wiris_system_PropertiesTools::getProperty($this->param, "accessible", "false") === "true") {
+			$this->step2_getAccessibility_step1();
+		} else {
+			$this->step3();
+		}
+	}
+	public function step1_getMetrics_error($msg) {
+		$this->step2();
+	}
+	public function step1_getMetrics($bs) {
+		$this->metrics = $this->render->render->getMetricsFromBytes($bs, $this->output);
+		$this->step2();
+	}
+	public function step1() {
+		if($this->param !== null && com_wiris_system_PropertiesTools::getProperty($this->param, "metrics", "false") === "true") {
+			$this->render->showImage($this->digest, null, null, $this->step1_getMetrics_);
+		} else {
+			$this->step2();
+		}
+	}
+	public $step2_getAccessibility_step2_;
+	public $step1_getMetrics_;
+	public $output;
+	public $param;
+	public $mml;
+	public $render;
+	public $accessibility;
+	public $metrics;
+	public $call;
+	public $digest;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.asyncimpl.CreateImageMethod'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/HttpPostAndContinue.class.php b/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/HttpPostAndContinue.class.php
new file mode 100644
index 0000000..9925ac4
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/asyncimpl/HttpPostAndContinue.class.php
@@ -0,0 +1,42 @@
+<?php
+
+class com_wiris_plugin_asyncimpl_HttpPostAndContinue implements com_wiris_plugin_impl_HttpListener{
+	public function __construct($h, $obj, $methodName) {
+		if(!php_Boot::$skip_constructor) {
+		$this->h = $h;
+		$this->obj = $obj;
+		$this->method = Reflect::field($obj, $methodName);
+		if(_hx_field($this, "method") === null) {
+			throw new HException("Method not found: " . $methodName);
+		}
+		$h->setListener($this);
+	}}
+	public function onError($msg) {
+		throw new HException($msg);
+	}
+	public function onData($data) {
+		$args = new _hx_array(array());
+		$args->push($data);
+		Reflect::callMethod($this->obj, $this->method, $args);
+	}
+	public function post() {
+		$this->h->request(true);
+	}
+	public $h;
+	public $method;
+	public $obj;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function doPost($h, $obj, $methodName) {
+		_hx_deref(new com_wiris_plugin_asyncimpl_HttpPostAndContinue($h, $obj, $methodName))->post();
+	}
+	function __toString() { return 'com.wiris.plugin.asyncimpl.HttpPostAndContinue'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/configuration/ConfigurationUpdater.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/configuration/ConfigurationUpdater.interface.php
new file mode 100644
index 0000000..ecfeb5d
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/configuration/ConfigurationUpdater.interface.php
@@ -0,0 +1,6 @@
+<?php
+
+interface com_wiris_plugin_configuration_ConfigurationUpdater {
+	function updateConfiguration(&$configuration);
+	function init($obj);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/CacheFormulaImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/CacheFormulaImpl.class.php
new file mode 100644
index 0000000..7e8dd98
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/CacheFormulaImpl.class.php
@@ -0,0 +1,9 @@
+<?php
+
+class com_wiris_plugin_impl_CacheFormulaImpl extends com_wiris_plugin_impl_CacheImpl {
+	public function __construct($conf) { if(!php_Boot::$skip_constructor) {
+		parent::__construct($conf);
+		$this->cacheFolder = $this->getAndCheckFolder(com_wiris_plugin_api_ConfigurationKeys::$FORMULA_FOLDER);
+	}}
+	function __toString() { return 'com.wiris.plugin.impl.CacheFormulaImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/CacheImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/CacheImpl.class.php
new file mode 100644
index 0000000..0bdd27f
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/CacheImpl.class.php
@@ -0,0 +1,122 @@
+<?php
+
+class com_wiris_plugin_impl_CacheImpl implements com_wiris_util_sys_Cache{
+	public function __construct($conf) {
+		if(!php_Boot::$skip_constructor) {
+		$this->conf = $conf;
+		$this->cacheFolder = $this->getAndCheckFolder(com_wiris_plugin_api_ConfigurationKeys::$CACHE_FOLDER);
+	}}
+	public function isFormulaFileName($name) {
+		$i = _hx_index_of($name, ".", null);
+		if($i === -1) {
+			return null;
+		}
+		$digest = _hx_substr($name, 0, $i);
+		if(strlen($digest) !== 32) {
+			return null;
+		}
+		return $digest;
+	}
+	public function updateFolderStructure($dir) {
+		$folder = com_wiris_util_sys_Store::newStore($dir);
+		$files = $folder->hlist();
+		if($files !== null) {
+			$i = null;
+			{
+				$_g1 = 0; $_g = $files->length;
+				while($_g1 < $_g) {
+					$i1 = $_g1++;
+					$digest = $this->isFormulaFileName($files[$i1]);
+					if($digest !== null) {
+						$newFolder = $this->getFolderStore($dir, $digest);
+						$newFolder->mkdirs();
+						$newFile = $this->getFileStoreWithParent($newFolder, $digest, _hx_substr($files[$i1], _hx_index_of($files[$i1], ".", null) + 1, null));
+						$file = com_wiris_util_sys_Store::newStoreWithParent($folder, $files[$i1]);
+						$file->moveTo($newFile);
+						unset($newFolder,$newFile,$file);
+					}
+					unset($i1,$digest);
+				}
+			}
+		}
+	}
+	public function updateFoldersStructure() {
+		$this->updateFolderStructure($this->getAndCheckFolder(com_wiris_plugin_api_ConfigurationKeys::$CACHE_FOLDER));
+		$this->updateFolderStructure($this->getAndCheckFolder(com_wiris_plugin_api_ConfigurationKeys::$FORMULA_FOLDER));
+	}
+	public function getFolderStore($dir, $digest) {
+		return com_wiris_util_sys_Store::newStore($dir . "/" . _hx_substr($digest, 0, 2) . "/" . _hx_substr($digest, 2, 2));
+	}
+	public function getFileStore($dir, $digest, $extension) {
+		return $this->getFileStoreWithParent($this->getFolderStore($dir, $digest), $digest, $extension);
+	}
+	public function getFileStoreWithParent($parent, $digest, $extension) {
+		return com_wiris_util_sys_Store::newStoreWithParent($parent, _hx_substr($digest, 4, null) . $extension);
+	}
+	public function getAndCheckFolder($key) {
+		$folder = com_wiris_system_PropertiesTools::getProperty($this->conf, $key, null);
+		if($folder === null || strlen(trim($folder)) === 0) {
+			throw new HException("Missing configuration value: " . $key);
+		}
+		return $folder;
+	}
+	public function delete($key) {
+	}
+	public function deleteAll() {
+		$formulaFolder = $this->getAndCheckFolder(com_wiris_plugin_api_ConfigurationKeys::$FORMULA_FOLDER);
+		$cacheFolder = $this->getAndCheckFolder(com_wiris_plugin_api_ConfigurationKeys::$CACHE_FOLDER);
+		$includes = new _hx_array(array());
+		$includes->push("svg");
+		$includes->push("png");
+		$includes->push("csv");
+		$includes->push("txt");
+		if(!(com_wiris_system_PropertiesTools::getProperty($this->conf, com_wiris_plugin_api_ConfigurationKeys::$SAVE_MODE, "xml") === "image")) {
+			$includes->push("ini");
+		}
+		com_wiris_util_sys_Store::deleteDirectory($formulaFolder, $includes);
+		com_wiris_util_sys_Store::deleteDirectory($cacheFolder, $includes);
+	}
+	public function get($key) {
+		$extension = _hx_substr($key, _hx_index_of($key, ".", null), strlen($key) - _hx_index_of($key, ".", null));
+		$digest = _hx_substr($key, 0, _hx_index_of($key, $extension, null));
+		$store = $this->getFileStore($this->cacheFolder, $digest, $extension);
+		if(com_wiris_plugin_impl_CacheImpl::$backwards_compat) {
+			if(!$store->exists()) {
+				$oldstore = com_wiris_util_sys_Store::newStore($this->cacheFolder . "/" . $digest . $extension);
+				if(!$oldstore->exists()) {
+					return null;
+				}
+				$parent = $store->getParent();
+				$parent->mkdirs();
+				$oldstore->moveTo($store);
+			}
+		} else {
+			if(!$store->exists()) {
+				return null;
+			}
+		}
+		return $store->readBinary();
+	}
+	public function set($key, $value) {
+		$extension = _hx_substr($key, _hx_index_of($key, ".", null), strlen($key) - _hx_index_of($key, ".", null));
+		$digest = _hx_substr($key, 0, _hx_index_of($key, $extension, null));
+		$parent = $this->getFolderStore($this->cacheFolder, $digest);
+		$parent->mkdirs();
+		$store = $this->getFileStoreWithParent($parent, $digest, $extension);
+		$store->writeBinary($value);
+	}
+	public $cacheFolder;
+	public $conf;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $backwards_compat = true;
+	function __toString() { return 'com.wiris.plugin.impl.CacheImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/CasImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/CasImpl.class.php
new file mode 100644
index 0000000..b42b995
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/CasImpl.class.php
@@ -0,0 +1,155 @@
+<?php
+
+class com_wiris_plugin_impl_CasImpl implements com_wiris_plugin_api_Cas{
+	public function __construct($plugin) {
+		if(!php_Boot::$skip_constructor) {
+		$this->plugin = $plugin;
+	}}
+	public function htmlentities($input, $entQuotes) {
+		$returnValue = str_replace("&", "&amp;", $input);
+		$returnValue = str_replace("<", "&lt;", $returnValue);
+		$returnValue = str_replace(">", "gt;", $returnValue);
+		if($entQuotes) {
+			$returnValue = str_replace("\"", "&quot;", $returnValue);
+			return $returnValue;
+		}
+		return $returnValue;
+	}
+	public function printCASContainer($config, $availableLanguages, $lang) {
+		$output = new StringBuf();
+		$output->add("<html><head><meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\"/><script>");
+		$output->add("var lang ='");
+		$output->add($lang);
+		$output->add("/strings.js';");
+		$output->add(" ");
+		$output->add(" var scriptsrc =  window.opener._wrs_conf_path + '/lang/' + lang;");
+		$output->add(" var script = document.createElement('script'); ");
+		$output->add(" script.src = scriptsrc;");
+		$output->add(" document.head.appendChild(script);");
+		$output->add("</script><script>");
+		$output->add("var scriptsrc = window.opener._wrs_conf_path + '/core/cas.js'; ");
+		$output->add(" var script = document.createElement('script'); ");
+		$output->add(" script.src = scriptsrc;");
+		$output->add(" document.head.appendChild(script);");
+		$output->add("</script>");
+		$output->add("<title>WIRIS CAS</title><style type=\"text/css\">");
+		$output->add("/*<!--*/ html, body, #optionForm { height: 100%; } body { overflow: hidden; margin: 0; } #controls { width: 100%; } /*-->*/</style></head>");
+		$output->add("<body><form id=\"optionForm\"><div id=\"appletContainer\"></div><table id=\"controls\"><tr><td>Width</td><td><input name=\"width\" type=\"text\" value=\"");
+		$output->add($config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CAS_WIDTH, null));
+		$output->add("\"/></td><td><input name=\"executeonload\" type=\"checkbox\"/> Calculate on load");
+		$output->add("</td><td><input name=\"toolbar\" type=\"checkbox\" checked /> Show toolbar</td><td>Language <select id=\"languageList\">");
+		$i = null;
+		{
+			$_g1 = 0; $_g = $availableLanguages->length;
+			while($_g1 < $_g) {
+				$i1 = $_g1++;
+				$language = $this->htmlentities($availableLanguages[$i1], true);
+				$output->add("<option value=\"");
+				$output->add($language);
+				$output->add("\">");
+				$output->add($language);
+				$output->add("</option>");
+				unset($language,$i1);
+			}
+		}
+		$output->add("</select></td></tr><tr><td>Height</td><td><input name=\"height\" type=\"text\" value=\"");
+		$output->add($config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CAS_HEIGHT, null));
+		$output->add("\"/></td><td><input name=\"focusonload\" type=\"checkbox\"/> Focus on load</td><td><input name=\"level\" type=\"checkbox\"/>");
+		$output->add("Elementary mode</td><td></td></tr><tr><td colspan=\"5\"><input id=\"submit\" value=\"Accept\" type=\"button\"/>");
+		$output->add("<input id=\"cancel\" value=\"Cancel\" type=\"button\"/></td></tr></table></form></body></html>");
+		return $output->b;
+	}
+	public function printCAS($codebase, $archive, $className) {
+		$output = new StringBuf();
+		$output->add("<html><head><style type=\"text/css\">/*<!--*/ html, body { height: 100%; } body { overflow: hidden; margin: 0; } applet { height: 100%; width: 100%; } /*-->*/</style></head>");
+		$output->add("<body><applet id=\"applet\" alt=\"WIRIS CAS\" codebase=\"");
+		$output->add($this->htmlentities($codebase, true));
+		$output->add("\" archive=\"");
+		$output->add($this->htmlentities($archive, true));
+		$output->add("\" code=\"");
+		$output->add($this->htmlentities($className, true));
+		$output->add("\"><p>You need JAVA&reg; to use WIRIS tools.<br />FREE download from <a target=\"_blank\" href=\"http://www.java.com\">www.java.com</a></p></applet></body></html>");
+		return $output->b;
+	}
+	public function getAvailableCASLanguages($languageString) {
+		$elem = null;
+		$langs = _hx_explode(",", $languageString);
+		$availableLanguages = new _hx_array(array());
+		$iter = $langs->iterator();
+		while($iter->hasNext()) {
+			$elem = $iter->next();
+			$elem = trim($elem);
+			$availableLanguages->push($elem);
+		}
+		if($availableLanguages->length === 0) {
+			$availableLanguages = new _hx_array(array());
+			$availableLanguages->push("");
+		}
+		return $availableLanguages;
+	}
+	public function cas($mode, $language) {
+		$output = new StringBuf();
+		$output->add("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">");
+		$config = $this->plugin->getConfiguration();
+		$availableLanguages = $this->getAvailableCASLanguages($config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CAS_LANGUAGES, null));
+		if($language === null || !com_wiris_system_ArrayEx::contains($availableLanguages, $language)) {
+			$language = $availableLanguages[0];
+		}
+		if($mode !== null && $mode === "applet") {
+			$codebase = str_replace("%LANG", $language, $config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CAS_CODEBASE, null));
+			$archive = str_replace("%LANG", $language, $config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CAS_ARCHIVE, null));
+			$className = str_replace("%LANG", $language, $config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CAS_CLASS, null));
+			$output->add($this->printCAS($codebase, $archive, $className));
+		} else {
+			$output->add($this->printCASContainer($config, $availableLanguages, $language));
+		}
+		return $output->b;
+	}
+	public function createCasImage($imageParameter) {
+		$output = "";
+		$contextPath = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CONTEXT_PATH, "/");
+		if($imageParameter !== null) {
+			$dataDecoded = com_wiris_plugin_impl_CasImpl::decodeBase64($imageParameter);
+			$digest = haxe_Md5::encode($imageParameter);
+			$store = $this->plugin->getStorageAndCache();
+			$store->storeData($digest, "png", $dataDecoded->b);
+			$showImagePath = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SHOWCASIMAGE_PATH, null);
+			$output .= com_wiris_plugin_impl_RenderImpl::concatPath($contextPath, $showImagePath) . rawurlencode($digest . ".png");
+		} else {
+			$output .= com_wiris_plugin_impl_RenderImpl::concatPath($contextPath, "core/cas.png");
+		}
+		return $output;
+	}
+	public function showCasImage($f, $provider) {
+		$formula = $f;
+		if(StringTools::endsWith($formula, ".png")) {
+			$formula = _hx_substr($formula, 0, strlen($formula) - 4);
+		}
+		$store = $this->plugin->getStorageAndCache();
+		$data = $store->retreiveData($formula, "png");
+		if($data === null) {
+			$data = com_wiris_system_Storage::newResourceStorage("cas.png")->readBinary();
+			if($data === null) {
+				throw new HException("Missing resource cas.png");
+			}
+		}
+		return $data;
+	}
+	public $plugin;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function decodeBase64($imageParameter) {
+		$b = new com_wiris_system_Base64();
+		$dataDecoded = $b->decodeBytes(haxe_io_Bytes::ofString($imageParameter));
+		return $dataDecoded;
+	}
+	function __toString() { return 'com.wiris.plugin.impl.CasImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/CleanCacheImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/CleanCacheImpl.class.php
new file mode 100644
index 0000000..8846435
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/CleanCacheImpl.class.php
@@ -0,0 +1,114 @@
+<?php
+
+class com_wiris_plugin_impl_CleanCacheImpl implements com_wiris_plugin_api_CleanCache{
+	public function __construct($pb) {
+		if(!php_Boot::$skip_constructor) {
+		$this->plugin = $pb;
+	}}
+	public function isGui() {
+		$wirisCacheGui = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CLEAN_CACHE_GUI, "false") === "true";
+		return $wirisCacheGui && !$this->accept;
+	}
+	public function validateToken($md5Token, $token) {
+		if($token !== null && $md5Token !== null) {
+			return $md5Token === com_wiris_system_Md5Tools::encodeString($token);
+		} else {
+			return false;
+		}
+	}
+	public function getContentType() {
+		if(!$this->gui) {
+			return "application/json";
+		} else {
+			return "text/html charset=UTF-8";
+		}
+	}
+	public function getCacheOutput() {
+		if($this->gui) {
+			$output = "";
+			$output .= "<html><head>\x0D\x0A";
+			$output .= "<title>WIRIS plugin clean cache service</title><meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\x0D\x0A";
+			$output .= "<link rel=stylesheet type=text/css href=" . $this->resourcePath . "?resourcefile=wirisplugin.css />";
+			$output .= "</head>";
+			$output .= "<div class=wirismaincontainer>";
+			$output .= "<body class=wirisplugincleancache>";
+			$output .= "<h2 class=wirisplugincleancache>WIRIS plugin clean cache service</h2>\x0D\x0A";
+			$output .= "<div class=wirisplugincleancacheform>";
+			if($this->wirisCleanCacheToken !== null) {
+				$output .= "<form action=" . $this->cleanCachePath . " method=post>";
+				$output .= "<span class=wirisplugincleancachetextform> Security token </span><input type=password autocomplete=off name=token>";
+				$output .= "<input type=\"submit\" value=\"Submit\">";
+				$output .= "</form>";
+			}
+			$output .= "<form action=" . $this->cleanCachePath . " method=post>";
+			$output .= "<span class=wirisplugincleancachetextform> Generate token </span> <input type=text name=newtoken>";
+			$output .= "<input type=\"submit\" value=\"Submit\">";
+			$output .= "</form>";
+			$output .= "</div>";
+			$output .= "<div class=wirisplugincleancacheresults>";
+			if($this->token !== null && !$this->validToken) {
+				$output .= "<span class=wirisplugincleancachewarning> Invalid Token </span>";
+			} else {
+				if($this->validToken && $this->token !== null) {
+					$output .= "<span class=wirisplugincleancachewarning> Cache deleted successfully </span>";
+				} else {
+					if($this->newToken !== null) {
+						$output .= " Your new token is: <br>";
+						$output .= "<span class=wirisplugincleancachewarning>" . haxe_Md5::encode($this->newToken) . "</span> <br>";
+						$output .= " Please copy it to your configuration.ini file <br>";
+						$output .= " For more information see <a href=http://www.wiris.com/plugins/docs/resources/configuration-table style=text-decoration:none>Server configuration file documentation</a>";
+					}
+				}
+			}
+			$output .= "</div>";
+			$output .= "</div>";
+			return $output;
+		} else {
+			$jsonOutput = new Hash();
+			if(!$this->validToken) {
+				$jsonOutput->set("status", "error");
+			} else {
+				$jsonOutput->set("status", "ok");
+			}
+			return com_wiris_util_json_JSon::encode($jsonOutput);
+		}
+	}
+	public function deleteCache() {
+		$this->storage->deleteCache();
+	}
+	public function init($param) {
+		$this->storage = $this->plugin->getStorageAndCache();
+		$this->token = $param->getParameter("token", null);
+		$this->newToken = $param->getParameter("newtoken", null);
+		$this->wirisCleanCacheToken = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CLEAN_CACHE_TOKEN, null);
+		$this->accept = (($param->getParameter("accept", null) !== null && $param->getParameter("accept", "") === "application/json") ? true : false);
+		$this->gui = $this->isGui();
+		$this->validToken = $this->validateToken($this->wirisCleanCacheToken, $this->token);
+		$this->cleanCachePath = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CLEAN_CACHE_PATH, "");
+		$this->resourcePath = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$RESOURCE_PATH, "");
+		if($this->token !== null && $this->validToken) {
+			$this->deleteCache();
+		}
+	}
+	public $resourcePath;
+	public $cleanCachePath;
+	public $storage;
+	public $gui;
+	public $accept;
+	public $validToken;
+	public $wirisCleanCacheToken;
+	public $newToken;
+	public $token;
+	public $plugin;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.impl.CleanCacheImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/ConfigurationImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/ConfigurationImpl.class.php
new file mode 100644
index 0000000..a8194f8
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/ConfigurationImpl.class.php
@@ -0,0 +1,192 @@
+<?php
+
+class com_wiris_plugin_impl_ConfigurationImpl implements com_wiris_plugin_api_Configuration{
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		$this->props = array();;
+	}}
+	public function setConfigurations($configurationKeys, $configurationValues) {
+		$configurationKeysArray = _hx_explode(",", $configurationKeys);
+		$configurationValuesArray = _hx_explode(",", $configurationValues);
+		$keysIterator = $configurationKeysArray->iterator();
+		$valuesIterator = $configurationValuesArray->iterator();
+		while($keysIterator->hasNext() && $valuesIterator->hasNext()) {
+			$key = $keysIterator->next();
+			$value = $valuesIterator->next();
+			if($this->getProperty($key, null) !== null) {
+				$this->setProperty($key, $value);
+			}
+			unset($value,$key);
+		}
+	}
+	public function getJsonConfiguration($configurationKeys) {
+		$configurationKeysArray = _hx_explode(",", $configurationKeys);
+		$iterator = $configurationKeysArray->iterator();
+		$jsonOutput = new Hash();
+		$jsonVariables = new Hash();
+		$thereIsNullValue = false;
+		while($iterator->hasNext()) {
+			$key = $iterator->next();
+			$value = $this->getProperty($key, "null");
+			if($value === "null") {
+				$thereIsNullValue = true;
+			}
+			$jsonVariables->set($key, $value);
+			unset($value,$key);
+		}
+		if(!$thereIsNullValue) {
+			$jsonOutput->set("status", "ok");
+		} else {
+			$jsonOutput->set("status", "warning");
+		}
+		$jsonOutput->set("result", $jsonVariables);
+		return com_wiris_util_json_JSon::encode($jsonOutput);
+	}
+	public function getJavaScriptConfigurationJson() {
+		$javaScriptHash = $this->getJavaScriptHash();
+		return com_wiris_util_json_JSon::encode($javaScriptHash);
+	}
+	public function getJavaScriptHash() {
+		$javaScriptHash = new Hash();
+		$javaScriptHash->set("_wrs_conf_editorEnabled", $this->getProperty("wiriseditorenabled", null) === "true");
+		$javaScriptHash->set("_wrs_conf_imageMathmlAttribute", $this->getProperty("wiriseditormathmlattribute", null));
+		$javaScriptHash->set("_wrs_conf_saveMode", $this->getProperty("wiriseditorsavemode", null));
+		$javaScriptHash->set("_wrs_conf_editMode", $this->getProperty("wiriseditoreditmode", null));
+		$parseLatexElements = new _hx_array(array());
+		if($this->getProperty("wiriseditorparselatex", null) === "true") {
+			$parseLatexElements->push("latex");
+		}
+		if($this->getProperty("wiriseditorparsexml", null) === "true") {
+			$parseLatexElements->push("xml");
+		}
+		$javaScriptHash->set("_wrs_conf_parseModes", $parseLatexElements);
+		$javaScriptHash->set("_wrs_conf_editorAttributes", $this->getProperty("wiriseditorwindowattributes", null));
+		$javaScriptHash->set("_wrs_conf_editorUrl", $this->plugin->getImageServiceURL("editor", false));
+		$javaScriptHash->set("_wrs_conf_modalWindow", $this->getProperty("wiriseditormodalwindow", null) === "true");
+		$javaScriptHash->set("_wrs_conf_modalWindowFullScreen", $this->getProperty("wiriseditormodalwindowfullscreen", null) === "true");
+		$javaScriptHash->set("_wrs_conf_CASEnabled", $this->getProperty("wiriscasenabled", null) === "true");
+		$javaScriptHash->set("_wrs_conf_CASMathmlAttribute", $this->getProperty("wiriscasmathmlattribute", null));
+		$javaScriptHash->set("_wrs_conf_CASAttributes", $this->getProperty("wiriscaswindowattributes", null));
+		$javaScriptHash->set("_wrs_conf_hostPlatform", $this->getProperty("wirishostplatform", null));
+		$javaScriptHash->set("_wrs_conf_versionPlatform", $this->getProperty("wirisversionplatform", "unknown"));
+		$javaScriptHash->set("_wrs_conf_enableAccessibility", $this->getProperty("wirisaccessibilityenabled", null) === "true");
+		$javaScriptHash->set("_wrs_conf_setSize", $this->getProperty("wiriseditorsetsize", "false") === "true");
+		$javaScriptHash->set("_wrs_conf_editorToolbar", $this->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_TOOLBAR, null));
+		$javaScriptHash->set("_wrs_conf_chemEnabled", $this->getProperty("wirischemeditorenabled", null) === "true");
+		$javaScriptHash->set("_wrs_conf_imageFormat", $this->getProperty("wirisimageformat", "png"));
+		if($this->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMS, null) !== null) {
+			$javaScriptHash->set("_wrs_conf_editorParameters", com_wiris_util_json_JSon::decode($this->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMS, null)));
+		} else {
+			$h = com_wiris_plugin_api_ConfigurationKeys::$imageConfigPropertiesInv;
+			$attributes = new Hash();
+			$confVal = "";
+			$i = 0;
+			$it = $h->keys();
+			$value = null;
+			while($it->hasNext()) {
+				$value = $it->next();
+				if($this->getProperty($value, null) !== null) {
+					$confVal = $this->getProperty($value, null);
+					str_replace("-", "_", $confVal);
+					str_replace("-", "_", $confVal);
+					$attributes->set($confVal, $value);
+				}
+			}
+			$javaScriptHash->set("_wrs_conf_editorParameters", $attributes);
+		}
+		$javaScriptHash->set("_wrs_conf_wirisPluginPerformance", $this->getProperty("wirispluginperformance", null) === "true");
+		$version = null;
+		try {
+			$version = com_wiris_system_Storage::newResourceStorage("VERSION")->read();
+			if($version === null) {
+				$version = "Missing version";
+			}
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$ex = $_ex_;
+			{
+				$version = "Missing version";
+			}
+		}
+		$javaScriptHash->set("_wrs_conf_version", $version);
+		return $javaScriptHash;
+	}
+	public function appendElement2JavascriptArray($array, $value) {
+		$arrayOpen = _hx_index_of($array, "[", null);
+		$arrayClose = _hx_index_of($array, "]", null);
+		if($arrayOpen === -1 || $arrayClose === -1) {
+			throw new HException("Array not valid");
+		}
+		return "[" . "'" . $value . "'" . (com_wiris_plugin_impl_ConfigurationImpl_0($this, $array, $arrayClose, $arrayOpen, $value));
+	}
+	public function appendVarJs($sb, $varName, $value, $comment) {
+		$sb->add("var ");
+		$sb->add($varName);
+		$sb->add(" = ");
+		$sb->add($value);
+		$sb->add(";");
+		if($comment !== null && strlen($comment) > 0) {
+			$sb->add("// ");
+			$sb->add($comment);
+		}
+		$sb->add("\x0D\x0A");
+	}
+	public function setPluginBuilderImpl($plugin) {
+		$this->plugin = $plugin;
+	}
+	public function initialize($cu) {
+		$cu->init($this->initObject);
+	}
+	public function initialize0() {
+		if($this->initialized) {
+			return;
+		}
+		$this->initialized = true;
+		$this->plugin->addConfigurationUpdater(new com_wiris_plugin_impl_FileConfigurationUpdater());
+		$this->plugin->addConfigurationUpdater(new com_wiris_plugin_impl_CustomConfigurationUpdater($this));
+		$a = $this->plugin->getConfigurationUpdaterChain();
+		$iter = $a->iterator();
+		while($iter->hasNext()) {
+			$cu = $iter->next();
+			$this->initialize($cu);
+			$cu->updateConfiguration($this->props);
+			unset($cu);
+		}
+	}
+	public function setInitObject($context) {
+		$this->initObject = $context;
+	}
+	public function setProperty($key, $value) {
+		$this->props[$key] = $value;
+	}
+	public function getProperty($key, $dflt) {
+		$this->initialize0();
+		return com_wiris_system_PropertiesTools::getProperty($this->props, $key, $dflt);
+	}
+	public function getFullConfiguration() {
+		$this->initialize0();
+		return $this->props;
+	}
+	public $initialized;
+	public $props;
+	public $initObject;
+	public $plugin;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.impl.ConfigurationImpl'; }
+}
+function com_wiris_plugin_impl_ConfigurationImpl_0(&$this, &$array, &$arrayClose, &$arrayOpen, &$value) {
+	if(strlen($array) === 2) {
+		return "]";
+	} else {
+		return "," . _hx_substr($array, $arrayOpen + 1, $arrayClose - $arrayOpen);
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/CustomConfigurationUpdater.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/CustomConfigurationUpdater.class.php
new file mode 100644
index 0000000..51d75af
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/CustomConfigurationUpdater.class.php
@@ -0,0 +1,42 @@
+<?php
+
+class com_wiris_plugin_impl_CustomConfigurationUpdater implements com_wiris_plugin_configuration_ConfigurationUpdater{
+	public function __construct($config) {
+		if(!php_Boot::$skip_constructor) {
+		$this->config = $config;
+	}}
+	public function updateConfiguration(&$configuration) {
+		$configuration = $configuration;
+		$confClass = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$CONFIGURATION_CLASS, null);
+		if($confClass !== null && _hx_index_of($confClass, "com.wiris.plugin.servlets.configuration.ParameterServletConfigurationUpdater", null) !== -1) {
+			return;
+		}
+		if($confClass !== null) {
+			$cls = Type::resolveClass($confClass);
+			if($cls === null) {
+				throw new HException("Class " . $confClass . " not found.");
+			}
+			$obj = Type::createInstance($cls, new _hx_array(array()));
+			if($obj === null) {
+				throw new HException("Instance from " . Std::string($cls) . " cannot be created.");
+			}
+			$cu = $obj;
+			$this->config->initialize($cu);
+			$cu->updateConfiguration($configuration);
+		}
+	}
+	public function init($obj) {
+	}
+	public $config;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.impl.CustomConfigurationUpdater'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/DefaultConfigurationUpdater.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/DefaultConfigurationUpdater.class.php
new file mode 100644
index 0000000..86f499d
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/DefaultConfigurationUpdater.class.php
@@ -0,0 +1,24 @@
+<?php
+
+class com_wiris_plugin_impl_DefaultConfigurationUpdater implements com_wiris_plugin_configuration_ConfigurationUpdater{
+	public function __construct() { 
+	}
+	public function updateConfiguration(&$configuration) {
+		$configuration = $configuration;
+		$s = com_wiris_system_Storage::newResourceStorage("default-configuration.ini")->read();
+		$defaultIniFile = com_wiris_util_sys_IniFile::newIniFileFromString($s);
+		$h = $defaultIniFile->getProperties();
+		$iter = $h->keys();
+		while($iter->hasNext()) {
+			$key = null;
+			$key = $iter->next();
+			if(com_wiris_system_PropertiesTools::getProperty($configuration, $key, null) === null) {
+				$configuration[$key] = $h->get($key);
+			}
+			unset($key);
+		}
+	}
+	public function init($obj) {
+	}
+	function __toString() { return 'com.wiris.plugin.impl.DefaultConfigurationUpdater'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/EditorImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/EditorImpl.class.php
new file mode 100644
index 0000000..8c7436a
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/EditorImpl.class.php
@@ -0,0 +1,91 @@
+<?php
+
+class com_wiris_plugin_impl_EditorImpl implements com_wiris_plugin_api_Editor{
+	public function __construct($plugin) {
+		if(!php_Boot::$skip_constructor) {
+		$this->plugin = $plugin;
+	}}
+	public function addLine($output, $s) {
+		$output->add($s);
+		$output->add("\x0D\x0A");
+	}
+	public function editor($language, $provider) {
+		$output = new StringBuf();
+		if($language === null || strlen($language) === 0) {
+			$language = "en";
+		}
+		$language = strtolower($language);
+		str_replace("-", "_", $language);
+		$store = com_wiris_system_Storage::newResourceStorage("lang/" . $language . "/strings.js");
+		if(!$store->exists()) {
+			$store = com_wiris_system_Storage::newResourceStorage("lang/" . _hx_substr($language, 0, 2) . "/strings.js");
+			$language = _hx_substr($language, 0, 2);
+			if(!$store->exists()) {
+				$language = "en";
+			}
+		}
+		$attributes = new StringBuf();
+		$attributes->add("");
+		$confVal = "";
+		$i = 0;
+		$config = $this->plugin->getConfiguration();
+		$h = com_wiris_plugin_api_ConfigurationKeys::$imageConfigPropertiesInv;
+		$it = $h->keys();
+		$value = null;
+		while($it->hasNext()) {
+			$value = $it->next();
+			if($config->getProperty($value, null) !== null) {
+				if($i !== 0) {
+					$attributes->add(",");
+				}
+				$i++;
+				$confVal = $config->getProperty($value, null);
+				str_replace("-", "_", $confVal);
+				str_replace("-", "_", $confVal);
+				$attributes->add("'");
+				$attributes->add(com_wiris_plugin_api_ConfigurationKeys::$imageConfigPropertiesInv->get($value));
+				$attributes->add("' : '");
+				$attributes->add($confVal);
+				$attributes->add("'");
+			}
+		}
+		$script = new StringBuf();
+		if($i > 0) {
+			$script->add("<script type=\"text/javascript\">window.wrs_attributes = {");
+			$script->add($attributes);
+			$script->add("};</script>");
+		}
+		$editorUrl = $this->plugin->getImageServiceURL("editor", false);
+		$isSegure = $provider->getParameter("secure", "false") === "true";
+		if(StringTools::startsWith($editorUrl, "http:") && $isSegure) {
+			$editorUrl = "https:" . _hx_substr($editorUrl, 5, null);
+		}
+		$this->addLine($output, "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">");
+		$this->addLine($output, "<html><head>");
+		$this->addLine($output, "<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\"/>");
+		$this->addLine($output, $script->b);
+		$this->addLine($output, "<script type=\"text/javascript\" src=\"" . $editorUrl . "?lang=" . rawurlencode($language) . "\"></script>");
+		$this->addLine($output, "<script type=\"text/javascript\" src=\"../core/editor.js\"></script>");
+		$this->addLine($output, "<script type=\"text/javascript\" src=\"../lang/" . rawurlencode($language) . "/strings.js\"></script>");
+		$this->addLine($output, "<title>WIRIS editor</title>");
+		$this->addLine($output, "<style type=\"text/css\">/*<!--*/html, body, #container { height: 100%; } body { margin: 0; }");
+		$this->addLine($output, "#links { text-align: right; margin-right: 20px; } #links_rtl {text-align: left; margin-left: 20px;} #controls { float: left; } #controls_rtl {float: right;}/*-->*/</style>");
+		$this->addLine($output, "</head><body topmargin=\"0\" leftmargin=\"0\" marginwidth=\"0\" marginheight=\"0\">");
+		$this->addLine($output, "<div id=\"container\"><div id=\"editorContainer\"></div><div id=\"controls\"></div>");
+		$this->addLine($output, "<div id=\"links\"><a href=\"http://www.wiris.com/editor3/docs/manual/latex-support\" id=\"a_latex\" target=\"_blank\">LaTeX</a> | ");
+		$this->addLine($output, "<a href=\"http://www.wiris.com/editor3/docs/manual\" target=\"_blank\" id=\"a_manual\">Manual</a></div></div></body>");
+		return $output->b;
+	}
+	public $plugin;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.impl.EditorImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/FileConfigurationUpdater.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/FileConfigurationUpdater.class.php
new file mode 100644
index 0000000..92b1ee0
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/FileConfigurationUpdater.class.php
@@ -0,0 +1,28 @@
+<?php
+
+class com_wiris_plugin_impl_FileConfigurationUpdater implements com_wiris_plugin_configuration_ConfigurationUpdater{
+	public function __construct() { 
+	}
+	public function updateConfiguration(&$configuration) {
+		$configuration = $configuration;
+		$confDir = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$CONFIGURATION_PATH, null);
+		if($confDir !== null) {
+			$confFile = $confDir . "/configuration.ini";
+			$s = com_wiris_system_Storage::newStorage($confFile);
+			if($s->exists()) {
+				$defaultIniFile = com_wiris_util_sys_IniFile::newIniFileFromFilename($confFile);
+				$h = $defaultIniFile->getProperties();
+				$iter = $h->keys();
+				while($iter->hasNext()) {
+					$key = null;
+					$key = $iter->next();
+					$configuration[$key] = $h->get($key);
+					unset($key);
+				}
+			}
+		}
+	}
+	public function init($obj) {
+	}
+	function __toString() { return 'com.wiris.plugin.impl.FileConfigurationUpdater'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/FileStorageAndCache.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/FileStorageAndCache.class.php
new file mode 100644
index 0000000..4c5c755
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/FileStorageAndCache.class.php
@@ -0,0 +1,62 @@
+<?php
+
+class com_wiris_plugin_impl_FileStorageAndCache implements com_wiris_plugin_storage_StorageAndCache{
+	public function __construct() {
+		;
+	}
+	public function deleteCache() {
+	}
+	public function getExtension($service) {
+		if($service === "png") {
+			return ".png";
+		}
+		return "." . $service . ".txt";
+	}
+	public function getAndCheckFolder($key) {
+		$folder = com_wiris_system_PropertiesTools::getProperty($this->config, $key, null);
+		if($folder === null || strlen(trim($folder)) === 0) {
+			throw new HException("Missing configuration value: " . $key);
+		}
+		return $folder;
+	}
+	public function storeData($digest, $service, $stream) {
+		$formula = $this->getAndCheckFolder(com_wiris_plugin_api_ConfigurationKeys::$CACHE_FOLDER);
+		$store = com_wiris_util_sys_Store::newStoreWithParent(com_wiris_util_sys_Store::newStore($formula), $digest . $this->getExtension($service));
+		$store->writeBinary(haxe_io_Bytes::ofData($stream));
+	}
+	public function retreiveData($digest, $service) {
+		$formula = $this->getAndCheckFolder(com_wiris_plugin_api_ConfigurationKeys::$CACHE_FOLDER);
+		$store = com_wiris_util_sys_Store::newStoreWithParent(com_wiris_util_sys_Store::newStore($formula), $digest . $this->getExtension($service));
+		if(!$store->exists()) {
+			return null;
+		}
+		return $store->readBinary()->b;
+	}
+	public function decodeDigest($digest) {
+		$formula = $this->getAndCheckFolder(com_wiris_plugin_api_ConfigurationKeys::$FORMULA_FOLDER);
+		$store = com_wiris_util_sys_Store::newStoreWithParent(com_wiris_util_sys_Store::newStore($formula), $digest . ".ini");
+		return $store->read();
+	}
+	public function codeDigest($content) {
+		$formula = $this->getAndCheckFolder(com_wiris_plugin_api_ConfigurationKeys::$FORMULA_FOLDER);
+		$digest = com_wiris_system_Md5Tools::encodeString($content);
+		$store = com_wiris_util_sys_Store::newStoreWithParent(com_wiris_util_sys_Store::newStore($formula), $digest . ".ini");
+		$store->write($content);
+		return $digest;
+	}
+	public function init($obj, $config, $cache, $cacheFormula) {
+		$this->config = $config;
+	}
+	public $config;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.impl.FileStorageAndCache'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/FolderTreeStorageAndCache.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/FolderTreeStorageAndCache.class.php
new file mode 100644
index 0000000..98d0e1f
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/FolderTreeStorageAndCache.class.php
@@ -0,0 +1,88 @@
+<?php
+
+class com_wiris_plugin_impl_FolderTreeStorageAndCache implements com_wiris_plugin_storage_StorageAndCache{
+	public function __construct() {
+		;
+	}
+	public function deleteCache() {
+		$cache = new com_wiris_plugin_impl_CacheImpl($this->config);
+		try {
+			$cache->deleteAll();
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+				throw new HException("Error: can't delete cache: " . Std::string($e->getMessage()));
+			}
+		}
+	}
+	public function getExtension($service) {
+		if($service === "png") {
+			return "png";
+		}
+		if($service === "svg") {
+			return "svg";
+		}
+		return $service . ".txt";
+	}
+	public function storeData($digest, $service, $stream) {
+		try {
+			$this->cache->set($digest . "." . $this->getExtension($service), haxe_io_Bytes::ofData($stream));
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+				throw new HException("Error: can't write on cache: " . Std::string($e->getMessage()));
+			}
+		}
+	}
+	public function retreiveData($digest, $service) {
+		$data = $this->cache->get($digest . "." . $this->getExtension($service));
+		if($data !== null) {
+			return $data->b;
+		} else {
+			return null;
+		}
+	}
+	public function decodeDigest($digest) {
+		$data = $this->cacheFormula->get($digest . ".ini");
+		if($data !== null) {
+			return com_wiris_system_Utf8::fromBytes($data->b);
+		} else {
+			return null;
+		}
+	}
+	public function codeDigest($content) {
+		$digest = com_wiris_system_Md5Tools::encodeString($content);
+		try {
+			$this->cacheFormula->set($digest . ".ini", haxe_io_Bytes::ofData(com_wiris_system_Utf8::toBytes($content)));
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+				throw new HException("Error: can't write on cache: " . Std::string($e->getMessage()));
+			}
+		}
+		return $digest;
+	}
+	public function init($obj, $config, $cache, $cacheFormula) {
+		$this->config = $config;
+		$this->cache = $cache;
+		$this->cacheFormula = $cacheFormula;
+	}
+	public $cacheFormula;
+	public $cache;
+	public $config;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $backwards_compat = true;
+	function __toString() { return 'com.wiris.plugin.impl.FolderTreeStorageAndCache'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/GenericParamsProviderImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/GenericParamsProviderImpl.class.php
new file mode 100644
index 0000000..d471764
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/GenericParamsProviderImpl.class.php
@@ -0,0 +1,70 @@
+<?php
+
+class com_wiris_plugin_impl_GenericParamsProviderImpl implements com_wiris_plugin_api_ParamsProvider{
+	public function __construct($properties) {
+		if(!php_Boot::$skip_constructor) {
+		$this->properties = $properties;
+	}}
+	public function getServiceParameters() {
+		$serviceParams = array();;
+		$serviceParamListArray = _hx_explode(",", com_wiris_plugin_api_ConfigurationKeys::$SERVICES_PARAMETERS_LIST);
+		$i = null;
+		{
+			$_g1 = 0; $_g = $serviceParamListArray->length;
+			while($_g1 < $_g) {
+				$i1 = $_g1++;
+				$key = $serviceParamListArray[$i1];
+				$value = com_wiris_system_PropertiesTools::getProperty($this->properties, $key, null);
+				if($value !== null) {
+					$serviceParams[$key] = $value;
+				}
+				unset($value,$key,$i1);
+			}
+		}
+		return $serviceParams;
+	}
+	public function getRenderParameters($configuration) {
+		$renderParams = array();;
+		$renderParameterList = _hx_explode(",", $configuration->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_LIST, com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_DEFAULT_LIST));
+		$i = null;
+		{
+			$_g1 = 0; $_g = $renderParameterList->length;
+			while($_g1 < $_g) {
+				$i1 = $_g1++;
+				$key = $renderParameterList[$i1];
+				$value = com_wiris_system_PropertiesTools::getProperty($this->properties, $key, null);
+				if($value !== null) {
+					$renderParams[$key] = $value;
+				}
+				unset($value,$key,$i1);
+			}
+		}
+		return $renderParams;
+	}
+	public function getParameters() {
+		return $this->properties;
+	}
+	public function getRequiredParameter($param) {
+		$parameter = com_wiris_system_PropertiesTools::getProperty($this->properties, $param, null);
+		if($parameter !== null) {
+			return $parameter;
+		} else {
+			throw new HException("Error: parameter " . $param . " is required");
+		}
+	}
+	public function getParameter($param, $dflt) {
+		return com_wiris_system_PropertiesTools::getProperty($this->properties, $param, $dflt);
+	}
+	public $properties;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.impl.GenericParamsProviderImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/HttpImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/HttpImpl.class.php
new file mode 100644
index 0000000..3fdff35
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/HttpImpl.class.php
@@ -0,0 +1,72 @@
+<?php
+
+class com_wiris_plugin_impl_HttpImpl extends haxe_Http {
+	public function __construct($url, $listener) {
+		if(!isset($this->onError)) $this->onError = array(new _hx_lambda(array(&$this, &$listener, &$url), "com_wiris_plugin_impl_HttpImpl_0"), 'execute');
+		if(!isset($this->onData)) $this->onData = array(new _hx_lambda(array(&$this, &$listener, &$url), "com_wiris_plugin_impl_HttpImpl_1"), 'execute');
+		if(!php_Boot::$skip_constructor) {
+		parent::__construct($url);
+		$this->listener = $listener;
+	}}
+	public function setListener($listener) {
+		$this->listener = $listener;
+	}
+	public function setProxy($proxy) {
+		_hx_qtype("haxe.Http")->{"PROXY"} = $proxy;
+	}
+	public function getProxy() {
+		$proxy = Reflect::field(_hx_qtype("haxe.Http"), "PROXY");
+		if($proxy === null) {
+			return null;
+		}
+		return $proxy;
+	}
+	public function getData() {
+		return $this->data;
+	}
+	public function onError($msg) { return call_user_func_array($this->onError, array($msg)); }
+	public $onError = null;
+	public function onData($data) { return call_user_func_array($this->onData, array($data)); }
+	public $onData = null;
+	public function request($post) {
+		$proxy = $this->getProxy();
+		if($proxy !== null && $proxy->host !== null && strlen($proxy->host) > 0) {
+			$hpa = $proxy->auth;
+			if($hpa->user !== null && strlen($hpa->user) > 0) {
+				$data = _hx_deref(new com_wiris_system_Base64())->encodeBytes(haxe_io_Bytes::ofString($hpa->user . ":" . $hpa->pass))->toString();
+				$this->setHeader("Proxy-Authorization", "Basic " . $data);
+			}
+		}
+		parent::request($post);
+	}
+	public $listener;
+	public $data;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.impl.HttpImpl'; }
+}
+function com_wiris_plugin_impl_HttpImpl_0(&$this, &$listener, &$url, $msg) {
+	{
+		if($this->listener !== null) {
+			$this->listener->onError($msg);
+		} else {
+			throw new HException($msg);
+		}
+	}
+}
+function com_wiris_plugin_impl_HttpImpl_1(&$this, &$listener, &$url, $data) {
+	{
+		$this->data = $data;
+		if($this->listener !== null) {
+			$this->listener->onData($data);
+		}
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/HttpListener.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/HttpListener.interface.php
new file mode 100644
index 0000000..94d4dcc
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/HttpListener.interface.php
@@ -0,0 +1,6 @@
+<?php
+
+interface com_wiris_plugin_impl_HttpListener {
+	function onError($msg);
+	function onData($data);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/ImageFormatControllerPng.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/ImageFormatControllerPng.class.php
new file mode 100644
index 0000000..e2f9302
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/ImageFormatControllerPng.class.php
@@ -0,0 +1,69 @@
+<?php
+
+class com_wiris_plugin_impl_ImageFormatControllerPng implements com_wiris_plugin_api_ImageFormatController{
+	public function __construct() { 
+	}
+	public function getMetrics($bytes, &$output) {
+		$output = $output;
+		$width = 0;
+		$height = 0;
+		$dpi = 0;
+		$baseline = 0;
+		$bi = new haxe_io_BytesInput($bytes, null, null);
+		$n = $bytes->length;
+		$alloc = 10;
+		$b = haxe_io_Bytes::alloc($alloc);
+		$bi->readBytes($b, 0, 8);
+		$n -= 8;
+		while($n > 0) {
+			$len = com_wiris_system_InputEx::readInt32_($bi);
+			$typ = com_wiris_system_InputEx::readInt32_($bi);
+			if($typ === 1229472850) {
+				$width = com_wiris_system_InputEx::readInt32_($bi);
+				$height = com_wiris_system_InputEx::readInt32_($bi);
+				com_wiris_system_InputEx::readInt32_($bi);
+				$bi->readByte();
+			} else {
+				if($typ === 1650545477) {
+					$baseline = com_wiris_system_InputEx::readInt32_($bi);
+				} else {
+					if($typ === 1883789683) {
+						$dpi = com_wiris_system_InputEx::readInt32_($bi);
+						$dpi = Math::round($dpi / 39.37);
+						com_wiris_system_InputEx::readInt32_($bi);
+						$bi->readByte();
+					} else {
+						if($len > $alloc) {
+							$alloc = $len;
+							$b = haxe_io_Bytes::alloc($alloc);
+						}
+						$bi->readBytes($b, 0, $len);
+					}
+				}
+			}
+			com_wiris_system_InputEx::readInt32_($bi);
+			$n -= $len + 12;
+			unset($typ,$len);
+		}
+		$r = null;
+		if($output !== null) {
+			$output["width"] = "" . _hx_string_rec($width, "");
+			$output["height"] = "" . _hx_string_rec($height, "");
+			$output["baseline"] = "" . _hx_string_rec($baseline, "");
+			if($dpi !== 96) {
+				$output["dpi"] = "" . _hx_string_rec($dpi, "");
+			}
+			$r = "";
+		} else {
+			$r = "&cw=" . _hx_string_rec($width, "") . "&ch=" . _hx_string_rec($height, "") . "&cb=" . _hx_string_rec($baseline, "");
+			if($dpi !== 96) {
+				$r = $r . "&dpi=" . _hx_string_rec($dpi, "");
+			}
+		}
+		return $r;
+	}
+	public function getContentType() {
+		return "image/png";
+	}
+	function __toString() { return 'com.wiris.plugin.impl.ImageFormatControllerPng'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/ImageFormatControllerSvg.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/ImageFormatControllerSvg.class.php
new file mode 100644
index 0000000..763a06a
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/ImageFormatControllerSvg.class.php
@@ -0,0 +1,34 @@
+<?php
+
+class com_wiris_plugin_impl_ImageFormatControllerSvg implements com_wiris_plugin_api_ImageFormatController{
+	public function __construct() { 
+	}
+	public function getMetrics($bytes, &$output) {
+		$svg = $bytes->toString();
+		$svgRoot = _hx_substr($svg, 0, _hx_index_of($svg, ">", null));
+		$firstIndex = _hx_index_of($svgRoot, "height=", null) + 8;
+		$endIndex = _hx_index_of($svgRoot, "\"", $firstIndex);
+		$height = _hx_substr($svgRoot, $firstIndex, $endIndex - $firstIndex);
+		$firstIndex = _hx_index_of($svgRoot, "width=", null) + 7;
+		$endIndex = _hx_index_of($svgRoot, "\"", $firstIndex);
+		$width = _hx_substr($svgRoot, $firstIndex, $endIndex - $firstIndex);
+		$firstIndex = _hx_index_of($svgRoot, "wrs:baseline=", null) + 14;
+		$endIndex = _hx_index_of($svgRoot, "\"", $firstIndex);
+		$baseline = _hx_substr($svgRoot, $firstIndex, $endIndex - $firstIndex);
+		$output = $output;
+		$r = null;
+		if($output !== null) {
+			$output["width"] = "" . $width;
+			$output["height"] = "" . $height;
+			$output["baseline"] = "" . $baseline;
+			$r = "";
+		} else {
+			$r = "&cw=" . $width . "&ch=" . $height . "&cb=" . $baseline;
+		}
+		return $r;
+	}
+	public function getContentType() {
+		return "image/svg+xml";
+	}
+	function __toString() { return 'com.wiris.plugin.impl.ImageFormatControllerSvg'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/PluginBuilderImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/PluginBuilderImpl.class.php
new file mode 100644
index 0000000..c9c8188
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/PluginBuilderImpl.class.php
@@ -0,0 +1,278 @@
+<?php
+
+class com_wiris_plugin_impl_PluginBuilderImpl extends com_wiris_plugin_api_PluginBuilder {
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		parent::__construct();
+		$this->updaterChain = new _hx_array(array());
+		$this->updaterChain->push(new com_wiris_plugin_impl_DefaultConfigurationUpdater());
+		$ci = new com_wiris_plugin_impl_ConfigurationImpl();
+		$this->configuration = $ci;
+		$ci->setPluginBuilderImpl($this);
+	}}
+	public function newGenericParamsProvider($properties) {
+		return new com_wiris_plugin_impl_GenericParamsProviderImpl($properties);
+	}
+	public function getImageFormatController() {
+		$imageFormatController = null;
+		if($this->configuration->getProperty(com_wiris_plugin_api_ConfigurationKeys::$IMAGE_FORMAT, "png") === "svg") {
+			$imageFormatController = new com_wiris_plugin_impl_ImageFormatControllerSvg();
+		} else {
+			$imageFormatController = new com_wiris_plugin_impl_ImageFormatControllerPng();
+		}
+		return $imageFormatController;
+	}
+	public function isEditorLicensed() {
+		$licenseClass = Type::resolveClass("com.wiris.util.sys.License");
+		if($licenseClass !== null) {
+			$init = Reflect::field($licenseClass, "init");
+			$initMethodParams = new _hx_array(array());
+			$initMethodParams->push($this->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_KEY, ""));
+			$initMethodParams->push("");
+			$initMethodParams->push(new _hx_array(array(4, 5, 9, 10)));
+			Reflect::callMethod($licenseClass, $init, $initMethodParams);
+			$isLicensedMethod = Reflect::field($licenseClass, "isLicensed");
+			$isLicensedObject = Reflect::callMethod($licenseClass, $isLicensedMethod, null);
+			$isLicensed = null;
+			if(_hx_index_of(Type::getClassName(Type::getClass($isLicensedObject)), "Boolean", null) !== -1) {
+				$isLicensed = _hx_string_call($isLicensedObject, "toString", array());
+			} else {
+				$isLicensed = $isLicensedObject;
+			}
+			return $isLicensed;
+		}
+		return false;
+	}
+	public function addStats($url) {
+		$saveMode = $this->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SAVE_MODE, "xml");
+		$externalPlugin = $this->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EXTERNAL_PLUGIN, "false");
+		$version = null;
+		try {
+			$version = com_wiris_system_Storage::newResourceStorage("VERSION")->read();
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$ex = $_ex_;
+			{
+				$version = "Missing version";
+			}
+		}
+		$tech = null;
+		try {
+			$tech = str_replace("\x0A", "", com_wiris_system_Storage::newResourceStorage("tech.txt")->read());
+			$tech = str_replace("\x0D", "", $tech);
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$ex2 = $_ex_;
+			{
+				$tech = "MissingTech";
+			}
+		}
+		if(_hx_index_of($url, "?", null) !== -1) {
+			return $url . "&stats-mode=" . $saveMode . "&stats-version=" . $version . "&stats-scriptlang=" . $tech . "&external=" . $externalPlugin;
+		} else {
+			return $url . "?stats-mode=" . $saveMode . "&stats-version=" . $version . "&stats-scriptlang=" . $tech . "&external=" . $externalPlugin;
+		}
+	}
+	public function addCorsHeaders($response, $origin) {
+		$conf = $this->getConfiguration();
+		if($conf->getProperty("wiriscorsenabled", "false") === "true") {
+			$confDir = $conf->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CONFIGURATION_PATH, null);
+			$corsConfFile = $confDir . "/corsservers.ini";
+			$s = com_wiris_system_Storage::newStorage($corsConfFile);
+			if($s->exists()) {
+				$dir = $s->read();
+				$allowedHosts = _hx_explode("\x0A", $dir);
+				if(com_wiris_system_ArrayEx::contains($allowedHosts, $origin)) {
+					$response->setHeader("Access-Control-Allow-Origin", $origin);
+				}
+			} else {
+				$response->setHeader("Access-Control-Allow-Origin", "*");
+			}
+		}
+	}
+	public function addReferer($h) {
+		$conf = $this->getConfiguration();
+		if($conf->getProperty("wirisexternalplugin", "false") === "true") {
+			$h->setHeader("Referer", $conf->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EXTERNAL_REFERER, "external referer not found"));
+		} else {
+			$h->setHeader("Referer", $conf->getProperty(com_wiris_plugin_api_ConfigurationKeys::$REFERER, ""));
+		}
+	}
+	public function addProxy($h) {
+		$conf = $this->getConfiguration();
+		$proxyEnabled = $conf->getProperty(com_wiris_plugin_api_ConfigurationKeys::$HTTPPROXY, "false");
+		if($proxyEnabled === "true") {
+			$host = $conf->getProperty(com_wiris_plugin_api_ConfigurationKeys::$HTTPPROXY_HOST, null);
+			$port = Std::parseInt($conf->getProperty(com_wiris_plugin_api_ConfigurationKeys::$HTTPPROXY_PORT, "80"));
+			if($host !== null && strlen($host) > 0) {
+				$user = $conf->getProperty(com_wiris_plugin_api_ConfigurationKeys::$HTTPPROXY_USER, null);
+				$pass = $conf->getProperty(com_wiris_plugin_api_ConfigurationKeys::$HTTPPROXY_PASS, null);
+				$h->setProxy(com_wiris_std_system_HttpProxy::newHttpProxy($host, $port, $user, $pass));
+			}
+		}
+	}
+	public function getImageServiceURL($service, $stats) {
+		$protocol = null;
+		$port = null;
+		$url = null;
+		$config = $this->getConfiguration();
+		if(Type::resolveClass("com.wiris.editor.services.PublicServices") !== null) {
+			if($config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SERVICE_HOST, null) === "www.wiris.net") {
+				return $this->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CONTEXT_PATH, "/") . "/editor/editor";
+			}
+		}
+		$protocol = $config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SERVICE_PROTOCOL, null);
+		$port = $config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SERVICE_PORT, null);
+		$url = $config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$INTEGRATION_PATH, null);
+		if($protocol === null && $url !== null) {
+			if(StringTools::startsWith($url, "https")) {
+				$protocol = "https";
+			}
+		}
+		if($protocol === null) {
+			$protocol = "http";
+		}
+		if($port !== null) {
+			if($protocol === "http") {
+				if(!($port === "80")) {
+					$port = ":" . $port;
+				} else {
+					$port = "";
+				}
+			}
+			if($protocol === "https") {
+				if(!($port === "443")) {
+					$port = ":" . $port;
+				} else {
+					$port = "";
+				}
+			}
+		} else {
+			$port = "";
+		}
+		$domain = $config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SERVICE_HOST, null);
+		$path = $config->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SERVICE_PATH, null);
+		if($service !== null) {
+			$end = _hx_last_index_of($path, "/", null);
+			if($end === -1) {
+				$path = $service;
+			} else {
+				$path = _hx_substr($path, 0, $end) . "/" . $service;
+			}
+		}
+		if($stats) {
+			$path = $this->addStats($path);
+		}
+		return $protocol . "://" . $domain . $port . $path;
+	}
+	public function newResourceLoader() {
+		return new com_wiris_plugin_impl_ServiceResourceLoaderImpl();
+	}
+	public function newCleanCache() {
+		return new com_wiris_plugin_impl_CleanCacheImpl($this);
+	}
+	public function setStorageAndCacheCacheFormulaObject($cacheFormula) {
+		$this->storageAndCacheCacheFormulaObject = $cacheFormula;
+	}
+	public function setStorageAndCacheCacheObject($cache) {
+		$this->storageAndCacheCacheObject = $cache;
+	}
+	public function setStorageAndCacheInitObject($obj) {
+		$this->storageAndCacheInitObject = $obj;
+	}
+	public function getConfigurationUpdaterChain() {
+		return $this->updaterChain;
+	}
+	public function initialize($sac, $conf) {
+		if($this->storageAndCacheCacheObject === null) {
+			$this->storageAndCacheCacheObject = new com_wiris_plugin_impl_CacheImpl($conf);
+		}
+		if($this->storageAndCacheCacheFormulaObject === null) {
+			$this->storageAndCacheCacheFormulaObject = new com_wiris_plugin_impl_CacheFormulaImpl($conf);
+		}
+		$sac->init($this->storageAndCacheInitObject, $conf, $this->storageAndCacheCacheObject, $this->storageAndCacheCacheFormulaObject);
+	}
+	public function getStorageAndCache() {
+		if($this->store === null) {
+			$className = $this->configuration->getProperty(com_wiris_plugin_api_ConfigurationKeys::$STORAGE_CLASS, null);
+			if($className === null || $className === "FolderTreeStorageAndCache") {
+				$this->store = new com_wiris_plugin_impl_FolderTreeStorageAndCache();
+			} else {
+				if($className === "FileStorageAndCache") {
+					$this->store = new com_wiris_plugin_impl_FileStorageAndCache();
+				} else {
+					$cls = Type::resolveClass($className);
+					if($cls === null) {
+						throw new HException("Class " . $className . " not found.");
+					}
+					$this->store = Type::createInstance($cls, new _hx_array(array()));
+					if($this->store === null) {
+						throw new HException("Instance from " . Std::string($cls) . " cannot be created.");
+					}
+				}
+			}
+			$this->initialize($this->store, $this->configuration->getFullConfiguration());
+		}
+		return $this->store;
+	}
+	public function getConfiguration() {
+		return $this->configuration;
+	}
+	public function newAsyncTextService() {
+		return new com_wiris_plugin_asyncimpl_AsyncTextServiceImpl($this);
+	}
+	public function newTextService() {
+		if(Type::resolveClass("com.wiris.editor.services.PublicServices") !== null && $this->isEditorLicensed()) {
+			return new com_wiris_plugin_impl_TextServiceImplIntegratedServices($this);
+		}
+		return new com_wiris_plugin_impl_TextServiceImpl($this);
+	}
+	public function newCas() {
+		return new com_wiris_plugin_impl_CasImpl($this);
+	}
+	public function newEditor() {
+		return new com_wiris_plugin_impl_EditorImpl($this);
+	}
+	public function newTest() {
+		return new com_wiris_plugin_impl_TestImpl($this);
+	}
+	public function newAsyncRender() {
+		return new com_wiris_plugin_asyncimpl_AsyncRenderImpl($this);
+	}
+	public function newRender() {
+		if(Type::resolveClass("com.wiris.editor.services.PublicServices") !== null && $this->isEditorLicensed()) {
+			return new com_wiris_plugin_impl_RenderImplIntegratedServices($this);
+		}
+		return new com_wiris_plugin_impl_RenderImpl($this);
+	}
+	public function setStorageAndCache($store) {
+		$this->store = $store;
+	}
+	public function getCustomParamsProvider() {
+		return $this->customParamsProvider;
+	}
+	public function setCustomParamsProvider($provider) {
+		$this->customParamsProvider = $provider;
+	}
+	public function addConfigurationUpdater($conf) {
+		$this->updaterChain->push($conf);
+	}
+	public $customParamsProvider;
+	public $storageAndCacheCacheFormulaObject = null;
+	public $storageAndCacheCacheObject = null;
+	public $storageAndCacheInitObject;
+	public $updaterChain;
+	public $store;
+	public $configuration;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.impl.PluginBuilderImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/RenderImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/RenderImpl.class.php
new file mode 100644
index 0000000..94ad40a
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/RenderImpl.class.php
@@ -0,0 +1,346 @@
+<?php
+
+class com_wiris_plugin_impl_RenderImpl implements com_wiris_plugin_api_Render{
+	public function __construct($plugin) {
+		if(!php_Boot::$skip_constructor) {
+		$this->plugin = $plugin;
+	}}
+	public function safeMath2Accessible($mml, $lang, $param) {
+		try {
+			$text = $this->plugin->newTextService()->mathml2accessible($mml, $lang, $param);
+			return $text;
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$ex = $_ex_;
+			{
+				return "";
+			}
+		}
+	}
+	public function getMetricsFromBytes($bs, &$output) {
+		$output = $output;
+		$width = 0;
+		$height = 0;
+		$dpi = 0;
+		$baseline = 0;
+		$bys = haxe_io_Bytes::ofData($bs);
+		$bi = new haxe_io_BytesInput($bys, null, null);
+		$n = $bys->length;
+		$alloc = 10;
+		$b = haxe_io_Bytes::alloc($alloc);
+		$bi->readBytes($b, 0, 8);
+		$n -= 8;
+		while($n > 0) {
+			$len = com_wiris_system_InputEx::readInt32_($bi);
+			$typ = com_wiris_system_InputEx::readInt32_($bi);
+			if($typ === 1229472850) {
+				$width = com_wiris_system_InputEx::readInt32_($bi);
+				$height = com_wiris_system_InputEx::readInt32_($bi);
+				com_wiris_system_InputEx::readInt32_($bi);
+				$bi->readByte();
+			} else {
+				if($typ === 1650545477) {
+					$baseline = com_wiris_system_InputEx::readInt32_($bi);
+				} else {
+					if($typ === 1883789683) {
+						$dpi = com_wiris_system_InputEx::readInt32_($bi);
+						$dpi = Math::round($dpi / 39.37);
+						com_wiris_system_InputEx::readInt32_($bi);
+						$bi->readByte();
+					} else {
+						if($len > $alloc) {
+							$alloc = $len;
+							$b = haxe_io_Bytes::alloc($alloc);
+						}
+						$bi->readBytes($b, 0, $len);
+					}
+				}
+			}
+			com_wiris_system_InputEx::readInt32_($bi);
+			$n -= $len + 12;
+			unset($typ,$len);
+		}
+		$r = null;
+		if($output !== null) {
+			$output["width"] = "" . _hx_string_rec($width, "");
+			$output["height"] = "" . _hx_string_rec($height, "");
+			$output["baseline"] = "" . _hx_string_rec($baseline, "");
+			if($dpi !== 96) {
+				$output["dpi"] = "" . _hx_string_rec($dpi, "");
+			}
+			$r = "";
+		} else {
+			$r = "&cw=" . _hx_string_rec($width, "") . "&ch=" . _hx_string_rec($height, "") . "&cb=" . _hx_string_rec($baseline, "");
+			if($dpi !== 96) {
+				$r = $r . "&dpi=" . _hx_string_rec($dpi, "");
+			}
+		}
+		return $r;
+	}
+	public function getMetrics($digest, &$output) {
+		$output = $output;
+		$bs = null;
+		try {
+			$bs = $this->showImage($digest, null, null);
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+				return "";
+			}
+		}
+		$b = haxe_io_Bytes::ofData($bs);
+		return $this->plugin->getImageFormatController()->getMetrics($b, $output);
+	}
+	public function getEditorParametersList() {
+		$pl = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_LIST, com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_DEFAULT_LIST);
+		return _hx_explode(",", $pl);
+	}
+	public function getMathml($digest) {
+		return null;
+	}
+	public function showImageHash($digest, $lang) {
+		$imageFormat = $this->plugin->getConfiguration()->getProperty("wirisimageformat", "png");
+		$store = $this->plugin->getStorageAndCache();
+		$bs = null;
+		$bs = $store->retreiveData($digest, $imageFormat);
+		if($bs !== null) {
+			$jsonResult = new Hash();
+			$content = haxe_io_Bytes::ofData($bs);
+			if($imageFormat === "png") {
+				$content = _hx_deref(new com_wiris_system_Base64())->encodeBytes($content);
+			}
+			$metrics = array();;
+			$this->getMetrics($digest, $metrics);
+			if($lang === null) {
+				$lang = "en";
+			}
+			$s = $store->retreiveData($digest, $lang);
+			$hashMetrics = com_wiris_system_PropertiesTools::fromProperties($metrics);
+			$keys = $hashMetrics->keys();
+			while($keys->hasNext()) {
+				$currentKey = $keys->next();
+				$jsonResult->set($currentKey, $hashMetrics->get($currentKey));
+				unset($currentKey);
+			}
+			if($s !== null) {
+				$cachedServiceText = com_wiris_system_Utf8::fromBytes($s);
+				$b = StringTools::endsWith($cachedServiceText, "}") && StringTools::startsWith($cachedServiceText, "{");
+				if($b) {
+					$altJson = com_wiris_util_json_JSon::decode($cachedServiceText);
+					$result = $altJson->get("result");
+					$jsonResult->set("alt", $result->get("text"));
+				} else {
+					$jsonResult->set("alt", $cachedServiceText);
+				}
+			}
+			$jsonResult->set("content", $content->toString());
+			$jsonResult->set("format", $imageFormat);
+			return $jsonResult;
+		} else {
+			return null;
+		}
+	}
+	public function showImageJson($digest, $lang) {
+		$jsonResult = $this->showImageHash($digest, $lang);
+		if($jsonResult !== null) {
+			$jsonSb = new StringBuf();
+			$iter = $jsonResult->keys();
+			$jsonSb->add("{\"status\":\"ok\",\"result\":{");
+			while($iter->hasNext()) {
+				$key = $iter->next();
+				$value = $jsonResult->get($key);
+				$value = str_replace("\\", "\\\\", $value);
+				$value = str_replace("\"", "\\\"", $value);
+				$value = str_replace("\x0D", "\\r", $value);
+				$value = str_replace("\x0A", "\\n", $value);
+				$value = str_replace("\x09", "\\t", $value);
+				$jsonSb->add("\"" . $key . "\":" . "\"" . $value . "\"");
+				if($iter->hasNext()) {
+					$jsonSb->add(",");
+				}
+				unset($value,$key);
+			}
+			$jsonSb->add("}}");
+			return $jsonSb->b;
+		} else {
+			return "{\"status\":\"warning\"}";
+		}
+	}
+	public function showImage($digest, $mml, $provider) {
+		if($digest === null && $mml === null) {
+			throw new HException("Missing parameters 'formula' or 'mml'.");
+		}
+		if($digest !== null && $mml !== null) {
+			throw new HException("Only one parameter 'formula' or 'mml' is valid.");
+		}
+		$atts = false;
+		if($digest === null && $mml !== null && $provider !== null) {
+			$digest = $this->computeDigest($mml, $provider->getRenderParameters($this->plugin->getConfiguration()));
+		}
+		$formula = $this->plugin->getStorageAndCache()->decodeDigest($digest);
+		if($formula === null) {
+			throw new HException("Formula associated to digest not found.");
+		}
+		if(StringTools::startsWith($formula, "<")) {
+			throw new HException("Not implemented.");
+		}
+		$iniFile = com_wiris_util_sys_IniFile::newIniFileFromString($formula);
+		$renderParams = $iniFile->getProperties();
+		$i = null;
+		$ss = $this->getEditorParametersList();
+		if($provider !== null) {
+			$renderParameters = $provider->getRenderParameters($this->plugin->getConfiguration());
+			{
+				$_g1 = 0; $_g = $ss->length;
+				while($_g1 < $_g) {
+					$i1 = $_g1++;
+					$key = $ss[$i1];
+					$value = com_wiris_system_PropertiesTools::getProperty($renderParameters, $key, null);
+					if($value !== null) {
+						$atts = true;
+						$renderParams->set($key, $value);
+					}
+					unset($value,$key,$i1);
+				}
+			}
+		}
+		if($atts) {
+			if($mml !== null) {
+				$digest = $this->computeDigest($mml, com_wiris_system_PropertiesTools::toProperties($renderParams));
+			} else {
+				$digest = $this->computeDigest($renderParams->get("mml"), com_wiris_system_PropertiesTools::toProperties($renderParams));
+			}
+		}
+		$store = $this->plugin->getStorageAndCache();
+		$bs = null;
+		$bs = $store->retreiveData($digest, $this->plugin->getConfiguration()->getProperty("wirisimageformat", "png"));
+		if($bs === null) {
+			if($this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMS, null) !== null) {
+				$json = com_wiris_util_json_JSon::decode($this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMS, null));
+				$decodedHash = $json;
+				$keys = $decodedHash->keys();
+				$notAllowedParams = _hx_explode(",", com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_NOTRENDER_LIST);
+				while($keys->hasNext()) {
+					$key = $keys->next();
+					if(!com_wiris_system_ArrayEx::contains($notAllowedParams, $key)) {
+						$renderParams->set($key, $decodedHash->get($key));
+					}
+					unset($key);
+				}
+			} else {
+				$_g1 = 0; $_g = $ss->length;
+				while($_g1 < $_g) {
+					$i1 = $_g1++;
+					$key = $ss[$i1];
+					if(!$renderParams->exists($key)) {
+						$confKey = com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->get($key);
+						if($confKey !== null) {
+							$value = $this->plugin->getConfiguration()->getProperty($confKey, null);
+							if($value !== null) {
+								$renderParams->set($key, $value);
+							}
+							unset($value);
+						}
+						unset($confKey);
+					}
+					unset($key,$i1);
+				}
+			}
+			$renderParams->set("format", $this->plugin->getConfiguration()->getProperty("wirisimageformat", "png"));
+			$h = new com_wiris_plugin_impl_HttpImpl($this->plugin->getImageServiceURL(null, true), null);
+			$this->plugin->addReferer($h);
+			$this->plugin->addProxy($h);
+			$iter = $renderParams->keys();
+			while($iter->hasNext()) {
+				$key = $iter->next();
+				$h->setParameter($key, $renderParams->get($key));
+				unset($key);
+			}
+			$h->request(true);
+			$b = haxe_io_Bytes::ofString($h->getData());
+			$store->storeData($digest, $this->plugin->getConfiguration()->getProperty("wirisimageformat", "png"), $b->b);
+			$bs = $b->b;
+		}
+		return $bs;
+	}
+	public function createImage($mml, $provider, &$output) {
+		$output = $output;
+		if($mml === null) {
+			throw new HException("Missing parameter 'mml'.");
+		}
+		$digest = $this->computeDigest($mml, $provider->getRenderParameters($this->plugin->getConfiguration()));
+		$contextPath = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CONTEXT_PATH, "/");
+		$showImagePath = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SHOWIMAGE_PATH, null);
+		$saveMode = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SAVE_MODE, "xml");
+		$s = "";
+		if($provider->getParameter("metrics", "false") === "true") {
+			$s = $this->getMetrics($digest, $output);
+		}
+		$a = "";
+		if($provider->getParameter("accessible", "false") === "true") {
+			$lang = $provider->getParameter("lang", "en");
+			$text = $this->safeMath2Accessible($mml, $lang, $provider->getParameters());
+			if($output === null) {
+				$a = "&text=" . com_wiris_util_type_UrlUtils::urlComponentEncode($text);
+			} else {
+				$output["alt"] = $text;
+			}
+		}
+		$rparam = "";
+		if($provider->getParameter("refererquery", null) !== null) {
+			$refererquery = $provider->getParameter("refererquery", "");
+			$rparam = "&refererquery=" . $refererquery;
+		}
+		if($provider->getParameter("base64", null) !== null || $saveMode === "base64") {
+			$bs = $this->showImage($digest, null, $provider);
+			$by = haxe_io_Bytes::ofData($bs);
+			$b64 = _hx_deref(new com_wiris_system_Base64())->encodeBytes($by);
+			$imageContentType = $this->plugin->getImageFormatController()->getContentType();
+			return "data:" . $imageContentType . ";base64," . $b64->toString();
+		} else {
+			return com_wiris_plugin_impl_RenderImpl::concatPath($contextPath, $showImagePath) . com_wiris_util_type_UrlUtils::urlComponentEncode($digest) . $s . $a . $rparam;
+		}
+	}
+	public function computeDigest($mml, $param) {
+		$ss = $this->getEditorParametersList();
+		$i = null;
+		$renderParams = new Hash();
+		{
+			$_g1 = 0; $_g = $ss->length;
+			while($_g1 < $_g) {
+				$i1 = $_g1++;
+				$key = $ss[$i1];
+				$value = com_wiris_system_PropertiesTools::getProperty($param, $key, null);
+				if($value !== null) {
+					$renderParams->set($key, $value);
+				}
+				unset($value,$key,$i1);
+			}
+		}
+		if($mml !== null) {
+			$renderParams->set("mml", $mml);
+		}
+		$s = com_wiris_util_sys_IniFile::propertiesToString($renderParams);
+		return $this->plugin->getStorageAndCache()->codeDigest($s);
+	}
+	public $plugin;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function concatPath($s1, $s2) {
+		if(_hx_last_index_of($s1, "/", null) === strlen($s1) - 1) {
+			return $s1 . $s2;
+		} else {
+			return $s1 . "/" . $s2;
+		}
+	}
+	function __toString() { return 'com.wiris.plugin.impl.RenderImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/RenderImplIntegratedServices.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/RenderImplIntegratedServices.class.php
new file mode 100644
index 0000000..3e46502
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/RenderImplIntegratedServices.class.php
@@ -0,0 +1,130 @@
+<?php
+
+class com_wiris_plugin_impl_RenderImplIntegratedServices extends com_wiris_plugin_impl_RenderImpl {
+	public function __construct($plugin) { if(!php_Boot::$skip_constructor) {
+		parent::__construct($plugin);
+	}}
+	public function render($format, $mml, $latex, $properties, $outProperties) {
+		$servicesClass = Type::resolveClass("com.wiris.editor.services.PublicServices");
+		$getInstance = Reflect::field($servicesClass, "getInstance");
+		$publicServices = Reflect::callMethod($servicesClass, $getInstance, null);
+		$args = new _hx_array(array());
+		$args->push($mml);
+		$args->push($latex);
+		$args->push($properties);
+		$args->push($outProperties);
+		try {
+			if(_hx_index_of($format, "png", null) !== -1) {
+				$renderPngMethod = Reflect::field($publicServices, "renderPng");
+				$pngObject = Reflect::callMethod($publicServices, $renderPngMethod, $args);
+				$pngBytes = $pngObject;
+				return haxe_io_Bytes::ofData($pngBytes);
+			} else {
+				if(_hx_index_of($format, "svg", null) !== -1) {
+					$renderSvgMethod = Reflect::field($publicServices, "renderSvg");
+					$svgObject = Reflect::callMethod($publicServices, $renderSvgMethod, $args);
+					$svgString = $svgObject;
+					return haxe_io_Bytes::ofString($svgString);
+				} else {
+					throw new HException("Unexpected image format.");
+				}
+			}
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+				throw new HException($e->getMessage());
+			}
+		}
+	}
+	public function showImage($digest, $mml, $provider) {
+		if($digest === null && $mml === null) {
+			throw new HException("Missing parameters 'formula' or 'mml'.");
+		}
+		if($digest !== null && $mml !== null) {
+			throw new HException("Only one parameter 'formula' or 'mml' is valid.");
+		}
+		$atts = false;
+		if($digest === null && $mml !== null) {
+			$digest = $this->computeDigest($mml, $provider->getRenderParameters($this->plugin->getConfiguration()));
+		}
+		$formula = $this->plugin->getStorageAndCache()->decodeDigest($digest);
+		if($formula === null) {
+			throw new HException("Formula associated to digest not found.");
+		}
+		if(StringTools::startsWith($formula, "<")) {
+			throw new HException("Not implemented.");
+		}
+		$iniFile = com_wiris_util_sys_IniFile::newIniFileFromString($formula);
+		$renderParams = $iniFile->getProperties();
+		$ss = $this->getEditorParametersList();
+		$i = null;
+		if($provider !== null) {
+			$renderParameters = $provider->getRenderParameters($this->plugin->getConfiguration());
+			{
+				$_g1 = 0; $_g = $ss->length;
+				while($_g1 < $_g) {
+					$i1 = $_g1++;
+					$key = $ss[$i1];
+					$value = com_wiris_system_PropertiesTools::getProperty($renderParameters, $key, null);
+					if($value !== null) {
+						$atts = true;
+						$renderParams->set($key, $value);
+					}
+					unset($value,$key,$i1);
+				}
+			}
+			if($atts) {
+				if($mml !== null) {
+					$digest = $this->computeDigest($mml, com_wiris_system_PropertiesTools::toProperties($renderParams));
+				} else {
+					$digest = $this->computeDigest($renderParams->get("mml"), com_wiris_system_PropertiesTools::toProperties($renderParams));
+				}
+			}
+		}
+		$store = $this->plugin->getStorageAndCache();
+		$bs = null;
+		$bs = $store->retreiveData($digest, $this->plugin->getConfiguration()->getProperty("wirisimageformat", "png"));
+		if($bs === null) {
+			if($this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMS, null) !== null) {
+				$json = com_wiris_util_json_JSon::decode($this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMS, null));
+				$decodedHash = $json;
+				$keys = $decodedHash->keys();
+				$notAllowedParams = _hx_explode(",", com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_NOTRENDER_LIST);
+				while($keys->hasNext()) {
+					$key = $keys->next();
+					if(!com_wiris_system_ArrayEx::contains($notAllowedParams, $key)) {
+						$renderParams->set($key, $decodedHash->get($key));
+					}
+					unset($key);
+				}
+			} else {
+				$_g1 = 0; $_g = $ss->length;
+				while($_g1 < $_g) {
+					$i1 = $_g1++;
+					$key = $ss[$i1];
+					if(!$renderParams->exists($key)) {
+						$confKey = com_wiris_plugin_api_ConfigurationKeys::$imageConfigProperties->get($key);
+						if($confKey !== null) {
+							$value = $this->plugin->getConfiguration()->getProperty($confKey, null);
+							if($value !== null) {
+								$renderParams->set($key, $value);
+							}
+							unset($value);
+						}
+						unset($confKey);
+					}
+					unset($key,$i1);
+				}
+			}
+			$prop = com_wiris_system_PropertiesTools::toProperties($renderParams);
+			$iter = $renderParams->keys();
+			$mml = $renderParams->get("mml");
+			$b = $this->render($this->plugin->getConfiguration()->getProperty("wirisimageformat", "png"), $mml, null, $prop, null);
+			$store->storeData($digest, $this->plugin->getConfiguration()->getProperty("wirisimageformat", "png"), $b->b);
+			$bs = $b->b;
+		}
+		return $bs;
+	}
+	function __toString() { return 'com.wiris.plugin.impl.RenderImplIntegratedServices'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/ServiceResourceLoaderImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/ServiceResourceLoaderImpl.class.php
new file mode 100644
index 0000000..6cd34a0
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/ServiceResourceLoaderImpl.class.php
@@ -0,0 +1,46 @@
+<?php
+
+class com_wiris_plugin_impl_ServiceResourceLoaderImpl implements com_wiris_plugin_api_ServiceResourceLoader{
+	public function __construct() { 
+	}
+	public function getContentType($name) {
+		$ext = _hx_substr($name, _hx_last_index_of($name, ".", null) + 1, null);
+		if($ext === "png") {
+			return "image/png";
+		} else {
+			if($ext === "gif") {
+				return "image/gif";
+			} else {
+				if($ext === "jpg" || $ext === "jpeg") {
+					return "image/jpeg";
+				} else {
+					if($ext === "html" || $ext === "htm") {
+						return "text/html";
+					} else {
+						if($ext === "css") {
+							return "text/css";
+						} else {
+							if($ext === "js") {
+								return "application/javascript";
+							} else {
+								if($ext === "txt") {
+									return "text/plain";
+								} else {
+									if($ext === "ini") {
+										return "text/plain";
+									} else {
+										return "application/octet-stream";
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	public function getContent($resource) {
+		return com_wiris_system_Storage::newResourceStorage($resource)->read();
+	}
+	function __toString() { return 'com.wiris.plugin.impl.ServiceResourceLoaderImpl'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/TestImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/TestImpl.class.php
new file mode 100644
index 0000000..1b7fca9
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/TestImpl.class.php
@@ -0,0 +1,223 @@
+<?php
+
+class com_wiris_plugin_impl_TestImpl implements com_wiris_plugin_api_Test{
+	public function __construct($plugin) {
+		if(!php_Boot::$skip_constructor) {
+		$this->plugin = $plugin;
+	}}
+	public function createTableRow($testName, $reportText, $solutionLink, $condition) {
+		$output = "";
+		$output .= "<tr>";
+		$output .= "<td>" . $testName . "</td>";
+		$output .= "<td>" . $reportText . "</td>";
+		$output .= "<td>";
+		if($condition) {
+			$output .= "<span class=\"ok\">OK</span><br/>";
+		} else {
+			$output .= "<span class=\"error\">ERROR</span><br/>";
+		}
+		$output .= "</td>";
+		$output .= "</tr>\x0D\x0A";
+		return $output;
+	}
+	public function getTestPage() {
+		$random = "" . _hx_string_rec(Math::floor(Math::random() * 9999), "");
+		$mml = "<math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mrow><msqrt><mn>" . $random . "</mn></msqrt></mrow></math>";
+		$testName = null; $reportText = null; $solutionLink = null;
+		$this->conf = $this->plugin->getConfiguration();
+		$condition = null;
+		$output = "";
+		$output .= "<html><head>\x0D\x0A";
+		$output .= "<title>WIRIS plugin test page</title><meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" /><style type=\"text/css\">/*<!--*/html {font-family: sans-serif;}h2 {margin-left: 1em;}h3 {margin-left: 2em;}p {margin-left: 3em;}p.concrete {margin-left: 4em;}.ok {font-weight: bold;color: #0c0;}.error {font-weight: bold;color: #f00;}/*-->*/</style><style type=\"text/css\">body{font-family: Arial;}span{font-weight: bold;}span.ok {color: #009900;}span.error {color: #dd0000;}table, th, td, tr {border: solid 1px #000000;border-collapse:collapse;padding: 5px;}th{background-color: #eeeeee;}img{border:none;}</style>\x0D\x0A";
+		$output .= "<script src=\"../core/WIRISplugins.js?viewer=image\" ></script>\x0D\x0A";
+		$output .= "</head><body><h1>WIRIS plugin test page</h1>\x0D\x0A";
+		$output .= "<table><tr><th>Test</th><th>Report</th><th>Status</th></tr>\x0D\x0A";
+		$testName = "WIRIS plugin version";
+		try {
+			$s = com_wiris_system_Storage::newResourceStorage("VERSION")->read();
+			$reportText = "<b>" . $s . "</b>";
+			$solutionLink = "";
+			$condition = true;
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$ex = $_ex_;
+			{
+				$reportText = "Missing version";
+				$solutionLink = "";
+				$condition = false;
+			}
+		}
+		$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+		$testName = "Creating and storing data";
+		$solutionLink = "";
+		$param = array();;
+		$outp = array();;
+		$provider = $this->plugin->newGenericParamsProvider($param);
+		$imageUrl = $this->plugin->newRender()->createImage($mml, $provider, $outp);
+		$reportText = "<a href=\"" . $imageUrl . "\" />" . $imageUrl . "</a>";
+		$condition = true;
+		$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+		$testName = "Retrieving data";
+		$solutionLink = "";
+		if($this->conf->getProperty("wirispluginperformance", "false") === "true") {
+			$this->plugin->newRender()->showImage(null, $mml, $provider);
+			$digest = $this->plugin->newRender()->computeDigest($mml, $provider->getRenderParameters($this->plugin->getConfiguration()));
+			$imageUrlJson = $this->plugin->newRender()->showImageJson($digest, "en");
+			$imageJson = com_wiris_util_json_JSon::decode($imageUrlJson);
+			$result = $imageJson->get("result");
+			$content = $result->get("content");
+			if($this->conf->getProperty("wirisimageformat", "svg") === "svg") {
+				$reportText = "<img src=\"" . "data:image/svg+xml;charset=utf8," . com_wiris_util_type_UrlUtils::urlComponentEncode($content) . "\" />";
+			} else {
+				$reportText = "<img src='" . "data:image/png;base64," . $content . "' />";
+			}
+		} else {
+			$reportText = "<img src='" . $imageUrl . "' />";
+		}
+		$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+		$testName = "JavaScript MathML filter";
+		$solutionLink = "";
+		$reportText = $mml;
+		$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+		$testName = "Host platform";
+		$solutionLink = "";
+		$platform = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$HOST_PLATFORM, "failed");
+		$reportText = $platform;
+		$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+		$testName = "Filter test";
+		$solutionLink = "";
+		$condition = true;
+		$p = null;
+		$p = array();;
+		$p["savemode"] = "safeXml";
+		$s2 = str_replace("<", com_wiris_plugin_impl_TestImpl_0($this, $condition, $ex, $imageUrl, $mml, $outp, $output, $p, $param, $platform, $provider, $random, $reportText, $solutionLink, $testName), $mml);
+		$s2 = str_replace(">", com_wiris_plugin_impl_TestImpl_1($this, $condition, $ex, $imageUrl, $mml, $outp, $output, $p, $param, $platform, $provider, $random, $reportText, $s2, $solutionLink, $testName), $s2);
+		$s2 = str_replace("\"", com_wiris_plugin_impl_TestImpl_2($this, $condition, $ex, $imageUrl, $mml, $outp, $output, $p, $param, $platform, $provider, $random, $reportText, $s2, $solutionLink, $testName), $s2);
+		$reportText = $this->plugin->newTextService()->filter("square root: " . $s2, $p);
+		$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+		$testName = "Connecting to www.wiris.net";
+		$solutionLink = "";
+		$condition = true;
+		try {
+			$h = new com_wiris_plugin_impl_HttpImpl("http://www.wiris.net", null);
+			$h->request(true);
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$ex2 = $_ex_;
+			{
+				$condition = false;
+			}
+		}
+		$reportText = "Checking if WIRIS server is reachable";
+		$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+		if(Type::resolveClass("com.wiris.editor.services.PublicServices") !== null) {
+			$condition = true;
+			$testName = "Testing integrated services";
+			$reportText = "WIRIS Services installed";
+			$solutionLink = "";
+			$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+			$isLicensed = $this->plugin->isEditorLicensed();
+			$condition = false;
+			$testName = "WIRIS editor license";
+			$reportText = "Checking WIRIS editor valid license";
+			$output .= $this->createTableRow($testName, $reportText, $solutionLink, $isLicensed);
+		} else {
+			$reportText = "WIRIS Services not installed";
+		}
+		$debug = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$DEBUG, "false") === "true";
+		if($debug) {
+			$testName = "Font family";
+			$solutionLink = "";
+			$condition = true;
+			$reportText = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$FONT_FAMILY, "");
+			$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+			$testName = "Configuration file";
+			$solutionLink = "";
+			$condition = true;
+			$reportText = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CONFIGURATION_PATH, "") . "\\configuration.ini";
+			$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+			$testName = "Cache path";
+			$solutionLink = "";
+			$condition = true;
+			$reportText = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CACHE_FOLDER, "");
+			$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+			$testName = "Formula path";
+			$solutionLink = "";
+			$condition = true;
+			$reportText = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$FORMULA_FOLDER, "");
+			$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+			$testName = "Integration path";
+			$solutionLink = "";
+			$condition = true;
+			$reportText = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$INTEGRATION_PATH, "");
+			$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+			$testName = "Context path";
+			$solutionLink = "";
+			$condition = true;
+			$reportText = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$CONTEXT_PATH, "");
+			$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+			$testName = "default-configuration.ini load";
+			$solutionLink = "";
+			$defaultConfiguration = com_wiris_system_Storage::newResourceStorage("default-configuration.ini")->read();
+			$condition = $defaultConfiguration !== null && strlen($defaultConfiguration) > 0;
+			if($condition) {
+				$reportText = "Length: " . _hx_string_rec(strlen($defaultConfiguration), "");
+			} else {
+				$reportText = "Not found!";
+			}
+			$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+			$testName = "cas.png load";
+			$solutionLink = "";
+			$casPng = com_wiris_system_Storage::newResourceStorage("cas.png")->readBinary();
+			$casPngLength = 0;
+			if($casPng !== null) {
+				$casPngLength = haxe_io_Bytes::ofData($casPng)->length;
+				$condition = $casPngLength > 0;
+			} else {
+				$condition = false;
+			}
+			if($condition) {
+				$reportText = "Length: " . _hx_string_rec($casPngLength, "");
+			} else {
+				$reportText = "Not found!";
+			}
+			$output .= $this->createTableRow($testName, $reportText, $solutionLink, $condition);
+		}
+		$output .= "<div id=\"haxe:trace\"></div>";
+		return $output;
+	}
+	public $conf;
+	public $plugin;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.plugin.impl.TestImpl'; }
+}
+function com_wiris_plugin_impl_TestImpl_0(&$this, &$condition, &$ex, &$imageUrl, &$mml, &$outp, &$output, &$p, &$param, &$platform, &$provider, &$random, &$reportText, &$solutionLink, &$testName) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar(171);
+		return $s->toString();
+	}
+}
+function com_wiris_plugin_impl_TestImpl_1(&$this, &$condition, &$ex, &$imageUrl, &$mml, &$outp, &$output, &$p, &$param, &$platform, &$provider, &$random, &$reportText, &$s2, &$solutionLink, &$testName) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar(187);
+		return $s->toString();
+	}
+}
+function com_wiris_plugin_impl_TestImpl_2(&$this, &$condition, &$ex, &$imageUrl, &$mml, &$outp, &$output, &$p, &$param, &$platform, &$provider, &$random, &$reportText, &$s2, &$solutionLink, &$testName) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar(168);
+		return $s->toString();
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/TextFilter.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/TextFilter.class.php
new file mode 100644
index 0000000..572531c
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/TextFilter.class.php
@@ -0,0 +1,254 @@
+<?php
+
+class com_wiris_plugin_impl_TextFilter {
+	public function __construct($plugin) {
+		if(!php_Boot::$skip_constructor) {
+		$this->plugin = $plugin;
+		$this->render = $plugin->newRender();
+		$this->service = $plugin->newTextService();
+		$this->fixUrl = null;
+	}}
+	public function save_xml_encode($str) {
+		$tags = com_wiris_plugin_impl_TextFilterTags::newSafeXml();
+		$str = str_replace($tags->out_double_quote, $tags->in_double_quote, $str);
+		$str = str_replace($tags->out_open, $tags->in_open, $str);
+		$str = str_replace($tags->out_close, $tags->in_close, $str);
+		$str = str_replace($tags->out_entity, $tags->in_entity, $str);
+		$str = str_replace($tags->out_quote, $tags->in_quote, $str);
+		return $str;
+	}
+	public function html_entity_encode($str) {
+		$str = str_replace("<", "&lt;", $str);
+		$str = str_replace(">", "&gt;", $str);
+		$str = str_replace("\"", "&quot;", $str);
+		$str = str_replace("&", "&amp;", $str);
+		return $str;
+	}
+	public function html_entity_decode($str) {
+		$str = str_replace("&lt;", "<", $str);
+		$str = str_replace("&gt;", ">", $str);
+		$str = str_replace("&quot;", "\"", $str);
+		$str = str_replace("&nbsp;", com_wiris_plugin_impl_TextFilter::$NBSP, $str);
+		$str = str_replace("&amp;", "&", $str);
+		return $str;
+	}
+	public function math2Img($str, $prop) {
+		$img = "<img";
+		$output = array();;
+		$prop["centerbaseline"] = "false";
+		$prop["accessible"] = "true";
+		$prop["metrics"] = "true";
+		$provider = $this->plugin->newGenericParamsProvider($prop);
+		$src = null;
+		$alt = null;
+		$width = null;
+		$height = null;
+		$baseline = null;
+		if($this->plugin->getConfiguration()->getProperty("wirispluginperformance", "false") === "false") {
+			$src = $this->render->createImage($str, $provider, $output);
+			$img .= " src=\"" . $src . "\"";
+			$alt = com_wiris_system_PropertiesTools::getProperty($output, "alt", null);
+			$width = com_wiris_system_PropertiesTools::getProperty($output, "width", null);
+			$height = com_wiris_system_PropertiesTools::getProperty($output, "height", null);
+			$baseline = com_wiris_system_PropertiesTools::getProperty($output, "baseline", null);
+		} else {
+			$digest = $this->render->computeDigest($str, $prop);
+			$hashImage = $this->render->showImageHash($digest, com_wiris_system_PropertiesTools::getProperty($prop, "lang", null));
+			if($hashImage === null) {
+				$this->render->showImage(null, $str, $provider);
+				$hashImage = $this->render->showImageHash($digest, com_wiris_system_PropertiesTools::getProperty($prop, "lang", null));
+			}
+			$content = $hashImage->get("content");
+			if($this->plugin->getConfiguration()->getProperty("wirisimageformat", "png") === "png") {
+				$img .= " src=\"data:image/png;base64," . $content . "\"";
+			} else {
+				$img .= " src=\"data:image/svg+xml;charset=utf8," . com_wiris_util_type_UrlUtils::urlComponentEncode($content) . "\"";
+			}
+			if($hashImage->exists("alt")) {
+				$alt = $hashImage->get("alt");
+			} else {
+				$alt = $this->service->mathml2accessible($str, null, $prop);
+			}
+			$width = $hashImage->get("width");
+			$height = $hashImage->get("height");
+			$baseline = $hashImage->get("baseline");
+		}
+		$dpi = Std::parseFloat($this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$WIRIS_DPI, "96"));
+		if($this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMS, null) !== null) {
+			$json = com_wiris_util_json_JSon::decode($this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMS, null));
+			$decodedHash = $json;
+			if($decodedHash->exists("dpi")) {
+				$dpi = Std::parseFloat($decodedHash->get("dpi"));
+			}
+		}
+		$mml = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$FILTER_OUTPUT_MATHML, "false") === "true";
+		$f = 96 / $dpi;
+		$dwidth = $f * Std::parseFloat($width);
+		$dheight = $f * Std::parseFloat($height);
+		$dbaseline = $f * Std::parseFloat($baseline);
+		$alt = $this->html_entity_encode($alt);
+		$img .= " class=\"Wirisformula\"";
+		$img .= " alt=\"" . $alt . "\"";
+		$img .= " width=\"" . _hx_string_rec($dwidth, "") . "\"";
+		$img .= " height=\"" . _hx_string_rec($dheight, "") . "\"";
+		$d = $dbaseline - $dheight;
+		$img .= " style=\"vertical-align:" . _hx_string_rec($d, "") . "px\"";
+		if($mml) {
+			$tag = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_MATHML_ATTRIBUTE, "data-mathml");
+			$img .= " " . $tag . "='" . $this->save_xml_encode($str) . "'";
+		}
+		$img .= "/>";
+		return $img;
+	}
+	public function filterApplet($tags, $text, $prop, $safeXML) {
+		$n0 = null;
+		$n1 = null;
+		$output = null;
+		$sub = null;
+		$output = new StringBuf();
+		$n0 = 0;
+		$n1 = _hx_index_of(strtoupper($text), $tags->in_appletopen, $n0);
+		while($n1 >= 0) {
+			$output->add(_hx_substr($text, $n0, $n1 - $n0));
+			$n0 = $n1;
+			$n1 = _hx_index_of(strtoupper($text), $tags->in_appletclose, $n0);
+			if($n1 >= 0) {
+				$n1 = $n1 + strlen($tags->in_appletclose);
+				$sub = _hx_substr($text, $n0, $n1 - $n0);
+				if($safeXML) {
+					if($this->fixUrl === null) {
+						$this->fixUrl = new EReg("<a href=\"[^\"]*\"[^>]*>([^<]*)<\\/a>|<a href=\"[^\"]*\">", "");
+					}
+					$sub = $this->fixUrl->replace($sub, "\$1");
+					$sub = $this->html_entity_decode($sub);
+					$sub = str_replace($tags->in_double_quote, $tags->out_double_quote, $sub);
+					$sub = str_replace($tags->in_open, $tags->out_open, $sub);
+					$sub = str_replace($tags->in_close, $tags->out_close, $sub);
+					$sub = str_replace($tags->in_entity, $tags->out_entity, $sub);
+					$sub = str_replace($tags->in_quote, $tags->out_quote, $sub);
+				}
+				$n0 = $n1;
+				$output->add($sub);
+				$n1 = _hx_index_of(strtoupper($text), $tags->in_appletopen, $n0);
+			}
+		}
+		$output->add(_hx_substr($text, $n0, null));
+		return $output->b;
+	}
+	public function filterMath($tags, $text, $prop, $safeXML) {
+		$n0 = null;
+		$n1 = null;
+		$m0 = null;
+		$m1 = null;
+		$output = null;
+		$sub = null;
+		$output = new StringBuf();
+		$n0 = 0;
+		$n1 = _hx_index_of($text, $tags->in_mathopen, $n0);
+		$tag = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_MATHML_ATTRIBUTE, "data-mathml");
+		$dataMathml = _hx_index_of($text, $tag, 0);
+		while($n1 >= 0) {
+			$m0 = $n0;
+			$output->add(_hx_substr($text, $n0, $n1 - $n0));
+			$n0 = $n1;
+			$n1 = _hx_index_of($text, $tags->in_mathclose, $n0);
+			if($n1 >= 0) {
+				$n1 = $n1 + strlen($tags->in_mathclose);
+				$sub = _hx_substr($text, $n0, $n1 - $n0);
+				if($safeXML) {
+					if($dataMathml !== -1) {
+						$m1 = _hx_index_of($text, "/>", $n1);
+						if($m1 >= 0 && (_hx_index_of($text, "<img", $n1) === -1 || _hx_index_of($text, "<img", $n1) > $m1)) {
+							$m0 = _hx_last_index_of(_hx_substr($text, $m0, $n0 - $m0), "<img", null);
+							if($m0 >= 0) {
+								if(_hx_index_of($text, $tag, $m0) > 0 && _hx_index_of($text, $tag, $m0) < $n1) {
+									$n0 = $n1;
+									$output->add($sub);
+									$n1 = _hx_index_of($text, $tags->in_mathopen, $n0);
+									$m0 = $m1;
+									continue;
+								}
+							}
+						}
+					}
+					if($this->fixUrl === null) {
+						$this->fixUrl = new EReg("<a href=\"[^\"]*\"[^>]*>([^<]*)<\\/a>|<a href=\"[^\"]*\">", "");
+					}
+					$sub = $this->fixUrl->replace($sub, "\$1");
+					$sub = $this->html_entity_decode($sub);
+					$sub = str_replace($tags->in_double_quote, $tags->out_double_quote, $sub);
+					$sub = str_replace($tags->in_open, $tags->out_open, $sub);
+					$sub = str_replace($tags->in_close, $tags->out_close, $sub);
+					$sub = str_replace($tags->in_entity, $tags->out_entity, $sub);
+					$sub = str_replace($tags->in_quote, $tags->out_quote, $sub);
+				}
+				$subtext = null;
+				try {
+					$subtext = $this->math2Img($sub, $prop);
+				}catch(Exception $e) {
+					$_ex_ = ($e instanceof HException) ? $e->e : $e;
+					$e = $_ex_;
+					{
+						$subtext = $sub;
+					}
+				}
+				$sub = $subtext;
+				$n0 = $n1;
+				$output->add($sub);
+				$n1 = _hx_index_of($text, $tags->in_mathopen, $n0);
+				unset($subtext,$e);
+			}
+		}
+		$output->add(_hx_substr($text, $n0, null));
+		return $output->b;
+	}
+	public function filter($str, $prop) {
+		$saveMode = null;
+		if($prop !== null) {
+			$saveMode = com_wiris_system_PropertiesTools::getProperty($prop, "savemode", null);
+		}
+		if($saveMode === null) {
+			$saveMode = $this->plugin->getConfiguration()->getProperty(com_wiris_plugin_api_ConfigurationKeys::$SAVE_MODE, "xml");
+		}
+		$b = null;
+		$b = $saveMode === "safeXml";
+		$tags = null;
+		$mathNamespace = null;
+		$namespaceIndex = _hx_index_of($str, ":" . "math", null);
+		if($namespaceIndex >= 0) {
+			$mathNamespace = _hx_substr($str, _hx_last_index_of($str, "<", $namespaceIndex) + 1, $namespaceIndex - (_hx_last_index_of($str, "<", $namespaceIndex) + 1));
+		}
+		if($b) {
+			$tags = com_wiris_plugin_impl_TextFilterTags::newSafeXml();
+		} else {
+			$tags = com_wiris_plugin_impl_TextFilterTags::newXml($mathNamespace);
+		}
+		$str = $this->filterMath($tags, $str, $prop, $b);
+		$str = $this->filterApplet($tags, $str, $prop, $b);
+		return $str;
+	}
+	public $fixUrl;
+	public $service;
+	public $render;
+	public $plugin;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $NBSP;
+	function __toString() { return 'com.wiris.plugin.impl.TextFilter'; }
+}
+com_wiris_plugin_impl_TextFilter::$NBSP = com_wiris_plugin_impl_TextFilter_0();
+function com_wiris_plugin_impl_TextFilter_0() {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar(160);
+		return $s->toString();
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/TextFilterTags.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/TextFilterTags.class.php
new file mode 100644
index 0000000..d557850
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/TextFilterTags.class.php
@@ -0,0 +1,97 @@
+<?php
+
+class com_wiris_plugin_impl_TextFilterTags {
+	public function __construct() {
+		;
+	}
+	public function init($tags, $mathNamespace) {
+		if($mathNamespace !== null) {
+			$tags->mathTag = $mathNamespace . ":" . $tags->mathTag;
+		}
+		$tags->in_appletopen = $this->in_open . "APPLET";
+		$tags->in_appletclose = $this->in_open . "/APPLET" . $this->in_close;
+		$tags->in_mathopen = $this->in_open . $this->mathTag;
+		$tags->in_mathclose = $this->in_open . "/" . $this->mathTag . $this->in_close;
+		$tags->out_open = "<";
+		$tags->out_close = ">";
+		$tags->out_entity = "&";
+		$tags->out_quote = "'";
+		$tags->out_double_quote = "\"";
+	}
+	public $mathTag;
+	public $in_appletclose;
+	public $in_appletopen;
+	public $out_quote;
+	public $in_quote;
+	public $out_entity;
+	public $in_entity;
+	public $out_close;
+	public $in_close;
+	public $out_open;
+	public $in_open;
+	public $out_double_quote;
+	public $in_double_quote;
+	public $in_mathclose;
+	public $in_mathopen;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function newSafeXml() {
+		$tags = new com_wiris_plugin_impl_TextFilterTags();
+		$tags->in_open = com_wiris_plugin_impl_TextFilterTags_0($tags);
+		$tags->in_close = com_wiris_plugin_impl_TextFilterTags_1($tags);
+		$tags->in_entity = com_wiris_plugin_impl_TextFilterTags_2($tags);
+		$tags->in_quote = "`";
+		$tags->in_double_quote = com_wiris_plugin_impl_TextFilterTags_3($tags);
+		$tags->mathTag = "math";
+		$tags->init($tags, null);
+		return $tags;
+	}
+	static function newXml($mathNamespace) {
+		$tags = new com_wiris_plugin_impl_TextFilterTags();
+		$tags->in_open = "<";
+		$tags->in_close = ">";
+		$tags->in_entity = "&";
+		$tags->in_quote = "'";
+		$tags->in_double_quote = "\"";
+		$tags->mathTag = "math";
+		$tags->init($tags, $mathNamespace);
+		return $tags;
+	}
+	function __toString() { return 'com.wiris.plugin.impl.TextFilterTags'; }
+}
+function com_wiris_plugin_impl_TextFilterTags_0(&$tags) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar(171);
+		return $s->toString();
+	}
+}
+function com_wiris_plugin_impl_TextFilterTags_1(&$tags) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar(187);
+		return $s->toString();
+	}
+}
+function com_wiris_plugin_impl_TextFilterTags_2(&$tags) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar(167);
+		return $s->toString();
+	}
+}
+function com_wiris_plugin_impl_TextFilterTags_3(&$tags) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar(168);
+		return $s->toString();
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/TextServiceImpl.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/TextServiceImpl.class.php
new file mode 100644
index 0000000..5ce40ea
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/TextServiceImpl.class.php
@@ -0,0 +1,193 @@
+<?php
+
+class com_wiris_plugin_impl_TextServiceImpl implements com_wiris_plugin_impl_HttpListener, com_wiris_plugin_api_TextService{
+	public function __construct($plugin) {
+		if(!php_Boot::$skip_constructor) {
+		$this->plugin = $plugin;
+	}}
+	public function onError($msg) {
+		if($this->serviceName === "mathml2accessible") {
+			$this->status = com_wiris_util_json_JsonAPIResponse::$STATUS_WARNING;
+			$this->data = "Error converting from MathML to accessible text.";
+		} else {
+			$this->error = $msg;
+			$this->status = com_wiris_util_json_JsonAPIResponse::$STATUS_ERROR;
+		}
+	}
+	public function onData($msg) {
+		$this->status = com_wiris_util_json_JsonAPIResponse::$STATUS_OK;
+	}
+	public function filter($str, $prop) {
+		return _hx_deref(new com_wiris_plugin_impl_TextFilter($this->plugin))->filter($str, $prop);
+	}
+	public function getMathML($digest, $latex) {
+		if($digest !== null) {
+			$content = $this->plugin->getStorageAndCache()->decodeDigest($digest);
+			if($content !== null) {
+				if(StringTools::startsWith($content, "<")) {
+					$breakline = null;
+					$breakline = _hx_index_of($content, "\x0A", 0);
+					return _hx_substr($content, 0, $breakline);
+				} else {
+					$iniFile = com_wiris_util_sys_IniFile::newIniFileFromString($content);
+					$mathml = $iniFile->getProperties()->get("mml");
+					if($mathml !== null) {
+						return $mathml;
+					} else {
+						return "Error: mathml not found.";
+					}
+				}
+			} else {
+				return "Error: formula not found.";
+			}
+		} else {
+			if($latex !== null) {
+				return $this->latex2mathml($latex);
+			} else {
+				return "Error: no digest or latex has been sent.";
+			}
+		}
+	}
+	public function latex2mathml($latex) {
+		$param = array();;
+		$param["latex"] = $latex;
+		$provider = $this->plugin->newGenericParamsProvider($param);
+		$mathml = $this->service("latex2mathml", $provider);
+		return ((_hx_index_of($mathml, "Error converting", null) !== -1) ? $mathml : $latex);
+	}
+	public function mathml2latex($mml) {
+		$param = array();;
+		$param["mml"] = $mml;
+		$provider = $this->plugin->newGenericParamsProvider($param);
+		return $this->service("mathml2latex", $provider);
+	}
+	public function mathml2accessible($mml, $lang, $param) {
+		if($lang !== null) {
+			$param["lang"] = $lang;
+		}
+		$param["mml"] = $mml;
+		$provider = $this->plugin->newGenericParamsProvider($param);
+		$reponse = $this->jsonResponse("mathml2accessible", $provider);
+		if($reponse->getStatus() === com_wiris_util_json_JsonAPIResponse::$STATUS_OK) {
+			$result = $reponse->getResult();
+			return $result->get("text");
+		} else {
+			return "Error converting from mathml to text";
+		}
+	}
+	public function jsonResponse($serviceName, $provider) {
+		$renderParams = $provider->getRenderParameters($this->plugin->getConfiguration());
+		$digest = $this->plugin->newRender()->computeDigest(null, $renderParams);
+		$this->serviceName = $serviceName;
+		$url = $this->plugin->getImageServiceURL($serviceName, com_wiris_plugin_impl_TextServiceImpl::hasStats($serviceName));
+		$h = new com_wiris_plugin_impl_HttpImpl($url, $this);
+		$this->plugin->addReferer($h);
+		$this->plugin->addProxy($h);
+		$ha = com_wiris_system_PropertiesTools::fromProperties($provider->getServiceParameters());
+		$iter = $ha->keys();
+		while($iter->hasNext()) {
+			$k = $iter->next();
+			$h->setParameter($k, $ha->get($k));
+			unset($k);
+		}
+		$h->setParameter("httpstatus", "true");
+		try {
+			$h->request(true);
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+				if(_hx_index_of($serviceName, "mathml2accessible", null) !== -1) {
+					return null;
+				} else {
+					throw new HException($e->getMessage());
+				}
+			}
+		}
+		$r = com_wiris_plugin_impl_TextServiceImpl_0($this, $digest, $e, $h, $ha, $iter, $provider, $renderParams, $serviceName, $url);
+		$response = new com_wiris_util_json_JsonAPIResponse();
+		if($this->status === com_wiris_util_json_JsonAPIResponse::$STATUS_ERROR) {
+			$response->setStatus(com_wiris_util_json_JsonAPIResponse::$STATUS_ERROR);
+			$response->addError($this->error);
+		} else {
+			$response->setStatus(com_wiris_util_json_JsonAPIResponse::$STATUS_OK);
+			$response->addResult("text", $r);
+		}
+		if($digest !== null) {
+			$store = $this->plugin->getStorageAndCache();
+			$ext = com_wiris_plugin_impl_TextServiceImpl::getDigestExtension($serviceName, $provider);
+			$store->storeData($digest, $ext, com_wiris_system_Utf8::toBytes($response->getResponse()));
+		}
+		return $response;
+	}
+	public function service($serviceName, $provider) {
+		$this->serviceName = $serviceName;
+		$digest = null;
+		$renderParams = $provider->getRenderParameters($this->plugin->getConfiguration());
+		if(com_wiris_plugin_impl_TextServiceImpl::hasCache($serviceName)) {
+			$digest = $this->plugin->newRender()->computeDigest(null, $renderParams);
+			$store = $this->plugin->getStorageAndCache();
+			$ext = com_wiris_plugin_impl_TextServiceImpl::getDigestExtension($serviceName, $provider);
+			$s = $store->retreiveData($digest, $ext);
+			if($s !== null) {
+				$cachedServiceText = com_wiris_system_Utf8::fromBytes($s);
+				try {
+					com_wiris_util_json_JSon::decode($cachedServiceText);
+				}catch(Exception $e) {
+					$_ex_ = ($e instanceof HException) ? $e->e : $e;
+					$e = $_ex_;
+					{
+						$cachedJsonResponse = new com_wiris_util_json_JsonAPIResponse();
+						$cachedJsonResponse->setStatus(com_wiris_util_json_JsonAPIResponse::$STATUS_OK);
+						$cachedJsonResponse->addResult("text", $cachedServiceText);
+						return $cachedJsonResponse->getResponse();
+					}
+				}
+				return $cachedServiceText;
+			}
+		}
+		return $this->jsonResponse($serviceName, $provider)->getResponse();
+	}
+	public $data;
+	public $error;
+	public $status;
+	public $serviceName;
+	public $plugin;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function hasCache($serviceName) {
+		if($serviceName === "mathml2accessible") {
+			return true;
+		}
+		return false;
+	}
+	static function hasStats($serviceName) {
+		if($serviceName === "latex2mathml") {
+			return true;
+		}
+		return false;
+	}
+	static function getDigestExtension($serviceName, $provider) {
+		$lang = $provider->getParameter("lang", "en");
+		if($lang !== null && strlen($lang) === 0) {
+			return "en";
+		}
+		return $lang;
+	}
+	function __toString() { return 'com.wiris.plugin.impl.TextServiceImpl'; }
+}
+function com_wiris_plugin_impl_TextServiceImpl_0(&$this, &$digest, &$e, &$h, &$ha, &$iter, &$provider, &$renderParams, &$serviceName, &$url) {
+	if($this->data !== null) {
+		return $this->data;
+	} else {
+		return $h->getData();
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/impl/TextServiceImplIntegratedServices.class.php b/filter/wiris/integration/lib/com/wiris/plugin/impl/TextServiceImplIntegratedServices.class.php
new file mode 100644
index 0000000..429f64b
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/impl/TextServiceImplIntegratedServices.class.php
@@ -0,0 +1,121 @@
+<?php
+
+class com_wiris_plugin_impl_TextServiceImplIntegratedServices extends com_wiris_plugin_impl_TextServiceImpl {
+	public function __construct($plugin) { if(!php_Boot::$skip_constructor) {
+		parent::__construct($plugin);
+	}}
+	public function mathml2accessible($mml, $lang, $param) {
+		$servicesClass = Type::resolveClass("com.wiris.editor.services.PublicServices");
+		$getInstance = Reflect::field($servicesClass, "getInstance");
+		$publicServices = Reflect::callMethod($servicesClass, $getInstance, null);
+		$serviceMethod = Reflect::field($publicServices, "mathml2accessible");
+		$args = new _hx_array(array());
+		if($mml === null) {
+			throw new HException("Missing mml");
+		} else {
+			$args->push($mml);
+		}
+		$args->push($lang);
+		$args->push($param);
+		$serviceText = null;
+		$serviceText = Reflect::callMethod($publicServices, $serviceMethod, $args);
+		return $serviceText;
+	}
+	public function serviceText($serviceName, $provider) {
+		$servicesClass = Type::resolveClass("com.wiris.editor.services.PublicServices");
+		$getInstance = Reflect::field($servicesClass, "getInstance");
+		$publicServices = Reflect::callMethod($servicesClass, $getInstance, null);
+		$serviceMethod = Reflect::field($publicServices, $serviceName);
+		$args = new _hx_array(array());
+		$jsonResponse = new com_wiris_util_json_JsonAPIResponse();
+		$result = new Hash();
+		$serviceText = null;
+		try {
+			if(_hx_index_of($serviceName, "mathml2accessible", null) !== -1) {
+				$mml = $provider->getParameter("mml", null);
+				if($mml === null) {
+					throw new HException("Missing mml");
+				} else {
+					$args->push($mml);
+				}
+				$lang = $provider->getParameter("lang", "en");
+				$args->push($lang);
+				$args->push($provider->getParameters());
+				$serviceText = Reflect::callMethod($publicServices, $serviceMethod, $args);
+			} else {
+				if(_hx_index_of($serviceName, "mathml2latex", null) !== -1) {
+					$mml = $provider->getParameter("mml", null);
+					if($mml === null) {
+						throw new HException("Missing mml");
+					} else {
+						$args->push($mml);
+					}
+					$keepMathml = $provider->getParameter("keepMathml", "false");
+					if(_hx_index_of($keepMathml, "true", null) !== -1) {
+						$args->push(true);
+					} else {
+						$args->push(false);
+					}
+					$args->push($provider->getParameters());
+					$serviceText = Reflect::callMethod($publicServices, $serviceMethod, $args);
+				} else {
+					if(_hx_index_of($serviceName, "latex2mathml", null) !== -1) {
+						$latex = $provider->getParameter("latex", null);
+						if($latex === null) {
+							throw new HException("Missing LaTeX");
+						} else {
+							$args->push($latex);
+						}
+						$keepLatex = $provider->getParameter("saveLatex", "false");
+						if(_hx_index_of($keepLatex, "false", null) !== -1) {
+							$args->push(false);
+						} else {
+							$args->push(true);
+						}
+						$args->push($provider->getParameters());
+						$serviceText = Reflect::callMethod($publicServices, $serviceMethod, $args);
+					} else {
+						throw new HException("Unknow service " . $serviceName);
+					}
+				}
+			}
+			$result->set("text", $serviceText);
+			$jsonResponse->setStatus(com_wiris_util_json_JsonAPIResponse::$STATUS_OK);
+			$jsonResponse->setResult($result);
+			return $jsonResponse->getResponse();
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+				if(_hx_index_of($serviceName, "mathml2accessible", null) !== -1) {
+					$result->set("text", "Error converting from MathML to accessible text");
+					$jsonResponse->setResult($result);
+					$jsonResponse->setStatus(com_wiris_util_json_JsonAPIResponse::$STATUS_WARNING);
+					return $jsonResponse->getResponse();
+				} else {
+					throw new HException($e->getMessage());
+				}
+			}
+		}
+	}
+	public function service($serviceName, $provider) {
+		$digest = null;
+		if(com_wiris_plugin_impl_TextServiceImpl::hasCache($serviceName)) {
+			$digest = $this->plugin->newRender()->computeDigest(null, $provider->getRenderParameters($this->plugin->getConfiguration()));
+			$store = $this->plugin->getStorageAndCache();
+			$ext = com_wiris_plugin_impl_TextServiceImpl::getDigestExtension($serviceName, $provider);
+			$s = $store->retreiveData($digest, $ext);
+			if($s !== null) {
+				return com_wiris_system_Utf8::fromBytes($s);
+			}
+		}
+		$result = $this->serviceText($serviceName, $provider);
+		if($digest !== null) {
+			$store = $this->plugin->getStorageAndCache();
+			$ext = com_wiris_plugin_impl_TextServiceImpl::getDigestExtension($serviceName, $provider);
+			$store->storeData($digest, $ext, com_wiris_system_Utf8::toBytes($result));
+		}
+		return $result;
+	}
+	function __toString() { return 'com.wiris.plugin.impl.TextServiceImplIntegratedServices'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/storage/StorageAndCache.interface.php b/filter/wiris/integration/lib/com/wiris/plugin/storage/StorageAndCache.interface.php
new file mode 100644
index 0000000..4298908
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/storage/StorageAndCache.interface.php
@@ -0,0 +1,10 @@
+<?php
+
+interface com_wiris_plugin_storage_StorageAndCache {
+	function deleteCache();
+	function storeData($digest, $service, $stream);
+	function retreiveData($digest, $service);
+	function decodeDigest($digest);
+	function codeDigest($content);
+	function init($obj, $config, $cache, $cacheFormula);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/plugin/web/PhpConfigurationUpdater.class.php b/filter/wiris/integration/lib/com/wiris/plugin/web/PhpConfigurationUpdater.class.php
new file mode 100644
index 0000000..78c518d
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/plugin/web/PhpConfigurationUpdater.class.php
@@ -0,0 +1,68 @@
+<?php
+
+class com_wiris_plugin_web_PhpConfigurationUpdater implements com_wiris_plugin_configuration_ConfigurationUpdater{
+	public function __construct() { 
+	}
+	public function updateConfiguration(&$configuration) {
+		$configuration = $configuration;
+		$v = null;
+		$base = null;
+		$base = dirname(__FILE__);
+		$v = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$CACHE_FOLDER, null);
+		if($v === null) {
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$CACHE_FOLDER] = $base . "/../../../../../../cache";
+		}
+		$v = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$FORMULA_FOLDER, null);
+		if($v === null) {
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$FORMULA_FOLDER] = $base . "/../../../../../../formulas";
+		}
+		$v = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$SHOWIMAGE_PATH, null);
+		if($v === null) {
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$SHOWIMAGE_PATH] = "integration/showimage.php?formula=";
+		}
+		$v = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$SHOWCASIMAGE_PATH, null);
+		if($v === null) {
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$SHOWCASIMAGE_PATH] = "integration/showcasimage.php?formula=";
+		}
+		$v = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$CLEAN_CACHE_PATH, null);
+		if($v === null) {
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$CLEAN_CACHE_PATH] = "cleancache.php";
+		}
+		$v = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$RESOURCE_PATH, null);
+		if($v === null) {
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$RESOURCE_PATH] = "resource.php";
+		}
+		$v = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$CONTEXT_PATH, null);
+		if($v === null) {
+			$filePath = dirname(dirname($_SERVER['SCRIPT_NAME']));
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$CONTEXT_PATH] = $filePath . "/";
+		}
+		$v = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$CONFIGURATION_PATH, null);
+		if($v === null) {
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$CONFIGURATION_PATH] = $base . "/../../../../../..";
+		}
+		$v = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$EXTERNAL_REFERER, null);
+		if($v === null) {
+			$external_referer = isset($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : '';
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$EXTERNAL_REFERER] = $external_referer;
+		}
+		$v = com_wiris_system_PropertiesTools::getProperty($configuration, com_wiris_plugin_api_ConfigurationKeys::$REFERER, null);
+		if($v === null) {
+			$referer = ((empty($_SERVER['HTTPS'])) ? "http://" : "https://");
+			$referer .= $_SERVER['SERVER_NAME'] . $_SERVER['SCRIPT_NAME'];
+			if(isset($_SERVER['QUERY_STRING'])) {
+				$referer .= "?" . $_SERVER['QUERY_STRING'];
+			}
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$REFERER] = $referer;
+		}
+		$userAgent = null;
+		$userAgent = new com_wiris_util_net_UserAgent(new com_wiris_system_service_HttpRequest());
+		if($userAgent->isIe()) {
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$IMAGE_FORMAT] = "png";
+			$configuration[com_wiris_plugin_api_ConfigurationKeys::$IMPROVE_PERFORMANCE] = "false";
+		}
+	}
+	public function init($obj) {
+	}
+	function __toString() { return 'com.wiris.plugin.web.PhpConfigurationUpdater'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/std/system/HttpProxy.class.php b/filter/wiris/integration/lib/com/wiris/std/system/HttpProxy.class.php
new file mode 100644
index 0000000..b079c2e
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/std/system/HttpProxy.class.php
@@ -0,0 +1,32 @@
+<?php
+
+class com_wiris_std_system_HttpProxy {
+	public function __construct($host, $port) {
+		if(!php_Boot::$skip_constructor) {
+		$this->port = $port;
+		$this->host = $host;
+		$this->auth = null;
+	}}
+	public $auth;
+	public $host;
+	public $port;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function newHttpProxy($host, $port, $user, $pass) {
+		$proxy = new com_wiris_std_system_HttpProxy($host, $port);
+		$hpa = new com_wiris_std_system_HttpProxyAuth();
+		$hpa->user = $user;
+		$hpa->pass = $pass;
+		$proxy->auth = $hpa;
+		return $proxy;
+	}
+	function __toString() { return 'com.wiris.std.system.HttpProxy'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/std/system/HttpProxyAuth.class.php b/filter/wiris/integration/lib/com/wiris/std/system/HttpProxyAuth.class.php
new file mode 100644
index 0000000..86dcac6
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/std/system/HttpProxyAuth.class.php
@@ -0,0 +1,20 @@
+<?php
+
+class com_wiris_std_system_HttpProxyAuth {
+	public function __construct() {
+		;
+	}
+	public $pass;
+	public $user;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.std.system.HttpProxyAuth'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/ArrayEx.class.php b/filter/wiris/integration/lib/com/wiris/system/ArrayEx.class.php
new file mode 100644
index 0000000..9398bad
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/ArrayEx.class.php
@@ -0,0 +1,30 @@
+<?php
+
+class com_wiris_system_ArrayEx {
+	public function __construct(){}
+	static function contains($a, $b) {
+		{
+			$_g = 0;
+			while($_g < $a->length) {
+				$x = $a[$_g];
+				++$_g;
+				if($x == $b) {
+					return true;
+				}
+				unset($x);
+			}
+		}
+		return false;
+	}
+	static function indexOf($a, $b) {
+		$idx = 0;
+		while($idx < $a->length) {
+			if($a[$idx] == $b) {
+				return $idx;
+			}
+			++$idx;
+		}
+		return -1;
+	}
+	function __toString() { return 'com.wiris.system.ArrayEx'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/Base64.class.php b/filter/wiris/integration/lib/com/wiris/system/Base64.class.php
new file mode 100644
index 0000000..022b875
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/Base64.class.php
@@ -0,0 +1,20 @@
+<?php
+
+class com_wiris_system_Base64 extends haxe_BaseCode {
+	public function __construct() { if(!php_Boot::$skip_constructor) {
+		parent::__construct(haxe_io_Bytes::ofString("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"));
+	}}
+	public function encodeBytes($bytes) {
+		$base64 = parent::encodeBytes($bytes)->toString();
+		$remaining = 4 - _hx_mod(strlen($base64), 4);
+		while($remaining > 0 && $remaining < 3) {
+			$base64 .= "=";
+			--$remaining;
+		}
+		return haxe_io_Bytes::ofString($base64);
+	}
+	public function decodeBytes($bytes) {
+		return haxe_io_Bytes::ofString(base64_decode($bytes->b));
+	}
+	function __toString() { return 'com.wiris.system.Base64'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/CallWrapper.class.php b/filter/wiris/integration/lib/com/wiris/system/CallWrapper.class.php
new file mode 100644
index 0000000..4d3aeff
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/CallWrapper.class.php
@@ -0,0 +1,111 @@
+<?php
+
+class com_wiris_system_CallWrapper {
+	public function __construct() {
+		;
+	}
+	public function autoload($className) {
+		if(function_exists('__autoload')) {
+			__autoload($className);
+		}
+	}
+	public function phpStop() {
+		spl_autoload_unregister('_hx_autoload');
+		spl_autoload_register(array($this, 'autoload'));
+		restore_exception_handler();
+		restore_error_handler();
+		error_reporting($this->errorReportingLevel);
+	}
+	public function setErrorReporting($level) {
+		$this->errorReportingLevel = $level;
+	}
+	public function phpStart() {
+		$this->errorReportingLevel = error_reporting(E_ALL & ~E_STRICT);
+		set_error_handler('_hx_error_handler', E_ALL);
+		set_exception_handler('_hx_exception_handler');
+		spl_autoload_register('_hx_autoload');
+	}
+	public function stop() {
+		if($this->isRunning) {
+			$this->isRunning = false;
+			$this->phpStop();
+		}
+	}
+	public function start() {
+		if(!$this->isRunning) {
+			$this->isRunning = true;
+			$this->phpStart();
+			com_wiris_system_Storage::$resourcesDir = null;
+		}
+	}
+	public function init($haxelib) {
+		if(!class_exists('php_Boot', false)) {
+			$this->setErrorReporting(error_reporting());
+			require_once($haxelib . '/lib/php/Boot.class.php');;
+			$this->phpStop();
+		} else {
+			if(is_file($haxelib . '/cache/haxe_autoload.php')) {
+				require_once($haxelib . '/cache/haxe_autoload.php');;
+			} else {
+				
+					if (!function_exists('_hx_wiris_load')) {
+						function _hx_wiris_load($d, $pack = array()) {
+							$h = opendir($d);
+							while(false !== ($f = readdir($h))) {
+								if($f == '.' || $f == '..') continue;
+								$p = $d . '/' . $f;
+								if (is_file($p) && substr($f, -4) == '.php') {
+									$bn = basename($f, '.php');
+									$name = false;
+									if(substr($bn, -6) == '.class') {
+										$bn = substr($bn, 0, -6);
+										$t = '_hx_class';
+									} else if(substr($bn, -5) == '.enum') {
+										$bn = substr($bn, 0, -5);
+										$t = '_hx_enum';
+									} else if(substr($bn, -10) == '.interface') {
+										$bn = substr($bn, 0, -10);
+										$t = '_hx_interface';
+									} else if(substr($bn, -7) == '.extern') {
+										$bn = substr($bn, 0, -7);
+										$t = '_hx_class';
+										$name = $bn;
+									} else {
+										continue;
+									}
+									$qname = ($bn == 'HList' && empty($pack)) ? 'List' : join(array_merge($pack, array($bn)), '.');
+									$phpname = !empty($name) ? $name : join(array_merge($pack, array($bn)), '_');
+									_hx_register_type(new $t($phpname, $qname, $p));
+
+								} else if(is_dir($p)) {
+									_hx_wiris_load($p, array_merge($pack, array($f)));
+								}
+							}
+						}
+					}
+					_hx_wiris_load($haxelib . '/lib');
+					;
+			}
+		}
+	}
+	public $errorReportingLevel;
+	public $isRunning = false;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $wrapper;
+	static function getInstance() {
+		if(com_wiris_system_CallWrapper::$wrapper === null) {
+			com_wiris_system_CallWrapper::$wrapper = new com_wiris_system_CallWrapper();
+		}
+		return com_wiris_system_CallWrapper::$wrapper;
+	}
+	function __toString() { return 'com.wiris.system.CallWrapper'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/Exception.class.php b/filter/wiris/integration/lib/com/wiris/system/Exception.class.php
new file mode 100644
index 0000000..ad200f4
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/Exception.class.php
@@ -0,0 +1,23 @@
+<?php
+
+class com_wiris_system_Exception {
+	public function __construct($message, $cause = null) {
+		if(!php_Boot::$skip_constructor) {
+		$this->message = $message;
+	}}
+	public function getMessage() {
+		return $this->message;
+	}
+	public $message;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.system.Exception'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/InputEx.class.php b/filter/wiris/integration/lib/com/wiris/system/InputEx.class.php
new file mode 100644
index 0000000..75b5ed3
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/InputEx.class.php
@@ -0,0 +1,21 @@
+<?php
+
+class com_wiris_system_InputEx {
+	public function __construct(){}
+	static function readInt32_($a) {
+		$ch1 = $a->readByte();
+		$ch2 = $a->readByte();
+		$ch3 = $a->readByte();
+		$ch4 = $a->readByte();
+		return ($ch1 << 8 | $ch2) << 16 | ($ch3 << 8 | $ch4);
+	}
+	static function length_($a) {
+		$x = Reflect::field($a, "len");
+		if($x !== null && Std::is($x, _hx_qtype("Int"))) {
+			return $x;
+		} else {
+			throw new HException("Not implemented!");
+		}
+	}
+	function __toString() { return 'com.wiris.system.InputEx'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/Md5Tools.class.php b/filter/wiris/integration/lib/com/wiris/system/Md5Tools.class.php
new file mode 100644
index 0000000..9274c43
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/Md5Tools.class.php
@@ -0,0 +1,12 @@
+<?php
+
+class com_wiris_system_Md5Tools {
+	public function __construct(){}
+	static function encodeString($content) {
+		return haxe_Md5::encode($content);
+	}
+	static function encodeBytes($content) {
+		return haxe_Md5::encode($content->toString());
+	}
+	function __toString() { return 'com.wiris.system.Md5Tools'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/PropertiesTools.class.php b/filter/wiris/integration/lib/com/wiris/system/PropertiesTools.class.php
new file mode 100644
index 0000000..1f17a66
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/PropertiesTools.class.php
@@ -0,0 +1,40 @@
+<?php
+
+class com_wiris_system_PropertiesTools {
+	public function __construct(){}
+	static function getSystemProperty($s) {
+		return null;
+	}
+	static function getProperty($prop, $key, $dflt = null) {
+		if(isset($prop[$key])) {
+			return $prop[$key];
+		}
+		return $dflt;
+	}
+	static function newProperties() {
+		return array();;
+	}
+	static function setProperty($prop, $key, $value) {
+		$prop[$key] = $value;
+	}
+	static function fromProperties($prop) {
+		$ht = new Hash();
+		$key = "";
+		$value = "";
+		foreach ($prop as $key => $value) {
+		$ht->set($key, $value);
+		}
+		return $ht;
+	}
+	static function toProperties($h) {
+		$np = array();;
+		$ks = $h->keys();
+		while($ks->hasNext()) {
+			$k = $ks->next();
+			$np[$k] = $h->get($k);
+			unset($k);
+		}
+		return $np;
+	}
+	function __toString() { return 'com.wiris.system.PropertiesTools'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/Storage.class.php b/filter/wiris/integration/lib/com/wiris/system/Storage.class.php
new file mode 100644
index 0000000..2fb7380
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/Storage.class.php
@@ -0,0 +1,146 @@
+<?php
+
+class com_wiris_system_Storage {
+	public function __construct($location) {
+		if(!php_Boot::$skip_constructor) {
+		$location = str_replace("/", com_wiris_system_Storage::getDirectorySeparator(), $location);
+		$location = str_replace("\\", com_wiris_system_Storage::getDirectorySeparator(), $location);
+		$this->location = $location;
+	}}
+	public function setResourceObject($obj) {
+	}
+	public function hlist() {
+		return sys_FileSystem::readDirectory($this->location);
+	}
+	public function isDirectory() {
+		return is_dir($this->location);
+	}
+	public function delete() {
+		if(is_dir($this->location)) {
+			@rmdir($this->location);
+		} else {
+			@unlink($this->location);
+		}
+	}
+	public function toString() {
+		return $this->location;
+	}
+	public function getParent() {
+		$path = null;
+		$path = com_wiris_system_Storage_0($this, $path);
+		if($path === null) {
+			$path = $this->location;
+		}
+		$index = _hx_last_index_of($path, com_wiris_system_Storage::getDirectorySeparator(), null);
+		$path = (($index !== -1) ? _hx_substr($path, 0, $index) : ".");
+		return new com_wiris_system_Storage($path);
+	}
+	public function mkdirs() {
+		$parent = $this->getParent();
+		if(!$parent->exists()) {
+			$parent->mkdirs();
+		}
+		if(!$this->exists()) {
+			@mkdir($this->location, 493);
+		}
+	}
+	public function exists() {
+		$exists = false;
+		$exists = file_exists($this->location);
+		return $exists;
+	}
+	public function read() {
+		return haxe_io_Bytes::ofData($this->readBinary())->toString();
+	}
+	public function readBinary() {
+		$bytes = null;
+		$fi = sys_io_File::read($this->location, true);
+		$bytes = $fi->readAll(null);
+		return $bytes->b;
+	}
+	public function write($s) {
+		$this->writeBinary(haxe_io_Bytes::ofString($s)->b);
+	}
+	public function writeBinary($bs) {
+		$bytes = haxe_io_Bytes::ofData($bs);
+		$fo = sys_io_File::write($this->location, true);
+		$fo->writeBytes($bytes, 0, $bytes->length);
+	}
+	public $location;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $directorySeparator;
+	static $resourcesDir;
+	static function newResourceStorage($name) {
+		$name = com_wiris_system_Storage::getResourcesDir() . com_wiris_system_Storage::getDirectorySeparator() . $name;
+		return new com_wiris_system_Storage($name);
+	}
+	static function newStorage($name) {
+		return new com_wiris_system_Storage($name);
+	}
+	static function newStorageWithParent($parent, $name) {
+		return new com_wiris_system_Storage($parent->location . com_wiris_system_Storage::getDirectorySeparator() . $name);
+	}
+	static function getResourcesDir() {
+		if(com_wiris_system_Storage::$resourcesDir === null) {
+			com_wiris_system_Storage::setResourcesDir();
+		}
+		return com_wiris_system_Storage::$resourcesDir;
+	}
+	static function setResourcesDir() {
+		$filedir = com_wiris_system_Storage::getCallerFile();
+		com_wiris_system_Storage::$resourcesDir = _hx_substr($filedir, 0, _hx_last_index_of($filedir, com_wiris_system_Storage::getDirectorySeparator() . "com" . com_wiris_system_Storage::getDirectorySeparator(), null));
+	}
+	static function getCallerFile() {
+		$thisfile = "";
+		
+		$trace = debug_backtrace();
+		foreach ($trace as $item) {
+			if (!com_wiris_system_Storage::isSystemFile($item['file'])) {
+				return $item['file'];
+			}
+		}
+		$thisfile = $trace[0]['file'];
+		;
+		return $thisfile;
+	}
+	static function isSystemFile($file) {
+		$file = str_replace("\\", "/", $file);
+		return _hx_index_of($file, "/com/wiris/system/", null) !== -1 || _hx_index_of($file, "/com/wiris/std/", null) !== -1 || _hx_index_of($file, "/com/wiris/util/", null) !== -1;
+	}
+	static function getDirectorySeparator() {
+		if(com_wiris_system_Storage::$directorySeparator === null) {
+			com_wiris_system_Storage::setDirectorySeparator();
+		}
+		return com_wiris_system_Storage::$directorySeparator;
+	}
+	static function setDirectorySeparator() {
+		$sep = null;
+		$sep = DIRECTORY_SEPARATOR;
+		com_wiris_system_Storage::$directorySeparator = $sep;
+	}
+	static function getCurrentPath() {
+		throw new HException("Not implemented!");
+		return null;
+	}
+	function __toString() { return $this->toString(); }
+}
+function com_wiris_system_Storage_0(&$this, &$path) {
+	{
+		$p = realpath($this->location);
+		if(($p === false)) {
+			return null;
+		} else {
+			return $p;
+		}
+		unset($p);
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/StringEx.class.php b/filter/wiris/integration/lib/com/wiris/system/StringEx.class.php
new file mode 100644
index 0000000..39deb15
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/StringEx.class.php
@@ -0,0 +1,21 @@
+<?php
+
+class com_wiris_system_StringEx {
+	public function __construct(){}
+	static function substring($s, $start, $end = null) {
+		if($end === null) {
+			return _hx_substr($s, $start, null);
+		}
+		return _hx_substr($s, $start, $end - $start);
+	}
+	static function compareTo($s1, $s2) {
+		if($s1 > $s2) {
+			return 1;
+		}
+		if($s1 < $s2) {
+			return -1;
+		}
+		return 0;
+	}
+	function __toString() { return 'com.wiris.system.StringEx'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/System.class.php b/filter/wiris/integration/lib/com/wiris/system/System.class.php
new file mode 100644
index 0000000..4020b80
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/System.class.php
@@ -0,0 +1,14 @@
+<?php
+
+class com_wiris_system_System {
+	public function __construct(){}
+	static function arraycopy($src, $srcPos, $dest, $destPos, $n) {
+		$_g = 0;
+		while($_g < $n) {
+			$i = $_g++;
+			$dest[$destPos + $i] = $src[$srcPos + $i];
+			unset($i);
+		}
+	}
+	function __toString() { return 'com.wiris.system.System'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/TypeTools.class.php b/filter/wiris/integration/lib/com/wiris/system/TypeTools.class.php
new file mode 100644
index 0000000..2175af2
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/TypeTools.class.php
@@ -0,0 +1,37 @@
+<?php
+
+class com_wiris_system_TypeTools {
+	public function __construct(){}
+	static function floatToString($value) {
+		return "" . _hx_string_rec($value, "");
+	}
+	static function isFloating($str) {
+		$pattern = new EReg("^(\\d|\\d\\.|\\.\\d)", "");
+		return $pattern->match($str);
+	}
+	static function isInteger($str) {
+		$pattern = new EReg("^(\\d)", "");
+		return $pattern->match($str);
+	}
+	static function isIdentifierPart($c) {
+		$letterPattern = new EReg("[a-z]", "i");
+		$numberPattern = new EReg("[0-9]", "");
+		$str = chr($c);
+		return $letterPattern->match($str) || $numberPattern->match($str) || $str === "_";
+	}
+	static function isIdentifierStart($c) {
+		$letterPattern = new EReg("[a-z]", "i");
+		$str = chr($c);
+		return $letterPattern->match($str) || $str === "_";
+	}
+	static function isArray($o) {
+		return Std::is($o, _hx_qtype("Array"));
+	}
+	static function isHash($o) {
+		return Std::is($o, _hx_qtype("Hash"));
+	}
+	static function string2ByteData_iso8859_1($str) {
+		return haxe_io_Bytes::ofString($str);
+	}
+	function __toString() { return 'com.wiris.system.TypeTools'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/Utf8.class.php b/filter/wiris/integration/lib/com/wiris/system/Utf8.class.php
new file mode 100644
index 0000000..9f78930
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/Utf8.class.php
@@ -0,0 +1,41 @@
+<?php
+
+class com_wiris_system_Utf8 {
+	public function __construct() { 
+	}
+	static function getLength($s) {
+		return haxe_Utf8::length($s);
+	}
+	static function charCodeAt($s, $i) {
+		return haxe_Utf8::charCodeAt($s, $i);
+	}
+	static function charAt($s, $i) {
+		return com_wiris_system_Utf8_0($i, $s);
+	}
+	static function uchr($i) {
+		$s = new haxe_Utf8(null);
+		$s->addChar($i);
+		return $s->toString();
+	}
+	static function sub($s, $pos, $len) {
+		return haxe_Utf8::sub($s, $pos, $len);
+	}
+	static function toBytes($s) {
+		return haxe_io_Bytes::ofString($s)->b;
+	}
+	static function fromBytes($s) {
+		$bs = haxe_io_Bytes::ofData($s);
+		return $bs->toString();
+	}
+	static function getIterator($s) {
+		return new com_wiris_system__Utf8_StringIterator($s);
+	}
+	function __toString() { return 'com.wiris.system.Utf8'; }
+}
+function com_wiris_system_Utf8_0(&$i, &$s) {
+	{
+		$s1 = new haxe_Utf8(null);
+		$s1->addChar(haxe_Utf8::charCodeAt($s, $i));
+		return $s1->toString();
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/_Utf8/StringIterator.class.php b/filter/wiris/integration/lib/com/wiris/system/_Utf8/StringIterator.class.php
new file mode 100644
index 0000000..6a8d0a7
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/_Utf8/StringIterator.class.php
@@ -0,0 +1,48 @@
+<?php
+
+class com_wiris_system__Utf8_StringIterator {
+	public function __construct($s) {
+		if(!php_Boot::$skip_constructor) {
+		$this->source = $s;
+		$this->n = strlen($this->source);
+		$this->offset = 0;
+	}}
+	public function next() {
+		$c = ord($this->source[$this->offset++]);
+		if(($c & 128) !== 0) {
+			$c2 = ord($this->source[$this->offset++]);
+			if(($c & 32) !== 0) {
+				$c3 = ord($this->source[$this->offset++]);
+				if(($c & 16) !== 0) {
+					$c4 = ord($this->source[$this->offset++]);
+					$c = ($c & 7) << 18 | ($c2 & 63) << 12 | ($c3 & 63) << 6 | $c4 & 63;
+				} else {
+					$c = ($c & 15) << 12 | ($c2 & 63) << 6 | $c3 & 63;
+				}
+			} else {
+				$c = ($c & 31) << 6 | $c2 & 63;
+			}
+		}
+		return $c;
+	}
+	public function nextByte() {
+		return ord($this->source[$this->offset++]);
+	}
+	public function hasNext() {
+		return $this->offset < $this->n;
+	}
+	public $source;
+	public $n;
+	public $offset;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.system._Utf8.StringIterator'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/service/HttpRequest.class.php b/filter/wiris/integration/lib/com/wiris/system/service/HttpRequest.class.php
new file mode 100644
index 0000000..c21d0c1
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/service/HttpRequest.class.php
@@ -0,0 +1,65 @@
+<?php
+
+class com_wiris_system_service_HttpRequest {
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		$this->extraParams = new Hash();
+		$this->headers = new Hash();
+		$this->setHeaders();
+	}}
+	public function getHeader($key) {
+		$httpKey = null;
+		$httpKey = "HTTP_" . $this->headers->get($key);
+		$header = null;
+		$header = isset($_SERVER[$httpKey]) ? $_SERVER[$httpKey] : '';
+		return $header;
+	}
+	public function setParameter($key, $value) {
+		$this->extraParams->set($key, $value);
+	}
+	public function getParameterNames() {
+		$param = new _hx_array(array());
+		$key = "";
+		foreach ($_GET as $key => $value) {
+		$param->insert(0, $key);
+		}
+		foreach ($_POST as $key => $value) {
+		$param->insert(0, $key);
+		}
+		return $param;
+	}
+	public function getContextURL() {
+		return "";
+	}
+	public function getParameter($key) {
+		$param = null;
+		if(isset($_POST[$key])) {
+			$param = $_POST[$key];
+		} else {
+			if(isset($_GET[$key])) {
+				$param = $_GET[$key];
+			} else {
+				if($this->extraParams->exists($key)) {
+					return $this->extraParams->get($key);
+				}
+			}
+		}
+		return $param;
+	}
+	public function setHeaders() {
+		$this->headers->set("User-Agent", "USER_AGENT");
+	}
+	public $headers;
+	public $extraParams;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.system.service.HttpRequest'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/system/service/HttpResponse.class.php b/filter/wiris/integration/lib/com/wiris/system/service/HttpResponse.class.php
new file mode 100644
index 0000000..8f117d0
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/system/service/HttpResponse.class.php
@@ -0,0 +1,170 @@
+<?php
+
+class com_wiris_system_service_HttpResponse {
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		$this->headers = new Hash();
+	}}
+	public function setReturnCode($r) {
+		$code = null;
+		switch($r) {
+		case 100:{
+			$code = "100 Continue";
+		}break;
+		case 101:{
+			$code = "101 Switching Protocols";
+		}break;
+		case 200:{
+			$code = "200 Continue";
+		}break;
+		case 201:{
+			$code = "201 Created";
+		}break;
+		case 202:{
+			$code = "202 Accepted";
+		}break;
+		case 203:{
+			$code = "203 Non-Authoritative Information";
+		}break;
+		case 204:{
+			$code = "204 No Content";
+		}break;
+		case 205:{
+			$code = "205 Reset Content";
+		}break;
+		case 206:{
+			$code = "206 Partial Content";
+		}break;
+		case 300:{
+			$code = "300 Multiple Choices";
+		}break;
+		case 301:{
+			$code = "301 Moved Permanently";
+		}break;
+		case 302:{
+			$code = "302 Found";
+		}break;
+		case 303:{
+			$code = "303 See Other";
+		}break;
+		case 304:{
+			$code = "304 Not Modified";
+		}break;
+		case 305:{
+			$code = "305 Use Proxy";
+		}break;
+		case 307:{
+			$code = "307 Temporary Redirect";
+		}break;
+		case 400:{
+			$code = "400 Bad Request";
+		}break;
+		case 401:{
+			$code = "401 Unauthorized";
+		}break;
+		case 402:{
+			$code = "402 Payment Required";
+		}break;
+		case 403:{
+			$code = "403 Forbidden";
+		}break;
+		case 404:{
+			$code = "404 Not Found";
+		}break;
+		case 405:{
+			$code = "405 Method Not Allowed";
+		}break;
+		case 406:{
+			$code = "406 Not Acceptable";
+		}break;
+		case 407:{
+			$code = "407 Proxy Authentication Required";
+		}break;
+		case 408:{
+			$code = "408 Request Timeout";
+		}break;
+		case 409:{
+			$code = "409 Conflict";
+		}break;
+		case 410:{
+			$code = "410 Gone";
+		}break;
+		case 411:{
+			$code = "411 Length Required";
+		}break;
+		case 412:{
+			$code = "412 Precondition Failed";
+		}break;
+		case 413:{
+			$code = "413 Request Entity Too Large";
+		}break;
+		case 414:{
+			$code = "414 Request-URI Too Long";
+		}break;
+		case 415:{
+			$code = "415 Unsupported Media Type";
+		}break;
+		case 416:{
+			$code = "416 Requested Range Not Satisfiable";
+		}break;
+		case 417:{
+			$code = "417 Expectation Failed";
+		}break;
+		case 500:{
+			$code = "500 Internal Server Error";
+		}break;
+		case 501:{
+			$code = "501 Not Implemented";
+		}break;
+		case 502:{
+			$code = "502 Bad Gateway";
+		}break;
+		case 503:{
+			$code = "503 Service Unavailable";
+		}break;
+		case 504:{
+			$code = "504 Gateway Timeout";
+		}break;
+		case 505:{
+			$code = "505 HTTP Version Not Supported";
+		}break;
+		default:{
+			$code = "";
+		}break;
+		}
+		header("HTTP/1.1 " . code, true, r);;
+	}
+	public function getHeader($name) {
+		return $this->headers->get($name);
+	}
+	public function close() {
+		flush();;
+	}
+	public function writeString($s) {
+		echo($s);
+	}
+	public function writeBinary($data) {
+		$this->writeString($data->toString());
+	}
+	public function sendError($num, $message) {
+		$this->setReturnCode($num);
+		$this->writeString($message);
+		$this->close();
+	}
+	public function setHeader($name, $value) {
+		$this->headers->set($name, $value);
+		header($name . ": " . $value);
+	}
+	public $headers;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.system.service.HttpResponse'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/util/json/JSon.class.php b/filter/wiris/integration/lib/com/wiris/util/json/JSon.class.php
new file mode 100644
index 0000000..1d04df0
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/util/json/JSon.class.php
@@ -0,0 +1,596 @@
+<?php
+
+class com_wiris_util_json_JSon extends com_wiris_util_json_StringParser {
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		parent::__construct();
+	}}
+	public function newLine($depth, $sb) {
+		$sb->add("\x0D\x0A");
+		$i = null;
+		{
+			$_g = 0;
+			while($_g < $depth) {
+				$i1 = $_g++;
+				$sb->add("  ");
+				unset($i1);
+			}
+		}
+		$this->lastDepth = $depth;
+	}
+	public function setAddNewLines($addNewLines) {
+		$this->addNewLines = $addNewLines;
+	}
+	public function decodeArray() {
+		$v = new _hx_array(array());
+		$this->nextToken();
+		$this->skipBlanks();
+		if($this->c === 93) {
+			$this->nextToken();
+			return $v;
+		}
+		while($this->c !== 93) {
+			$o = $this->localDecode();
+			$v->push($o);
+			$this->skipBlanks();
+			if($this->c === 44) {
+				$this->nextToken();
+				$this->skipBlanks();
+			} else {
+				if($this->c !== 93) {
+					throw new HException("Expected ',' or ']'.");
+				}
+			}
+			unset($o);
+		}
+		$this->nextToken();
+		return $v;
+	}
+	public function decodeHash() {
+		$h = new Hash();
+		$this->nextToken();
+		$this->skipBlanks();
+		if($this->c === 125) {
+			$this->nextToken();
+			return $h;
+		}
+		while($this->c !== 125) {
+			$key = $this->decodeString();
+			$this->skipBlanks();
+			if($this->c !== 58) {
+				throw new HException("Expected ':'.");
+			}
+			$this->nextToken();
+			$this->skipBlanks();
+			$o = $this->localDecode();
+			$h->set($key, $o);
+			$this->skipBlanks();
+			if($this->c === 44) {
+				$this->nextToken();
+				$this->skipBlanks();
+			} else {
+				if($this->c !== 125) {
+					throw new HException("Expected ',' or '}'. " . $this->getPositionRepresentation());
+				}
+			}
+			unset($o,$key);
+		}
+		$this->nextToken();
+		return $h;
+	}
+	public function decodeNumber() {
+		$sb = new StringBuf();
+		$hex = false;
+		$floating = false;
+		do {
+			$sb->add(com_wiris_util_json_JSon_0($this, $floating, $hex, $sb));
+			$this->nextToken();
+			if($this->c === 120) {
+				$hex = true;
+				$sb->add(com_wiris_util_json_JSon_1($this, $floating, $hex, $sb));
+				$this->nextToken();
+			}
+			if($this->c === 46 || $this->c === 69 || $this->c === 101) {
+				$floating = true;
+			}
+		} while($this->c >= 48 && $this->c <= 58 || $hex && $this->isHexDigit($this->c) || $floating && ($this->c === 46 || $this->c === 69 || $this->c === 101 || $this->c === 45));
+		if($floating) {
+			return Std::parseFloat($sb->b);
+		} else {
+			return Std::parseInt($sb->b);
+		}
+	}
+	public function decodeString() {
+		$sb = new StringBuf();
+		$d = $this->c;
+		$this->nextToken();
+		while($this->c !== $d) {
+			if($this->c === 92) {
+				$this->nextToken();
+				if($this->c === 110) {
+					$sb->add("\x0A");
+				} else {
+					if($this->c === 114) {
+						$sb->add("\x0D");
+					} else {
+						if($this->c === 34) {
+							$sb->add("\"");
+						} else {
+							if($this->c === 39) {
+								$sb->add("'");
+							} else {
+								if($this->c === 116) {
+									$sb->add("\x09");
+								} else {
+									if($this->c === 92) {
+										$sb->add("\\");
+									} else {
+										if($this->c === 117) {
+											$this->nextToken();
+											$code = com_wiris_util_json_JSon_2($this, $d, $sb);
+											$this->nextToken();
+											$code .= com_wiris_util_json_JSon_3($this, $code, $d, $sb);
+											$this->nextToken();
+											$code .= com_wiris_util_json_JSon_4($this, $code, $d, $sb);
+											$this->nextToken();
+											$code .= com_wiris_util_json_JSon_5($this, $code, $d, $sb);
+											$dec = Std::parseInt("0x" . $code);
+											$sb->add(com_wiris_util_json_JSon_6($this, $code, $d, $dec, $sb));
+											unset($dec,$code);
+										} else {
+											throw new HException("Unknown scape sequence '\\" . com_wiris_util_json_JSon_7($this, $d, $sb) . "'");
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			} else {
+				$sb->add(com_wiris_util_json_JSon_8($this, $d, $sb));
+			}
+			$this->nextToken();
+		}
+		$this->nextToken();
+		return $sb->b;
+	}
+	public function decodeBooleanOrNull() {
+		$sb = new StringBuf();
+		while(com_wiris_util_xml_WCharacterBase::isLetter($this->c)) {
+			$sb->b .= chr($this->c);
+			$this->nextToken();
+		}
+		$word = $sb->b;
+		if($word === "true") {
+			return true;
+		} else {
+			if($word === "false") {
+				return false;
+			} else {
+				if($word === "null") {
+					return null;
+				} else {
+					throw new HException("Unrecognized keyword \"" . $word . "\".");
+				}
+			}
+		}
+	}
+	public function localDecode() {
+		$this->skipBlanks();
+		if($this->c === 123) {
+			return $this->decodeHash();
+		} else {
+			if($this->c === 91) {
+				return $this->decodeArray();
+			} else {
+				if($this->c === 34) {
+					return $this->decodeString();
+				} else {
+					if($this->c === 39) {
+						return $this->decodeString();
+					} else {
+						if($this->c === 45 || $this->c >= 48 && $this->c <= 58) {
+							return $this->decodeNumber();
+						} else {
+							if($this->c === 116 || $this->c === 102 || $this->c === 110) {
+								return $this->decodeBooleanOrNull();
+							} else {
+								throw new HException("Unrecognized char " . _hx_string_rec($this->c, ""));
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	public function localDecodeString($str) {
+		$this->init($str);
+		return $this->localDecode();
+	}
+	public function encodeIntegerFormat($sb, $i) {
+		$sb->add($i->toString());
+	}
+	public function encodeLong($sb, $i) {
+		$sb->add("" . Std::string($i));
+	}
+	public function encodeFloat($sb, $d) {
+		$sb->add(com_wiris_system_TypeTools::floatToString($d));
+	}
+	public function encodeBoolean($sb, $b) {
+		$sb->add((($b) ? "true" : "false"));
+	}
+	public function encodeInteger($sb, $i) {
+		$sb->add("" . _hx_string_rec($i, ""));
+	}
+	public function encodeString($sb, $s) {
+		$s = str_replace("\\", "\\\\", $s);
+		$s = str_replace("\"", "\\\"", $s);
+		$s = str_replace("\x0D", "\\r", $s);
+		$s = str_replace("\x0A", "\\n", $s);
+		$s = str_replace("\x09", "\\t", $s);
+		$sb->add("\"");
+		$sb->add($s);
+		$sb->add("\"");
+	}
+	public function encodeArray($sb, $v) {
+		$newLines = $this->addNewLines && com_wiris_util_json_JSon::getDepth($v) > 2;
+		$this->depth++;
+		$myDepth = $this->lastDepth;
+		$sb->add("[");
+		if($newLines) {
+			$this->newLine($this->depth, $sb);
+		}
+		$i = null;
+		{
+			$_g1 = 0; $_g = $v->length;
+			while($_g1 < $_g) {
+				$i1 = $_g1++;
+				$o = $v[$i1];
+				if($i1 > 0) {
+					$sb->add(",");
+					if($newLines) {
+						$this->newLine($this->depth, $sb);
+					}
+				}
+				$this->encodeImpl($sb, $o);
+				unset($o,$i1);
+			}
+		}
+		if($newLines) {
+			$this->newLine($myDepth, $sb);
+		}
+		$sb->add("]");
+		$this->depth--;
+	}
+	public function encodeHash($sb, $h) {
+		$newLines = $this->addNewLines && com_wiris_util_json_JSon::getDepth($h) > 2;
+		$this->depth++;
+		$myDepth = $this->lastDepth;
+		$sb->add("{");
+		if($newLines) {
+			$this->newLine($this->depth, $sb);
+		}
+		$e = $h->keys();
+		$first = true;
+		while($e->hasNext()) {
+			if($first) {
+				$first = false;
+			} else {
+				$sb->add(",");
+				if($newLines) {
+					$this->newLine($this->depth, $sb);
+				}
+			}
+			$key = $e->next();
+			$this->encodeString($sb, $key);
+			$sb->add(":");
+			$this->encodeImpl($sb, $h->get($key));
+			unset($key);
+		}
+		if($newLines) {
+			$this->newLine($myDepth, $sb);
+		}
+		$sb->add("}");
+		$this->depth--;
+	}
+	public function encodeImpl($sb, $o) {
+		if(com_wiris_system_TypeTools::isHash($o)) {
+			$this->encodeHash($sb, $o);
+		} else {
+			if(com_wiris_system_TypeTools::isArray($o)) {
+				$this->encodeArray($sb, $o);
+			} else {
+				if(Std::is($o, _hx_qtype("String"))) {
+					$this->encodeString($sb, $o);
+				} else {
+					if(Std::is($o, _hx_qtype("Int"))) {
+						$this->encodeInteger($sb, $o);
+					} else {
+						if(Std::is($o, _hx_qtype("haxe.Int64"))) {
+							$this->encodeLong($sb, $o);
+						} else {
+							if(Std::is($o, _hx_qtype("com.wiris.util.json.JSonIntegerFormat"))) {
+								$this->encodeIntegerFormat($sb, $o);
+							} else {
+								if(Std::is($o, _hx_qtype("Bool"))) {
+									$this->encodeBoolean($sb, $o);
+								} else {
+									if(Std::is($o, _hx_qtype("Float"))) {
+										$this->encodeFloat($sb, $o);
+									} else {
+										throw new HException("Impossible to convert to json object of type " . Std::string(Type::getClass($o)));
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	public function encodeObject($o) {
+		$sb = new StringBuf();
+		$this->depth = 0;
+		$this->encodeImpl($sb, $o);
+		return $sb->b;
+	}
+	public $lastDepth;
+	public $depth;
+	public $addNewLines;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function sb() { $args = func_get_args(); return call_user_func_array(self::$sb, $args); }
+	static $sb;
+	static function encode($o) {
+		$js = new com_wiris_util_json_JSon();
+		return $js->encodeObject($o);
+	}
+	static function decode($str) {
+		$json = new com_wiris_util_json_JSon();
+		return $json->localDecodeString($str);
+	}
+	static function getDepth($o) {
+		if(com_wiris_system_TypeTools::isHash($o)) {
+			$h = $o;
+			$m = 0;
+			if($h->exists("_left_") || $h->exists("_right_")) {
+				if($h->exists("_left_")) {
+					$m = com_wiris_common_WInteger::max(com_wiris_util_json_JSon::getDepth($h->get("_left_")), $m);
+				}
+				if($h->exists("_right_")) {
+					$m = com_wiris_common_WInteger::max(com_wiris_util_json_JSon::getDepth($h->get("_right_")), $m);
+				}
+				return $m;
+			}
+			$iter = $h->keys();
+			while($iter->hasNext()) {
+				$key = $iter->next();
+				$m = com_wiris_common_WInteger::max(com_wiris_util_json_JSon::getDepth($h->get($key)), $m);
+				unset($key);
+			}
+			return $m + 2;
+		} else {
+			if(com_wiris_system_TypeTools::isArray($o)) {
+				$a = $o;
+				$i = null;
+				$m = 0;
+				{
+					$_g1 = 0; $_g = $a->length;
+					while($_g1 < $_g) {
+						$i1 = $_g1++;
+						$m = com_wiris_common_WInteger::max(com_wiris_util_json_JSon::getDepth($a[$i1]), $m);
+						unset($i1);
+					}
+				}
+				return $m + 1;
+			} else {
+				return 1;
+			}
+		}
+	}
+	static function getString($o) {
+		return $o;
+	}
+	static function getFloat($n) {
+		if(Std::is($n, _hx_qtype("Float"))) {
+			return $n;
+		} else {
+			if(Std::is($n, _hx_qtype("Int"))) {
+				return $n + 0.0;
+			} else {
+				return 0.0;
+			}
+		}
+	}
+	static function getInt($n) {
+		if(Std::is($n, _hx_qtype("Float"))) {
+			return Math::round($n);
+		} else {
+			if(Std::is($n, _hx_qtype("Int"))) {
+				return $n;
+			} else {
+				return 0;
+			}
+		}
+	}
+	static function getBoolean($b) {
+		return $b;
+	}
+	static function getArray($a) {
+		return $a;
+	}
+	static function getHash($a) {
+		return $a;
+	}
+	static function compare($a, $b, $eps) {
+		if(com_wiris_system_TypeTools::isHash($a)) {
+			$isBHash = com_wiris_system_TypeTools::isHash($b);
+			if(!$isBHash) {
+				return false;
+			}
+			$ha = $a;
+			$hb = $b;
+			$it = $ha->keys();
+			$itb = $hb->keys();
+			while($it->hasNext()) {
+				if(!$itb->hasNext()) {
+					return false;
+				}
+				$itb->next();
+				$key = $it->next();
+				if(!$hb->exists($key) || !com_wiris_util_json_JSon::compare($ha->get($key), $hb->get($key), $eps)) {
+					return false;
+				}
+				unset($key);
+			}
+			if($itb->hasNext()) {
+				return false;
+			}
+			return true;
+		} else {
+			if(com_wiris_system_TypeTools::isArray($a)) {
+				$isBArray = com_wiris_system_TypeTools::isArray($b);
+				if(!$isBArray) {
+					return false;
+				}
+				$aa = $a;
+				$ab = $b;
+				if($aa->length !== $ab->length) {
+					return false;
+				}
+				$i = null;
+				{
+					$_g1 = 0; $_g = $aa->length;
+					while($_g1 < $_g) {
+						$i1 = $_g1++;
+						if(!com_wiris_util_json_JSon::compare($aa[$i1], $ab[$i1], $eps)) {
+							return false;
+						}
+						unset($i1);
+					}
+				}
+				return true;
+			} else {
+				if(Std::is($a, _hx_qtype("String"))) {
+					if(!Std::is($b, _hx_qtype("String"))) {
+						return false;
+					}
+					return _hx_equal($a, $b);
+				} else {
+					if(Std::is($a, _hx_qtype("Int"))) {
+						if(!Std::is($b, _hx_qtype("Int"))) {
+							return false;
+						}
+						return _hx_equal($a, $b);
+					} else {
+						if(Std::is($a, _hx_qtype("haxe.Int64"))) {
+							$isBLong = Std::is($b, _hx_qtype("haxe.Int64"));
+							if(!$isBLong) {
+								return false;
+							}
+							return _hx_equal($a, $b);
+						} else {
+							if(Std::is($a, _hx_qtype("com.wiris.util.json.JSonIntegerFormat"))) {
+								if(!Std::is($b, _hx_qtype("com.wiris.util.json.JSonIntegerFormat"))) {
+									return false;
+								}
+								$ja = $a;
+								$jb = $b;
+								return $ja->toString() === $jb->toString();
+							} else {
+								if(Std::is($a, _hx_qtype("Bool"))) {
+									if(!Std::is($b, _hx_qtype("Bool"))) {
+										return false;
+									}
+									return _hx_equal($a, $b);
+								} else {
+									if(Std::is($a, _hx_qtype("Float"))) {
+										if(!Std::is($b, _hx_qtype("Float"))) {
+											return false;
+										}
+										$da = com_wiris_util_json_JSon::getFloat($a);
+										$db = com_wiris_util_json_JSon::getFloat($b);
+										return $da >= $db - $eps && $da <= $db + $eps;
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+		return true;
+	}
+	function __toString() { return 'com.wiris.util.json.JSon'; }
+}
+function com_wiris_util_json_JSon_0(&$this, &$floating, &$hex, &$sb) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($this->c);
+		return $s->toString();
+	}
+}
+function com_wiris_util_json_JSon_1(&$this, &$floating, &$hex, &$sb) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($this->c);
+		return $s->toString();
+	}
+}
+function com_wiris_util_json_JSon_2(&$this, &$d, &$sb) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($this->c);
+		return $s->toString();
+	}
+}
+function com_wiris_util_json_JSon_3(&$this, &$code, &$d, &$sb) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($this->c);
+		return $s->toString();
+	}
+}
+function com_wiris_util_json_JSon_4(&$this, &$code, &$d, &$sb) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($this->c);
+		return $s->toString();
+	}
+}
+function com_wiris_util_json_JSon_5(&$this, &$code, &$d, &$sb) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($this->c);
+		return $s->toString();
+	}
+}
+function com_wiris_util_json_JSon_6(&$this, &$code, &$d, &$dec, &$sb) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($dec);
+		return $s->toString();
+	}
+}
+function com_wiris_util_json_JSon_7(&$this, &$d, &$sb) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($this->c);
+		return $s->toString();
+	}
+}
+function com_wiris_util_json_JSon_8(&$this, &$d, &$sb) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($this->c);
+		return $s->toString();
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/util/json/JSonIntegerFormat.class.php b/filter/wiris/integration/lib/com/wiris/util/json/JSonIntegerFormat.class.php
new file mode 100644
index 0000000..69d965c
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/util/json/JSonIntegerFormat.class.php
@@ -0,0 +1,29 @@
+<?php
+
+class com_wiris_util_json_JSonIntegerFormat {
+	public function __construct($n, $format) {
+		if(!php_Boot::$skip_constructor) {
+		$this->n = $n;
+		$this->format = $format;
+	}}
+	public function toString() {
+		if($this->format === com_wiris_util_json_JSonIntegerFormat::$HEXADECIMAL) {
+			return "0x" . StringTools::hex($this->n, 0);
+		}
+		return "" . _hx_string_rec($this->n, "");
+	}
+	public $format;
+	public $n;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $HEXADECIMAL = 0;
+	function __toString() { return $this->toString(); }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/util/json/JsonAPIResponse.class.php b/filter/wiris/integration/lib/com/wiris/util/json/JsonAPIResponse.class.php
new file mode 100644
index 0000000..a0bf67b
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/util/json/JsonAPIResponse.class.php
@@ -0,0 +1,76 @@
+<?php
+
+class com_wiris_util_json_JsonAPIResponse {
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		$this->result = new Hash();
+		$this->errors = new _hx_array(array());
+		$this->warnings = new _hx_array(array());
+	}}
+	public function toString() {
+		return $this->getResponse();
+	}
+	public function getStatus() {
+		return $this->status;
+	}
+	public function setStatus($status) {
+		if($status !== com_wiris_util_json_JsonAPIResponse::$STATUS_OK && $status !== com_wiris_util_json_JsonAPIResponse::$STATUS_WARNING && $status !== com_wiris_util_json_JsonAPIResponse::$STATUS_ERROR) {
+			throw new HException("Invalid status code");
+		}
+		$this->status = $status;
+	}
+	public function addError($error) {
+		$this->errors->push($error);
+	}
+	public function addWarning($warning) {
+		$this->warnings->push($warning);
+	}
+	public function getResult() {
+		if($this->status === com_wiris_util_json_JsonAPIResponse::$STATUS_ERROR) {
+			return null;
+		} else {
+			return $this->result;
+		}
+	}
+	public function setResult($obj) {
+		$this->result = $obj;
+	}
+	public function addResult($key, $value) {
+		$this->result->set($key, $value);
+	}
+	public function getResponse() {
+		$response = new Hash();
+		if($this->status === com_wiris_util_json_JsonAPIResponse::$STATUS_ERROR) {
+			$response->set("errors", $this->errors);
+			$response->set("status", "error");
+		}
+		if($this->status === com_wiris_util_json_JsonAPIResponse::$STATUS_WARNING) {
+			$response->set("warnings", $this->warnings);
+			$response->set("result", $this->result);
+			$response->set("status", "warning");
+		}
+		if($this->status === com_wiris_util_json_JsonAPIResponse::$STATUS_OK) {
+			$response->set("result", $this->result);
+			$response->set("status", "ok");
+		}
+		return com_wiris_util_json_JSon::encode($response);
+	}
+	public $warnings;
+	public $errors;
+	public $result;
+	public $status;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $STATUS_OK = 0;
+	static $STATUS_WARNING = 1;
+	static $STATUS_ERROR = -1;
+	function __toString() { return $this->toString(); }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/util/json/StringParser.class.php b/filter/wiris/integration/lib/com/wiris/util/json/StringParser.class.php
new file mode 100644
index 0000000..5df8088
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/util/json/StringParser.class.php
@@ -0,0 +1,75 @@
+<?php
+
+class com_wiris_util_json_StringParser {
+	public function __construct() {
+		;
+	}
+	public function isHexDigit($c) {
+		if($c >= 48 && $c <= 58) {
+			return true;
+		}
+		if($c >= 97 && $c <= 102) {
+			return true;
+		}
+		if($c >= 65 && $c <= 70) {
+			return true;
+		}
+		return false;
+	}
+	public function getPositionRepresentation() {
+		$i0 = com_wiris_common_WInteger::min($this->i, $this->n);
+		$s0 = com_wiris_common_WInteger::max(0, $this->i - 20);
+		$e0 = com_wiris_common_WInteger::min($this->n, $this->i + 20);
+		return "..." . _hx_substr($this->str, $s0, $i0 - $s0) . " >>> . <<<" . _hx_substr($this->str, $i0, $e0);
+	}
+	public function nextSafeToken() {
+		if($this->i < $this->n) {
+			$this->c = haxe_Utf8::charCodeAt(_hx_substr($this->str, $this->i, null), 0);
+			$this->i += strlen((com_wiris_util_json_StringParser_0($this)));
+		} else {
+			$this->c = -1;
+		}
+	}
+	public function nextToken() {
+		if($this->c === -1) {
+			throw new HException("End of string");
+		}
+		$this->nextSafeToken();
+	}
+	public function skipBlanks() {
+		while($this->i < $this->n && com_wiris_util_json_StringParser::isBlank($this->c)) {
+			$this->nextToken();
+		}
+	}
+	public function init($str) {
+		$this->str = $str;
+		$this->i = 0;
+		$this->n = strlen($str);
+		$this->nextToken();
+	}
+	public $str;
+	public $c;
+	public $n;
+	public $i;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function isBlank($c) {
+		return $c === 32 || $c === 10 || $c === 13 || $c === 9 || $c === 160;
+	}
+	function __toString() { return 'com.wiris.util.json.StringParser'; }
+}
+function com_wiris_util_json_StringParser_0(&$this) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($this->c);
+		return $s->toString();
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/util/net/UserAgent.class.php b/filter/wiris/integration/lib/com/wiris/util/net/UserAgent.class.php
new file mode 100644
index 0000000..1861a3b
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/util/net/UserAgent.class.php
@@ -0,0 +1,27 @@
+<?php
+
+class com_wiris_util_net_UserAgent {
+	public function __construct($request) {
+		if(!php_Boot::$skip_constructor) {
+		$this->request = $request;
+	}}
+	public function isIe() {
+		if(_hx_index_of($this->request->getHeader("User-Agent"), "Trident", null) !== -1) {
+			return true;
+		} else {
+			return false;
+		}
+	}
+	public $request;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'com.wiris.util.net.UserAgent'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/util/sys/Cache.interface.php b/filter/wiris/integration/lib/com/wiris/util/sys/Cache.interface.php
new file mode 100644
index 0000000..15bdf45
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/util/sys/Cache.interface.php
@@ -0,0 +1,8 @@
+<?php
+
+interface com_wiris_util_sys_Cache {
+	function delete($key);
+	function deleteAll();
+	function get($key);
+	function set($key, $value);
+}
diff --git a/filter/wiris/integration/lib/com/wiris/util/sys/IniFile.class.php b/filter/wiris/integration/lib/com/wiris/util/sys/IniFile.class.php
new file mode 100644
index 0000000..5c2452b
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/util/sys/IniFile.class.php
@@ -0,0 +1,179 @@
+<?php
+
+class com_wiris_util_sys_IniFile {
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		$this->props = new Hash();
+	}}
+	public function loadProperties($file) {
+		$start = null;
+		$end = 0;
+		$count = 1;
+		while(($start = _hx_index_of($file, "\x0A", $end)) !== -1) {
+			$line = _hx_substr($file, $end, $start - $end);
+			$end = $start + 1;
+			$this->loadPropertiesLine($line, $count);
+			$count++;
+			unset($line);
+		}
+		if($end < strlen($file)) {
+			$line = _hx_substr($file, $end, null);
+			$this->loadPropertiesLine($line, $count);
+		}
+	}
+	public function loadPropertiesLine($line, $count) {
+		$line = trim($line);
+		if(strlen($line) === 0) {
+			return;
+		}
+		if(StringTools::startsWith($line, ";") || StringTools::startsWith($line, "#")) {
+			return;
+		}
+		$equals = _hx_index_of($line, "=", null);
+		if($equals === -1) {
+			throw new HException("Malformed INI file " . $this->filename . " in line " . _hx_string_rec($count, "") . " no equal sign found.");
+		}
+		$key = _hx_substr($line, 0, $equals);
+		$key = trim($key);
+		$value = _hx_substr($line, $equals + 1, null);
+		$value = trim($value);
+		if(StringTools::startsWith($value, "\"") && StringTools::endsWith($value, "\"")) {
+			$value = _hx_substr($value, 1, strlen($value) - 2);
+		}
+		$backslash = 0;
+		while(($backslash = _hx_index_of($value, "\\", $backslash)) !== -1) {
+			if(strlen($value) <= $backslash + 1) {
+				continue;
+			}
+			$letter = _hx_substr($value, $backslash + 1, 1);
+			if($letter === "n") {
+				$letter = "\x0A";
+			} else {
+				if($letter === "r") {
+					$letter = "\x0D";
+				} else {
+					if($letter === "t") {
+						$letter = "\x09";
+					}
+				}
+			}
+			$value = _hx_substr($value, 0, $backslash) . $letter . _hx_substr($value, $backslash + 2, null);
+			$backslash++;
+			unset($letter);
+		}
+		$this->props->set($key, $value);
+	}
+	public function loadINI() {
+		$s = com_wiris_system_Storage::newStorage($this->filename);
+		if(!$s->exists()) {
+			$s = com_wiris_system_Storage::newResourceStorage($this->filename);
+		}
+		try {
+			$file = $s->read();
+			if($file !== null) {
+				$this->loadProperties($file);
+			}
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+			}
+		}
+	}
+	public function getProperties() {
+		return $this->props;
+	}
+	public $props;
+	public $filename;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function newIniFileFromFilename($path) {
+		$ini = new com_wiris_util_sys_IniFile();
+		$ini->filename = $path;
+		$ini->loadINI();
+		return $ini;
+	}
+	static function newIniFileFromString($inifile) {
+		$ini = new com_wiris_util_sys_IniFile();
+		$ini->filename = "";
+		$ini->loadProperties($inifile);
+		return $ini;
+	}
+	static function propertiesToString($h) {
+		$sb = new StringBuf();
+		$iter = $h->keys();
+		$keys = new _hx_array(array());
+		while($iter->hasNext()) {
+			$keys->push($iter->next());
+		}
+		$i = null;
+		$j = null;
+		$n = $keys->length;
+		{
+			$_g = 0;
+			while($_g < $n) {
+				$i1 = $_g++;
+				{
+					$_g1 = $i1 + 1;
+					while($_g1 < $n) {
+						$j1 = $_g1++;
+						$s1 = $keys[$i1];
+						$s2 = $keys[$j1];
+						if(com_wiris_util_sys_IniFile::compareStrings($s1, $s2) > 0) {
+							$keys[$i1] = $s2;
+							$keys[$j1] = $s1;
+						}
+						unset($s2,$s1,$j1);
+					}
+					unset($_g1);
+				}
+				unset($i1);
+			}
+		}
+		{
+			$_g = 0;
+			while($_g < $n) {
+				$i1 = $_g++;
+				$key = $keys[$i1];
+				$sb->add($key);
+				$sb->add("=");
+				$value = $h->get($key);
+				$value = str_replace("\\", "\\\\", $value);
+				$value = str_replace("\x0A", "\\n", $value);
+				$value = str_replace("\x0D", "\\r", $value);
+				$value = str_replace("\x09", "\\t", $value);
+				$sb->add($value);
+				$sb->add("\x0A");
+				unset($value,$key,$i1);
+			}
+		}
+		return $sb->b;
+	}
+	static function compareStrings($a, $b) {
+		$i = null;
+		$an = strlen($a);
+		$bn = strlen($b);
+		$n = (($an > $bn) ? $bn : $an);
+		{
+			$_g = 0;
+			while($_g < $n) {
+				$i1 = $_g++;
+				$c = _hx_char_code_at($a, $i1) - _hx_char_code_at($b, $i1);
+				if($c !== 0) {
+					return $c;
+				}
+				unset($i1,$c);
+			}
+		}
+		return strlen($a) - strlen($b);
+	}
+	function __toString() { return 'com.wiris.util.sys.IniFile'; }
+}
diff --git a/filter/wiris/integration/lib/com/wiris/util/sys/Store.class.php b/filter/wiris/integration/lib/com/wiris/util/sys/Store.class.php
new file mode 100644
index 0000000..3acf262
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/util/sys/Store.class.php
@@ -0,0 +1,184 @@
+<?php
+
+class com_wiris_util_sys_Store {
+	public function __construct() {
+		;
+	}
+	public function deleteFolderContents() {
+		if($this->exists() && is_dir($this->getFile())) {
+			$files = $this->hlist();
+			$i = null;
+			{
+				$_g1 = 0; $_g = $files->length;
+				while($_g1 < $_g) {
+					$i1 = $_g1++;
+					if(!($files[$i1] === "." || $files[$i1] === "..")) {
+						$f = com_wiris_util_sys_Store::newStoreWithParent($this, $files[$i1]);
+						if(is_dir($f->getFile())) {
+							$f->deleteFolderContents();
+							@rmdir($f->getFile());
+						} else {
+							@unlink($f->getFile());
+						}
+						unset($f);
+					}
+					unset($i1);
+				}
+			}
+		}
+	}
+	public function delete() {
+		if(is_dir($this->file)) {
+			@rmdir($this->file);
+		} else {
+			@unlink($this->file);
+		}
+	}
+	public function moveTo($dest) {
+		rename($this->file, $dest->getFile());
+	}
+	public function copyTo($dest) {
+		$b = $this->readBinary();
+		$dest->writeBinary($b);
+	}
+	public function getParent() {
+		$parent = com_wiris_util_sys_Store_0($this);
+		if($parent === null) {
+			$parent = $this->file;
+		}
+		$i = com_wiris_common_WInteger::max(_hx_last_index_of($parent, "/", null), _hx_last_index_of($parent, "\\", null));
+		if($i < 0) {
+			return com_wiris_util_sys_Store::newStore(".");
+		}
+		$parent = _hx_substr($parent, 0, $i);
+		return com_wiris_util_sys_Store::newStore($parent);
+	}
+	public function exists() {
+		return file_exists($this->file);
+	}
+	public function getFile() {
+		return $this->file;
+	}
+	public function read() {
+		return sys_io_File::getContent($this->file);
+	}
+	public function append($str) {
+		$output = sys_io_File::append($this->file, true);
+		$output->writeString($str);
+		$output->flush();
+		$output->close();
+	}
+	public function readBinary() {
+		return sys_io_File::getBytes($this->file);
+	}
+	public function writeBinary($bs) {
+		sys_io_File::saveBytes($this->file, $bs);
+	}
+	public function write($str) {
+		sys_io_File::saveContent($this->file, $str);
+	}
+	public function mkdirs() {
+		$parent = $this->getParent();
+		if(!$parent->exists() && !($parent->getFile() === $this->file)) {
+			$parent->mkdirs();
+		}
+		if(!$this->exists()) {
+			@mkdir($this->file, 493);
+		}
+	}
+	public function hlist() {
+		return sys_FileSystem::readDirectory($this->file);
+	}
+	public $file;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function newStore($folder) {
+		$s = new com_wiris_util_sys_Store();
+		$s->file = $folder;
+		return $s;
+	}
+	static function newStoreWithParent($store, $str) {
+		return com_wiris_util_sys_Store::newStore($store->getFile() . "/" . $str);
+	}
+	static function getCurrentPath() {
+		return com_wiris_util_sys_Store_1();
+	}
+	static function deleteDirectory($folder, $included) {
+		if($folder === null || !file_exists($folder)) {
+			return;
+		}
+		$path = com_wiris_util_sys_Store_2($folder, $included);
+		$files = sys_FileSystem::readDirectory($folder);
+		$i = 0;
+		{
+			$_g1 = 0; $_g = $files->length;
+			while($_g1 < $_g) {
+				$i1 = $_g1++;
+				$file = $files[$i1];
+				$file = $path . "/" . $file;
+				if(is_dir($file)) {
+					com_wiris_util_sys_Store::deleteDirectory($file, $included);
+				} else {
+					$includedIterator = $included->iterator();
+					if($included !== null) {
+						while($includedIterator->hasNext()) {
+							if(StringTools::endsWith($file, $includedIterator->next())) {
+								@unlink($file);
+							}
+						}
+					} else {
+						@unlink($file);
+					}
+					unset($includedIterator);
+				}
+				unset($i1,$file);
+			}
+		}
+		$files = sys_FileSystem::readDirectory($folder);
+		if($files->length === 0) {
+			@rmdir($folder);
+		}
+	}
+	function __toString() { return 'com.wiris.util.sys.Store'; }
+}
+function com_wiris_util_sys_Store_0(&$this) {
+	{
+		$p = realpath($this->file);
+		if(($p === false)) {
+			return null;
+		} else {
+			return $p;
+		}
+		unset($p);
+	}
+}
+function com_wiris_util_sys_Store_1() {
+	{
+		$p = realpath(".");
+		if(($p === false)) {
+			return null;
+		} else {
+			return $p;
+		}
+		unset($p);
+	}
+}
+function com_wiris_util_sys_Store_2(&$folder, &$included) {
+	{
+		$p = realpath($folder);
+		if(($p === false)) {
+			return null;
+		} else {
+			return $p;
+		}
+		unset($p);
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/util/type/UrlUtils.class.php b/filter/wiris/integration/lib/com/wiris/util/type/UrlUtils.class.php
new file mode 100644
index 0000000..ff6b989
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/util/type/UrlUtils.class.php
@@ -0,0 +1,56 @@
+<?php
+
+class com_wiris_util_type_UrlUtils {
+	public function __construct(){}
+	static $charCodeA;
+	static $charCodeZ;
+	static $charCodea;
+	static $charCodez;
+	static $charCode0;
+	static $charCode9;
+	static function isAllowed($c) {
+		$allowedChars = _hx_index_of("-_.!~*'()", com_wiris_util_type_UrlUtils_0($c), null) !== -1;
+		return $c >= com_wiris_util_type_UrlUtils::$charCodeA && $c <= com_wiris_util_type_UrlUtils::$charCodeZ || $c >= com_wiris_util_type_UrlUtils::$charCodea && $c <= com_wiris_util_type_UrlUtils::$charCodez || $c >= com_wiris_util_type_UrlUtils::$charCode0 && $c <= com_wiris_util_type_UrlUtils::$charCode9 || $allowedChars;
+	}
+	static function urlComponentEncode($uriComponent) {
+		$sb = new StringBuf();
+		$buf = haxe_io_Bytes::ofData(com_wiris_system_Utf8::toBytes($uriComponent));
+		$i = null;
+		{
+			$_g1 = 0; $_g = $buf->length;
+			while($_g1 < $_g) {
+				$i1 = $_g1++;
+				$b = ord($buf->b[$i1]) & 255;
+				if(com_wiris_util_type_UrlUtils::isAllowed($b)) {
+					$sb->add(com_wiris_util_type_UrlUtils_1($_g, $_g1, $b, $buf, $i, $i1, $sb, $uriComponent));
+				} else {
+					$sb->add("%");
+					$sb->add(StringTools::hex($b, 2));
+				}
+				unset($i1,$b);
+			}
+		}
+		return $sb->b;
+	}
+	function __toString() { return 'com.wiris.util.type.UrlUtils'; }
+}
+com_wiris_util_type_UrlUtils::$charCodeA = _hx_char_code_at("A", 0);
+com_wiris_util_type_UrlUtils::$charCodeZ = _hx_char_code_at("Z", 0);
+com_wiris_util_type_UrlUtils::$charCodea = _hx_char_code_at("a", 0);
+com_wiris_util_type_UrlUtils::$charCodez = _hx_char_code_at("z", 0);
+com_wiris_util_type_UrlUtils::$charCode0 = _hx_char_code_at("0", 0);
+com_wiris_util_type_UrlUtils::$charCode9 = _hx_char_code_at("9", 0);
+function com_wiris_util_type_UrlUtils_0(&$c) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($c);
+		return $s->toString();
+	}
+}
+function com_wiris_util_type_UrlUtils_1(&$_g, &$_g1, &$b, &$buf, &$i, &$i1, &$sb, &$uriComponent) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($b);
+		return $s->toString();
+	}
+}
diff --git a/filter/wiris/integration/lib/com/wiris/util/xml/WCharacterBase.class.php b/filter/wiris/integration/lib/com/wiris/util/xml/WCharacterBase.class.php
new file mode 100644
index 0000000..988e89e
--- /dev/null
+++ b/filter/wiris/integration/lib/com/wiris/util/xml/WCharacterBase.class.php
@@ -0,0 +1,898 @@
+<?php
+
+class com_wiris_util_xml_WCharacterBase {
+	public function __construct(){}
+	static $NEGATIVE_THIN_SPACE = 57344;
+	static $ROOT = 61696;
+	static $ROOT_VERTICAL = 61727;
+	static $ROOT_NO_TAIL = 61728;
+	static $ROOT_NO_TAIL_VERTICAL = 61759;
+	static $ROOT_LEFT_TAIL = 61760;
+	static $ROOT_VERTICAL_LINE = 61761;
+	static $ROUND_BRACKET_LEFT = 40;
+	static $ROUND_BRACKET_RIGHT = 41;
+	static $COMMA = 44;
+	static $FULL_STOP = 46;
+	static $SQUARE_BRACKET_LEFT = 91;
+	static $SQUARE_BRACKET_RIGHT = 93;
+	static $CIRCUMFLEX_ACCENT = 94;
+	static $LOW_LINE = 95;
+	static $CURLY_BRACKET_LEFT = 123;
+	static $VERTICAL_BAR = 124;
+	static $CURLY_BRACKET_RIGHT = 125;
+	static $TILDE = 126;
+	static $MACRON = 175;
+	static $COMBINING_LOW_LINE = 818;
+	static $MODIFIER_LETTER_CIRCUMFLEX_ACCENT = 710;
+	static $CARON = 711;
+	static $EN_QUAD = 8192;
+	static $EM_QUAD = 8193;
+	static $EN_SPACE = 8194;
+	static $EM_SPACE = 8195;
+	static $THICK_SPACE = 8196;
+	static $MID_SPACE = 8197;
+	static $SIX_PER_EM_SPACE = 8198;
+	static $FIGIRE_SPACE = 8199;
+	static $PUNCTUATION_SPACE = 8200;
+	static $THIN_SPACE = 8201;
+	static $HAIR_SPACE = 8202;
+	static $ZERO_WIDTH_SPACE = 8203;
+	static $ZERO_WIDTH_NON_JOINER = 8204;
+	static $ZERO_WIDTH_JOINER = 8205;
+	static $DOUBLE_VERTICAL_BAR = 8214;
+	static $DOUBLE_HORIZONTAL_BAR = 9552;
+	static $NARROW_NO_BREAK_SPACE = 8239;
+	static $MEDIUM_MATHEMATICAL_SPACE = 8287;
+	static $WORD_JOINER = 8288;
+	static $PLANCKOVER2PI = 8463;
+	static $LEFTWARDS_ARROW = 8592;
+	static $UPWARDS_ARROW = 8593;
+	static $RIGHTWARDS_ARROW = 8594;
+	static $DOWNWARDS_ARROW = 8595;
+	static $LEFTRIGHT_ARROW = 8596;
+	static $UP_DOWN_ARROW = 8597;
+	static $LEFTWARDS_ARROW_FROM_BAR = 8612;
+	static $RIGHTWARDS_ARROW_FROM_BAR = 8614;
+	static $LEFTWARDS_ARROW_WITH_HOOK = 8617;
+	static $RIGHTWARDS_ARROW_WITH_HOOK = 8618;
+	static $LEFTWARDS_HARPOON_WITH_BARB_UPWARDS = 8636;
+	static $RIGHTWARDS_HARPOON_WITH_BARB_UPWARDS = 8640;
+	static $LEFTWARDS_DOUBLE_ARROW = 8656;
+	static $RIGHTWARDS_DOUBLE_ARROW = 8658;
+	static $LEFT_RIGHT_DOUBLE_ARROW = 8660;
+	static $LEFTWARDS_ARROW_OVER_RIGHTWARDS_ARROW = 8646;
+	static $RIGHTWARDS_ARROW_OVER_LEFTWARDS_ARROW = 8644;
+	static $LEFTWARDS_HARPOON_OVER_RIGHTWARDS_HARPOON = 8651;
+	static $RIGHTWARDS_HARPOON_OVER_LEFTWARDS_HARPOON = 8652;
+	static $RIGHTWARDS_ARROW_ABOVE_SHORT_LEFTWARDS_ARROW = 10562;
+	static $SHORT_RIGHTWARDS_ARROW_ABOVE_LEFTWARDS_ARROW = 10564;
+	static $LONG_RIGHTWARDS_ARROW = 10230;
+	static $LONG_LEFTWARDS_ARROW = 10229;
+	static $LONG_LEFT_RIGHT_ARROW = 10231;
+	static $LONG_LEFTWARDS_DOUBLE_ARROW = 10232;
+	static $LONG_RIGHTWARDS_DOUBLE_ARROW = 10233;
+	static $LONG_LEFT_RIGHT_DOUBLE_ARROW = 10234;
+	static $TILDE_OPERATOR = 8764;
+	static $LEFT_CEILING = 8968;
+	static $RIGHT_CEILING = 8969;
+	static $LEFT_FLOOR = 8970;
+	static $RIGHT_FLOOR = 8971;
+	static $TOP_PARENTHESIS = 9180;
+	static $BOTTOM_PARENTHESIS = 9181;
+	static $TOP_SQUARE_BRACKET = 9140;
+	static $BOTTOM_SQUARE_BRACKET = 9141;
+	static $TOP_CURLY_BRACKET = 9182;
+	static $BOTTOM_CURLY_BRACKET = 9183;
+	static $MATHEMATICAL_LEFT_ANGLE_BRACKET = 10216;
+	static $MATHEMATICAL_RIGHT_ANGLE_BRACKET = 10217;
+	static $DOUBLE_STRUCK_ITALIC_CAPITAL_D = 8517;
+	static $DOUBLE_STRUCK_ITALIC_SMALL_D = 8518;
+	static $DOUBLE_STRUCK_ITALIC_SMALL_E = 8519;
+	static $DOUBLE_STRUCK_ITALIC_SMALL_I = 8520;
+	static $EPSILON = 949;
+	static $VAREPSILON = 1013;
+	static $DIGIT_ZERO = 48;
+	static $DIGIT_NINE = 57;
+	static $LATIN_CAPITAL_LETTER_A = 65;
+	static $LATIN_CAPITAL_LETTER_Z = 90;
+	static $LATIN_SMALL_LETTER_A = 97;
+	static $LATIN_SMALL_LETTER_Z = 122;
+	static $MATHEMATICAL_SCRIPT_CAPITAL_A = 119964;
+	static $MATHEMATICAL_SCRIPT_SMALL_A = 119990;
+	static $MATHEMATICAL_FRAKTUR_CAPITAL_A = 120068;
+	static $MATHEMATICAL_FRAKTUR_SMALL_A = 120094;
+	static $MATHEMATICAL_DOUBLE_STRUCK_CAPITAL_A = 120120;
+	static $MATHEMATICAL_DOUBLE_STRUCK_SMALL_A = 120146;
+	static $MATHEMATICAL_DOUBLE_STRUCK_DIGIT_ZERO = 120792;
+	static function isDigit($c) {
+		if(48 <= $c && $c <= 57) {
+			return true;
+		}
+		if(1632 <= $c && $c <= 1641) {
+			return true;
+		}
+		if(1776 <= $c && $c <= 1785) {
+			return true;
+		}
+		if(2790 <= $c && $c <= 2799) {
+			return true;
+		}
+		return false;
+	}
+	static function isIdentifier($c) {
+		return com_wiris_util_xml_WCharacterBase::isLetter($c) || com_wiris_util_xml_WCharacterBase::isCombiningCharacter($c) || $c === 95;
+	}
+	static function isLarge($c) {
+		return com_wiris_util_xml_WCharacterBase::binarySearch(com_wiris_util_xml_WCharacterBase::$largeOps, $c);
+	}
+	static function isVeryLarge($c) {
+		return com_wiris_util_xml_WCharacterBase::binarySearch(com_wiris_util_xml_WCharacterBase::$veryLargeOps, $c);
+	}
+	static function isBinaryOp($c) {
+		return com_wiris_util_xml_WCharacterBase::binarySearch(com_wiris_util_xml_WCharacterBase::$binaryOps, $c);
+	}
+	static function isRelation($c) {
+		return com_wiris_util_xml_WCharacterBase::binarySearch(com_wiris_util_xml_WCharacterBase::$relations, $c);
+	}
+	static function binarySearch($v, $c) {
+		$min = 0;
+		$max = $v->length - 1;
+		do {
+			$mid = Math::floor(($min + $max) / 2);
+			$cc = $v[$mid];
+			if($c === $cc) {
+				return true;
+			} else {
+				if($c < $cc) {
+					$max = $mid - 1;
+				} else {
+					$min = $mid + 1;
+				}
+			}
+			unset($mid,$cc);
+		} while($min <= $max);
+		return false;
+	}
+	static $binaryOps;
+	static $relations;
+	static $largeOps;
+	static $veryLargeOps;
+	static $tallLetters;
+	static $longLetters;
+	static $negations;
+	static $mirrorDictionary;
+	static $subSuperScriptDictionary;
+	static $accentsDictionary = null;
+	static function initAccentsDictionary() {
+		if(com_wiris_util_xml_WCharacterBase::$accentsDictionary !== null) {
+			return;
+		}
+		$h = new Hash();
+		$h->set("A", new _hx_array(array(192, 193, 194, 195, 196, 197, 256, 258, 260, 461, 478, 480, 506, 512, 514, 550, 570, 7680, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 9398, 11375, 65313)));
+		$h->set("AA", new _hx_array(array(42802)));
+		$h->set("AE", new _hx_array(array(198, 482, 508)));
+		$h->set("AO", new _hx_array(array(42804)));
+		$h->set("AU", new _hx_array(array(42806)));
+		$h->set("AV", new _hx_array(array(42808, 42810)));
+		$h->set("AY", new _hx_array(array(42812)));
+		$h->set("B", new _hx_array(array(385, 386, 579, 7682, 7684, 7686, 9399, 65314)));
+		$h->set("C", new _hx_array(array(199, 262, 264, 266, 268, 391, 571, 7688, 9400, 42814, 65315)));
+		$h->set("D", new _hx_array(array(208, 270, 272, 393, 394, 395, 7690, 7692, 7694, 7696, 7698, 9401, 42873, 65316)));
+		$h->set("DZ", new _hx_array(array(452, 497)));
+		$h->set("Dz", new _hx_array(array(453, 498)));
+		$h->set("E", new _hx_array(array(200, 201, 202, 203, 274, 276, 278, 280, 282, 398, 400, 516, 518, 552, 7700, 7702, 7704, 7706, 7708, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 9402, 65317)));
+		$h->set("F", new _hx_array(array(401, 7710, 9403, 42875, 65318)));
+		$h->set("G", new _hx_array(array(284, 286, 288, 290, 403, 484, 486, 500, 7712, 9404, 42877, 42878, 42912, 65319)));
+		$h->set("H", new _hx_array(array(292, 294, 542, 7714, 7716, 7718, 7720, 7722, 9405, 11367, 11381, 42893, 65320)));
+		$h->set("I", new _hx_array(array(204, 205, 206, 207, 296, 298, 300, 302, 304, 407, 463, 520, 522, 7724, 7726, 7880, 7882, 9406, 65321)));
+		$h->set("J", new _hx_array(array(308, 584, 9407, 65322)));
+		$h->set("K", new _hx_array(array(310, 408, 488, 7728, 7730, 7732, 9408, 11369, 42816, 42818, 42820, 42914, 65323)));
+		$h->set("L", new _hx_array(array(313, 315, 317, 319, 321, 573, 7734, 7736, 7738, 7740, 9409, 11360, 11362, 42822, 42824, 42880, 65324)));
+		$h->set("LJ", new _hx_array(array(455)));
+		$h->set("Lj", new _hx_array(array(456)));
+		$h->set("M", new _hx_array(array(412, 7742, 7744, 7746, 9410, 11374, 65325)));
+		$h->set("N", new _hx_array(array(209, 323, 325, 327, 413, 504, 544, 7748, 7750, 7752, 7754, 9411, 42896, 42916, 65326)));
+		$h->set("NJ", new _hx_array(array(458)));
+		$h->set("Nj", new _hx_array(array(459)));
+		$h->set("O", new _hx_array(array(210, 211, 212, 213, 214, 216, 332, 334, 336, 390, 415, 416, 465, 490, 492, 510, 524, 526, 554, 556, 558, 560, 7756, 7758, 7760, 7762, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 9412, 42826, 42828, 65327)));
+		$h->set("OI", new _hx_array(array(418)));
+		$h->set("OO", new _hx_array(array(42830)));
+		$h->set("OU", new _hx_array(array(546)));
+		$h->set("OE", new _hx_array(array(140, 338)));
+		$h->set("oe", new _hx_array(array(156, 339)));
+		$h->set("P", new _hx_array(array(420, 7764, 7766, 9413, 11363, 42832, 42834, 42836, 65328)));
+		$h->set("Q", new _hx_array(array(586, 9414, 42838, 42840, 65329)));
+		$h->set("R", new _hx_array(array(340, 342, 344, 528, 530, 588, 7768, 7770, 7772, 7774, 9415, 11364, 42842, 42882, 42918, 65330)));
+		$h->set("S", new _hx_array(array(346, 348, 350, 352, 536, 7776, 7778, 7780, 7782, 7784, 7838, 9416, 11390, 42884, 42920, 65331)));
+		$h->set("T", new _hx_array(array(354, 356, 358, 428, 430, 538, 574, 7786, 7788, 7790, 7792, 9417, 42886, 65332)));
+		$h->set("TZ", new _hx_array(array(42792)));
+		$h->set("U", new _hx_array(array(217, 218, 219, 220, 360, 362, 364, 366, 368, 370, 431, 467, 469, 471, 473, 475, 532, 534, 580, 7794, 7796, 7798, 7800, 7802, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 9418, 65333)));
+		$h->set("V", new _hx_array(array(434, 581, 7804, 7806, 9419, 42846, 65334)));
+		$h->set("VY", new _hx_array(array(42848)));
+		$h->set("W", new _hx_array(array(372, 7808, 7810, 7812, 7814, 7816, 9420, 11378, 65335)));
+		$h->set("X", new _hx_array(array(7818, 7820, 9421, 65336)));
+		$h->set("Y", new _hx_array(array(221, 374, 376, 435, 562, 590, 7822, 7922, 7924, 7926, 7928, 7934, 9422, 65337)));
+		$h->set("Z", new _hx_array(array(377, 379, 381, 437, 548, 7824, 7826, 7828, 9423, 11371, 11391, 42850, 65338)));
+		$h->set("a", new _hx_array(array(224, 225, 226, 227, 228, 229, 257, 259, 261, 462, 479, 481, 507, 513, 515, 551, 592, 7681, 7834, 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 9424, 11365, 65345)));
+		$h->set("aa", new _hx_array(array(42803)));
+		$h->set("ae", new _hx_array(array(230, 483, 509)));
+		$h->set("ao", new _hx_array(array(42805)));
+		$h->set("au", new _hx_array(array(42807)));
+		$h->set("av", new _hx_array(array(42809, 42811)));
+		$h->set("ay", new _hx_array(array(42813)));
+		$h->set("b", new _hx_array(array(384, 387, 595, 7683, 7685, 7687, 9425, 65346)));
+		$h->set("c", new _hx_array(array(231, 263, 265, 267, 269, 392, 572, 7689, 8580, 9426, 42815, 65347)));
+		$h->set("d", new _hx_array(array(271, 273, 396, 598, 599, 7691, 7693, 7695, 7697, 7699, 9427, 42874, 65348)));
+		$h->set("dz", new _hx_array(array(454, 499)));
+		$h->set("e", new _hx_array(array(232, 233, 234, 235, 275, 277, 279, 281, 283, 477, 517, 519, 553, 583, 603, 7701, 7703, 7705, 7707, 7709, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 9428, 65349)));
+		$h->set("f", new _hx_array(array(402, 7711, 9429, 42876, 65350)));
+		$h->set("g", new _hx_array(array(285, 287, 289, 291, 485, 487, 501, 608, 7545, 7713, 9430, 42879, 42913, 65351)));
+		$h->set("h", new _hx_array(array(293, 295, 543, 613, 7715, 7717, 7719, 7721, 7723, 7830, 9431, 11368, 11382, 65352)));
+		$h->set("hv", new _hx_array(array(405)));
+		$h->set("i", new _hx_array(array(236, 237, 238, 239, 297, 299, 301, 303, 305, 464, 521, 523, 616, 7725, 7727, 7881, 7883, 9432, 65353)));
+		$h->set("j", new _hx_array(array(309, 496, 585, 9433, 65354)));
+		$h->set("k", new _hx_array(array(311, 409, 489, 7729, 7731, 7733, 9434, 11370, 42817, 42819, 42821, 42915, 65355)));
+		$h->set("l", new _hx_array(array(314, 316, 318, 320, 322, 383, 410, 619, 7735, 7737, 7739, 7741, 9435, 11361, 42823, 42825, 42881, 65356)));
+		$h->set("lj", new _hx_array(array(457)));
+		$h->set("m", new _hx_array(array(623, 625, 7743, 7745, 7747, 9436, 65357)));
+		$h->set("n", new _hx_array(array(241, 324, 326, 328, 329, 414, 505, 626, 7749, 7751, 7753, 7755, 9437, 42897, 42917, 65358)));
+		$h->set("nj", new _hx_array(array(460)));
+		$h->set("o", new _hx_array(array(242, 243, 244, 245, 246, 248, 333, 335, 337, 417, 466, 491, 493, 511, 525, 527, 555, 557, 559, 561, 596, 629, 7757, 7759, 7761, 7763, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 9438, 42827, 42829, 65359)));
+		$h->set("oi", new _hx_array(array(419)));
+		$h->set("ou", new _hx_array(array(547)));
+		$h->set("oo", new _hx_array(array(42831)));
+		$h->set("p", new _hx_array(array(421, 7549, 7765, 7767, 9439, 42833, 42835, 42837, 65360)));
+		$h->set("q", new _hx_array(array(587, 9440, 42839, 42841, 65361)));
+		$h->set("r", new _hx_array(array(341, 343, 345, 529, 531, 589, 637, 7769, 7771, 7773, 7775, 9441, 42843, 42883, 42919, 65362)));
+		$h->set("s", new _hx_array(array(223, 347, 349, 351, 353, 537, 575, 7777, 7779, 7781, 7783, 7785, 7835, 9442, 42885, 42921, 65363)));
+		$h->set("t", new _hx_array(array(355, 357, 359, 429, 539, 648, 7787, 7789, 7791, 7793, 7831, 9443, 11366, 42887, 65364)));
+		$h->set("tz", new _hx_array(array(42793)));
+		$h->set("u", new _hx_array(array(249, 250, 251, 252, 361, 363, 365, 367, 369, 371, 432, 468, 470, 472, 474, 476, 533, 535, 649, 7795, 7797, 7799, 7801, 7803, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 9444, 65365)));
+		$h->set("v", new _hx_array(array(651, 652, 7805, 7807, 9445, 42847, 65366)));
+		$h->set("vy", new _hx_array(array(42849)));
+		$h->set("w", new _hx_array(array(373, 7809, 7811, 7813, 7815, 7817, 7832, 9446, 11379, 65367)));
+		$h->set("x", new _hx_array(array(7819, 7821, 9447, 65368)));
+		$h->set("y", new _hx_array(array(253, 255, 375, 436, 563, 591, 7823, 7833, 7923, 7925, 7927, 7929, 7935, 9448, 65369)));
+		$h->set("z", new _hx_array(array(378, 380, 382, 438, 549, 576, 7825, 7827, 7829, 9449, 11372, 42851, 65370)));
+		com_wiris_util_xml_WCharacterBase::$accentsDictionary = $h;
+	}
+	static $horizontalLTRStretchyChars;
+	static $tallAccents;
+	static $PUNCTUATION_CATEGORY = "P";
+	static $OTHER_CATEGORY = "C";
+	static $LETTER_CATEGORY = "L";
+	static $MARK_CATEGORY = "M";
+	static $NUMBER_CATEGORY = "N";
+	static $SYMBOL_CATEGORY = "S";
+	static $PHONETICAL_CATEGORY = "F";
+	static $UNICODES_WITH_CATEGORIES = "@P:21-23,25-2A,2C-2F,3A-3B,3F-40,5B-5D,5F,7B,7D,A1,A7,AB,B6-B7,BB,BF,37E,387,55A-55F,589-58A,5BE,5C0,5C3,5C6,5F3-5F4,609-60A,60C-60D,61B,61E-61F,66A-66D,6D4,E4F,E5A-E5B,2010-2022,2025-2026,2030-203E,2040,2043,2047,204E-2051,2057,205E,2308-230B,2329-232A,2772-2773,27C5-27C6,27E6-27EF,2983-2998,29D8-29DB,29FC-29FD,2E17,3030,FD3E-FD3F@C:AD,600-603,6DD,200B-200F,202A-202E,206A-206F@L:41-5A,61-7A,AA,B5,BA,C0-D6,D8-F6,F8-2C1,2C6-2D1,2E0-2E4,2EC,2EE,370-374,376-377,37A-37D,386,388-38A,38C,38E-3A1,3A3-3F5,3F7-481,48A-527,531-556,559,561-587,5D0-5EA,5F0-5F2,620-64A,66E-66F,671-6D3,6D5,6E5-6E6,6EE-6EF,6FA-6FC,6FF,750-77F,E01-E30,E32-E33,E40-E46,1D00-1DBF,1E00-1F15,1F18-1F1D,1F20-1F45,1F48-1F4D,1F50-1F57,1F59,1F5B,1F5D,1F5F-1F7D,1F80-1FB4,1FB6-1FBC,1FBE,1FC2-1FC4,1FC6-1FCC,1FD0-1FD3,1FD6-1FDB,1FE0-1FEC,1FF2-1FF4,1FF6-1FFC,207F,2090-2094,2102,2107,210A-2113,2115,2119-211D,2124,2126,2128,212B-212D,212F-2138,213C-213F,2145-2149,214E,2184,2C60-2C7F,306E,A717-A71F,A727,A788,A78B-A78C,A792,FB00-FB04,FB13-FB17,FB1D,FB1F-FB28,FB2A-FB36,FB38-FB3C,FB3E,FB40-FB41,FB43-FB44,FB46-FBB1,FBD3-FBE9,FBFC-FBFF,FC5E-FC63,FC6A,FC6D,FC70,FC73,FC91,FC94,FDF2,FE70-FE74,FE76-FEFC,1D400-1D454,1D456-1D49C,1D49E-1D49F,1D4A2,1D4A5-1D4A6,1D4A9-1D4AC,1D4AE-1D4B9,1D4BB,1D4BD-1D4C3,1D4C5-1D505,1D507-1D50A,1D50D-1D514,1D516-1D51C,1D51E-1D539,1D53B-1D53E,1D540-1D544,1D546,1D54A-1D550,1D552-1D6A5,1D6A8-1D6C0,1D6C2-1D6DA,1D6DC-1D6FA,1D6FC-1D714,1D716-1D734,1D736-1D74E,1D750-1D76E,1D770-1D788,1D78A-1D7A8,1D7AA-1D7C2,1D7C4-1D7C9@M:300-36F,483-489,591-5BD,5BF,5C1-5C2,5C4-5C5,5C7,610-61A,64B-65F,670,6D6-6DC,6DF-6E4,6E7-6E8,6EA-6ED,E31,E34-E3A,E47-E4E,1DC0-1DC1,1DC3,1DCA,1DFE-1DFF,20D0-20D2,20D6-20D7,20DB-20DF,20E1,20E4-20F0,FB1E,FE20-FE23@N:30-39,B2-B3,B9,BC-BE,660-669,6F0-6F9,E50-E59,2070,2074-2079,2080-2089,2153-215E,2460-2468,24EA,2780-2793,1D7CE-1D7FF@S:24,2B,3C-3E,5E,60,7C,7E,A2-A6,A8-A9,AC,AE-B1,B4,B8,D7,F7,2C2-2C5,2D2-2DF,2E5-2EB,2ED,2EF-2FF,375,384-385,3F6,482,58F,606-608,60B,60E-60F,6DE,6E9,6FD-6FE,E3F,1FBD,1FBF-1FC1,1FCD-1FCF,1FDD-1FDF,1FED-1FEF,1FFD-1FFE,2044,2052,20A0-20BA,2105,2116-2118,211E,2120,2122,2125,2127,2129,212E,2140-2144,214A-214B,214D,2190-21EA,21F4-2300,2302,2305-2306,230C-2313,2315-231A,231C-2323,232C-232E,2332,2336,233D,233F-2340,2353,2370,237C,2393-2394,23AF,23B4-23B6,23CE,23D0,23DC-23E7,2423,24B6-24E9,2500,2502,2506,2508,250A,250C,2510,2514,2518,251C,2524,252C,2534,253C,2550-256C,2571-2572,2580,2584,2588,258C,2590-2593,25A0-25FF,2605-2606,2609,260C,260E,2612,2621,2639-2644,2646-2649,2660-2667,2669-266B,266D-266F,267E,2680-2689,26A0,26A5,26AA-26AC,26B2,26E2,2702,2709,2713,2720,272A,2736,273D,279B,27C0-27C4,27C7-27C9,27CB-27CD,27D0-27E5,27F0-27FF,2900-2982,2999-29D7,29DC-29FB,29FE-2AFF,2B12-2B4C,2B50-2B54,3012,A720-A721,A789-A78A,FB29,FBB2-FBC1,FDFC,FFFC-FFFD,1D6C1,1D6DB,1D6FB,1D715,1D735,1D74F,1D76F,1D789,1D7A9,1D7C3@F:70,62,74,64,288,256,63,25F,6B,261,71,262,294,6D,271,6E,273,272,14B,274,72,280,27E,27D,278,3B2,66,76,3B8,F0,73,7A,283,292,282,290,E7,29D,78,263,3C7,281,127,295,68,266,26C,26E,28B,279,27B,6A,270,6C,26D,28E,29F,1A5,253,1AD,257,188,284,199,260,2A0,29B,28D,77,265,29C,2A1-2A2,267,298,1C0,1C3,1C2,1C1,27A,255,291,2C71,287,297,296,286,293,27C,2E2,1AB,26B,67,2A6,2A3,2A7,2A4,2A8,2A5,1DBF,1D4A,1D91,1BB,29E,2E3,19E,19B,3BB,17E,161,1F0,10D,69,65,25B,61,251,254,6F,75,79,F8,153,276,252,28C,264,26F,268,289,26A,28F,28A,259,275,250,E6,25C,25A,131,25E,29A,258,277,269,2BC,325,30A,32C,2B0,324,330,33C,32A,33A-33B,339,31C,31F-320,308,33D,318-319,2DE,2B7,2B2,2E0,2E4,303,207F,2E1,31A,334,31D,2D4,31E,2D5,329,32F,361,35C,322,2F9,2C,2BB,307,2D7,2D6,2B8,323,321,32B,2C8,2CC,2D0-2D1,306,2E,7C,2016,203F,2197-2198,30B,301,304,300,30F,A71B-A71C,2E5-2E9,30C,302,1DC4-1DC5,1DC8,311,2C7,2C6,316,2CE,317,2CF,2AD,2A9-2AB,274D,2A,56,46,57,43,4C,4A,152,398,1D191,1D18F,31-33,346,34D,34A-34C,348-349,5C,34E,2193,2191,2EC,1DB9,362,347,2B6,2ED,2F1-2F2,2F7,41-42,44-45,47-49,4B,4D-55,58-5B,5D,2F,28-29,7B,7D@";
+	static function getCategoriesUnicode() {
+		$categoriesUnicode = new Hash();
+		$categoriesUnicode->set(com_wiris_util_xml_WCharacterBase::$SYMBOL_CATEGORY, "SymbolUnicodeCategory");
+		$categoriesUnicode->set(com_wiris_util_xml_WCharacterBase::$PUNCTUATION_CATEGORY, "PunctuationUnicodeCategory");
+		$categoriesUnicode->set(com_wiris_util_xml_WCharacterBase::$LETTER_CATEGORY, "LetterUnicodeCategory");
+		$categoriesUnicode->set(com_wiris_util_xml_WCharacterBase::$MARK_CATEGORY, "MarkUnicodeCategory");
+		$categoriesUnicode->set(com_wiris_util_xml_WCharacterBase::$NUMBER_CATEGORY, "NumberUnicodeCategory");
+		$categoriesUnicode->set(com_wiris_util_xml_WCharacterBase::$PHONETICAL_CATEGORY, "PhoneticalUnicodeCategory");
+		$categoriesUnicode->set(com_wiris_util_xml_WCharacterBase::$OTHER_CATEGORY, "OtherUnicodeCategory");
+		return $categoriesUnicode;
+	}
+	static function getUnicodeCategoryList($category) {
+		$indexStart = _hx_index_of(com_wiris_util_xml_WCharacterBase::$UNICODES_WITH_CATEGORIES, "@" . $category . ":", null);
+		$unicodes = _hx_substr(com_wiris_util_xml_WCharacterBase::$UNICODES_WITH_CATEGORIES, $indexStart + 3, null);
+		$indexEnd = _hx_index_of($unicodes, "@", null);
+		$unicodes = _hx_substr($unicodes, 0, $indexEnd);
+		return com_wiris_util_xml_WCharacterBase::getUnicodesRangedStringList($unicodes);
+	}
+	static function getUnicodesRangedStringList($unicodesRangedList) {
+		$inputList = _hx_explode(",", $unicodesRangedList);
+		$unicodeList = new _hx_array(array());
+		$i = 0;
+		while($i < $inputList->length) {
+			$actual_range = $inputList[$i];
+			$actual_range = str_replace(" ", "", $actual_range);
+			if(_hx_index_of($actual_range, "-", null) !== -1) {
+				$firstRangeValueHex = com_wiris_util_xml_WCharacterBase::hexStringToUnicode(_hx_array_get(_hx_explode("-", $actual_range), 0));
+				$lastRangeValueHex = com_wiris_util_xml_WCharacterBase::hexStringToUnicode(_hx_array_get(_hx_explode("-", $actual_range), 1));
+				$actualValue = $firstRangeValueHex;
+				while($actualValue <= $lastRangeValueHex) {
+					$unicodeList->push(com_wiris_util_xml_WCharacterBase_0($actualValue, $actual_range, $firstRangeValueHex, $i, $inputList, $lastRangeValueHex, $unicodeList, $unicodesRangedList));
+					$actualValue++;
+				}
+				unset($lastRangeValueHex,$firstRangeValueHex,$actualValue);
+			} else {
+				$actualValue = com_wiris_util_xml_WCharacterBase::hexStringToUnicode($actual_range);
+				$unicodeList->push(com_wiris_util_xml_WCharacterBase_1($actualValue, $actual_range, $i, $inputList, $unicodeList, $unicodesRangedList));
+				unset($actualValue);
+			}
+			$i++;
+			unset($actual_range);
+		}
+		return $unicodeList;
+	}
+	static function hexStringToUnicode($unicode) {
+		return Std::parseInt("0x" . $unicode);
+	}
+	static $invisible;
+	static function getMirror($str) {
+		$mirroredStr = "";
+		$i = 0;
+		while($i < strlen($str)) {
+			$c = _hx_char_code_at($str, $i);
+			$j = 0;
+			while($j < com_wiris_util_xml_WCharacterBase::$mirrorDictionary->length) {
+				if($c === com_wiris_util_xml_WCharacterBase::$mirrorDictionary[$j]) {
+					$c = com_wiris_util_xml_WCharacterBase::$mirrorDictionary[$j + 1];
+					break;
+				}
+				$j += 2;
+			}
+			$mirroredStr .= com_wiris_util_xml_WCharacterBase_2($c, $i, $j, $mirroredStr, $str);
+			++$i;
+			unset($j,$c);
+		}
+		return $mirroredStr;
+	}
+	static function isStretchyLTR($c) {
+		$i = 0;
+		while($i < com_wiris_util_xml_WCharacterBase::$horizontalLTRStretchyChars->length) {
+			if($c === com_wiris_util_xml_WCharacterBase::$horizontalLTRStretchyChars[$i]) {
+				return true;
+			}
+			++$i;
+		}
+		return false;
+	}
+	static function getNegated($c) {
+		$i = 0;
+		while($i < com_wiris_util_xml_WCharacterBase::$negations->length) {
+			if(com_wiris_util_xml_WCharacterBase::$negations[$i] === $c) {
+				return com_wiris_util_xml_WCharacterBase::$negations[$i + 1];
+			}
+			$i += 2;
+		}
+		return -1;
+	}
+	static function getNotNegated($c) {
+		$i = 1;
+		while($i < com_wiris_util_xml_WCharacterBase::$negations->length) {
+			if(com_wiris_util_xml_WCharacterBase::$negations[$i] === $c) {
+				return com_wiris_util_xml_WCharacterBase::$negations[$i - 1];
+			}
+			$i += 2;
+		}
+		return -1;
+	}
+	static function isCombining($s) {
+		$it = com_wiris_system_Utf8::getIterator($s);
+		while($it->hasNext()) {
+			if(!com_wiris_util_xml_WCharacterBase::isCombiningCharacter($it->next())) {
+				return false;
+			}
+		}
+		return true;
+	}
+	static function isCombiningCharacter($c) {
+		return $c >= 768 && $c <= 879 || $c >= 6832 && $c <= 6911 || $c >= 7616 && $c <= 7679 && ($c >= 8400 && $c <= 8447) && ($c >= 65056 && $c <= 65071);
+	}
+	static function isLetter($c) {
+		if(com_wiris_util_xml_WCharacterBase::isDigit($c)) {
+			return false;
+		}
+		if(65 <= $c && $c <= 90) {
+			return true;
+		}
+		if(97 <= $c && $c <= 122) {
+			return true;
+		}
+		if(192 <= $c && $c <= 696 && $c !== 215 && $c !== 247) {
+			return true;
+		}
+		if(867 <= $c && $c <= 1521) {
+			return true;
+		}
+		if(1552 <= $c && $c <= 8188) {
+			return true;
+		}
+		if($c === 8472 || $c === 8467 || com_wiris_util_xml_WCharacterBase::isDoubleStruck($c) || com_wiris_util_xml_WCharacterBase::isFraktur($c) || com_wiris_util_xml_WCharacterBase::isScript($c)) {
+			return true;
+		}
+		if(com_wiris_util_xml_WCharacterBase::isChinese($c)) {
+			return true;
+		}
+		if(com_wiris_util_xml_WCharacterBase::isKorean($c)) {
+			return true;
+		}
+		return false;
+	}
+	static function isUnicodeMathvariant($c) {
+		return com_wiris_util_xml_WCharacterBase::isDoubleStruck($c) || com_wiris_util_xml_WCharacterBase::isFraktur($c) || com_wiris_util_xml_WCharacterBase::isScript($c);
+	}
+	static function isRequiredByQuizzes($c) {
+		return $c === 120128 || $c === 8450 || $c === 8461 || $c === 8469 || $c === 8473 || $c === 8474 || $c === 8477 || $c === 8484;
+	}
+	static function isDoubleStruck($c) {
+		return $c >= 120120 && $c <= 120171 || $c === 8450 || $c === 8461 || $c === 8469 || $c === 8473 || $c === 8474 || $c === 8477 || $c === 8484;
+	}
+	static function isFraktur($c) {
+		return $c >= 120068 && $c <= 120119 || $c === 8493 || $c === 8460 || $c === 8465 || $c === 8476 || $c === 8488;
+	}
+	static function isScript($c) {
+		return $c >= 119964 && $c <= 120015 || $c === 8458 || $c === 8459 || $c === 8466 || $c === 8464 || $c === 8499 || $c === 8500 || $c === 8492 || $c === 8495 || $c === 8496 || $c === 8497 || $c === 8475;
+	}
+	static function isLowerCase($c) {
+		return $c >= 97 && $c <= 122 || $c >= 224 && $c <= 255 || $c >= 591 && $c >= 659 || $c >= 661 && $c <= 687 || $c >= 940 && $c <= 974;
+	}
+	static function isWord($c) {
+		if(com_wiris_util_xml_WCharacterBase::isDevanagari($c) || com_wiris_util_xml_WCharacterBase::isChinese($c) || com_wiris_util_xml_WCharacterBase::isHebrew($c) || com_wiris_util_xml_WCharacterBase::isThai($c) || com_wiris_util_xml_WCharacterBase::isGujarati($c) || com_wiris_util_xml_WCharacterBase::isKorean($c)) {
+			return true;
+		}
+		return false;
+	}
+	static function isArabianString($s) {
+		$i = strlen($s) - 1;
+		while($i >= 0) {
+			if(!com_wiris_util_xml_WCharacterBase::isArabian(_hx_char_code_at($s, $i))) {
+				return false;
+			}
+			--$i;
+		}
+		return true;
+	}
+	static function isArabian($c) {
+		if($c >= 1536 && $c <= 1791 && !com_wiris_util_xml_WCharacterBase::isDigit($c)) {
+			return true;
+		}
+		return false;
+	}
+	static function isHebrew($c) {
+		if($c >= 1424 && $c <= 1535) {
+			return true;
+		}
+		return false;
+	}
+	static function isChinese($c) {
+		if($c >= 13312 && $c <= 40959) {
+			return true;
+		}
+		return false;
+	}
+	static function isKorean($c) {
+		if($c >= 12593 && $c <= 52044) {
+			return true;
+		}
+		return false;
+	}
+	static function isGreek($c) {
+		if($c >= 945 && $c <= 969) {
+			return true;
+		} else {
+			if($c >= 913 && $c <= 937 && $c !== 930) {
+				return true;
+			} else {
+				if($c === 977 || $c === 981 || $c === 982) {
+					return true;
+				}
+			}
+		}
+		return false;
+	}
+	static function isDevanagari($c) {
+		if($c >= 2304 && $c < 2431) {
+			return true;
+		}
+		return false;
+	}
+	static function isGujarati($c) {
+		if($c >= 2689 && $c < 2788 || $c === 2800 || $c === 2801) {
+			return true;
+		}
+		return false;
+	}
+	static function isThai($c) {
+		if(3585 <= $c && $c < 3676) {
+			return true;
+		}
+		return false;
+	}
+	static function isDevanagariString($s) {
+		$i = strlen($s) - 1;
+		while($i >= 0) {
+			if(!com_wiris_util_xml_WCharacterBase::isDevanagari(_hx_char_code_at($s, $i))) {
+				return false;
+			}
+			--$i;
+		}
+		return true;
+	}
+	static function isRTL($c) {
+		if(com_wiris_util_xml_WCharacterBase::isHebrew($c) || com_wiris_util_xml_WCharacterBase::isArabian($c)) {
+			return true;
+		}
+		return false;
+	}
+	static function isTallLetter($c) {
+		if(97 <= $c && $c <= 122 || 945 <= $c && $c <= 969) {
+			return com_wiris_util_xml_WCharacterBase::binarySearch(com_wiris_util_xml_WCharacterBase::$tallLetters, $c);
+		}
+		return true;
+	}
+	static function isLongLetter($c) {
+		if(97 <= $c && $c <= 122 || 945 <= $c && $c <= 969) {
+			return com_wiris_util_xml_WCharacterBase::binarySearch(com_wiris_util_xml_WCharacterBase::$longLetters, $c);
+		} else {
+			if(65 <= $c && $c <= 90) {
+				return false;
+			}
+		}
+		return true;
+	}
+	static function isLTRNumber($text) {
+		$i = 0;
+		$n = haxe_Utf8::length($text);
+		while($i < $n) {
+			if(!com_wiris_util_xml_WCharacterBase::isDigit(haxe_Utf8::charCodeAt($text, $i))) {
+				return false;
+			}
+			++$i;
+		}
+		return true;
+	}
+	static function isSuperscript($c) {
+		return $c === 178 || $c === 179 || $c === 185 || $c >= 8304 && $c <= 8319 && $c !== 8306 && $c !== 8307;
+	}
+	static function isSubscript($c) {
+		return $c >= 8320 && $c <= 8348 && $c !== 8335;
+	}
+	static function isSuperscriptOrSubscript($c) {
+		return com_wiris_util_xml_WCharacterBase::isSuperscript($c) || com_wiris_util_xml_WCharacterBase::isSubscript($c);
+	}
+	static function normalizeSubSuperScript($c) {
+		$i = 0;
+		$n = com_wiris_util_xml_WCharacterBase::$subSuperScriptDictionary->length;
+		while($i < $n) {
+			if(com_wiris_util_xml_WCharacterBase::$subSuperScriptDictionary[$i] === $c) {
+				return com_wiris_util_xml_WCharacterBase::$subSuperScriptDictionary[$i + 1];
+			}
+			$i += 2;
+		}
+		return $c;
+	}
+	static function isInvisible($c) {
+		return com_wiris_util_xml_WCharacterBase::binarySearch(com_wiris_util_xml_WCharacterBase::$invisible, $c);
+	}
+	static $horizontalOperators;
+	static function isHorizontalOperator($c) {
+		return com_wiris_util_xml_WCharacterBase::binarySearch(com_wiris_util_xml_WCharacterBase::$horizontalOperators, $c);
+	}
+	static $latinLetters;
+	static $greekLetters;
+	static function latin2Greek($l) {
+		$index = -1;
+		if($l < 100) {
+			$index = _hx_index_of(com_wiris_util_xml_WCharacterBase::$latinLetters, "@00" . _hx_string_rec($l, "") . "@", null);
+		} else {
+			if($l < 1000) {
+				$index = _hx_index_of(com_wiris_util_xml_WCharacterBase::$latinLetters, "@0" . _hx_string_rec($l, "") . "@", null);
+			} else {
+				$index = _hx_index_of(com_wiris_util_xml_WCharacterBase::$latinLetters, "@" . _hx_string_rec($l, "") . "@", null);
+			}
+		}
+		if($index !== -1) {
+			$s = _hx_substr(com_wiris_util_xml_WCharacterBase::$greekLetters, $index + 1, 4);
+			return Std::parseInt($s);
+		}
+		return $l;
+	}
+	static function greek2Latin($g) {
+		$index = -1;
+		if($g < 100) {
+			$index = _hx_index_of(com_wiris_util_xml_WCharacterBase::$greekLetters, "@00" . _hx_string_rec($g, "") . "@", null);
+		} else {
+			if($g < 1000) {
+				$index = _hx_index_of(com_wiris_util_xml_WCharacterBase::$greekLetters, "@0" . _hx_string_rec($g, "") . "@", null);
+			} else {
+				$index = _hx_index_of(com_wiris_util_xml_WCharacterBase::$greekLetters, "@" . _hx_string_rec($g, "") . "@", null);
+			}
+		}
+		if($index !== -1) {
+			$s = _hx_substr(com_wiris_util_xml_WCharacterBase::$latinLetters, $index + 1, 4);
+			return Std::parseInt($s);
+		}
+		return $g;
+	}
+	static function isOp($c) {
+		return com_wiris_util_xml_WCharacterBase::isLarge($c) || com_wiris_util_xml_WCharacterBase::isVeryLarge($c) || com_wiris_util_xml_WCharacterBase::isBinaryOp($c) || com_wiris_util_xml_WCharacterBase::isRelation($c) || $c === _hx_char_code_at(".", 0) || $c === _hx_char_code_at(",", 0) || $c === _hx_char_code_at(":", 0);
+	}
+	static function isTallAccent($c) {
+		$i = 0;
+		while($i < com_wiris_util_xml_WCharacterBase::$tallAccents->length) {
+			if($c === com_wiris_util_xml_WCharacterBase::$tallAccents[$i]) {
+				return true;
+			}
+			++$i;
+		}
+		return false;
+	}
+	static function isDisplayedWithStix($c) {
+		if($c >= 592 && $c <= 687) {
+			return true;
+		}
+		if($c >= 688 && $c <= 767) {
+			return true;
+		}
+		if($c >= 8215 && $c <= 8233 || $c >= 8241 && $c <= 8303) {
+			return true;
+		}
+		if($c >= 8304 && $c <= 8351) {
+			return true;
+		}
+		if($c >= 8400 && $c <= 8447) {
+			return true;
+		}
+		if($c >= 8448 && $c <= 8527) {
+			return true;
+		}
+		if($c >= 8528 && $c <= 8591) {
+			return true;
+		}
+		if($c >= 8592 && $c <= 8703) {
+			return true;
+		}
+		if($c >= 8704 && $c <= 8959) {
+			return true;
+		}
+		if($c >= 8960 && $c <= 9215) {
+			return true;
+		}
+		if($c >= 9312 && $c <= 9471) {
+			return true;
+		}
+		if($c >= 9472 && $c <= 9599) {
+			return true;
+		}
+		if($c >= 9600 && $c <= 9631) {
+			return true;
+		}
+		if($c >= 9632 && $c <= 9727) {
+			return true;
+		}
+		if($c >= 9728 && $c <= 9983) {
+			return true;
+		}
+		if($c >= 9984 && $c <= 10175) {
+			return true;
+		}
+		if($c >= 10176 && $c <= 10223) {
+			return true;
+		}
+		if($c >= 10224 && $c <= 10239) {
+			return true;
+		}
+		if($c >= 10240 && $c <= 10495) {
+			return true;
+		}
+		if($c >= 10496 && $c <= 10623) {
+			return true;
+		}
+		if($c >= 10624 && $c <= 10751) {
+			return true;
+		}
+		if($c >= 10752 && $c <= 11007) {
+			return true;
+		}
+		if($c >= 11008 && $c <= 11263) {
+			return true;
+		}
+		if($c >= 12288 && $c <= 12351) {
+			return true;
+		}
+		if($c >= 57344 && $c <= 65535) {
+			return true;
+		}
+		if($c >= 119808 && $c <= 119963 || $c >= 120224 && $c <= 120831) {
+			return true;
+		}
+		if($c === 12398 || $c === 42791 || $c === 42898) {
+			return true;
+		}
+		return false;
+	}
+	static function latinToDoublestruck($codepoint) {
+		if($codepoint === 67) {
+			return 8450;
+		} else {
+			if($codepoint === 72) {
+				return 8461;
+			} else {
+				if($codepoint === 78) {
+					return 8469;
+				} else {
+					if($codepoint === 80) {
+						return 8473;
+					} else {
+						if($codepoint === 81) {
+							return 8474;
+						} else {
+							if($codepoint === 82) {
+								return 8477;
+							} else {
+								if($codepoint === 90) {
+									return 8484;
+								} else {
+									if($codepoint >= com_wiris_util_xml_WCharacterBase::$LATIN_CAPITAL_LETTER_A && $codepoint <= com_wiris_util_xml_WCharacterBase::$LATIN_CAPITAL_LETTER_Z) {
+										return $codepoint + (com_wiris_util_xml_WCharacterBase::$MATHEMATICAL_DOUBLE_STRUCK_CAPITAL_A - com_wiris_util_xml_WCharacterBase::$LATIN_CAPITAL_LETTER_A);
+									} else {
+										if($codepoint >= com_wiris_util_xml_WCharacterBase::$LATIN_SMALL_LETTER_A && $codepoint <= com_wiris_util_xml_WCharacterBase::$LATIN_SMALL_LETTER_Z) {
+											return $codepoint + (com_wiris_util_xml_WCharacterBase::$MATHEMATICAL_DOUBLE_STRUCK_SMALL_A - com_wiris_util_xml_WCharacterBase::$LATIN_SMALL_LETTER_A);
+										} else {
+											if($codepoint >= com_wiris_util_xml_WCharacterBase::$DIGIT_ZERO && $codepoint <= com_wiris_util_xml_WCharacterBase::$DIGIT_NINE) {
+												return $codepoint + (com_wiris_util_xml_WCharacterBase::$MATHEMATICAL_DOUBLE_STRUCK_DIGIT_ZERO - com_wiris_util_xml_WCharacterBase::$DIGIT_ZERO);
+											} else {
+												return $codepoint;
+											}
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	static function latinToScript($codepoint) {
+		if($codepoint === 66) {
+			return 8492;
+		} else {
+			if($codepoint === 69) {
+				return 8496;
+			} else {
+				if($codepoint === 70) {
+					return 8497;
+				} else {
+					if($codepoint === 72) {
+						return 8459;
+					} else {
+						if($codepoint === 73) {
+							return 8464;
+						} else {
+							if($codepoint === 76) {
+								return 8466;
+							} else {
+								if($codepoint === 77) {
+									return 8499;
+								} else {
+									if($codepoint === 82) {
+										return 8475;
+									} else {
+										if($codepoint === 101) {
+											return 8495;
+										} else {
+											if($codepoint === 103) {
+												return 8458;
+											} else {
+												if($codepoint === 111) {
+													return 8500;
+												} else {
+													if($codepoint >= com_wiris_util_xml_WCharacterBase::$LATIN_CAPITAL_LETTER_A && $codepoint <= com_wiris_util_xml_WCharacterBase::$LATIN_CAPITAL_LETTER_Z) {
+														return $codepoint + (com_wiris_util_xml_WCharacterBase::$MATHEMATICAL_SCRIPT_CAPITAL_A - com_wiris_util_xml_WCharacterBase::$LATIN_CAPITAL_LETTER_A);
+													} else {
+														if($codepoint >= com_wiris_util_xml_WCharacterBase::$LATIN_SMALL_LETTER_A && $codepoint <= com_wiris_util_xml_WCharacterBase::$LATIN_SMALL_LETTER_Z) {
+															return $codepoint + (com_wiris_util_xml_WCharacterBase::$MATHEMATICAL_SCRIPT_SMALL_A - com_wiris_util_xml_WCharacterBase::$LATIN_SMALL_LETTER_A);
+														} else {
+															return $codepoint;
+														}
+													}
+												}
+											}
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	static function latinToFraktur($codepoint) {
+		if($codepoint === 67) {
+			return 8493;
+		} else {
+			if($codepoint === 72) {
+				return 8460;
+			} else {
+				if($codepoint === 73) {
+					return 8465;
+				} else {
+					if($codepoint === 82) {
+						return 8476;
+					} else {
+						if($codepoint === 90) {
+							return 8488;
+						} else {
+							if($codepoint >= com_wiris_util_xml_WCharacterBase::$LATIN_CAPITAL_LETTER_A && $codepoint <= com_wiris_util_xml_WCharacterBase::$LATIN_CAPITAL_LETTER_Z) {
+								return $codepoint + (com_wiris_util_xml_WCharacterBase::$MATHEMATICAL_FRAKTUR_CAPITAL_A - com_wiris_util_xml_WCharacterBase::$LATIN_CAPITAL_LETTER_A);
+							} else {
+								if($codepoint >= com_wiris_util_xml_WCharacterBase::$LATIN_SMALL_LETTER_A && $codepoint <= com_wiris_util_xml_WCharacterBase::$LATIN_SMALL_LETTER_Z) {
+									return $codepoint + (com_wiris_util_xml_WCharacterBase::$MATHEMATICAL_FRAKTUR_SMALL_A - com_wiris_util_xml_WCharacterBase::$LATIN_SMALL_LETTER_A);
+								} else {
+									return $codepoint;
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	static function stripAccent($c) {
+		com_wiris_util_xml_WCharacterBase::initAccentsDictionary();
+		if($c >= 128) {
+			$i = com_wiris_util_xml_WCharacterBase::$accentsDictionary->keys();
+			while($i->hasNext()) {
+				$s = $i->next();
+				$chars = com_wiris_util_xml_WCharacterBase::$accentsDictionary->get($s);
+				if(com_wiris_util_xml_WCharacterBase::binarySearch($chars, $c)) {
+					return $s;
+				}
+				unset($s,$chars);
+			}
+			return com_wiris_util_xml_WCharacterBase_3($c, $i);
+		} else {
+			return com_wiris_util_xml_WCharacterBase_4($c);
+		}
+	}
+	function __toString() { return 'com.wiris.util.xml.WCharacterBase'; }
+}
+com_wiris_util_xml_WCharacterBase::$binaryOps = new _hx_array(array(43, 45, 47, 177, 183, 215, 247, 8226, 8722, 8723, 8724, 8726, 8727, 8728, 8743, 8744, 8745, 8746, 8760, 8768, 8846, 8851, 8852, 8853, 8854, 8855, 8856, 8857, 8858, 8859, 8861, 8862, 8863, 8864, 8865, 8890, 8891, 8900, 8901, 8902, 8903, 8905, 8906, 8907, 8908, 8910, 8911, 8914, 8915, 8966, 9021, 9675, 10678, 10789, 10794, 10797, 10798, 10799, 10804, 10805, 10812, 10815, 10835, 10836, 10837, 10838, 10846, 10847, 10851));
+com_wiris_util_xml_WCharacterBase::$relations = new _hx_array(array(60, 61, 62, 8592, 8593, 8594, 8595, 8596, 8597, 8598, 8599, 8600, 8601, 8602, 8603, 8604, 8605, 8606, 8608, 8610, 8611, 8614, 8617, 8618, 8619, 8620, 8621, 8622, 8624, 8625, 8627, 8630, 8631, 8636, 8637, 8638, 8639, 8640, 8641, 8642, 8643, 8644, 8645, 8646, 8647, 8648, 8649, 8650, 8651, 8652, 8653, 8654, 8655, 8656, 8657, 8658, 8659, 8660, 8661, 8666, 8667, 8669, 8693, 8712, 8713, 8715, 8716, 8733, 8739, 8740, 8741, 8742, 8764, 8765, 8769, 8770, 8771, 8772, 8773, 8774, 8775, 8776, 8777, 8778, 8779, 8781, 8782, 8783, 8784, 8785, 8786, 8787, 8788, 8789, 8790, 8791, 8793, 8794, 8795, 8796, 8799, 8800, 8801, 8802, 8804, 8805, 8806, 8807, 8808, 8809, 8810, 8811, 8812, 8814, 8815, 8816, 8817, 8818, 8819, 8820, 8821, 8822, 8823, 8824, 8825, 8826, 8827, 8828, 8829, 8830, 8831, 8832, 8833, 8834, 8835, 8836, 8837, 8838, 8839, 8840, 8841, 8842, 8843, 8847, 8848, 8849, 8850, 8866, 8867, 8869, 8871, 8872, 8873, 8874, 8875, 8876, 8877, 8878, 8879, 8882, 8883, 8884, 8885, 8886, 8887, 8888, 8904, 8909, 8912, 8913, 8918, 8919, 8920, 8921, 8922, 8923, 8926, 8927, 8930, 8931, 8934, 8935, 8936, 8937, 8938, 8939, 8940, 8941, 8994, 8995, 9123, 10229, 10230, 10231, 10232, 10233, 10234, 10236, 10239, 10501, 10514, 10515, 10531, 10532, 10533, 10534, 10535, 10536, 10537, 10538, 10547, 10550, 10551, 10560, 10561, 10562, 10564, 10567, 10574, 10575, 10576, 10577, 10578, 10579, 10580, 10581, 10582, 10583, 10584, 10585, 10586, 10587, 10588, 10589, 10590, 10591, 10592, 10593, 10606, 10607, 10608, 10620, 10621, 10869, 10877, 10878, 10885, 10886, 10887, 10888, 10889, 10890, 10891, 10892, 10901, 10902, 10909, 10910, 10913, 10914, 10927, 10928, 10933, 10934, 10935, 10936, 10937, 10938, 10949, 10950, 10955, 10956, 10987, 11005));
+com_wiris_util_xml_WCharacterBase::$largeOps = new _hx_array(array(8719, 8720, 8721, 8896, 8897, 8898, 8899, 10756, 10757, 10758, 10759, 10760));
+com_wiris_util_xml_WCharacterBase::$veryLargeOps = new _hx_array(array(8747, 8748, 8749, 8750, 8751, 8752, 8753, 8754, 8755, 10763, 10764, 10765, 10766, 10767, 10768, 10774, 10775, 10776, 10777, 10778, 10779, 10780));
+com_wiris_util_xml_WCharacterBase::$tallLetters = new _hx_array(array(98, 100, 102, 104, 105, 106, 107, 108, 116, 946, 948, 950, 952, 955, 958));
+com_wiris_util_xml_WCharacterBase::$longLetters = new _hx_array(array(103, 106, 112, 113, 121, 946, 947, 950, 951, 956, 958, 961, 962, 966, 967, 968));
+com_wiris_util_xml_WCharacterBase::$negations = new _hx_array(array(61, 8800, 8801, 8802, 8764, 8769, 8712, 8713, 8715, 8716, 8834, 8836, 8835, 8837, 8838, 8840, 8839, 8841, 62, 8815, 60, 8814, 8805, 8817, 8804, 8816, 10878, 8817, 10877, 8816, 8776, 8777, 8771, 8772, 8773, 8775, 8849, 8930, 8850, 8931, 8707, 8708, 8741, 8742));
+com_wiris_util_xml_WCharacterBase::$mirrorDictionary = new _hx_array(array(40, 41, 41, 40, 60, 62, 62, 60, 91, 93, 93, 91, 123, 125, 125, 123, 171, 187, 187, 171, 3898, 3899, 3899, 3898, 3900, 3901, 3901, 3900, 5787, 5788, 5788, 5787, 8249, 8250, 8250, 8249, 8261, 8262, 8262, 8261, 8317, 8318, 8318, 8317, 8333, 8334, 8334, 8333, 8712, 8715, 8713, 8716, 8714, 8717, 8715, 8712, 8716, 8713, 8717, 8714, 8725, 10741, 8764, 8765, 8765, 8764, 8771, 8909, 8786, 8787, 8787, 8786, 8788, 8789, 8789, 8788, 8804, 8805, 8805, 8804, 8806, 8807, 8807, 8806, 8808, 8809, 8809, 8808, 8810, 8811, 8811, 8810, 8814, 8815, 8815, 8814, 8816, 8817, 8817, 8816, 8818, 8819, 8819, 8818, 8820, 8821, 8821, 8820, 8822, 8823, 8823, 8822, 8824, 8825, 8825, 8824, 8826, 8827, 8827, 8826, 8828, 8829, 8829, 8828, 8830, 8831, 8831, 8830, 8832, 8833, 8833, 8832, 8834, 8835, 8835, 8834, 8836, 8837, 8837, 8836, 8838, 8839, 8839, 8838, 8840, 8841, 8841, 8840, 8842, 8843, 8843, 8842, 8847, 8848, 8848, 8847, 8849, 8850, 8850, 8849, 8856, 10680, 8866, 8867, 8867, 8866, 8870, 10974, 8872, 10980, 8873, 10979, 8875, 10981, 8880, 8881, 8881, 8880, 8882, 8883, 8883, 8882, 8884, 8885, 8885, 8884, 8886, 8887, 8887, 8886, 8905, 8906, 8906, 8905, 8907, 8908, 8908, 8907, 8909, 8771, 8912, 8913, 8913, 8912, 8918, 8919, 8919, 8918, 8920, 8921, 8921, 8920, 8922, 8923, 8923, 8922, 8924, 8925, 8925, 8924, 8926, 8927, 8927, 8926, 8928, 8929, 8929, 8928, 8930, 8931, 8931, 8930, 8932, 8933, 8933, 8932, 8934, 8935, 8935, 8934, 8936, 8937, 8937, 8936, 8938, 8939, 8939, 8938, 8940, 8941, 8941, 8940, 8944, 8945, 8945, 8944, 8946, 8954, 8947, 8955, 8948, 8956, 8950, 8957, 8951, 8958, 8954, 8946, 8955, 8947, 8956, 8948, 8957, 8950, 8958, 8951, 8968, 8969, 8969, 8968, 8970, 8971, 8971, 8970, 9001, 9002, 9002, 9001, 10088, 10089, 10089, 10088, 10090, 10091, 10091, 10090, 10092, 10093, 10093, 10092, 10094, 10095, 10095, 10094, 10096, 10097, 10097, 10096, 10098, 10099, 10099, 10098, 10100, 10101, 10101, 10100, 10179, 10180, 10180, 10179, 10181, 10182, 10182, 10181, 10184, 10185, 10185, 10184, 10187, 10189, 10189, 10187, 10197, 10198, 10198, 10197, 10205, 10206, 10206, 10205, 10210, 10211, 10211, 10210, 10212, 10213, 10213, 10212, 10214, 10215, 10215, 10214, 10216, 10217, 10217, 10216, 10218, 10219, 10219, 10218, 10220, 10221, 10221, 10220, 10222, 10223, 10223, 10222, 10627, 10628, 10628, 10627, 10629, 10630, 10630, 10629, 10631, 10632, 10632, 10631, 10633, 10634, 10634, 10633, 10635, 10636, 10636, 10635, 10637, 10640, 10638, 10639, 10639, 10638, 10640, 10637, 10641, 10642, 10642, 10641, 10643, 10644, 10644, 10643, 10645, 10646, 10646, 10645, 10647, 10648, 10648, 10647, 10680, 8856, 10688, 10689, 10689, 10688, 10692, 10693, 10693, 10692, 10703, 10704, 10704, 10703, 10705, 10706, 10706, 10705, 10708, 10709, 10709, 10708, 10712, 10713, 10713, 10712, 10714, 10715, 10715, 10714, 10741, 8725, 10744, 10745, 10745, 10744, 10748, 10749, 10749, 10748, 10795, 10796, 10796, 10795, 10797, 10798, 10798, 10797, 10804, 10805, 10805, 10804, 10812, 10813, 10813, 10812, 10852, 10853, 10853, 10852, 10873, 10874, 10874, 10873, 10877, 10878, 10878, 10877, 10879, 10880, 10880, 10879, 10881, 10882, 10882, 10881, 10883, 10884, 10884, 10883, 10891, 10892, 10892, 10891, 10897, 10898, 10898, 10897, 10899, 10900, 10900, 10899, 10901, 10902, 10902, 10901, 10903, 10904, 10904, 10903, 10905, 10906, 10906, 10905, 10907, 10908, 10908, 10907, 10913, 10914, 10914, 10913, 10918, 10919, 10919, 10918, 10920, 10921, 10921, 10920, 10922, 10923, 10923, 10922, 10924, 10925, 10925, 10924, 10927, 10928, 10928, 10927, 10931, 10932, 10932, 10931, 10939, 10940, 10940, 10939, 10941, 10942, 10942, 10941, 10943, 10944, 10944, 10943, 10945, 10946, 10946, 10945, 10947, 10948, 10948, 10947, 10949, 10950, 10950, 10949, 10957, 10958, 10958, 10957, 10959, 10960, 10960, 10959, 10961, 10962, 10962, 10961, 10963, 10964, 10964, 10963, 10965, 10966, 10966, 10965, 10974, 8870, 10979, 8873, 10980, 8872, 10981, 8875, 10988, 10989, 10989, 10988, 10999, 11000, 11000, 10999, 11001, 11002, 11002, 11001, 11778, 11779, 11779, 11778, 11780, 11781, 11781, 11780, 11785, 11786, 11786, 11785, 11788, 11789, 11789, 11788, 11804, 11805, 11805, 11804, 11808, 11809, 11809, 11808, 11810, 11811, 11811, 11810, 11812, 11813, 11813, 11812, 11814, 11815, 11815, 11814, 11816, 11817, 11817, 11816, 12296, 12297, 12297, 12296, 12298, 12299, 12299, 12298, 12300, 12301, 12301, 12300, 12302, 12303, 12303, 12302, 12304, 12305, 12305, 12304, 12308, 12309, 12309, 12308, 12310, 12311, 12311, 12310, 12312, 12313, 12313, 12312, 12314, 12315, 12315, 12314, 65113, 65114, 65114, 65113, 65115, 65116, 65116, 65115, 65117, 65118, 65118, 65117, 65124, 65125, 65125, 65124, 65288, 65289, 65289, 65288, 65308, 65310, 65310, 65308, 65339, 65341, 65341, 65339, 65371, 65373, 65373, 65371, 65375, 65376, 65376, 65375, 65378, 65379, 65379, 65378, 9115, 9118, 9116, 9119, 9117, 9120, 9118, 9115, 9119, 9116, 9120, 9117, 9121, 9124, 9122, 9125, 9123, 9126, 9124, 9121, 9125, 9122, 9126, 9123, 9127, 9131, 9130, 9134, 9129, 9133, 9131, 9127, 9134, 9130, 9133, 9129, 9128, 9132, 9132, 9128));
+com_wiris_util_xml_WCharacterBase::$subSuperScriptDictionary = new _hx_array(array(178, 50, 179, 51, 185, 49, 8304, 48, 8305, 105, 8308, 52, 8309, 53, 8310, 54, 8311, 55, 8312, 56, 8313, 57, 8314, 43, 8315, 45, 8316, 61, 8317, 40, 8318, 41, 8319, 110, 8320, 48, 8321, 49, 8322, 50, 8323, 51, 8324, 52, 8325, 53, 8326, 54, 8327, 55, 8328, 56, 8329, 57, 8330, 43, 8331, 45, 8332, 61, 8333, 40, 8334, 41, 8336, 97, 8337, 101, 8338, 111, 8339, 120, 8340, 601, 8341, 104, 8342, 107, 8343, 108, 8344, 109, 8345, 110, 8346, 112, 8347, 115, 8348, 116));
+com_wiris_util_xml_WCharacterBase::$horizontalLTRStretchyChars = new _hx_array(array(com_wiris_util_xml_WCharacterBase::$LEFTWARDS_ARROW, com_wiris_util_xml_WCharacterBase::$RIGHTWARDS_ARROW, com_wiris_util_xml_WCharacterBase::$LEFTRIGHT_ARROW, com_wiris_util_xml_WCharacterBase::$LEFTWARDS_ARROW_FROM_BAR, com_wiris_util_xml_WCharacterBase::$RIGHTWARDS_ARROW_FROM_BAR, com_wiris_util_xml_WCharacterBase::$LEFTWARDS_ARROW_WITH_HOOK, com_wiris_util_xml_WCharacterBase::$RIGHTWARDS_ARROW_WITH_HOOK, com_wiris_util_xml_WCharacterBase::$LEFTWARDS_HARPOON_WITH_BARB_UPWARDS, com_wiris_util_xml_WCharacterBase::$RIGHTWARDS_HARPOON_WITH_BARB_UPWARDS, com_wiris_util_xml_WCharacterBase::$LEFTWARDS_DOUBLE_ARROW, com_wiris_util_xml_WCharacterBase::$RIGHTWARDS_DOUBLE_ARROW, com_wiris_util_xml_WCharacterBase::$TOP_CURLY_BRACKET, com_wiris_util_xml_WCharacterBase::$BOTTOM_CURLY_BRACKET, com_wiris_util_xml_WCharacterBase::$TOP_PARENTHESIS, com_wiris_util_xml_WCharacterBase::$BOTTOM_PARENTHESIS, com_wiris_util_xml_WCharacterBase::$TOP_SQUARE_BRACKET, com_wiris_util_xml_WCharacterBase::$BOTTOM_SQUARE_BRACKET, com_wiris_util_xml_WCharacterBase::$LEFTWARDS_ARROW_OVER_RIGHTWARDS_ARROW, com_wiris_util_xml_WCharacterBase::$RIGHTWARDS_ARROW_OVER_LEFTWARDS_ARROW, com_wiris_util_xml_WCharacterBase::$LEFTWARDS_HARPOON_OVER_RIGHTWARDS_HARPOON, com_wiris_util_xml_WCharacterBase::$RIGHTWARDS_HARPOON_OVER_LEFTWARDS_HARPOON));
+com_wiris_util_xml_WCharacterBase::$tallAccents = new _hx_array(array(com_wiris_util_xml_WCharacterBase::$LEFTWARDS_ARROW_OVER_RIGHTWARDS_ARROW, com_wiris_util_xml_WCharacterBase::$RIGHTWARDS_ARROW_OVER_LEFTWARDS_ARROW, com_wiris_util_xml_WCharacterBase::$LEFTWARDS_HARPOON_OVER_RIGHTWARDS_HARPOON, com_wiris_util_xml_WCharacterBase::$RIGHTWARDS_HARPOON_OVER_LEFTWARDS_HARPOON));
+com_wiris_util_xml_WCharacterBase::$invisible = new _hx_array(array(8289, 8290, 8291));
+com_wiris_util_xml_WCharacterBase::$horizontalOperators = new _hx_array(array(175, 818, 8592, 8594, 8596, 8612, 8614, 8617, 8618, 8636, 8637, 8640, 8641, 8644, 8646, 8651, 8652, 8656, 8658, 8660, 8764, 9140, 9141, 9180, 9181, 9182, 9183, 9552, 10562, 10564, 10602, 10605));
+com_wiris_util_xml_WCharacterBase::$latinLetters = "@0065@0066@0067@0068@0069@0070@0071@0072@0073@0074@0075@0076@0077@0078@0079@0080@0081@0082@0083@0084@0085@0086@0087@0088@0089@0090" . "@0097@0098@0099@0100@0101@0102@0103@0104@0105@0106@0107@0108@0109@0110@0111@0112@0113@0114@0115@0116@0117@0118@0119@0120@0121@0122@";
+com_wiris_util_xml_WCharacterBase::$greekLetters = "@0913@0914@0935@0916@0917@0934@0915@0919@0921@0977@0922@0923@0924@0925@0927@0928@0920@0929@0931@0932@0933@0962@0937@0926@0936@0918" . "@0945@0946@0967@0948@0949@0966@0947@0951@0953@0966@0954@0955@0956@0957@0959@0960@0952@0961@0963@0964@0965@0982@0969@0958@0968@0950@";
+function com_wiris_util_xml_WCharacterBase_0(&$actualValue, &$actual_range, &$firstRangeValueHex, &$i, &$inputList, &$lastRangeValueHex, &$unicodeList, &$unicodesRangedList) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($actualValue);
+		return $s->toString();
+	}
+}
+function com_wiris_util_xml_WCharacterBase_1(&$actualValue, &$actual_range, &$i, &$inputList, &$unicodeList, &$unicodesRangedList) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($actualValue);
+		return $s->toString();
+	}
+}
+function com_wiris_util_xml_WCharacterBase_2(&$c, &$i, &$j, &$mirroredStr, &$str) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($c);
+		return $s->toString();
+	}
+}
+function com_wiris_util_xml_WCharacterBase_3(&$c, &$i) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($c);
+		return $s->toString();
+	}
+}
+function com_wiris_util_xml_WCharacterBase_4(&$c) {
+	{
+		$s = new haxe_Utf8(null);
+		$s->addChar($c);
+		return $s->toString();
+	}
+}
diff --git a/filter/wiris/integration/lib/default-configuration.ini b/filter/wiris/integration/lib/default-configuration.ini
new file mode 100644
index 0000000..d36be11
--- /dev/null
+++ b/filter/wiris/integration/lib/default-configuration.ini
@@ -0,0 +1,46 @@
+wirisdebug = false
+
+#wiriscachedirectory=C:/soft/Tomcat_5.5/wiris/cache
+#wirisformuladirectory=C:/soft/Tomcat_5.5/wiris/formulas
+wirisimageservicehost = www.wiris.net
+#wirisimageserviceprotocol = http
+#wirisimageserviceport = 80
+wirisimageservicepath = /demo/editor/render
+
+wirisenableaccessibility = true
+
+# Editor
+wiriseditorenabled = true
+wiriseditormathmlattribute = data-mathml
+wiriseditorsavemode = xml
+wiriseditoreditmode = default
+wiriseditorparselatex = true
+wiriseditorparsexml = false
+wiriseditorwindowattributes = width=570, height=450, scroll=no, resizable=yes
+wiriseditorsetsize = false
+wiriseditortoolbar =
+wiriseditormodalwindow = true
+wiriseditormodalwindowfullscreen = false
+#wirisparsememorylimit = 60
+wirischemeditorenabled = true
+wirisimageformat = svg
+
+# CAS
+wiriscasenabled = false
+wiriscascodebase = http://www.wiris.net/demo/wiris/wiris-codebase
+wiriscasarchive = wrs_net_%LANG.jar
+wiriscasclass = WirisApplet_net_%LANG
+wiriscaslanguages = en, es, fr, it, nl, et, ca, eu, pt, de
+wiriscaswidth = 450
+wiriscasheight = 400
+wiriscaswindowattributes = width=640, height=480, scroll=no, resizable=yes
+wiriscasmathmlattribute = alt
+
+wirishostplatform = unknown
+wirisaccessibilityenabled = true
+
+# Filter
+wirisfilteroutputmathml = true
+
+# Experimental settings
+wirispluginperformance = true
\ No newline at end of file
diff --git a/filter/wiris/integration/lib/haxe/BaseCode.class.php b/filter/wiris/integration/lib/haxe/BaseCode.class.php
new file mode 100644
index 0000000..24a48eb
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/BaseCode.class.php
@@ -0,0 +1,118 @@
+<?php
+
+class haxe_BaseCode {
+	public function __construct($base) {
+		if(!php_Boot::$skip_constructor) {
+		$len = $base->length;
+		$nbits = 1;
+		while($len > 1 << $nbits) {
+			$nbits++;
+		}
+		if($nbits > 8 || $len !== 1 << $nbits) {
+			throw new HException("BaseCode : base length must be a power of two.");
+		}
+		$this->base = $base;
+		$this->nbits = $nbits;
+	}}
+	public function decodeString($s) {
+		return $this->decodeBytes(haxe_io_Bytes::ofString($s))->toString();
+	}
+	public function encodeString($s) {
+		return $this->encodeBytes(haxe_io_Bytes::ofString($s))->toString();
+	}
+	public function decodeBytes($b) {
+		$nbits = $this->nbits;
+		$base = $this->base;
+		if($this->tbl === null) {
+			$this->initTable();
+		}
+		$tbl = $this->tbl;
+		$size = $b->length * $nbits >> 3;
+		$out = haxe_io_Bytes::alloc($size);
+		$buf = 0;
+		$curbits = 0;
+		$pin = 0;
+		$pout = 0;
+		while($pout < $size) {
+			while($curbits < 8) {
+				$curbits += $nbits;
+				$buf <<= $nbits;
+				$i = $tbl[ord($b->b[$pin++])];
+				if($i === -1) {
+					throw new HException("BaseCode : invalid encoded char");
+				}
+				$buf |= $i;
+				unset($i);
+			}
+			$curbits -= 8;
+			$out->b[$pout++] = chr($buf >> $curbits & 255);
+		}
+		return $out;
+	}
+	public function initTable() {
+		$tbl = new _hx_array(array());
+		{
+			$_g = 0;
+			while($_g < 256) {
+				$i = $_g++;
+				$tbl[$i] = -1;
+				unset($i);
+			}
+		}
+		{
+			$_g1 = 0; $_g = $this->base->length;
+			while($_g1 < $_g) {
+				$i = $_g1++;
+				$tbl[ord($this->base->b[$i])] = $i;
+				unset($i);
+			}
+		}
+		$this->tbl = $tbl;
+	}
+	public function encodeBytes($b) {
+		$nbits = $this->nbits;
+		$base = $this->base;
+		$size = intval($b->length * 8 / $nbits);
+		$out = haxe_io_Bytes::alloc($size + (((_hx_mod($b->length * 8, $nbits) === 0) ? 0 : 1)));
+		$buf = 0;
+		$curbits = 0;
+		$mask = (1 << $nbits) - 1;
+		$pin = 0;
+		$pout = 0;
+		while($pout < $size) {
+			while($curbits < $nbits) {
+				$curbits += 8;
+				$buf <<= 8;
+				$buf |= ord($b->b[$pin++]);
+			}
+			$curbits -= $nbits;
+			$out->b[$pout++] = chr(ord($base->b[$buf >> $curbits & $mask]));
+		}
+		if($curbits > 0) {
+			$out->b[$pout++] = chr(ord($base->b[$buf << $nbits - $curbits & $mask]));
+		}
+		return $out;
+	}
+	public $tbl;
+	public $nbits;
+	public $base;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function encode($s, $base) {
+		$b = new haxe_BaseCode(haxe_io_Bytes::ofString($base));
+		return $b->encodeString($s);
+	}
+	static function decode($s, $base) {
+		$b = new haxe_BaseCode(haxe_io_Bytes::ofString($base));
+		return $b->decodeString($s);
+	}
+	function __toString() { return 'haxe.BaseCode'; }
+}
diff --git a/filter/wiris/integration/lib/haxe/Http.class.php b/filter/wiris/integration/lib/haxe/Http.class.php
new file mode 100644
index 0000000..1883b83
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/Http.class.php
@@ -0,0 +1,544 @@
+<?php
+
+class haxe_Http {
+	public function __construct($url) {
+		if(!isset($this->onStatus)) $this->onStatus = array(new _hx_lambda(array(&$this, &$url), "haxe_Http_0"), 'execute');
+		if(!isset($this->onError)) $this->onError = array(new _hx_lambda(array(&$this, &$url), "haxe_Http_1"), 'execute');
+		if(!isset($this->onData)) $this->onData = array(new _hx_lambda(array(&$this, &$url), "haxe_Http_2"), 'execute');
+		if(!php_Boot::$skip_constructor) {
+		$this->url = $url;
+		$this->headers = new Hash();
+		$this->params = new Hash();
+		$this->cnxTimeout = 10;
+		$this->noShutdown = !function_exists("stream_socket_shutdown");
+	}}
+	public function onStatus($status) { return call_user_func_array($this->onStatus, array($status)); }
+	public $onStatus = null;
+	public function onError($msg) { return call_user_func_array($this->onError, array($msg)); }
+	public $onError = null;
+	public function onData($data) { return call_user_func_array($this->onData, array($data)); }
+	public $onData = null;
+	public function readChunk($chunk_re, $api, $buf, $len) {
+		if($this->chunk_size === null) {
+			if($this->chunk_buf !== null) {
+				$b = new haxe_io_BytesBuffer();
+				$b->b .= $this->chunk_buf->b;
+				{
+					if($len < 0 || $len > $buf->length) {
+						throw new HException(haxe_io_Error::$OutsideBounds);
+					}
+					$b->b .= substr($buf->b, 0, $len);
+				}
+				$buf = $b->getBytes();
+				$len += $this->chunk_buf->length;
+				$this->chunk_buf = null;
+			}
+			if($chunk_re->match($buf->toString())) {
+				$p = $chunk_re->matchedPos();
+				if($p->len <= $len) {
+					$cstr = $chunk_re->matched(1);
+					$this->chunk_size = Std::parseInt("0x" . $cstr);
+					if($cstr === "0") {
+						$this->chunk_size = null;
+						$this->chunk_buf = null;
+						return false;
+					}
+					$len -= $p->len;
+					return $this->readChunk($chunk_re, $api, $buf->sub($p->len, $len), $len);
+				}
+			}
+			if($len > 10) {
+				$this->onError("Invalid chunk");
+				return false;
+			}
+			$this->chunk_buf = $buf->sub(0, $len);
+			return true;
+		}
+		if($this->chunk_size > $len) {
+			$this->chunk_size -= $len;
+			$api->writeBytes($buf, 0, $len);
+			return true;
+		}
+		$end = $this->chunk_size + 2;
+		if($len >= $end) {
+			if($this->chunk_size > 0) {
+				$api->writeBytes($buf, 0, $this->chunk_size);
+			}
+			$len -= $end;
+			$this->chunk_size = null;
+			if($len === 0) {
+				return true;
+			}
+			return $this->readChunk($chunk_re, $api, $buf->sub($end, $len), $len);
+		}
+		if($this->chunk_size > 0) {
+			$api->writeBytes($buf, 0, $this->chunk_size);
+		}
+		$this->chunk_size -= $len;
+		return true;
+	}
+	public function readHttpResponse($api, $sock) {
+		$b = new haxe_io_BytesBuffer();
+		$k = 4;
+		$s = haxe_io_Bytes::alloc(4);
+		$sock->setTimeout($this->cnxTimeout);
+		while(true) {
+			$p = $sock->input->readBytes($s, 0, $k);
+			while($p !== $k) {
+				$p += $sock->input->readBytes($s, $p, $k - $p);
+			}
+			{
+				if($k < 0 || $k > $s->length) {
+					throw new HException(haxe_io_Error::$OutsideBounds);
+				}
+				$b->b .= substr($s->b, 0, $k);
+			}
+			switch($k) {
+			case 1:{
+				$c = ord($s->b[0]);
+				if($c === 10) {
+					break 2;
+				}
+				if($c === 13) {
+					$k = 3;
+				} else {
+					$k = 4;
+				}
+			}break;
+			case 2:{
+				$c = ord($s->b[1]);
+				if($c === 10) {
+					if(ord($s->b[0]) === 13) {
+						break 2;
+					}
+					$k = 4;
+				} else {
+					if($c === 13) {
+						$k = 3;
+					} else {
+						$k = 4;
+					}
+				}
+			}break;
+			case 3:{
+				$c = ord($s->b[2]);
+				if($c === 10) {
+					if(ord($s->b[1]) !== 13) {
+						$k = 4;
+					} else {
+						if(ord($s->b[0]) !== 10) {
+							$k = 2;
+						} else {
+							break 2;
+						}
+					}
+				} else {
+					if($c === 13) {
+						if(ord($s->b[1]) !== 10 || ord($s->b[0]) !== 13) {
+							$k = 1;
+						} else {
+							$k = 3;
+						}
+					} else {
+						$k = 4;
+					}
+				}
+			}break;
+			case 4:{
+				$c = ord($s->b[3]);
+				if($c === 10) {
+					if(ord($s->b[2]) !== 13) {
+						continue 2;
+					} else {
+						if(ord($s->b[1]) !== 10 || ord($s->b[0]) !== 13) {
+							$k = 2;
+						} else {
+							break 2;
+						}
+					}
+				} else {
+					if($c === 13) {
+						if(ord($s->b[2]) !== 10 || ord($s->b[1]) !== 13) {
+							$k = 3;
+						} else {
+							$k = 1;
+						}
+					}
+				}
+			}break;
+			}
+			unset($p);
+		}
+		$headers = _hx_explode("\x0D\x0A", $b->getBytes()->toString());
+		$response = $headers->shift();
+		$rp = _hx_explode(" ", $response);
+		$status = Std::parseInt($rp[1]);
+		if($status === 0 || $status === null) {
+			throw new HException("Response status error");
+		}
+		$headers->pop();
+		$headers->pop();
+		$this->responseHeaders = new Hash();
+		$size = null;
+		$chunked = false;
+		{
+			$_g = 0;
+			while($_g < $headers->length) {
+				$hline = $headers[$_g];
+				++$_g;
+				$a = _hx_explode(": ", $hline);
+				$hname = $a->shift();
+				$hval = haxe_Http_3($this, $_g, $a, $api, $b, $chunked, $headers, $hline, $hname, $k, $response, $rp, $s, $size, $sock, $status);
+				$this->responseHeaders->set($hname, $hval);
+				switch(strtolower($hname)) {
+				case "content-length":{
+					$size = Std::parseInt($hval);
+				}break;
+				case "transfer-encoding":{
+					$chunked = strtolower($hval) === "chunked";
+				}break;
+				}
+				unset($hval,$hname,$hline,$a);
+			}
+		}
+		$this->onStatus($status);
+		$chunk_re = new EReg("^([0-9A-Fa-f]+)[ ]*\x0D\x0A", "m");
+		$this->chunk_size = null;
+		$this->chunk_buf = null;
+		$bufsize = 1024;
+		$buf = haxe_io_Bytes::alloc($bufsize);
+		if($size === null) {
+			if(!$this->noShutdown) {
+				$sock->shutdown(false, true);
+			}
+			try {
+				while(true) {
+					$len = $sock->input->readBytes($buf, 0, $bufsize);
+					if($chunked) {
+						if(!$this->readChunk($chunk_re, $api, $buf, $len)) {
+							break;
+						}
+					} else {
+						$api->writeBytes($buf, 0, $len);
+					}
+					unset($len);
+				}
+			}catch(Exception $e) {
+				$_ex_ = ($e instanceof HException) ? $e->e : $e;
+				if(($e = $_ex_) instanceof haxe_io_Eof){
+				} else throw $e;;
+			}
+		} else {
+			$api->prepare($size);
+			try {
+				while($size > 0) {
+					$len = $sock->input->readBytes($buf, 0, (($size > $bufsize) ? $bufsize : $size));
+					if($chunked) {
+						if(!$this->readChunk($chunk_re, $api, $buf, $len)) {
+							break;
+						}
+					} else {
+						$api->writeBytes($buf, 0, $len);
+					}
+					$size -= $len;
+					unset($len);
+				}
+			}catch(Exception $e) {
+				$_ex_ = ($e instanceof HException) ? $e->e : $e;
+				if(($e = $_ex_) instanceof haxe_io_Eof){
+					throw new HException("Transfert aborted");
+				} else throw $e;;
+			}
+		}
+		if($chunked && ($this->chunk_size !== null || $this->chunk_buf !== null)) {
+			throw new HException("Invalid chunk");
+		}
+		if($status < 200 || $status >= 400) {
+			throw new HException("Http Error #" . _hx_string_rec($status, ""));
+		}
+		$api->close();
+	}
+	public function customRequest($post, $api, $sock = null, $method = null) {
+		$url_regexp = new EReg("^(https?://)?([a-zA-Z\\.0-9-]+)(:[0-9]+)?(.*)\$", "");
+		if(!$url_regexp->match($this->url)) {
+			$this->onError("Invalid URL");
+			return;
+		}
+		$secure = $url_regexp->matched(1) === "https://";
+		if($sock === null) {
+			if($secure) {
+				$sock = new php_net_SslSocket();
+			} else {
+				$sock = new sys_net_Socket();
+			}
+		}
+		$host = $url_regexp->matched(2);
+		$portString = $url_regexp->matched(3);
+		$request = $url_regexp->matched(4);
+		if($request === "") {
+			$request = "/";
+		}
+		$port = (($portString === null || $portString === "") ? (($secure) ? 443 : 80) : Std::parseInt(_hx_substr($portString, 1, strlen($portString) - 1)));
+		$data = null;
+		$multipart = _hx_field($this, "file") !== null;
+		$boundary = null;
+		$uri = null;
+		if($multipart) {
+			$post = true;
+			$boundary = Std::string(Std::random(1000)) . Std::string(Std::random(1000)) . Std::string(Std::random(1000)) . Std::string(Std::random(1000));
+			while(strlen($boundary) < 38) {
+				$boundary = "-" . $boundary;
+			}
+			$b = new StringBuf();
+			if(null == $this->params) throw new HException('null iterable');
+			$it = $this->params->keys();
+			while($it->hasNext()) {
+				$p = $it->next();
+				$b->add("--");
+				$b->add($boundary);
+				$b->add("\x0D\x0A");
+				$b->add("Content-Disposition: form-data; name=\"");
+				$b->add($p);
+				$b->add("\"");
+				$b->add("\x0D\x0A");
+				$b->add("\x0D\x0A");
+				$b->add($this->params->get($p));
+				$b->add("\x0D\x0A");
+			}
+			$b->add("--");
+			$b->add($boundary);
+			$b->add("\x0D\x0A");
+			$b->add("Content-Disposition: form-data; name=\"");
+			$b->add($this->file->param);
+			$b->add("\"; filename=\"");
+			$b->add($this->file->filename);
+			$b->add("\"");
+			$b->add("\x0D\x0A");
+			$b->add("Content-Type: " . "application/octet-stream" . "\x0D\x0A" . "\x0D\x0A");
+			$uri = $b->b;
+		} else {
+			if(null == $this->params) throw new HException('null iterable');
+			$it = $this->params->keys();
+			while($it->hasNext()) {
+				$p = $it->next();
+				if($uri === null) {
+					$uri = "";
+				} else {
+					$uri .= "&";
+				}
+				$uri .= rawurlencode($p) . "=" . rawurlencode($this->params->get($p));
+			}
+		}
+		$b = new StringBuf();
+		if($method !== null) {
+			$b->add($method);
+			$b->add(" ");
+		} else {
+			if($post) {
+				$b->add("POST ");
+			} else {
+				$b->add("GET ");
+			}
+		}
+		if(_hx_field(_hx_qtype("haxe.Http"), "PROXY") !== null) {
+			$b->add("http://");
+			$b->add($host);
+			if($port !== 80) {
+				$b->add(":");
+				$b->add($port);
+			}
+		}
+		$b->add($request);
+		if(!$post && $uri !== null) {
+			if(_hx_index_of($request, "?", 0) >= 0) {
+				$b->add("&");
+			} else {
+				$b->add("?");
+			}
+			$b->add($uri);
+		}
+		$b->add(" HTTP/1.1\x0D\x0AHost: " . $host . "\x0D\x0A");
+		if($this->postData !== null) {
+			$b->add("Content-Length: " . _hx_string_rec(strlen($this->postData), "") . "\x0D\x0A");
+		} else {
+			if($post && $uri !== null) {
+				if($multipart || $this->headers->get("Content-Type") === null) {
+					$b->add("Content-Type: ");
+					if($multipart) {
+						$b->add("multipart/form-data");
+						$b->add("; boundary=");
+						$b->add($boundary);
+					} else {
+						$b->add("application/x-www-form-urlencoded");
+					}
+					$b->add("\x0D\x0A");
+				}
+				if($multipart) {
+					$b->add("Content-Length: " . _hx_string_rec((strlen($uri) + $this->file->size + strlen($boundary) + 6), "") . "\x0D\x0A");
+				} else {
+					$b->add("Content-Length: " . _hx_string_rec(strlen($uri), "") . "\x0D\x0A");
+				}
+			}
+		}
+		if(null == $this->headers) throw new HException('null iterable');
+		$it = $this->headers->keys();
+		while($it->hasNext()) {
+			$h = $it->next();
+			$b->add($h);
+			$b->add(": ");
+			$b->add($this->headers->get($h));
+			$b->add("\x0D\x0A");
+		}
+		$b->add("\x0D\x0A");
+		if($this->postData !== null) {
+			$b->add($this->postData);
+		} else {
+			if($post && $uri !== null) {
+				$b->add($uri);
+			}
+		}
+		try {
+			if(_hx_field(_hx_qtype("haxe.Http"), "PROXY") !== null) {
+				$sock->connect(new sys_net_Host(haxe_Http::$PROXY->host), haxe_Http::$PROXY->port);
+			} else {
+				$sock->connect(new sys_net_Host($host), $port);
+			}
+			$sock->write($b->b);
+			if($multipart) {
+				$bufsize = 4096;
+				$buf = haxe_io_Bytes::alloc($bufsize);
+				while($this->file->size > 0) {
+					$size = haxe_Http_4($this, $api, $b, $boundary, $buf, $bufsize, $data, $host, $method, $multipart, $port, $portString, $post, $request, $secure, $sock, $uri, $url_regexp);
+					$len = 0;
+					try {
+						$len = $this->file->io->readBytes($buf, 0, $size);
+					}catch(Exception $e) {
+						$_ex_ = ($e instanceof HException) ? $e->e : $e;
+						if(($e = $_ex_) instanceof haxe_io_Eof){
+							break;
+						} else throw $e;;
+					}
+					$sock->output->writeFullBytes($buf, 0, $len);
+					$this->file->size -= $len;
+					unset($size,$len,$e);
+				}
+				$sock->write("\x0D\x0A");
+				$sock->write("--");
+				$sock->write($boundary);
+				$sock->write("--");
+			}
+			$this->readHttpResponse($api, $sock);
+			$sock->close();
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			$e = $_ex_;
+			{
+				try {
+					$sock->close();
+				}catch(Exception $e) {
+					$_ex_ = ($e instanceof HException) ? $e->e : $e;
+					$e1 = $_ex_;
+					{
+					}
+				}
+				$this->onError(Std::string($e));
+			}
+		}
+	}
+	public function fileTransfert($argname, $filename, $file, $size) {
+		$this->file = _hx_anonymous(array("param" => $argname, "filename" => $filename, "io" => $file, "size" => $size));
+	}
+	public function request($post) {
+		$me = $this;
+		$me1 = $this;
+		$output = new haxe_io_BytesOutput();
+		$old = (isset($this->onError) ? $this->onError: array($this, "onError"));
+		$err = false;
+		$this->onError = array(new _hx_lambda(array(&$err, &$me, &$me1, &$old, &$output, &$post), "haxe_Http_5"), 'execute');
+		$this->customRequest($post, $output, null, null);
+		if(!$err) {
+			$me1->onData($output->getBytes()->toString());
+		}
+	}
+	public function setPostData($data) {
+		$this->postData = $data;
+	}
+	public function setParameter($param, $value) {
+		$this->params->set($param, $value);
+	}
+	public function setHeader($header, $value) {
+		$this->headers->set($header, $value);
+	}
+	public $params;
+	public $headers;
+	public $postData;
+	public $file;
+	public $chunk_buf;
+	public $chunk_size;
+	public $responseHeaders;
+	public $cnxTimeout;
+	public $noShutdown;
+	public $url;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $PROXY = null;
+	static function requestUrl($url) {
+		$h = new haxe_Http($url);
+		$r = null;
+		$h->onData = array(new _hx_lambda(array(&$h, &$r, &$url), "haxe_Http_6"), 'execute');
+		$h->onError = array(new _hx_lambda(array(&$h, &$r, &$url), "haxe_Http_7"), 'execute');
+		$h->request(false);
+		return $r;
+	}
+	function __toString() { return 'haxe.Http'; }
+}
+function haxe_Http_0(&$this, &$url, $status) {
+	{
+	}
+}
+function haxe_Http_1(&$this, &$url, $msg) {
+	{
+	}
+}
+function haxe_Http_2(&$this, &$url, $data) {
+	{
+	}
+}
+function haxe_Http_3(&$this, &$_g, &$a, &$api, &$b, &$chunked, &$headers, &$hline, &$hname, &$k, &$response, &$rp, &$s, &$size, &$sock, &$status) {
+	if($a->length === 1) {
+		return $a[0];
+	} else {
+		return $a->join(": ");
+	}
+}
+function haxe_Http_4(&$this, &$api, &$b, &$boundary, &$buf, &$bufsize, &$data, &$host, &$method, &$multipart, &$port, &$portString, &$post, &$request, &$secure, &$sock, &$uri, &$url_regexp) {
+	if($this->file->size > $bufsize) {
+		return $bufsize;
+	} else {
+		return $this->file->size;
+	}
+}
+function haxe_Http_5(&$err, &$me, &$me1, &$old, &$output, &$post, $e) {
+	{
+		$err = true;
+		call_user_func_array($old, array($e));
+	}
+}
+function haxe_Http_6(&$h, &$r, &$url, $d) {
+	{
+		$r = $d;
+	}
+}
+function haxe_Http_7(&$h, &$r, &$url, $e) {
+	{
+		throw new HException($e);
+	}
+}
diff --git a/filter/wiris/integration/lib/haxe/Int32.class.php b/filter/wiris/integration/lib/haxe/Int32.class.php
new file mode 100644
index 0000000..6f8c1e3
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/Int32.class.php
@@ -0,0 +1,92 @@
+<?php
+
+class haxe_Int32 {
+	public function __construct(){}
+	static function make($a, $b) {
+		return $a << 16 | $b;
+	}
+	static function ofInt($x) {
+		return $x | 0;
+	}
+	static function clamp($x) {
+		return $x | 0;
+	}
+	static function toInt($x) {
+		if(($x >> 30 & 1) !== _hx_shift_right($x, 31)) {
+			throw new HException("Overflow " . Std::string($x));
+		}
+		return $x & -1;
+	}
+	static function toNativeInt($x) {
+		return $x;
+	}
+	static function add($a, $b) {
+		return $a + $b | 0;
+	}
+	static function sub($a, $b) {
+		return $a - $b | 0;
+	}
+	static function mul($a, $b) {
+		return $a * ($b & 65535) + ($a * (_hx_shift_right($b, 16)) << 16 | 0) | 0;
+	}
+	static function div($a, $b) {
+		return intval($a / $b);
+	}
+	static function mod($a, $b) {
+		return _hx_mod($a, $b);
+	}
+	static function shl($a, $b) {
+		return $a << $b;
+	}
+	static function shr($a, $b) {
+		return $a >> $b;
+	}
+	static function ushr($a, $b) {
+		return _hx_shift_right($a, $b);
+	}
+	static function hand($a, $b) {
+		return $a & $b;
+	}
+	static function hor($a, $b) {
+		return $a | $b;
+	}
+	static function hxor($a, $b) {
+		return $a ^ $b;
+	}
+	static function neg($a) {
+		return -$a;
+	}
+	static function isNeg($a) {
+		return $a < 0;
+	}
+	static function isZero($a) {
+		return $a === 0;
+	}
+	static function complement($a) {
+		return ~$a;
+	}
+	static function compare($a, $b) {
+		return $a - $b;
+	}
+	static function ucompare($a, $b) {
+		if($a < 0) {
+			return haxe_Int32_0($a, $b);
+		}
+		return haxe_Int32_1($a, $b);
+	}
+	function __toString() { return 'haxe.Int32'; }
+}
+function haxe_Int32_0(&$a, &$b) {
+	if($b < 0) {
+		return ~$b - ~$a;
+	} else {
+		return 1;
+	}
+}
+function haxe_Int32_1(&$a, &$b) {
+	if($b < 0) {
+		return -1;
+	} else {
+		return $a - $b;
+	}
+}
diff --git a/filter/wiris/integration/lib/haxe/Int64.class.php b/filter/wiris/integration/lib/haxe/Int64.class.php
new file mode 100644
index 0000000..aae0e91
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/Int64.class.php
@@ -0,0 +1,347 @@
+<?php
+
+class haxe_Int64 {
+	public function __construct($high, $low) {
+		if(!php_Boot::$skip_constructor) {
+		$this->high = $high;
+		$this->low = $low;
+	}}
+	public function toString() {
+		if($this->high === 0 && $this->low === 0) {
+			return "0";
+		}
+		$str = "";
+		$neg = false;
+		$i = $this;
+		if($i->high < 0) {
+			$neg = true;
+			$i = haxe_Int64_0($this, $i, $neg, $str);
+		}
+		$ten = new haxe_Int64(0 | 0, 10 | 0);
+		while(!(($i->high | $i->low) === 0)) {
+			$r = haxe_Int64::divMod($i, $ten);
+			$str = _hx_string_rec(haxe_Int64_1($this, $i, $neg, $r, $str, $ten), "") . $str;
+			$i = $r->quotient;
+			unset($r);
+		}
+		if($neg) {
+			$str = "-" . $str;
+		}
+		return $str;
+	}
+	public $low;
+	public $high;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function make($high, $low) {
+		return new haxe_Int64($high, $low);
+	}
+	static function ofInt($x) {
+		return new haxe_Int64($x >> 31 | 0, $x | 0);
+	}
+	static function ofInt32($x) {
+		return new haxe_Int64($x >> 31, $x);
+	}
+	static function toInt($x) {
+		if(haxe_Int64_2($x) !== 0) {
+			if($x->high < 0) {
+				return -haxe_Int64::toInt(haxe_Int64_3($x));
+			}
+			throw new HException("Overflow");
+		}
+		return haxe_Int64_4($x);
+	}
+	static function getLow($x) {
+		return $x->low;
+	}
+	static function getHigh($x) {
+		return $x->high;
+	}
+	static function add($a, $b) {
+		$high = $a->high + $b->high | 0;
+		$low = $a->low + $b->low | 0;
+		if(haxe_Int32::ucompare($low, $a->low) < 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	}
+	static function sub($a, $b) {
+		$high = $a->high - $b->high | 0;
+		$low = $a->low - $b->low | 0;
+		if(haxe_Int32::ucompare($a->low, $b->low) < 0) {
+			$high = $high - (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	}
+	static function mul($a, $b) {
+		$mask = 65535 | 0;
+		$al = $a->low & $mask; $ah = _hx_shift_right($a->low, 16);
+		$bl = $b->low & $mask; $bh = _hx_shift_right($b->low, 16);
+		$p00 = $al * ($bl & 65535) + ($al * (_hx_shift_right($bl, 16)) << 16 | 0) | 0;
+		$p10 = $ah * ($bl & 65535) + ($ah * (_hx_shift_right($bl, 16)) << 16 | 0) | 0;
+		$p01 = $al * ($bh & 65535) + ($al * (_hx_shift_right($bh, 16)) << 16 | 0) | 0;
+		$p11 = $ah * ($bh & 65535) + ($ah * (_hx_shift_right($bh, 16)) << 16 | 0) | 0;
+		$low = $p00;
+		$high = ($p11 + (_hx_shift_right($p01, 16)) | 0) + (_hx_shift_right($p10, 16)) | 0;
+		$p01 = $p01 << 16;
+		$low = $low + $p01 | 0;
+		if(haxe_Int32::ucompare($low, $p01) < 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		$p10 = $p10 << 16;
+		$low = $low + $p10 | 0;
+		if(haxe_Int32::ucompare($low, $p10) < 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		$high = $high + haxe_Int64_5($a, $ah, $al, $b, $bh, $bl, $high, $low, $mask, $p00, $p01, $p10, $p11) | 0;
+		$high = $high + haxe_Int64_6($a, $ah, $al, $b, $bh, $bl, $high, $low, $mask, $p00, $p01, $p10, $p11) | 0;
+		return new haxe_Int64($high, $low);
+	}
+	static function divMod($modulus, $divisor) {
+		$quotient = new haxe_Int64(0 | 0, 0 | 0);
+		$mask = new haxe_Int64(0 | 0, 1 | 0);
+		$divisor = new haxe_Int64($divisor->high, $divisor->low);
+		while(!($divisor->high < 0)) {
+			$cmp = haxe_Int64_7($divisor, $mask, $modulus, $quotient);
+			$divisor->high = $divisor->high << 1 | _hx_shift_right($divisor->low, 31);
+			$divisor->low = $divisor->low << 1;
+			$mask->high = $mask->high << 1 | _hx_shift_right($mask->low, 31);
+			$mask->low = $mask->low << 1;
+			if($cmp >= 0) {
+				break;
+			}
+			unset($cmp);
+		}
+		while(!(($mask->low | $mask->high) === 0)) {
+			if(haxe_Int64_8($divisor, $mask, $modulus, $quotient) >= 0) {
+				$quotient->high = $quotient->high | $mask->high;
+				$quotient->low = $quotient->low | $mask->low;
+				$modulus = haxe_Int64::sub($modulus, $divisor);
+			}
+			$mask->low = _hx_shift_right($mask->low, 1) | $mask->high << 31;
+			$mask->high = _hx_shift_right($mask->high, 1);
+			$divisor->low = _hx_shift_right($divisor->low, 1) | $divisor->high << 31;
+			$divisor->high = _hx_shift_right($divisor->high, 1);
+		}
+		return _hx_anonymous(array("quotient" => $quotient, "modulus" => $modulus));
+	}
+	static function div($a, $b) {
+		$sign = ($a->high | $b->high) < 0;
+		if($a->high < 0) {
+			$a = haxe_Int64_9($a, $b, $sign);
+		}
+		if($b->high < 0) {
+			$b = haxe_Int64_10($a, $b, $sign);
+		}
+		$q = haxe_Int64::divMod($a, $b)->quotient;
+		return haxe_Int64_11($a, $b, $q, $sign);
+	}
+	static function mod($a, $b) {
+		$sign = ($a->high | $b->high) < 0;
+		if($a->high < 0) {
+			$a = haxe_Int64_12($a, $b, $sign);
+		}
+		if($b->high < 0) {
+			$b = haxe_Int64_13($a, $b, $sign);
+		}
+		$m = haxe_Int64::divMod($a, $b)->modulus;
+		return haxe_Int64_14($a, $b, $m, $sign);
+	}
+	static function shl($a, $b) {
+		return ((($b & 63) === 0) ? $a : ((($b & 63) < 32) ? new haxe_Int64($a->high << $b | _hx_shift_right($a->low, 32 - ($b & 63)), $a->low << $b) : new haxe_Int64($a->low << $b - 32, 0 | 0)));
+	}
+	static function shr($a, $b) {
+		return ((($b & 63) === 0) ? $a : ((($b & 63) < 32) ? new haxe_Int64($a->high >> $b, _hx_shift_right($a->low, $b) | $a->high << 32 - ($b & 63)) : new haxe_Int64($a->high >> 31, $a->high >> $b - 32)));
+	}
+	static function ushr($a, $b) {
+		return ((($b & 63) === 0) ? $a : ((($b & 63) < 32) ? new haxe_Int64(_hx_shift_right($a->high, $b), _hx_shift_right($a->low, $b) | $a->high << 32 - ($b & 63)) : new haxe_Int64(0 | 0, _hx_shift_right($a->high, $b - 32))));
+	}
+	static function hand($a, $b) {
+		return new haxe_Int64($a->high & $b->high, $a->low & $b->low);
+	}
+	static function hor($a, $b) {
+		return new haxe_Int64($a->high | $b->high, $a->low | $b->low);
+	}
+	static function hxor($a, $b) {
+		return new haxe_Int64($a->high ^ $b->high, $a->low ^ $b->low);
+	}
+	static function neg($a) {
+		$high = ~$a->high;
+		$low = -$a->low;
+		if($low === 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	}
+	static function isNeg($a) {
+		return $a->high < 0;
+	}
+	static function isZero($a) {
+		return ($a->high | $a->low) === 0;
+	}
+	static function compare($a, $b) {
+		$v = $a->high - $b->high;
+		return (($v !== 0) ? $v : haxe_Int32::ucompare($a->low, $b->low));
+	}
+	static function ucompare($a, $b) {
+		$v = haxe_Int32::ucompare($a->high, $b->high);
+		return (($v !== 0) ? $v : haxe_Int32::ucompare($a->low, $b->low));
+	}
+	static function toStr($a) {
+		return $a->toString();
+	}
+	function __toString() { return $this->toString(); }
+}
+function haxe_Int64_0(&$this, &$i, &$neg, &$str) {
+	{
+		$high = ~$i->high;
+		$low = -$i->low;
+		if($low === 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	}
+}
+function haxe_Int64_1(&$this, &$i, &$neg, &$r, &$str, &$ten) {
+	{
+		$x = $r->modulus->low;
+		if(($x >> 30 & 1) !== _hx_shift_right($x, 31)) {
+			throw new HException("Overflow " . Std::string($x));
+		}
+		return $x & -1;
+	}
+}
+function haxe_Int64_2(&$x) {
+	{
+		$x1 = $x->high;
+		if(($x1 >> 30 & 1) !== _hx_shift_right($x1, 31)) {
+			throw new HException("Overflow " . Std::string($x1));
+		}
+		return $x1 & -1;
+	}
+}
+function haxe_Int64_3(&$x) {
+	{
+		$high = ~$x->high;
+		$low = -$x->low;
+		if($low === 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	}
+}
+function haxe_Int64_4(&$x) {
+	{
+		$x1 = $x->low;
+		if(($x1 >> 30 & 1) !== _hx_shift_right($x1, 31)) {
+			throw new HException("Overflow " . Std::string($x1));
+		}
+		return $x1 & -1;
+	}
+}
+function haxe_Int64_5(&$a, &$ah, &$al, &$b, &$bh, &$bl, &$high, &$low, &$mask, &$p00, &$p01, &$p10, &$p11) {
+	{
+		$a1 = $a->low; $b1 = $b->high;
+		return $a1 * ($b1 & 65535) + ($a1 * (_hx_shift_right($b1, 16)) << 16 | 0) | 0;
+	}
+}
+function haxe_Int64_6(&$a, &$ah, &$al, &$b, &$bh, &$bl, &$high, &$low, &$mask, &$p00, &$p01, &$p10, &$p11) {
+	{
+		$a1 = $a->high; $b1 = $b->low;
+		return $a1 * ($b1 & 65535) + ($a1 * (_hx_shift_right($b1, 16)) << 16 | 0) | 0;
+	}
+}
+function haxe_Int64_7(&$divisor, &$mask, &$modulus, &$quotient) {
+	{
+		$v = haxe_Int32::ucompare($divisor->high, $modulus->high);
+		if($v !== 0) {
+			return $v;
+		} else {
+			return haxe_Int32::ucompare($divisor->low, $modulus->low);
+		}
+		unset($v);
+	}
+}
+function haxe_Int64_8(&$divisor, &$mask, &$modulus, &$quotient) {
+	{
+		$v = haxe_Int32::ucompare($modulus->high, $divisor->high);
+		if($v !== 0) {
+			return $v;
+		} else {
+			return haxe_Int32::ucompare($modulus->low, $divisor->low);
+		}
+		unset($v);
+	}
+}
+function haxe_Int64_9(&$a, &$b, &$sign) {
+	{
+		$high = ~$a->high;
+		$low = -$a->low;
+		if($low === 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	}
+}
+function haxe_Int64_10(&$a, &$b, &$sign) {
+	{
+		$high = ~$b->high;
+		$low = -$b->low;
+		if($low === 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	}
+}
+function haxe_Int64_11(&$a, &$b, &$q, &$sign) {
+	if($sign) {
+		$high = ~$q->high;
+		$low = -$q->low;
+		if($low === 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	} else {
+		return $q;
+	}
+}
+function haxe_Int64_12(&$a, &$b, &$sign) {
+	{
+		$high = ~$a->high;
+		$low = -$a->low;
+		if($low === 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	}
+}
+function haxe_Int64_13(&$a, &$b, &$sign) {
+	{
+		$high = ~$b->high;
+		$low = -$b->low;
+		if($low === 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	}
+}
+function haxe_Int64_14(&$a, &$b, &$m, &$sign) {
+	if($sign) {
+		$high = ~$m->high;
+		$low = -$m->low;
+		if($low === 0) {
+			$high = $high + (1 | 0) | 0;
+		}
+		return new haxe_Int64($high, $low);
+	} else {
+		return $m;
+	}
+}
diff --git a/filter/wiris/integration/lib/haxe/Log.class.php b/filter/wiris/integration/lib/haxe/Log.class.php
new file mode 100644
index 0000000..806d4a0
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/Log.class.php
@@ -0,0 +1,21 @@
+<?php
+
+class haxe_Log {
+	public function __construct(){}
+	static function trace($v, $infos = null) { return call_user_func_array(self::$trace, array($v, $infos)); }
+	public static $trace = null;
+	static function clear() { return call_user_func(self::$clear); }
+	public static $clear = null;
+	function __toString() { return 'haxe.Log'; }
+}
+haxe_Log::$trace = array(new _hx_lambda(array(), "haxe_Log_0"), 'execute');
+haxe_Log::$clear = array(new _hx_lambda(array(), "haxe_Log_1"), 'execute');
+function haxe_Log_0($v, $infos) {
+	{
+		_hx_trace($v, $infos);
+	}
+}
+function haxe_Log_1() {
+	{
+	}
+}
diff --git a/filter/wiris/integration/lib/haxe/Md5.class.php b/filter/wiris/integration/lib/haxe/Md5.class.php
new file mode 100644
index 0000000..3a56dc9
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/Md5.class.php
@@ -0,0 +1,9 @@
+<?php
+
+class haxe_Md5 {
+	public function __construct(){}
+	static function encode($s) {
+		return md5($s);
+	}
+	function __toString() { return 'haxe.Md5'; }
+}
diff --git a/filter/wiris/integration/lib/haxe/Utf8.class.php b/filter/wiris/integration/lib/haxe/Utf8.class.php
new file mode 100644
index 0000000..8c9abe6
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/Utf8.class.php
@@ -0,0 +1,66 @@
+<?php
+
+class haxe_Utf8 {
+	public function __construct($size = null) {
+		if(!php_Boot::$skip_constructor) {
+		$this->__b = "";
+	}}
+	public function toString() {
+		return $this->__b;
+	}
+	public function addChar($c) {
+		$this->__b .= haxe_Utf8::uchr($c);
+	}
+	public $__b;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function encode($s) {
+		return utf8_encode($s);
+	}
+	static function decode($s) {
+		return utf8_decode($s);
+	}
+	static function iter($s, $chars) {
+		$len = haxe_Utf8::length($s);
+		{
+			$_g = 0;
+			while($_g < $len) {
+				$i = $_g++;
+				call_user_func_array($chars, array(haxe_Utf8::charCodeAt($s, $i)));
+				unset($i);
+			}
+		}
+	}
+	static function charCodeAt($s, $index) {
+		return haxe_Utf8::uord(haxe_Utf8::sub($s, $index, 1));
+	}
+	static function uchr($i) {
+		return mb_convert_encoding(pack('N',$i), 'UTF-8', 'UCS-4BE');
+	}
+	static function uord($s) {
+		$c = unpack('N', mb_convert_encoding($s, 'UCS-4BE', 'UTF-8'));
+		return $c[1];
+	}
+	static function validate($s) {
+		return mb_check_encoding($s, "UTF-8");
+	}
+	static function length($s) {
+		return mb_strlen($s, "UTF-8");
+	}
+	static function compare($a, $b) {
+		return strcmp($a, $b);
+	}
+	static function sub($s, $pos, $len) {
+		return mb_substr($s, $pos, $len, "UTF-8");
+	}
+	static $enc = "UTF-8";
+	function __toString() { return $this->toString(); }
+}
diff --git a/filter/wiris/integration/lib/haxe/io/Bytes.class.php b/filter/wiris/integration/lib/haxe/io/Bytes.class.php
new file mode 100644
index 0000000..8c3cd49
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/io/Bytes.class.php
@@ -0,0 +1,88 @@
+<?php
+
+class haxe_io_Bytes {
+	public function __construct($length, $b) {
+		if(!php_Boot::$skip_constructor) {
+		$this->length = $length;
+		$this->b = $b;
+	}}
+	public function getData() {
+		return $this->b;
+	}
+	public function toHex() {
+		$s = new StringBuf();
+		$chars = new _hx_array(array());
+		$str = "0123456789abcdef";
+		{
+			$_g1 = 0; $_g = strlen($str);
+			while($_g1 < $_g) {
+				$i = $_g1++;
+				$chars->push(_hx_char_code_at($str, $i));
+				unset($i);
+			}
+		}
+		{
+			$_g1 = 0; $_g = $this->length;
+			while($_g1 < $_g) {
+				$i = $_g1++;
+				$c = ord($this->b[$i]);
+				$s->b .= chr($chars[$c >> 4]);
+				$s->b .= chr($chars[$c & 15]);
+				unset($i,$c);
+			}
+		}
+		return $s->b;
+	}
+	public function toString() {
+		return $this->b;
+	}
+	public function readString($pos, $len) {
+		if($pos < 0 || $len < 0 || $pos + $len > $this->length) {
+			throw new HException(haxe_io_Error::$OutsideBounds);
+		}
+		return substr($this->b, $pos, $len);
+	}
+	public function compare($other) {
+		return $this->b < $other->b ? -1 : ($this->b == $other->b ? 0 : 1);
+	}
+	public function sub($pos, $len) {
+		if($pos < 0 || $len < 0 || $pos + $len > $this->length) {
+			throw new HException(haxe_io_Error::$OutsideBounds);
+		}
+		return new haxe_io_Bytes($len, substr($this->b, $pos, $len));
+	}
+	public function blit($pos, $src, $srcpos, $len) {
+		if($pos < 0 || $srcpos < 0 || $len < 0 || $pos + $len > $this->length || $srcpos + $len > $src->length) {
+			throw new HException(haxe_io_Error::$OutsideBounds);
+		}
+		$this->b = substr($this->b, 0, $pos) . substr($src->b, $srcpos, $len) . substr($this->b, $pos+$len);
+	}
+	public function set($pos, $v) {
+		$this->b[$pos] = chr($v);
+	}
+	public function get($pos) {
+		return ord($this->b[$pos]);
+	}
+	public $b;
+	public $length;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function alloc($length) {
+		return new haxe_io_Bytes($length, str_repeat(chr(0), $length));
+	}
+	static function ofString($s) {
+		return new haxe_io_Bytes(strlen($s), $s);
+	}
+	static function ofData($b) {
+		return new haxe_io_Bytes(strlen($b), $b);
+	}
+	function __toString() { return $this->toString(); }
+}
diff --git a/filter/wiris/integration/lib/haxe/io/BytesBuffer.class.php b/filter/wiris/integration/lib/haxe/io/BytesBuffer.class.php
new file mode 100644
index 0000000..4ab4cdf
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/io/BytesBuffer.class.php
@@ -0,0 +1,37 @@
+<?php
+
+class haxe_io_BytesBuffer {
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		$this->b = "";
+	}}
+	public function getBytes() {
+		$bytes = new haxe_io_Bytes(strlen($this->b), $this->b);
+		$this->b = null;
+		return $bytes;
+	}
+	public function addBytes($src, $pos, $len) {
+		if($pos < 0 || $len < 0 || $pos + $len > $src->length) {
+			throw new HException(haxe_io_Error::$OutsideBounds);
+		}
+		$this->b .= substr($src->b, $pos, $len);
+	}
+	public function add($src) {
+		$this->b .= $src->b;
+	}
+	public function addByte($byte) {
+		$this->b .= chr($byte);
+	}
+	public $b;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	function __toString() { return 'haxe.io.BytesBuffer'; }
+}
diff --git a/filter/wiris/integration/lib/haxe/io/BytesInput.class.php b/filter/wiris/integration/lib/haxe/io/BytesInput.class.php
new file mode 100644
index 0000000..9af4911
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/io/BytesInput.class.php
@@ -0,0 +1,56 @@
+<?php
+
+class haxe_io_BytesInput extends haxe_io_Input {
+	public function __construct($b, $pos = null, $len = null) {
+		if(!php_Boot::$skip_constructor) {
+		if($pos === null) {
+			$pos = 0;
+		}
+		if($len === null) {
+			$len = $b->length - $pos;
+		}
+		if($pos < 0 || $len < 0 || $pos + $len > $b->length) {
+			throw new HException(haxe_io_Error::$OutsideBounds);
+		}
+		$this->b = $b->b;
+		$this->pos = $pos;
+		$this->len = $len;
+	}}
+	public function readBytes($buf, $pos, $len) {
+		if($pos < 0 || $len < 0 || $pos + $len > $buf->length) {
+			throw new HException(haxe_io_Error::$OutsideBounds);
+		}
+		if($this->len === 0 && $len > 0) {
+			throw new HException(new haxe_io_Eof());
+		}
+		if($this->len < $len) {
+			$len = $this->len;
+		}
+		$buf->b = substr($buf->b, 0, $pos) . substr($this->b, $this->pos, $len) . substr($buf->b, $pos+$len);
+		$this->pos += $len;
+		$this->len -= $len;
+		return $len;
+	}
+	public function readByte() {
+		if($this->len === 0) {
+			throw new HException(new haxe_io_Eof());
+		}
+		$this->len--;
+		return ord($this->b[$this->pos++]);
+	}
+	public $len;
+	public $pos;
+	public $b;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $__properties__ = array("set_bigEndian" => "setEndian");
+	function __toString() { return 'haxe.io.BytesInput'; }
+}
diff --git a/filter/wiris/integration/lib/haxe/io/BytesOutput.class.php b/filter/wiris/integration/lib/haxe/io/BytesOutput.class.php
new file mode 100644
index 0000000..fe41a72
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/io/BytesOutput.class.php
@@ -0,0 +1,36 @@
+<?php
+
+class haxe_io_BytesOutput extends haxe_io_Output {
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		$this->b = new haxe_io_BytesBuffer();
+	}}
+	public function getBytes() {
+		return $this->b->getBytes();
+	}
+	public function writeBytes($buf, $pos, $len) {
+		{
+			if($pos < 0 || $len < 0 || $pos + $len > $buf->length) {
+				throw new HException(haxe_io_Error::$OutsideBounds);
+			}
+			$this->b->b .= substr($buf->b, $pos, $len);
+		}
+		return $len;
+	}
+	public function writeByte($c) {
+		$this->b->b .= chr($c);
+	}
+	public $b;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $__properties__ = array("set_bigEndian" => "setEndian");
+	function __toString() { return 'haxe.io.BytesOutput'; }
+}
diff --git a/filter/wiris/integration/lib/haxe/io/Eof.class.php b/filter/wiris/integration/lib/haxe/io/Eof.class.php
new file mode 100644
index 0000000..f9099ec
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/io/Eof.class.php
@@ -0,0 +1,10 @@
+<?php
+
+class haxe_io_Eof {
+	public function __construct() { 
+	}
+	public function toString() {
+		return "Eof";
+	}
+	function __toString() { return $this->toString(); }
+}
diff --git a/filter/wiris/integration/lib/haxe/io/Error.enum.php b/filter/wiris/integration/lib/haxe/io/Error.enum.php
new file mode 100644
index 0000000..c8b1870
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/io/Error.enum.php
@@ -0,0 +1,12 @@
+<?php
+
+class haxe_io_Error extends Enum {
+	public static $Blocked;
+	public static function Custom($e) { return new haxe_io_Error("Custom", 3, array($e)); }
+	public static $OutsideBounds;
+	public static $Overflow;
+	public static $__constructors = array(0 => 'Blocked', 3 => 'Custom', 2 => 'OutsideBounds', 1 => 'Overflow');
+	}
+haxe_io_Error::$Blocked = new haxe_io_Error("Blocked", 0);
+haxe_io_Error::$OutsideBounds = new haxe_io_Error("OutsideBounds", 2);
+haxe_io_Error::$Overflow = new haxe_io_Error("Overflow", 1);
diff --git a/filter/wiris/integration/lib/haxe/io/Input.class.php b/filter/wiris/integration/lib/haxe/io/Input.class.php
new file mode 100644
index 0000000..c74f0e0
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/io/Input.class.php
@@ -0,0 +1,254 @@
+<?php
+
+class haxe_io_Input {
+	public function __construct(){}
+	public function readString($len) {
+		$b = haxe_io_Bytes::alloc($len);
+		$this->readFullBytes($b, 0, $len);
+		return $b->toString();
+	}
+	public function readInt32() {
+		$ch1 = $this->readByte();
+		$ch2 = $this->readByte();
+		$ch3 = $this->readByte();
+		$ch4 = $this->readByte();
+		$i = haxe_io_Input_0($this, $ch1, $ch2, $ch3, $ch4);
+		if($i > 2147483647) {
+			$i -= 0x100000000;
+		}
+		return $i | 0;
+	}
+	public function readUInt30() {
+		$ch1 = $this->readByte();
+		$ch2 = $this->readByte();
+		$ch3 = $this->readByte();
+		$ch4 = $this->readByte();
+		if(((($this->bigEndian) ? $ch1 : $ch4)) >= 64) {
+			throw new HException(haxe_io_Error::$Overflow);
+		}
+		return haxe_io_Input_1($this, $ch1, $ch2, $ch3, $ch4);
+	}
+	public function readInt31() {
+		$ch1 = null; $ch2 = null; $ch3 = null; $ch4 = null;
+		if($this->bigEndian) {
+			$ch4 = $this->readByte();
+			$ch3 = $this->readByte();
+			$ch2 = $this->readByte();
+			$ch1 = $this->readByte();
+		} else {
+			$ch1 = $this->readByte();
+			$ch2 = $this->readByte();
+			$ch3 = $this->readByte();
+			$ch4 = $this->readByte();
+		}
+		if((($ch4 & 128) === 0) != (($ch4 & 64) === 0)) {
+			throw new HException(haxe_io_Error::$Overflow);
+		}
+		return $ch1 | $ch2 << 8 | $ch3 << 16 | $ch4 << 24;
+	}
+	public function readUInt24() {
+		$ch1 = $this->readByte();
+		$ch2 = $this->readByte();
+		$ch3 = $this->readByte();
+		return haxe_io_Input_2($this, $ch1, $ch2, $ch3);
+	}
+	public function readInt24() {
+		$ch1 = $this->readByte();
+		$ch2 = $this->readByte();
+		$ch3 = $this->readByte();
+		$n = haxe_io_Input_3($this, $ch1, $ch2, $ch3);
+		if(($n & 8388608) !== 0) {
+			return $n - 16777216;
+		}
+		return $n;
+	}
+	public function readUInt16() {
+		$ch1 = $this->readByte();
+		$ch2 = $this->readByte();
+		return haxe_io_Input_4($this, $ch1, $ch2);
+	}
+	public function readInt16() {
+		$ch1 = $this->readByte();
+		$ch2 = $this->readByte();
+		$n = haxe_io_Input_5($this, $ch1, $ch2);
+		if(($n & 32768) !== 0) {
+			return $n - 65536;
+		}
+		return $n;
+	}
+	public function readInt8() {
+		$n = $this->readByte();
+		if($n >= 128) {
+			return $n - 256;
+		}
+		return $n;
+	}
+	public function readDouble() {
+		$a = unpack("d", $this->readString(8));
+		return $a[1];
+	}
+	public function readFloat() {
+		$a = unpack("f", $this->readString(4));
+		return $a[1];
+	}
+	public function readLine() {
+		$buf = new StringBuf();
+		$last = null;
+		$s = null;
+		try {
+			while(($last = $this->readByte()) !== 10) {
+				$buf->b .= chr($last);
+			}
+			$s = $buf->b;
+			if(_hx_char_code_at($s, strlen($s) - 1) === 13) {
+				$s = _hx_substr($s, 0, -1);
+			}
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			if(($e = $_ex_) instanceof haxe_io_Eof){
+				$s = $buf->b;
+				if(strlen($s) === 0) {
+					throw new HException($e);
+				}
+			} else throw $e;;
+		}
+		return $s;
+	}
+	public function readUntil($end) {
+		$buf = new StringBuf();
+		$last = null;
+		while(($last = $this->readByte()) !== $end) {
+			$buf->b .= chr($last);
+		}
+		return $buf->b;
+	}
+	public function read($nbytes) {
+		$s = haxe_io_Bytes::alloc($nbytes);
+		$p = 0;
+		while($nbytes > 0) {
+			$k = $this->readBytes($s, $p, $nbytes);
+			if($k === 0) {
+				throw new HException(haxe_io_Error::$Blocked);
+			}
+			$p += $k;
+			$nbytes -= $k;
+			unset($k);
+		}
+		return $s;
+	}
+	public function readFullBytes($s, $pos, $len) {
+		while($len > 0) {
+			$k = $this->readBytes($s, $pos, $len);
+			$pos += $k;
+			$len -= $k;
+			unset($k);
+		}
+	}
+	public function readAll($bufsize = null) {
+		if($bufsize === null) {
+			$bufsize = 8192;
+		}
+		$buf = haxe_io_Bytes::alloc($bufsize);
+		$total = new haxe_io_BytesBuffer();
+		try {
+			while(true) {
+				$len = $this->readBytes($buf, 0, $bufsize);
+				if($len === 0) {
+					throw new HException(haxe_io_Error::$Blocked);
+				}
+				{
+					if($len < 0 || $len > $buf->length) {
+						throw new HException(haxe_io_Error::$OutsideBounds);
+					}
+					$total->b .= substr($buf->b, 0, $len);
+				}
+				unset($len);
+			}
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			if(($e = $_ex_) instanceof haxe_io_Eof){
+			} else throw $e;;
+		}
+		return $total->getBytes();
+	}
+	public function setEndian($b) {
+		$this->bigEndian = $b;
+		return $b;
+	}
+	public function close() {
+	}
+	public function readBytes($s, $pos, $len) {
+		$k = $len;
+		$b = $s->b;
+		if($pos < 0 || $len < 0 || $pos + $len > $s->length) {
+			throw new HException(haxe_io_Error::$OutsideBounds);
+		}
+		while($k > 0) {
+			$b[$pos] = chr($this->readByte());
+			$pos++;
+			$k--;
+		}
+		return $len;
+	}
+	public function readByte() {
+		haxe_io_Input_6($this);
+	}
+	public $bigEndian;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $__properties__ = array("set_bigEndian" => "setEndian");
+	function __toString() { return 'haxe.io.Input'; }
+}
+function haxe_io_Input_0(&$this, &$ch1, &$ch2, &$ch3, &$ch4) {
+	if($this->bigEndian) {
+		return ($ch1 << 8 | $ch2) << 16 | ($ch3 << 8 | $ch4);
+	} else {
+		return ($ch4 << 8 | $ch3) << 16 | ($ch2 << 8 | $ch1);
+	}
+}
+function haxe_io_Input_1(&$this, &$ch1, &$ch2, &$ch3, &$ch4) {
+	if($this->bigEndian) {
+		return $ch4 | $ch3 << 8 | $ch2 << 16 | $ch1 << 24;
+	} else {
+		return $ch1 | $ch2 << 8 | $ch3 << 16 | $ch4 << 24;
+	}
+}
+function haxe_io_Input_2(&$this, &$ch1, &$ch2, &$ch3) {
+	if($this->bigEndian) {
+		return $ch3 | $ch2 << 8 | $ch1 << 16;
+	} else {
+		return $ch1 | $ch2 << 8 | $ch3 << 16;
+	}
+}
+function haxe_io_Input_3(&$this, &$ch1, &$ch2, &$ch3) {
+	if($this->bigEndian) {
+		return $ch3 | $ch2 << 8 | $ch1 << 16;
+	} else {
+		return $ch1 | $ch2 << 8 | $ch3 << 16;
+	}
+}
+function haxe_io_Input_4(&$this, &$ch1, &$ch2) {
+	if($this->bigEndian) {
+		return $ch2 | $ch1 << 8;
+	} else {
+		return $ch1 | $ch2 << 8;
+	}
+}
+function haxe_io_Input_5(&$this, &$ch1, &$ch2) {
+	if($this->bigEndian) {
+		return $ch2 | $ch1 << 8;
+	} else {
+		return $ch1 | $ch2 << 8;
+	}
+}
+function haxe_io_Input_6(&$this) {
+	throw new HException("Not implemented");
+}
diff --git a/filter/wiris/integration/lib/haxe/io/Output.class.php b/filter/wiris/integration/lib/haxe/io/Output.class.php
new file mode 100644
index 0000000..dda2d37
--- /dev/null
+++ b/filter/wiris/integration/lib/haxe/io/Output.class.php
@@ -0,0 +1,267 @@
+<?php
+
+class haxe_io_Output {
+	public function __construct(){}
+	public function writeString($s) {
+		$b = haxe_io_Bytes::ofString($s);
+		$this->writeFullBytes($b, 0, $b->length);
+	}
+	public function writeInput($i, $bufsize = null) {
+		if($bufsize === null) {
+			$bufsize = 4096;
+		}
+		$buf = haxe_io_Bytes::alloc($bufsize);
+		try {
+			while(true) {
+				$len = $i->readBytes($buf, 0, $bufsize);
+				if($len === 0) {
+					throw new HException(haxe_io_Error::$Blocked);
+				}
+				$p = 0;
+				while($len > 0) {
+					$k = $this->writeBytes($buf, $p, $len);
+					if($k === 0) {
+						throw new HException(haxe_io_Error::$Blocked);
+					}
+					$p += $k;
+					$len -= $k;
+					unset($k);
+				}
+				unset($p,$len);
+			}
+		}catch(Exception $e) {
+			$_ex_ = ($e instanceof HException) ? $e->e : $e;
+			if(($e = $_ex_) instanceof haxe_io_Eof){
+			} else throw $e;;
+		}
+	}
+	public function prepare($nbytes) {
+	}
+	public function writeInt32($x) {
+		if($this->bigEndian) {
+			$this->writeByte(haxe_io_Output_0($this, $x));
+			$this->writeByte(haxe_io_Output_1($this, $x) & 255);
+			$this->writeByte(haxe_io_Output_2($this, $x) & 255);
+			$this->writeByte(haxe_io_Output_3($this, $x));
+		} else {
+			$this->writeByte(haxe_io_Output_4($this, $x));
+			$this->writeByte(haxe_io_Output_5($this, $x) & 255);
+			$this->writeByte(haxe_io_Output_6($this, $x) & 255);
+			$this->writeByte(haxe_io_Output_7($this, $x));
+		}
+	}
+	public function writeUInt30($x) {
+		if($x < 0 || $x >= 1073741824) {
+			throw new HException(haxe_io_Error::$Overflow);
+		}
+		if($this->bigEndian) {
+			$this->writeByte(_hx_shift_right($x, 24));
+			$this->writeByte($x >> 16 & 255);
+			$this->writeByte($x >> 8 & 255);
+			$this->writeByte($x & 255);
+		} else {
+			$this->writeByte($x & 255);
+			$this->writeByte($x >> 8 & 255);
+			$this->writeByte($x >> 16 & 255);
+			$this->writeByte(_hx_shift_right($x, 24));
+		}
+	}
+	public function writeInt31($x) {
+		if($x < -1073741824 || $x >= 1073741824) {
+			throw new HException(haxe_io_Error::$Overflow);
+		}
+		if($this->bigEndian) {
+			$this->writeByte(_hx_shift_right($x, 24));
+			$this->writeByte($x >> 16 & 255);
+			$this->writeByte($x >> 8 & 255);
+			$this->writeByte($x & 255);
+		} else {
+			$this->writeByte($x & 255);
+			$this->writeByte($x >> 8 & 255);
+			$this->writeByte($x >> 16 & 255);
+			$this->writeByte(_hx_shift_right($x, 24));
+		}
+	}
+	public function writeUInt24($x) {
+		if($x < 0 || $x >= 16777216) {
+			throw new HException(haxe_io_Error::$Overflow);
+		}
+		if($this->bigEndian) {
+			$this->writeByte($x >> 16);
+			$this->writeByte($x >> 8 & 255);
+			$this->writeByte($x & 255);
+		} else {
+			$this->writeByte($x & 255);
+			$this->writeByte($x >> 8 & 255);
+			$this->writeByte($x >> 16);
+		}
+	}
+	public function writeInt24($x) {
+		if($x < -8388608 || $x >= 8388608) {
+			throw new HException(haxe_io_Error::$Overflow);
+		}
+		$this->writeUInt24($x & 16777215);
+	}
+	public function writeUInt16($x) {
+		if($x < 0 || $x >= 65536) {
+			throw new HException(haxe_io_Error::$Overflow);
+		}
+		if($this->bigEndian) {
+			$this->writeByte($x >> 8);
+			$this->writeByte($x & 255);
+		} else {
+			$this->writeByte($x & 255);
+			$this->writeByte($x >> 8);
+		}
+	}
+	public function writeInt16($x) {
+		if($x < -32768 || $x >= 32768) {
+			throw new HException(haxe_io_Error::$Overflow);
+		}
+		$this->writeUInt16($x & 65535);
+	}
+	public function writeInt8($x) {
+		if($x < -128 || $x >= 128) {
+			throw new HException(haxe_io_Error::$Overflow);
+		}
+		$this->writeByte($x & 255);
+	}
+	public function writeDouble($x) {
+		$this->write(haxe_io_Bytes::ofString(pack("d", $x)));
+	}
+	public function writeFloat($x) {
+		$this->write(haxe_io_Bytes::ofString(pack("f", $x)));
+	}
+	public function writeFullBytes($s, $pos, $len) {
+		while($len > 0) {
+			$k = $this->writeBytes($s, $pos, $len);
+			$pos += $k;
+			$len -= $k;
+			unset($k);
+		}
+	}
+	public function write($s) {
+		$l = $s->length;
+		$p = 0;
+		while($l > 0) {
+			$k = $this->writeBytes($s, $p, $l);
+			if($k === 0) {
+				throw new HException(haxe_io_Error::$Blocked);
+			}
+			$p += $k;
+			$l -= $k;
+			unset($k);
+		}
+	}
+	public function setEndian($b) {
+		$this->bigEndian = $b;
+		return $b;
+	}
+	public function close() {
+	}
+	public function flush() {
+	}
+	public function writeBytes($s, $pos, $len) {
+		$k = $len;
+		$b = $s->b;
+		if($pos < 0 || $len < 0 || $pos + $len > $s->length) {
+			throw new HException(haxe_io_Error::$OutsideBounds);
+		}
+		while($k > 0) {
+			$this->writeByte(ord($b[$pos]));
+			$pos++;
+			$k--;
+		}
+		return $len;
+	}
+	public function writeByte($c) {
+		throw new HException("Not implemented");
+	}
+	public $bigEndian;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $LN2;
+	static $__properties__ = array("set_bigEndian" => "setEndian");
+	function __toString() { return 'haxe.io.Output'; }
+}
+haxe_io_Output::$LN2 = Math::log(2);
+function haxe_io_Output_0(&$this, &$x) {
+	{
+		$x1 = _hx_shift_right($x, 24);
+		if(($x1 >> 30 & 1) !== _hx_shift_right($x1, 31)) {
+			throw new HException("Overflow " . Std::string($x1));
+		}
+		return $x1 & -1;
+	}
+}
+function haxe_io_Output_1(&$this, &$x) {
+	{
+		$x1 = _hx_shift_right($x, 16);
+		if(($x1 >> 30 & 1) !== _hx_shift_right($x1, 31)) {
+			throw new HException("Overflow " . Std::string($x1));
+		}
+		return $x1 & -1;
+	}
+}
+function haxe_io_Output_2(&$this, &$x) {
+	{
+		$x1 = _hx_shift_right($x, 8);
+		if(($x1 >> 30 & 1) !== _hx_shift_right($x1, 31)) {
+			throw new HException("Overflow " . Std::string($x1));
+		}
+		return $x1 & -1;
+	}
+}
+function haxe_io_Output_3(&$this, &$x) {
+	{
+		$x1 = $x & (255 | 0);
+		if(($x1 >> 30 & 1) !== _hx_shift_right($x1, 31)) {
+			throw new HException("Overflow " . Std::string($x1));
+		}
+		return $x1 & -1;
+	}
+}
+function haxe_io_Output_4(&$this, &$x) {
+	{
+		$x1 = $x & (255 | 0);
+		if(($x1 >> 30 & 1) !== _hx_shift_right($x1, 31)) {
+			throw new HException("Overflow " . Std::string($x1));
+		}
+		return $x1 & -1;
+	}
+}
+function haxe_io_Output_5(&$this, &$x) {
+	{
+		$x1 = _hx_shift_right($x, 8);
+		if(($x1 >> 30 & 1) !== _hx_shift_right($x1, 31)) {
+			throw new HException("Overflow " . Std::string($x1));
+		}
+		return $x1 & -1;
+	}
+}
+function haxe_io_Output_6(&$this, &$x) {
+	{
+		$x1 = _hx_shift_right($x, 16);
+		if(($x1 >> 30 & 1) !== _hx_shift_right($x1, 31)) {
+			throw new HException("Overflow " . Std::string($x1));
+		}
+		return $x1 & -1;
+	}
+}
+function haxe_io_Output_7(&$this, &$x) {
+	{
+		$x1 = _hx_shift_right($x, 24);
+		if(($x1 >> 30 & 1) !== _hx_shift_right($x1, 31)) {
+			throw new HException("Overflow " . Std::string($x1));
+		}
+		return $x1 & -1;
+	}
+}
diff --git a/filter/wiris/integration/lib/php/Boot.class.php b/filter/wiris/integration/lib/php/Boot.class.php
new file mode 100644
index 0000000..9fe3611
--- /dev/null
+++ b/filter/wiris/integration/lib/php/Boot.class.php
@@ -0,0 +1,894 @@
+<?php
+
+class php_Boot {
+	public function __construct(){}
+	static $qtypes;
+	static $ttypes;
+	static $tpaths;
+	static $skip_constructor = false;
+	function __toString() { return 'php.Boot'; }
+}
+{
+	$_hx_class_prefix = null;
+	
+function _hx_add($a, $b) {
+	if (!_hx_is_numeric($a) || !_hx_is_numeric($b)) {
+		return $a . $b;
+	} else {
+		return $a + $b;
+	}
+}
+
+function _hx_anonymous($arr = array()) {
+	$o = new _hx_anonymous();
+	foreach($arr as $k => $v)
+		$o->$k = $v;
+	return $o;
+}
+
+class _hx_array implements ArrayAccess, IteratorAggregate {
+	var $a;
+	var $length;
+	function __construct($a = array()) {
+		$this->a = $a;
+		$this->length = count($a);
+	}
+
+	function concat($a) {
+		return new _hx_array(array_merge($this->a, $a->a));
+	}
+
+	function copy() {
+		return new _hx_array($this->a);
+	}
+
+	function &get($index) {
+		if(isset($this->a[$index])) return $this->a[$index];
+		return null;
+	}
+
+	function insert($pos, $x) {
+		array_splice($this->a, $pos, 0, array($x));
+		$this->length++;
+	}
+
+	function iterator() {
+		return new _hx_array_iterator($this->a);
+	}
+
+	function getIterator() {
+		return $this->iterator();
+	}
+
+	function join($sep) {
+		return implode($sep, $this->a);
+	}
+
+	function pop() {
+		$r = array_pop($this->a);
+		$this->length = count($this->a);
+		return $r;
+	}
+
+	function push($x) {
+		$this->a[] = $x;
+		return ++$this->length;
+	}
+
+	function remove($x) {
+		for($i = 0; $i < count($this->a); $i++)
+			if($this->a[$i] === $x) {
+				unset($this->a[$i]);
+				$this->a = array_values($this->a);
+				$this->length--;
+				return true;
+			}
+		return false;
+	}
+
+	function removeAt($pos) {
+		if(array_key_exists($pos, $this->a)) {
+			unset($this->a[$pos]);
+			$this->length--;
+			return true;
+		} else
+			return false;
+	}
+
+	function reverse() {
+		$this->a = array_reverse($this->a, false);
+	}
+
+	function shift() {
+		$r = array_shift($this->a);
+		$this->length = count($this->a);
+		return $r;
+	}
+
+	function slice($pos, $end) {
+		if($end === null)
+			return new _hx_array(array_slice($this->a, $pos));
+		else
+			return new _hx_array(array_slice($this->a, $pos, $end-$pos));
+	}
+
+	function sort($f) {
+		usort($this->a, $f);
+	}
+
+	function splice($pos, $len) {
+		if($len < 0) $len = 0;
+		$nh = new _hx_array(array_splice($this->a, $pos, $len));
+		$this->length = count($this->a);
+		return $nh;
+	}
+
+	function toString() {
+		return '['.implode(',', array_map('_hx_string_rec',$this->a,array())).']';
+	}
+
+	function __toString() {
+		return $this->toString();
+	}
+
+	function unshift($x) {
+		array_unshift($this->a, $x);
+		$this->length++;
+	}
+
+	// ArrayAccess methods:
+	function offsetExists($offset) {
+		return isset($this->a[$offset]);
+	}
+
+	function offsetGet($offset) {
+		if(isset($this->a[$offset])) return $this->a[$offset];
+		return null;
+	}
+
+	function offsetSet($offset, $value) {
+		if($this->length <= $offset) {
+			$this->a = array_merge($this->a, array_fill(0, $offset+1-$this->length, null));
+			$this->length = $offset+1;
+		}
+		return $this->a[$offset] = $value;
+	}
+
+	function offsetUnset($offset) {
+		return $this->removeAt($offset);
+	}
+}
+
+class _hx_array_iterator implements Iterator {
+	private $a;
+	private $i;
+	public function __construct($a) {
+		$this->a = $a;
+		$this->i = 0;
+	}
+
+	public function next() {
+		if(!$this->hasNext()) return null;
+		return $this->a[$this->i++];
+	}
+
+	public function hasNext() {
+		return $this->i < count($this->a);
+	}
+
+	public function current() {
+		if (!$this->hasNext()) return false;
+		return $this->a[$this->i];
+	}
+
+	public function key() {
+		return $this->i;
+	}
+
+	public function valid() {
+		return $this->current() !== false;
+	}
+
+	public function rewind() {
+		$this->i = 0;
+	}
+	public function size() {
+		return count($this->a);
+	}
+}
+
+function _hx_array_get($a, $pos) { return $a[$pos]; }
+
+function _hx_array_increment($a, $pos) { return $a[$pos] += 1; }
+function _hx_array_decrement($a, $pos) { return $a[$pos] -= 1; }
+
+function _hx_array_assign($a, $i, $v) { return $a[$i] = $v; }
+
+class _hx_break_exception extends Exception {}
+
+function _hx_cast($v, $type) {
+	if(Std::is($v, $type)) {
+		return $v;
+	} else {
+		throw new HException('Class cast error');
+	}
+}
+
+function _hx_char_at($o, $i) { $c = substr($o, $i, 1); return FALSE === $c ? '' : $c; }
+
+function _hx_char_code_at($s, $pos) {
+	if($pos < 0 || $pos >= strlen($s)) return null;
+	return ord($s{$pos});
+}
+
+function _hx_deref($o) { return $o; }
+
+function _hx_equal($x, $y) {
+	if(is_null($x)) {
+		return is_null($y);
+	} else {
+		if(is_null($y)) {
+			return false;
+		} else {
+			if((is_float($x) || is_int($x)) && (is_float($y) || is_int($y))) {
+				return $x == $y;
+			} else {
+				return $x === $y;
+			}
+		}
+	}
+}
+
+function _hx_mod($x, $y) {
+	if (is_int($x) && is_int($y)) {
+		if ($y == 0) return 0;
+		return $x % $y;
+	}
+	if (!is_nan($x) && !is_nan($y) && !is_finite($y) && is_finite($x)) {
+		return $x;
+	} 
+	return fmod($x, $y);
+}
+
+function _hx_error_handler($errno, $errmsg, $filename, $linenum, $vars) {
+	$msg = $errmsg . ' (errno: ' . $errno . ') in ' . $filename . ' at line #' . $linenum;
+	$e = new HException($msg, $errmsg, $errno, _hx_anonymous(array('fileName' => 'Boot.hx', 'lineNumber' => __LINE__, 'className' => 'php.Boot', 'methodName' => '_hx_error_handler')));
+	$e->setFile($filename);
+	$e->setLine($linenum);
+	throw $e;
+	return null;
+}
+
+function _hx_exception_handler($e) {
+	if(0 == strncasecmp(PHP_SAPI, 'cli', 3)) {
+		$msg   = $e-> getMessage();
+		$nl    = "\n";
+		$pre   = '';
+		$post  = '';
+	} else {
+		$msg   = '<b>' . $e-> getMessage() . '</b>';
+		$nl    = "<br />";
+		$pre   = '<pre>';
+		$post  = '</pre>';
+	}
+	if(isset($GLOBALS['%s'])) {
+		$stack = '';
+		$i = $GLOBALS['%s']->length;
+		while(--$i >= 0)
+			$stack .= 'Called from '.$GLOBALS['%s'][$i].$nl;
+		die($pre.'uncaught exception: '.$msg.$nl.$nl.$stack.$post);
+	} else
+		die($pre.'uncaught exception: '.$msg.$nl.$nl.'in file: '.$e->getFile().' line '.$e->getLine().$nl.$e->getTraceAsString().$post);
+}
+
+function _hx_explode($delimiter, $s) {
+	if($delimiter == '')
+		return new _hx_array(str_split($s, 1));
+	return new _hx_array(explode($delimiter, $s));
+}
+
+function _hx_explode2($s, $delimiter) {
+	if($delimiter == '')
+		return new _hx_array(str_split($s, 1));
+	return new _hx_array(explode($delimiter, $s));
+}
+
+function _hx_field($o, $field) {
+	if(_hx_has_field($o, $field)) {
+		if($o instanceof _hx_type) {
+			if(is_callable($c = array($o->__tname__, $field)) && !property_exists($o->__tname__, $field)) {
+				return $c;
+			} else {
+				$name = $o->__tname__;
+				return eval('return '.$name.'::$'.$field.';');
+			}
+		} else {
+			if(is_string($o)) {
+				if($field == 'length') {
+					return strlen($o);
+				} else {
+					switch($field) {
+						case 'charAt'     : return array(new _hx_lambda(array(&$o), '_hx_char_at'), 'execute');
+						case 'charCodeAt' : return array(new _hx_lambda(array(&$o), '_hx_char_code_at'), 'execute');
+						case 'indexOf'    : return array(new _hx_lambda(array(&$o), '_hx_index_of'), 'execute');
+						case 'lastIndexOf': return array(new _hx_lambda(array(&$o), '_hx_last_index_of'), 'execute');
+						case 'split'      : return array(new _hx_lambda(array(&$o), '_hx_explode2'), 'execute');
+						case 'substr'     : return array(new _hx_lambda(array(&$o), '_hx_substr'), 'execute');
+						case 'toUpperCase': return array(new _hx_lambda(array(&$o), 'strtoupper'), 'execute');
+						case 'toLowerCase': return array(new _hx_lambda(array(&$o), 'strtolower'), 'execute');
+						case 'toString'   : return array(new _hx_lambda(array(&$o), '_hx_deref'), 'execute');
+					}
+					return null;
+				}
+			} else {
+				if(property_exists($o, $field)) {
+					if(is_array($o->$field) && is_callable($o->$field)) {
+						return $o->$field;
+					} else {
+						if(is_string($o->$field) && _hx_is_lambda($o->$field)) {
+							return array($o, $field);
+						} else {
+							return $o->$field;
+						}
+					}
+				} else if(isset($o->dynamics[$field])) {
+					return $o->dynamics[$field];
+				} else {
+					return array($o, $field);
+				}
+			}
+		}
+	} else {
+		return null;
+	}
+}
+
+function _hx_get_object_vars($o) {
+	$a = array_keys(get_object_vars($o));
+	if(isset($o->dynamics))
+		$a = array_merge($a, array_keys($o->dynamics));
+	$arr = array();
+	for($i=0;$i<count($a); $i++)
+	{
+		$k = '' . $a[$i];
+		if(substr($k, 0, 1) != '')
+			$arr[] = $k;
+	}
+	return $arr;
+}
+
+function _hx_has_field($o, $field) {
+	return
+		(is_object($o) && (method_exists($o, $field) || isset($o->$field) || property_exists($o, $field) || isset($o->dynamics[$field])))
+		||
+		(is_string($o) && (in_array($field, array('toUpperCase', 'toLowerCase', 'charAt', 'charCodeAt', 'indexOf', 'lastIndexOf', 'split', 'substr', 'toString', 'length'))))
+	;
+}
+
+function _hx_index_of($s, $value, $startIndex = null) {
+	$x = strpos($s, $value, $startIndex);
+	if($x === false)
+		return -1;
+	else
+		return $x;
+}
+
+function _hx_instanceof($v, $t) {
+	if($t === null) {
+		return false;
+	}
+	switch($t->__tname__) {
+		case 'Array'  : return is_array($v);
+		case 'String' : return is_string($v) && !_hx_is_lambda($v);
+		case 'Bool'   : return is_bool($v);
+		case 'Int'    : return is_int($v) || (is_float($v) && intval($v) == $v && !is_nan($v));
+		case 'Float'  : return is_float($v) || is_int($v);
+		case 'Dynamic': return true;
+		case 'Class'  : return ($v instanceof _hx_class || $v instanceof _hx_interface) && $v->__tname__ != 'Enum';
+		case 'Enum'   : return $v instanceof _hx_enum;
+		default       : return is_a($v, $t->__tname__);
+	}
+}
+
+function _hx_is_lambda($s) {
+	return (is_string($s) && substr($s, 0, 8) == chr(0).'lambda_') || (is_array($s) && count($s) > 0 && (is_a($s[0], '_hx_lambda') || is_a($s[0], '_hx_lambda2')));
+}
+
+function _hx_is_numeric($v)
+{
+	return is_numeric($v) && !is_string($v);
+}
+
+function _hx_last_index_of($s, $value, $startIndex = null) {
+	$x = strrpos($s, $value, $startIndex === null ? null : strlen($s) - $startIndex);
+	if($x === false)
+		return -1;
+	else
+		return $x;
+}
+
+function _hx_len($o) {
+	return is_string($o) ? strlen($o) : $o->length;
+}
+
+class _hx_list_iterator implements Iterator {
+	private $h;
+	private $list;
+	private $counter;
+	public function __construct($list) {
+		$this->list = $list;
+		$this->rewind();
+	}
+
+	public function next() {
+		if($this->h == null) return null;
+		$this->counter++;
+		$x = $this->h[0];
+		$this->h = $this->h[1];
+		return $x;
+	}
+
+	public function hasNext() {
+		return $this->h != null;
+	}
+
+	public function current() {
+		if (!$this->hasNext()) return null;
+		return $this->h[0];
+	}
+
+	public function key() {
+		return $this->counter;
+	}
+
+	public function valid() {
+		return $this->current() !== null;
+	}
+
+	public function rewind() {
+		$this->counter = -1;
+		$this->h = $this->list->h;
+	}
+
+	public function size() {
+		return $this->list->length;
+	}
+}
+
+function _hx_null() { return null; }
+
+class _hx_nullob {
+	function _throw()       { throw new HException('Null object'); }
+	function __call($f, $a) { $this->_throw(); }
+	function __get($f)      { $this->_throw(); }
+	function __set($f, $v)  { $this->_throw(); }
+	function __isset($f)    { $this->_throw(); }
+	function __unset($f)    { $this->_throw(); }
+	function __toString()   { return 'null'; }
+	static $inst;
+}
+
+_hx_nullob::$inst = new _hx_nullob();
+
+function _hx_nullob() { return _hx_nullob::$inst; }
+
+function _hx_qtype($n) {
+	return isset(php_Boot::$qtypes[$n]) ? php_Boot::$qtypes[$n] : null;
+}
+
+function _hx_register_type($t) {
+	php_Boot::$qtypes[$t->__qname__] = $t;
+	php_Boot::$ttypes[$t->__tname__] = $t;
+	if($t->__path__ !== null)
+		php_Boot::$tpaths[$t->__tname__] = $t->__path__;
+}
+
+function _hx_set_method($o, $field, $func) {
+	$value[0]->scope = $o;
+	$o->$field = $func;
+}
+
+function _hx_shift_right($v, $n) {
+	$z = 0x80000000;
+	if ($z & $v) {
+		$v = ($v>>1);
+		$v &= (~$z);
+		$v |= 0x40000000;
+		$v = ($v>>($n-1));
+	} else $v = ($v>>$n);
+	return $v;
+}
+
+function _hx_string_call($s, $method, $params) {
+	if(!is_string($s)) return call_user_func_array(array($s, $method), $params);
+	switch($method) {
+		case 'toUpperCase': return strtoupper($s);
+		case 'toLowerCase': return strtolower($s);
+		case 'charAt'     : return substr($s, $params[0], 1);
+		case 'charCodeAt' : return _hx_char_code_at($s, $params[0]);
+		case 'indexOf'    : return _hx_index_of($s, $params[0], (count($params) > 1 ? $params[1] : null));
+		case 'lastIndexOf': return _hx_last_index_of($s, (count($params) > 1 ? $params[1] : null), null);
+		case 'split'      : return _hx_explode($params[0], $s);
+		case 'substr'     : return _hx_substr($s, $params[0], (count($params) > 1 ? $params[1] : null));
+		case 'toString'   : return $s;
+		default           : throw new HException('Invalid Operation: ' . $method);
+	}
+}
+
+function _hx_string_rec($o, $s) {
+	if($o === null)                return 'null';
+	if(strlen($s) >= 5)            return '<...>';
+	if(is_int($o) || is_float($o)) return '' . $o;
+	if(is_bool($o))                return $o ? 'true' : 'false';
+	if(is_object($o)) {
+		$c = get_class($o);
+		if($o instanceof Enum) {
+			$b = $o->tag;
+			if(!empty($o->params)) {
+				$s .= "	";
+				$b .= '(';
+				for($i = 0; $i < count($o->params); $i++) {
+					if($i > 0)
+						$b .= ',' . _hx_string_rec($o->params[$i], $s);
+					else
+						$b .= _hx_string_rec($o->params[$i], $s);
+				}
+				$b .= ')';
+			}
+			return $b;
+		} else {
+			if ($o instanceof _hx_anonymous) {
+				if ($o->toString && is_callable($o->toString)) {
+					return call_user_func($o->toString);
+				}
+				$rfl = new ReflectionObject($o);
+				$b2 = "{
+";
+				$s .= "	";
+				$properties = $rfl->getProperties();
+
+				for($i = 0; $i < count($properties); $i++) {
+					$prop = $properties[$i];
+					$f = $prop->getName();
+					if($i > 0)
+						$b2 .= ", 
+";
+					$b2 .= $s . $f . ' : ' . _hx_string_rec($o->$f, $s);
+				}
+				$s = substr($s, 1);
+				$b2 .= "
+" . $s . '}';
+				return $b2;
+			} else {
+				if($o instanceof _hx_type)
+					return $o->__qname__;
+				else {
+					if(is_callable(array($o, 'toString')))
+						return $o->toString();
+					else {
+						if(is_callable(array($o, '__toString')))
+							return $o->__toString();
+						else
+							return '[' . _hx_ttype($c) . ']';
+					}
+				}
+			}
+		}
+	}
+	if(is_string($o)) {
+		if(_hx_is_lambda($o)) return 'function';
+//		if(strlen($s) > 0)    return '"' . str_replace('"', '\"', $o) . '"';
+		else                  return $o;
+	}
+	if(is_array($o)) {
+		if(is_callable($o)) return 'function';
+		$str = '[';
+		$s .= "	";
+		$first = true;
+		$assoc = true;
+		foreach($o as $k => $v)
+		{
+			if ($first && $k === 0)
+				$assoc = false;
+			$str .= ($first ? '' : ',') . ($assoc
+				? _hx_string_rec($k, $s) . '=>' . _hx_string_rec($o[$k], $s)
+				: _hx_string_rec($o[$k], $s)
+			);
+			$first = false;
+		}
+		$str .= ']';
+		return $str;
+	}
+	return '';
+}
+
+function _hx_substr($s, $pos, $len) {
+	if($pos !== null && $pos !== 0 && $len !== null && $len < 0) return '';
+	if($len === null) $len = strlen($s);
+	if($pos < 0) {
+		$pos = strlen($s) + $pos;
+		if($pos < 0) $pos = 0;
+	} else if($len < 0 )
+		$len = strlen($s) + $len - $pos;
+	$s = substr($s, $pos, $len);
+	if($s === false)
+		return '';
+	else
+		return $s;
+}
+
+function _hx_trace($v, $i) {
+	$msg = $i !== null ? $i->fileName.':'.$i->lineNumber.': ' : '';
+	echo $msg._hx_string_rec($v, '')."
+";
+}
+
+function _hx_ttype($n) {
+	return isset(php_Boot::$ttypes[$n]) ? php_Boot::$ttypes[$n] : null;
+}
+
+function _hx_make_var_args() {
+	$args = func_get_args();
+	$f = array_shift($args);
+	return call_user_func($f, new _hx_array($args));
+}
+
+class _hx_anonymous extends stdClass {
+	public function __call($m, $a) {
+		return call_user_func_array($this->$m, $a);
+	}
+
+	public function __set($n, $v) {
+		$this->$n = $v;
+	}
+
+	public function &__get($n) {
+		if(isset($this->$n))
+			return $this->$n;
+		$null = null;
+		return $null;
+	}
+
+	public function __isset($n) {
+		return isset($this->$n);
+	}
+
+	public function __unset($n) {
+		unset($this->$n);
+	}
+
+	public function __toString() {
+		$rfl = new ReflectionObject($this);
+		$b = '{ ';
+		$properties = $rfl->getProperties();
+		$first = true;
+		while(list(, $prop) = each($properties)) {
+			if($first)
+				$first = false;
+			else
+				$b .= ', ';
+			$f = $prop->getName();
+			$b .= $f . ' => ' . $this->$f;
+		}
+		$b .= ' }';
+		return $b;
+	}
+}
+
+class _hx_type {
+	public $__tname__;
+	public $__qname__;
+	public $__path__;
+	public function __construct($cn, $qn, $path = null) {
+		$this->__tname__ = $cn;
+		$this->__qname__ = $qn;
+		$this->__path__ = $path;
+		if(property_exists($cn, '__meta__'))
+			$this->__meta__ =  eval($cn.'::$__meta__');
+	}
+
+	public function toString()   { return $this->__toString(); }
+
+	public function __toString() {
+		return $this->__qname__;
+	}
+
+	private $rfl = false;
+	public function __rfl__() {
+		if($this->rfl !== false) return $this->rfl;
+		if(class_exists($this->__tname__) || interface_exists($this->__tname__))
+			$this->rfl = new ReflectionClass($this->__tname__);
+		else
+			$this->rfl = null;
+		return $this->rfl;
+	}
+
+	public function __call($n, $a) {
+		return call_user_func_array(array($this->__tname__, $n), $a);
+	}
+
+	public function __get($n) {
+		if(($r = $this->__rfl__())==null) return null;
+		if($r->hasProperty($n))
+			return $r->getStaticPropertyValue($n);
+		else if($r->hasMethod($n))
+			return array($r, $n);
+		else
+			return null;
+	}
+
+	public function __set($n, $v) {
+		if(($r = $this->__rfl__())==null) return null;
+		return $r->setStaticPropertyValue($n, $v);
+	}
+
+	public function __isset($n) {
+		if(($r = $this->__rfl__())==null) return null;
+		return $r->hasProperty($n) || $r->hasMethod($n);
+	}
+}
+
+class _hx_class extends _hx_type {}
+
+class _hx_enum extends _hx_type {}
+
+class _hx_interface extends _hx_type {}
+
+class HException extends Exception {
+	public function __construct($e, $message = null, $code = null, $p = null) {
+		$message = _hx_string_rec($e, '') . $message;
+		parent::__construct($message,$code);
+		$this->e = $e;
+		$this->p = $p;
+	}
+	public $e;
+	public $p;
+	public function setLine($l) {
+		$this->line = $l;
+	}
+	public function setFile($f) {
+		$this->file = $f;
+	}
+}
+
+class _hx_lambda {
+	public function __construct($locals, $func) {
+		$this->locals = $locals;
+		$this->func = $func;
+	}
+	public $locals;
+	public $func;
+
+	public function execute() {
+		// if use $this->locals directly in array_merge it works only if I make the assignement loop,
+		// so I've decided to reference $arr
+		$arr = array();
+		for ($i = 0; $i<count($this->locals);$i++)
+			$arr[] = & $this->locals[$i];
+		$args = func_get_args();
+		return call_user_func_array($this->func, array_merge($arr, $args));
+	}
+}
+
+class Enum {
+	public function __construct($tag, $index, $params = null) { $this->tag = $tag; $this->index = $index; $this->params = $params; }
+	public $tag;
+	public $index;
+	public $params;
+
+	public function __toString() {
+		return $this->tag;
+	}
+}
+
+error_reporting(E_ALL & ~E_STRICT);
+set_error_handler('_hx_error_handler', E_ALL);
+set_exception_handler('_hx_exception_handler');
+
+php_Boot::$qtypes = array();
+php_Boot::$ttypes = array();
+php_Boot::$tpaths = array();
+
+_hx_register_type(new _hx_class('String',  'String'));
+_hx_register_type(new _hx_class('_hx_array', 'Array'));
+_hx_register_type(new _hx_class('Int',     'Int'));
+_hx_register_type(new _hx_class('Float',   'Float'));
+_hx_register_type(new _hx_class('Class',   'Class'));
+_hx_register_type(new _hx_class('Enum',    'Enum'));
+_hx_register_type(new _hx_class('Dynamic', 'Dynamic'));
+_hx_register_type(new _hx_enum('Bool',     'Bool'));
+_hx_register_type(new _hx_enum('Void',     'Void'));
+
+
+$_hx_libdir = dirname(__FILE__) . '/..';
+$_hx_autload_cache_file = $_hx_libdir . '/../cache/haxe_autoload.php';
+if(!file_exists($_hx_autload_cache_file)) {
+	function _hx_build_paths($d, &$_hx_types_array, $pack, $prefix) {
+		$h = opendir($d);
+		while(false !== ($f = readdir($h))) {
+			$p = $d.'/'.$f;
+			if($f == '.' || $f == '..')
+				continue;
+				if (is_file($p) && substr($f, -4) == '.php') {
+				$bn = basename($f, '.php');
+				if ($prefix)
+				{
+					if ($prefix != substr($bn, 0, $lenprefix = strlen($prefix)))
+						continue;
+					$bn = substr($bn, $lenprefix);
+				}
+				if(substr($bn, -6) == '.class') {
+					$bn = substr($bn, 0, -6);
+					$t = 0;
+				} else if(substr($bn, -5) == '.enum') {
+					$bn = substr($bn, 0, -5);
+					$t = 1;
+				} else if(substr($bn, -10) == '.interface') {
+					$bn = substr($bn, 0, -10);
+					$t = 2;
+				} else if(substr($bn, -7) == '.extern') {
+					$bn = substr($bn, 0, -7);
+					$t = 3;
+				} else
+					continue;
+				$qname = ($bn == 'HList' && empty($pack)) ? 'List' : join(array_merge($pack, array($bn)), '.');
+				$_hx_types_array[] = array(
+					'path' => $p,
+					'name' => $prefix . $bn,
+					'type' => $t,
+					'qname' => $qname,
+					'phpname' => join(array_merge($pack, array($prefix . $bn)), '_')
+				);
+			} else if(is_dir($p))
+				_hx_build_paths($p, $_hx_types_array, array_merge($pack, array($f)), $prefix);
+		}
+		closedir($h);
+	}
+
+	$_hx_cache_content = '<?php
+
+';
+	$_hx_types_array = array();
+
+	_hx_build_paths($_hx_libdir, $_hx_types_array, array(), $_hx_class_prefix);
+
+	for($i=0;$i<count($_hx_types_array);$i++) {
+		$_hx_cache_content .= '_hx_register_type(new ';
+		$t = null;
+		if($_hx_types_array[$i]['type'] == 0) {
+			$t = new _hx_class($_hx_types_array[$i]['phpname'], $_hx_types_array[$i]['qname'], $_hx_types_array[$i]['path']);
+			$_hx_cache_content .= '_hx_class';
+		} else if($_hx_types_array[$i]['type'] == 1) {
+			$t = new _hx_enum($_hx_types_array[$i]['phpname'], $_hx_types_array[$i]['qname'], $_hx_types_array[$i]['path']);
+			$_hx_cache_content .= '_hx_enum';
+		} else if($_hx_types_array[$i]['type'] == 2) {
+			$t = new _hx_interface($_hx_types_array[$i]['phpname'], $_hx_types_array[$i]['qname'], $_hx_types_array[$i]['path']);
+			$_hx_cache_content .= '_hx_interface';
+		} else if($_hx_types_array[$i]['type'] == 3) {
+			$t = new _hx_class($_hx_types_array[$i]['name'], $_hx_types_array[$i]['qname'], $_hx_types_array[$i]['path']);
+			$_hx_cache_content .= '_hx_class';
+		}
+		_hx_register_type($t);
+		$_hx_cache_content .= '(\''.($_hx_types_array[$i]['type'] == 3 ? $_hx_types_array[$i]['name'] : $_hx_types_array[$i]['phpname']).'\', \''.$_hx_types_array[$i]['qname'].'\', \''.$_hx_types_array[$i]['path'].'\'));
+';
+	}
+	try {
+		file_put_contents($_hx_autload_cache_file, $_hx_cache_content);
+	} catch(Exception $e) {}
+	unset($_hx_types_array);
+	unset($_hx_cache_content);
+} else {
+	require($_hx_autload_cache_file);
+}
+
+function _hx_autoload($name) {
+	if(!isset(php_Boot::$tpaths[$name])) return false;
+	require_once(php_Boot::$tpaths[$name]);
+	return true;
+}
+
+if(!ini_get('date.timezone'))
+	date_default_timezone_set('UTC');
+
+spl_autoload_register('_hx_autoload');
+}
diff --git a/filter/wiris/integration/lib/php/Lib.class.php b/filter/wiris/integration/lib/php/Lib.class.php
new file mode 100644
index 0000000..c04022c
--- /dev/null
+++ b/filter/wiris/integration/lib/php/Lib.class.php
@@ -0,0 +1,119 @@
+<?php
+
+class php_Lib {
+	public function __construct(){}
+	static function hprint($v) {
+		echo(Std::string($v));
+	}
+	static function println($v) {
+		php_Lib::hprint($v);
+		php_Lib::hprint("\x0A");
+	}
+	static function dump($v) {
+		var_dump($v);
+	}
+	static function serialize($v) {
+		return serialize($v);
+	}
+	static function unserialize($s) {
+		return unserialize($s);
+	}
+	static function extensionLoaded($name) {
+		return extension_loaded($name);
+	}
+	static function isCli() {
+		return (0 == strncasecmp(PHP_SAPI, 'cli', 3));
+	}
+	static function printFile($file) {
+		return fpassthru(fopen($file, "r"));
+	}
+	static function toPhpArray($a) {
+		return $a->a;
+	}
+	static function toHaxeArray($a) {
+		return new _hx_array($a);
+	}
+	static function hashOfAssociativeArray($arr) {
+		$h = new Hash();
+		$h->h = $arr;
+		return $h;
+	}
+	static function associativeArrayOfHash($hash) {
+		return $hash->h;
+	}
+	static function objectOfAssociativeArray($arr) {
+		foreach($arr as $key => $value){
+			if(is_array($value)) $arr[$key] = php_Lib::objectOfAssociativeArray($value);
+		}
+		return _hx_anonymous($arr);
+	}
+	static function associativeArrayOfObject($ob) {
+		return (array) $ob;
+	}
+	static function mail($to, $subject, $message, $additionalHeaders = null, $additionalParameters = null) {
+		if(null !== $additionalParameters) {
+			return mail($to, $subject, $message, $additionalHeaders, $additionalParameters);
+		} else {
+			if(null !== $additionalHeaders) {
+				return mail($to, $subject, $message, $additionalHeaders);
+			} else {
+				return mail($to, $subject, $message);
+			}
+		}
+	}
+	static function rethrow($e) {
+		if(Std::is($e, _hx_qtype("php.Exception"))) {
+			$__rtex__ = $e;
+			throw $__rtex__;
+		} else {
+			throw new HException($e);
+		}
+	}
+	static function appendType($o, $path, $t) {
+		$name = $path->shift();
+		if($path->length === 0) {
+			$o->$name = $t;
+		} else {
+			$so = ((isset($o->$name)) ? $o->$name : _hx_anonymous(array()));
+			php_Lib::appendType($so, $path, $t);
+			$o->$name = $so;
+		}
+	}
+	static function getClasses() {
+		$path = null;
+		$o = _hx_anonymous(array());
+		reset(php_Boot::$qtypes);
+		while(($path = key(php_Boot::$qtypes)) !== null) {
+			php_Lib::appendType($o, _hx_explode(".", $path), php_Boot::$qtypes[$path]);
+			next(php_Boot::$qtypes);
+		}
+		return $o;
+	}
+	static function loadLib($pathToLib) {
+		$prefix = null;
+		$_hx_types_array = array();
+ 		$_hx_cache_content = '';
+ 		//Calling this function will put all types present in the specified types in the $_hx_types_array
+ 		_hx_build_paths($pathToLib, $_hx_types_array, array(), $prefix);
+
+ 		for($i=0;$i<count($_hx_types_array);$i++) {
+ 			//For every type that has been found, create its description
+ 			$t = null;
+ 			if($_hx_types_array[$i]['type'] == 0) {
+ 				$t = new _hx_class($_hx_types_array[$i]['phpname'], $_hx_types_array[$i]['qname'], $_hx_types_array[$i]['path']);
+ 			} else if($_hx_types_array[$i]['type'] == 1) {
+ 				$t = new _hx_enum($_hx_types_array[$i]['phpname'], $_hx_types_array[$i]['qname'], $_hx_types_array[$i]['path']);
+ 			} else if($_hx_types_array[$i]['type'] == 2) {
+ 				$t = new _hx_interface($_hx_types_array[$i]['phpname'], $_hx_types_array[$i]['qname'], $_hx_types_array[$i]['path']);
+ 			} else if($_hx_types_array[$i]['type'] == 3) {
+ 				$t = new _hx_class($_hx_types_array[$i]['name'], $_hx_types_array[$i]['qname'], $_hx_types_array[$i]['path']);
+ 			}
+ 			//Register the type
+ 			if(!array_key_exists($t->__qname__, php_Boot::$qtypes)) {
+ 				_hx_register_type($t);
+ 			}
+ 		}
+ 
+	}
+	function __toString() { return 'php.Lib'; }
+}
diff --git a/filter/wiris/integration/lib/php/net/SslSocket.class.php b/filter/wiris/integration/lib/php/net/SslSocket.class.php
new file mode 100644
index 0000000..0e8ace1
--- /dev/null
+++ b/filter/wiris/integration/lib/php/net/SslSocket.class.php
@@ -0,0 +1,17 @@
+<?php
+
+class php_net_SslSocket extends sys_net_Socket {
+	public function __construct() { if(!php_Boot::$skip_constructor) {
+		parent::__construct();
+		$this->protocol = "ssl";
+	}}
+	public function connect($host, $port) {
+		$errs = null;
+		$errn = null;
+		$r = stream_socket_client($this->protocol . "://" . $host->hostName . ":" . _hx_string_rec($port, ""), $errn, $errs);
+		sys_net_Socket::checkError($r, $errn, $errs);
+		$this->__s = $r;
+		$this->assignHandler();
+	}
+	function __toString() { return 'php.net.SslSocket'; }
+}
diff --git a/filter/wiris/integration/lib/sys/FileSystem.class.php b/filter/wiris/integration/lib/sys/FileSystem.class.php
new file mode 100644
index 0000000..64b0fd7
--- /dev/null
+++ b/filter/wiris/integration/lib/sys/FileSystem.class.php
@@ -0,0 +1,59 @@
+<?php
+
+class sys_FileSystem {
+	public function __construct(){}
+	static function exists($path) {
+		return file_exists($path);
+	}
+	static function rename($path, $newpath) {
+		rename($path, $newpath);
+	}
+	static function stat($path) {
+		$fp = fopen($path, "r");
+		$fstat = fstat($fp);
+		fclose($fp);;
+		return _hx_anonymous(array("gid" => $fstat['gid'], "uid" => $fstat['uid'], "atime" => Date::fromTime($fstat['atime'] * 1000), "mtime" => Date::fromTime($fstat['mtime'] * 1000), "ctime" => Date::fromTime($fstat['ctime'] * 1000), "dev" => $fstat['dev'], "ino" => $fstat['ino'], "nlink" => $fstat['nlink'], "rdev" => $fstat['rdev'], "size" => $fstat['size'], "mode" => $fstat['mode']));
+	}
+	static function fullPath($relpath) {
+		$p = realpath($relpath);
+		if(($p === false)) {
+			return null;
+		} else {
+			return $p;
+		}
+	}
+	static function kind($path) {
+		$k = filetype($path);
+		switch($k) {
+		case "file":{
+			return sys__FileSystem_FileKind::$kfile;
+		}break;
+		case "dir":{
+			return sys__FileSystem_FileKind::$kdir;
+		}break;
+		default:{
+			return sys__FileSystem_FileKind::kother($k);
+		}break;
+		}
+	}
+	static function isDirectory($path) {
+		return is_dir($path);
+	}
+	static function createDirectory($path) {
+		@mkdir($path, 493);
+	}
+	static function deleteFile($path) {
+		@unlink($path);
+	}
+	static function deleteDirectory($path) {
+		@rmdir($path);
+	}
+	static function readDirectory($path) {
+		$l = array();
+		$dh = opendir($path);
+        while (($file = readdir($dh)) !== false) if("." != $file && ".." != $file) $l[] = $file;
+        closedir($dh);;
+		return new _hx_array($l);
+	}
+	function __toString() { return 'sys.FileSystem'; }
+}
diff --git a/filter/wiris/integration/lib/sys/_FileSystem/FileKind.enum.php b/filter/wiris/integration/lib/sys/_FileSystem/FileKind.enum.php
new file mode 100644
index 0000000..d083012
--- /dev/null
+++ b/filter/wiris/integration/lib/sys/_FileSystem/FileKind.enum.php
@@ -0,0 +1,10 @@
+<?php
+
+class sys__FileSystem_FileKind extends Enum {
+	public static $kdir;
+	public static $kfile;
+	public static function kother($k) { return new sys__FileSystem_FileKind("kother", 2, array($k)); }
+	public static $__constructors = array(0 => 'kdir', 1 => 'kfile', 2 => 'kother');
+	}
+sys__FileSystem_FileKind::$kdir = new sys__FileSystem_FileKind("kdir", 0);
+sys__FileSystem_FileKind::$kfile = new sys__FileSystem_FileKind("kfile", 1);
diff --git a/filter/wiris/integration/lib/sys/io/File.class.php b/filter/wiris/integration/lib/sys/io/File.class.php
new file mode 100644
index 0000000..d379b1f
--- /dev/null
+++ b/filter/wiris/integration/lib/sys/io/File.class.php
@@ -0,0 +1,41 @@
+<?php
+
+class sys_io_File {
+	public function __construct(){}
+	static function getContent($path) {
+		return file_get_contents($path);
+	}
+	static function getBytes($path) {
+		return haxe_io_Bytes::ofString(sys_io_File::getContent($path));
+	}
+	static function saveContent($path, $content) {
+		file_put_contents($path, $content);
+	}
+	static function saveBytes($path, $bytes) {
+		$f = sys_io_File::write($path, null);
+		$f->write($bytes);
+		$f->close();
+	}
+	static function read($path, $binary = null) {
+		if($binary === null) {
+			$binary = true;
+		}
+		return new sys_io_FileInput(fopen($path, (($binary) ? "rb" : "r")));
+	}
+	static function write($path, $binary = null) {
+		if($binary === null) {
+			$binary = true;
+		}
+		return new sys_io_FileOutput(fopen($path, (($binary) ? "wb" : "w")));
+	}
+	static function append($path, $binary = null) {
+		if($binary === null) {
+			$binary = true;
+		}
+		return new sys_io_FileOutput(fopen($path, (($binary) ? "ab" : "a")));
+	}
+	static function copy($src, $dst) {
+		copy($src, $dst);
+	}
+	function __toString() { return 'sys.io.File'; }
+}
diff --git a/filter/wiris/integration/lib/sys/io/FileInput.class.php b/filter/wiris/integration/lib/sys/io/FileInput.class.php
new file mode 100644
index 0000000..00eee2a
--- /dev/null
+++ b/filter/wiris/integration/lib/sys/io/FileInput.class.php
@@ -0,0 +1,103 @@
+<?php
+
+class sys_io_FileInput extends haxe_io_Input {
+	public function __construct($f) {
+		if(!php_Boot::$skip_constructor) {
+		$this->__f = $f;
+	}}
+	public function readLine() {
+		$r = fgets($this->__f);
+		if((false === $r)) {
+			throw new HException(new haxe_io_Eof());
+		}
+		return rtrim($r, "\x0D\x0A");
+	}
+	public function eof() {
+		return feof($this->__f);
+	}
+	public function tell() {
+		$r = ftell($this->__f);
+		if(($r === false)) {
+			sys_io_FileInput_0($this, $r);
+		}
+		return $r;
+	}
+	public function seek($p, $pos) {
+		$w = null;
+		$t = ($pos);
+		switch($t->index) {
+		case 0:
+		{
+			$w = SEEK_SET;
+		}break;
+		case 1:
+		{
+			$w = SEEK_CUR;
+		}break;
+		case 2:
+		{
+			$w = SEEK_END;
+		}break;
+		}
+		$r = fseek($this->__f, $p, $w);
+		if(($r === false)) {
+			throw new HException(haxe_io_Error::Custom("An error occurred"));
+		}
+	}
+	public function close() {
+		parent::close();
+		if($this->__f !== null) {
+			fclose($this->__f);
+		}
+	}
+	public function readBytes($s, $p, $l) {
+		if(feof($this->__f)) {
+			sys_io_FileInput_1($this, $l, $p, $s);
+		}
+		$r = fread($this->__f, $l);
+		if(($r === false)) {
+			sys_io_FileInput_2($this, $l, $p, $r, $s);
+		}
+		$b = haxe_io_Bytes::ofString($r);
+		$s->blit($p, $b, 0, strlen($r));
+		return strlen($r);
+	}
+	public function readByte() {
+		if(feof($this->__f)) {
+			sys_io_FileInput_3($this);
+		}
+		$r = fread($this->__f, 1);
+		if(($r === false)) {
+			sys_io_FileInput_4($this, $r);
+		}
+		return ord($r);
+	}
+	public $__f;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $__properties__ = array("set_bigEndian" => "setEndian");
+	function __toString() { return 'sys.io.FileInput'; }
+}
+function sys_io_FileInput_0(&$this, &$r) {
+	throw new HException(haxe_io_Error::Custom("An error occurred"));
+}
+function sys_io_FileInput_1(&$this, &$l, &$p, &$s) {
+	throw new HException(new haxe_io_Eof());
+}
+function sys_io_FileInput_2(&$this, &$l, &$p, &$r, &$s) {
+	throw new HException(haxe_io_Error::Custom("An error occurred"));
+}
+function sys_io_FileInput_3(&$this) {
+	throw new HException(new haxe_io_Eof());
+}
+function sys_io_FileInput_4(&$this, &$r) {
+	throw new HException(haxe_io_Error::Custom("An error occurred"));
+}
diff --git a/filter/wiris/integration/lib/sys/io/FileOutput.class.php b/filter/wiris/integration/lib/sys/io/FileOutput.class.php
new file mode 100644
index 0000000..6a32488
--- /dev/null
+++ b/filter/wiris/integration/lib/sys/io/FileOutput.class.php
@@ -0,0 +1,88 @@
+<?php
+
+class sys_io_FileOutput extends haxe_io_Output {
+	public function __construct($f) {
+		if(!php_Boot::$skip_constructor) {
+		$this->__f = $f;
+	}}
+	public function tell() {
+		$r = ftell($this->__f);
+		if(($r === false)) {
+			sys_io_FileOutput_0($this, $r);
+		}
+		return $r;
+	}
+	public function seek($p, $pos) {
+		$w = null;
+		$t = ($pos);
+		switch($t->index) {
+		case 0:
+		{
+			$w = SEEK_SET;
+		}break;
+		case 1:
+		{
+			$w = SEEK_CUR;
+		}break;
+		case 2:
+		{
+			$w = SEEK_END;
+		}break;
+		}
+		$r = fseek($this->__f, $p, $w);
+		if(($r === false)) {
+			throw new HException(haxe_io_Error::Custom("An error occurred"));
+		}
+	}
+	public function close() {
+		parent::close();
+		if($this->__f !== null) {
+			fclose($this->__f);
+		}
+	}
+	public function flush() {
+		$r = fflush($this->__f);
+		if(($r === false)) {
+			throw new HException(haxe_io_Error::Custom("An error occurred"));
+		}
+	}
+	public function writeBytes($b, $p, $l) {
+		$s = $b->readString($p, $l);
+		if(feof($this->__f)) {
+			sys_io_FileOutput_1($this, $b, $l, $p, $s);
+		}
+		$r = fwrite($this->__f, $s, $l);
+		if(($r === false)) {
+			sys_io_FileOutput_2($this, $b, $l, $p, $r, $s);
+		}
+		return $r;
+	}
+	public function writeByte($c) {
+		$r = fwrite($this->__f, chr($c));
+		if(($r === false)) {
+			throw new HException(haxe_io_Error::Custom("An error occurred"));
+		}
+	}
+	public $__f;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static $__properties__ = array("set_bigEndian" => "setEndian");
+	function __toString() { return 'sys.io.FileOutput'; }
+}
+function sys_io_FileOutput_0(&$this, &$r) {
+	throw new HException(haxe_io_Error::Custom("An error occurred"));
+}
+function sys_io_FileOutput_1(&$this, &$b, &$l, &$p, &$s) {
+	throw new HException(new haxe_io_Eof());
+}
+function sys_io_FileOutput_2(&$this, &$b, &$l, &$p, &$r, &$s) {
+	throw new HException(haxe_io_Error::Custom("An error occurred"));
+}
diff --git a/filter/wiris/integration/lib/sys/io/FileSeek.enum.php b/filter/wiris/integration/lib/sys/io/FileSeek.enum.php
new file mode 100644
index 0000000..639bc2a
--- /dev/null
+++ b/filter/wiris/integration/lib/sys/io/FileSeek.enum.php
@@ -0,0 +1,11 @@
+<?php
+
+class sys_io_FileSeek extends Enum {
+	public static $SeekBegin;
+	public static $SeekCur;
+	public static $SeekEnd;
+	public static $__constructors = array(0 => 'SeekBegin', 1 => 'SeekCur', 2 => 'SeekEnd');
+	}
+sys_io_FileSeek::$SeekBegin = new sys_io_FileSeek("SeekBegin", 0);
+sys_io_FileSeek::$SeekCur = new sys_io_FileSeek("SeekCur", 1);
+sys_io_FileSeek::$SeekEnd = new sys_io_FileSeek("SeekEnd", 2);
diff --git a/filter/wiris/integration/lib/sys/net/Host.class.php b/filter/wiris/integration/lib/sys/net/Host.class.php
new file mode 100644
index 0000000..e7a518c
--- /dev/null
+++ b/filter/wiris/integration/lib/sys/net/Host.class.php
@@ -0,0 +1,42 @@
+<?php
+
+class sys_net_Host {
+	public function __construct($name) {
+		if(!php_Boot::$skip_constructor) {
+		$this->hostName = $name;
+		if(_hx_deref(new EReg("^(\\d{1,3}\\.){3}\\d{1,3}\$", ""))->match($name)) {
+			$this->_ip = $name;
+		} else {
+			$this->_ip = gethostbyname($name);
+			if($this->_ip === $name) {
+				$this->ip = 0 | 0;
+				return;
+			}
+		}
+		$p = _hx_explode(".", $this->_ip);
+		$this->ip = intval(sprintf("%02X%02X%02X%02X", $p[3], $p[2], $p[1], $p[0]), 16) | 0;
+	}}
+	public function reverse() {
+		return gethostbyaddress($this->_ip);
+	}
+	public function toString() {
+		return $this->_ip;
+	}
+	public $ip;
+	public $hostName;
+	public $_ip;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function localhost() {
+		return $_SERVER["HTTP_HOST"];
+	}
+	function __toString() { return $this->toString(); }
+}
diff --git a/filter/wiris/integration/lib/sys/net/Socket.class.php b/filter/wiris/integration/lib/sys/net/Socket.class.php
new file mode 100644
index 0000000..a6fa2bb
--- /dev/null
+++ b/filter/wiris/integration/lib/sys/net/Socket.class.php
@@ -0,0 +1,135 @@
+<?php
+
+class sys_net_Socket {
+	public function __construct() {
+		if(!php_Boot::$skip_constructor) {
+		$this->input = new sys_io_FileInput(null);
+		$this->output = new sys_io_FileOutput(null);
+		$this->protocol = "tcp";
+	}}
+	public function waitForRead() {
+		sys_net_Socket::select(new _hx_array(array($this)), null, null, null);
+	}
+	public function setFastSend($b) {
+		throw new HException("Not implemented");
+	}
+	public function setBlocking($b) {
+		$r = stream_set_blocking($this->__s, $b);
+		sys_net_Socket::checkError($r, 0, "Unable to block");
+	}
+	public function setTimeout($timeout) {
+		$s = intval($timeout);
+		$ms = intval(($timeout - $s) * 1000000);
+		$r = stream_set_timeout($this->__s, $s, $ms);
+		sys_net_Socket::checkError($r, 0, "Unable to set timeout");
+	}
+	public function host() {
+		$r = stream_socket_get_name($this->__s, false);
+		sys_net_Socket::checkError($r, 0, "Unable to retrieve the host name");
+		return $this->hpOfString($r);
+	}
+	public function peer() {
+		$r = stream_socket_get_name($this->__s, true);
+		sys_net_Socket::checkError($r, 0, "Unable to retrieve the peer name");
+		return $this->hpOfString($r);
+	}
+	public function hpOfString($s) {
+		$parts = _hx_explode(":", $s);
+		if($parts->length === 2) {
+			return _hx_anonymous(array("host" => new sys_net_Host($parts[0]), "port" => Std::parseInt($parts[1])));
+		} else {
+			return _hx_anonymous(array("host" => new sys_net_Host(_hx_substr($parts[1], 2, null)), "port" => Std::parseInt($parts[2])));
+		}
+	}
+	public function accept() {
+		$r = stream_socket_accept($this->__s);
+		sys_net_Socket::checkError($r, 0, "Unable to accept connections on socket");
+		$s = new sys_net_Socket();
+		$s->__s = $r;
+		$s->assignHandler();
+		return $s;
+	}
+	public function bind($host, $port) {
+		$errs = null;
+		$errn = null;
+		$r = stream_socket_server($this->protocol . "://" . $host->_ip . ":" . _hx_string_rec($port, ""), $errn, $errs, (($this->protocol === "udp") ? STREAM_SERVER_BIND : STREAM_SERVER_BIND | STREAM_SERVER_LISTEN));
+		sys_net_Socket::checkError($r, $errn, $errs);
+		$this->__s = $r;
+		$this->assignHandler();
+	}
+	public function shutdown($read, $write) {
+		$r = null;
+		if(function_exists("stream_socket_shutdown")) {
+			$rw = (($read && $write) ? 2 : (($write) ? 1 : (($read) ? 0 : 2)));
+			$r = stream_socket_shutdown($this->__s, $rw);
+		} else {
+			$r = fclose($this->__s);
+		}
+		sys_net_Socket::checkError($r, 0, "Unable to Shutdown");
+	}
+	public function listen($connections) {
+		throw new HException("Not implemented");
+	}
+	public function connect($host, $port) {
+		$errs = null;
+		$errn = null;
+		$r = stream_socket_client($this->protocol . "://" . $host->_ip . ":" . _hx_string_rec($port, ""), $errn, $errs);
+		sys_net_Socket::checkError($r, $errn, $errs);
+		$this->__s = $r;
+		$this->assignHandler();
+	}
+	public function write($content) {
+		fwrite($this->__s, $content);
+		return;
+	}
+	public function read() {
+		$b = "";
+		while (!feof($this->__s)) $b .= fgets($this->__s);
+		return $b;
+	}
+	public function close() {
+		fclose($this->__s);
+		{
+			$this->input->__f = null;
+			$this->output->__f = null;
+		}
+		$this->input->close();
+		$this->output->close();
+	}
+	public function assignHandler() {
+		$this->input->__f = $this->__s;
+		$this->output->__f = $this->__s;
+	}
+	public $custom;
+	public $output;
+	public $input;
+	public $protocol;
+	public $__s;
+	public function __call($m, $a) {
+		if(isset($this->$m) && is_callable($this->$m))
+			return call_user_func_array($this->$m, $a);
+		else if(isset($this->dynamics[$m]) && is_callable($this->dynamics[$m]))
+			return call_user_func_array($this->dynamics[$m], $a);
+		else if('toString' == $m)
+			return $this->__toString();
+		else
+			throw new HException('Unable to call '.$m.'');
+	}
+	static function checkError($r, $code, $msg) {
+		if(!($r === false)) {
+			return;
+		}
+		throw new HException(haxe_io_Error::Custom("Error [" . _hx_string_rec($code, "") . "]: " . $msg));
+	}
+	static function getType($isUdp) {
+		return (($isUdp) ? SOCK_DGRAM : SOCK_STREAM);
+	}
+	static function getProtocol($protocol) {
+		return getprotobyname($protocol);
+	}
+	static function select($read, $write, $others, $timeout = null) {
+		throw new HException("Not implemented");
+		return null;
+	}
+	function __toString() { return 'sys.net.Socket'; }
+}
diff --git a/filter/wiris/integration/lib/tech.txt b/filter/wiris/integration/lib/tech.txt
new file mode 100644
index 0000000..2c0ea7b
--- /dev/null
+++ b/filter/wiris/integration/lib/tech.txt
@@ -0,0 +1 @@
+php
diff --git a/filter/wiris/integration/lib/wirisplugin.css b/filter/wiris/integration/lib/wirisplugin.css
new file mode 100644
index 0000000..64aab49
--- /dev/null
+++ b/filter/wiris/integration/lib/wirisplugin.css
@@ -0,0 +1,43 @@
+body.wirisplugincleancache {
+    width: 600px;
+    margin: auto;
+    font-family: 'Segoe UI',Arial,Helvetica,sans-serif;
+    background-color: #E0E0E0;
+    text-align:center;
+}
+
+h2.wirisplugincleancache {
+    color: #4d626e;
+    font-size: 24px;
+    margin: 0px;
+    margin-bottom: 10px;
+    text-align: left;
+}
+
+div {
+    display: block;
+}
+div.wirismaincontainer {
+    padding: 1em;
+    margin-top: 10px;
+    background-color: white;
+}
+
+div.wirisplugincleancacheform {    
+    margin: 0 auto; 
+    display: inline-block;
+    text-align: right;
+}
+
+div.wirisplugincleancacheresults {    
+    text-align: center;
+    vertical-align:middle;
+}
+
+span.wirisplugincleancachewarning {
+    color: red;    
+}
+
+span.wirisplugincleancachetextform {
+    text-align: left;
+}
diff --git a/filter/wiris/integration/moodleparamsprovider.php b/filter/wiris/integration/moodleparamsprovider.php
new file mode 100644
index 0000000..011422f
--- /dev/null
+++ b/filter/wiris/integration/moodleparamsprovider.php
@@ -0,0 +1,76 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+require_once('../../../lib/moodlelib.php');
+
+class MoodleParamsProvider implements com_wiris_plugin_api_ParamsProvider {
+
+    private $parameters = array();
+    private $serviceparamlist = array('mml', 'lang', 'service', 'latex');
+    private $wrap;
+
+    public function __construct() {
+        $this->wrap = com_wiris_system_CallWrapper::getInstance();
+    }
+
+    public function getrequiredparameter($paramname) {
+        $this->wrap->stop();
+        $param = required_param($paramname, PARAM_RAW);
+        $this->wrap->start();
+        return $param;
+    }
+
+    public function getparameter($paramname, $dflt) {
+        $this->wrap->stop();
+        $param = optional_param($paramname, $dflt, PARAM_RAW);
+        $this->wrap->start();
+        return $param;
+    }
+
+    public function getparameters() {
+        return $this->parameters;
+    }
+
+    public function getserviceparameters() {
+        $this->wrap->stop();
+        $serviceparams = array();
+        foreach ($this->serviceparamlist as $key) {
+            if ($serviceparam = optional_param($key, false, PARAM_RAW)) {
+                $serviceparams[$key] = $serviceparam;
+            }
+        }
+        $this->wrap->start();
+        return $serviceparams;
+
+    }
+
+    public function getrenderparameters($configuration) {
+        $this->wrap->stop();
+        $renderparams = array();
+        // Can't change EDITOR_PARAMETER_LIST variable name so at this point condingStandars should be disabled.
+        // @codingStandardsIgnoreStart
+        $renderparameterlist = explode(",", $configuration->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_LIST, com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_DEFAULT_LIST));
+        // @codingStandardsIgnoreEnd
+        $i = null;
+        foreach ($renderparameterlist as $key) {
+            if ($renderparam = optional_param($key, false, PARAM_RAW)) {
+                $renderparams[$key] = $renderparam;
+            }
+        }
+        $this->wrap->start();
+        return $renderparams;
+    }
+}
diff --git a/filter/wiris/integration/phpparamsprovider.php b/filter/wiris/integration/phpparamsprovider.php
new file mode 100644
index 0000000..a1fa322
--- /dev/null
+++ b/filter/wiris/integration/phpparamsprovider.php
@@ -0,0 +1,53 @@
+<?php
+class PhpParamsProvider implements com_wiris_plugin_api_ParamsProvider {
+
+    private $parameters = array();
+    private $serviceParamsList = array('mml', 'lang', 'service', 'latex');
+
+    public function __construct() {
+        $this->parameters = array_merge($_GET, $_POST);
+    }
+
+    public function getRequiredParameter($paramname) {
+        if (array_key_exists($paramname, $this->parameters)) {
+            return $this->parameters[$paramname];
+        } else {
+            throw new Exception('Missing param ' . $paramname);
+        }
+    }
+
+    public function getParameter($paramname, $dflt) {
+        if (array_key_exists($paramname, $this->parameters)) {
+            return $this->parameters[$paramname];
+        } else {
+            return $dflt;
+        }
+    }
+
+    public function getParameters() {
+        return $this->parameters;
+    }
+
+    public function getServiceParameters() {
+        $serviceParams = array();
+        foreach ($this->serviceParamsList as $key) {
+            if (array_key_exists($key, $this->parameters)) {
+                $serviceParams[$key] = $this->parameters[$key];
+            }
+        }
+        return $serviceParams;
+
+    }
+
+    public function getRenderParameters($configuration) {
+        $renderParams = array();
+        $renderParameterList = explode(",", $configuration->getProperty(com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_LIST, com_wiris_plugin_api_ConfigurationKeys::$EDITOR_PARAMETERS_DEFAULT_LIST));
+        $i = null;
+        foreach ($renderParameterList as $key) {
+            if (array_key_exists($key, $this->parameters)) {
+                $renderParams[$key] = $this->parameters[$key];
+            }
+        }
+        return $renderParams;
+    }
+}
diff --git a/filter/wiris/integration/plugin.php b/filter/wiris/integration/plugin.php
new file mode 100644
index 0000000..0d26d0f
--- /dev/null
+++ b/filter/wiris/integration/plugin.php
@@ -0,0 +1,5 @@
+<?php
+if (!class_exists('com_wiris_system_CallWrapper', false)) {
+    require_once dirname(__FILE__).'/lib/com/wiris/system/CallWrapper.class.php';
+}
+com_wiris_system_CallWrapper::getInstance()->init(dirname(__FILE__));
diff --git a/filter/wiris/integration/pluginbuilder.php b/filter/wiris/integration/pluginbuilder.php
new file mode 100644
index 0000000..ffe1f4f
--- /dev/null
+++ b/filter/wiris/integration/pluginbuilder.php
@@ -0,0 +1,61 @@
+<?php
+// ${license.statement}
+require_once ('plugin.php');
+
+$wrap = com_wiris_system_CallWrapper::getInstance();
+$wrap->start();
+$pluginBuilder = com_wiris_plugin_api_PluginBuilder::getInstance();
+$wrap->stop();
+
+$moodle = file_exists('..' . DIRECTORY_SEPARATOR . 'version.php');
+
+if ($moodle) {
+    require_once('../../../' . 'config.php');
+    require_once($CFG->dirroot . '/filter/wiris/lib.php');
+    if (!class_exists('moodlefilecache')) {
+        require_once($CFG->dirroot . '/filter/wiris/classes/moodlefilecache.php');
+    }
+    if (!class_exists('moodledbcache')) {
+        require_once($CFG->dirroot . '/filter/wiris/classes/moodledbcache.php');
+    }
+    if (!class_exists('moodledbjsoncache')) {
+        require_once($CFG->dirroot . '/filter/wiris/classes/moodledbjsoncache.php');
+    }
+    // Automatic class loading not avaliable for Moodle 2.4 and 2.5.
+    wrs_loadclasses();
+    // define('NO_MOODLE_COOKIES', true); // Because it interferes with caching
+    $scriptName = explode('/', $_SERVER['SCRIPT_FILENAME']);
+    $scriptName = array_pop($scriptName);
+
+    if ($scriptName == 'showimage.php') {
+        define('ABORT_AFTER_CONFIG', true);
+        if (!defined('MOODLE_INTERNAL')) {
+            define('MOODLE_INTERNAL', true); // Moodle 2.2 - 2.5 min config doesn't define 'MOODLE_INTERNAL'.
+        }
+    }
+    $wrap->start();
+    $pluginBuilder->addConfigurationUpdater(new filter_wiris_configurationupdater());
+    $pluginBuilder->setCustomParamsProvider(new filter_wiris_paramsprovider());
+    $pluginBuilder->addConfigurationUpdater(new com_wiris_plugin_web_PhpConfigurationUpdater());
+    $pluginBuilder->getConfiguration()->getFullConfiguration();
+    // Class to manage file cache.
+    if ($pluginBuilder->getConfiguration()->getProperty('wirispluginperformance', 'false') == 'false' || 
+            $pluginBuilder->getConfiguration()->getProperty('wirisimageformat', 'png') == 'png') {
+        $cachefile = new moodlefilecache('filter_wiris', 'images');
+    }
+    else {
+        $cachefile = new moodledbjsoncache('filter_wiris_formulas', 'md5', 'jsoncontent');
+    }
+    $pluginBuilder->setStorageAndCacheCacheObject($cachefile);
+    // Class to manage formulas (i.e plain text) cache.
+    $cachedb = new moodledbcache('filter_wiris_formulas', 'md5', 'content');
+    $pluginBuilder->setStorageAndCacheCacheFormulaObject($cachedb);
+
+} else {
+    $wrap->start();
+    require_once('phpparamsprovider.php');
+    $pluginBuilder->setCustomParamsProvider(new PhpParamsProvider());
+    $pluginBuilder->addConfigurationUpdater(new com_wiris_plugin_web_PhpConfigurationUpdater());
+    $pluginBuilder->setStorageAndCacheCacheObject(new com_wiris_plugin_impl_CacheImpl($pluginBuilder->getConfiguration()->getFullConfiguration()));
+    $pluginBuilder->setStorageAndCacheCacheFormulaObject(new com_wiris_plugin_impl_CacheFormulaImpl($pluginBuilder->getConfiguration()->getFullConfiguration()));
+}
diff --git a/filter/wiris/integration/resource.php b/filter/wiris/integration/resource.php
new file mode 100644
index 0000000..60d526a
--- /dev/null
+++ b/filter/wiris/integration/resource.php
@@ -0,0 +1,10 @@
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+$provider = $pluginBuilder->getCustomParamsProvider();
+$resource = $provider->getRequiredParameter('resourcefile');
+
+$resourceLoader = $pluginBuilder->newResourceLoader();
+header('Content-Type:' . $resourceLoader->getContentType($resource));
+echo $resourceLoader->getcontent($resource);
diff --git a/filter/wiris/integration/service.php b/filter/wiris/integration/service.php
new file mode 100644
index 0000000..b9aa9e0
--- /dev/null
+++ b/filter/wiris/integration/service.php
@@ -0,0 +1,25 @@
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+$provider = $pluginBuilder->getCustomParamsProvider();
+
+$service = $provider->getRequiredParameter('service');
+$mml = $provider->getParameter('mml', null);
+$latex = $provider->getParameter('latex', null);
+$lang = $provider->getParameter('lang', 'en');
+
+$render = $pluginBuilder->newTextService();
+
+if (get_magic_quotes_gpc() == 1) {
+    $params = array_map('stripslashes', $params);
+}
+
+// Adding - if necessary - CORS headers
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+$r = $render->service($service, $provider);
+header('Content-Type: text/plain; charset=utf-8');
+echo $r;
diff --git a/filter/wiris/integration/showcasimage.php b/filter/wiris/integration/showcasimage.php
new file mode 100644
index 0000000..562f4d5
--- /dev/null
+++ b/filter/wiris/integration/showcasimage.php
@@ -0,0 +1,16 @@
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+$provider = $pluginBuilder->getCustomParamsProvider();
+$formula = $provider->getRequiredParameter('formula');
+$cas = $pluginBuilder->newCas();
+
+// Adding - if necessary - CORS headers
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+$r = $cas->showCasImage($formula, null);
+header('Content-Type: image/png');
+echo $r;
diff --git a/filter/wiris/integration/showimage.php b/filter/wiris/integration/showimage.php
new file mode 100644
index 0000000..c3f31ef
--- /dev/null
+++ b/filter/wiris/integration/showimage.php
@@ -0,0 +1,48 @@
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+$provider = $pluginBuilder->getCustomParamsProvider();
+
+$digest = $provider->getParameter('formula', null);
+$mml = $provider->getParameter('mml', null);
+$render = $pluginBuilder->newRender();
+$jsonformat = $provider->getParameter('jsonformat', null);
+$lang = $provider->getParameter('lang', 'en');
+
+// Backwards compatibility.
+// showimage.php?formula.png --> showimage.php?formula.
+// because formula is md5 string, remove all extensions.
+if (!is_null($digest)) {
+    $a = explode(".", $digest);
+    $digest = array_shift($a);
+}
+
+// Adding - if necessary - CORS headers
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+if ($pluginBuilder->getConfiguration()->getProperty("wirispluginperformance", "false") == "true") {
+
+    // Cache headers
+    header("Content-type: application/json");
+    header("Pragma:"); // HTTP 1.0
+    header("Cache-Control: public, max-age=3600"); // HTTP 1.1
+    // If digest == null formula is not in cache.
+    if (is_null($digest)) {
+        $render->showImage(null, $mml, $provider);
+        $digest = $render->computeDigest($mml, $provider->getRenderParameters($pluginBuilder->getConfiguration()));
+    }
+    $r = $render->showImageJson($digest, $lang);
+    // If a formula is not in server cache, this request shouldn't be cached.
+    if (strpos($r, "warning" )) {
+        header("Pragma: no-cache"); // HTTP 1.0
+        header("Cache-Control: no-cache, no-store, must-revalidate"); //HTTP 1.1
+    }
+} else {
+    $contentType = $pluginBuilder->getImageFormatController()->getContentType();
+    header('Content-Type: ' . $contentType);
+    $r = $render->showImage($digest, $mml, $provider);
+}
+echo $r;
diff --git a/filter/wiris/integration/test.php b/filter/wiris/integration/test.php
new file mode 100644
index 0000000..4fcefce
--- /dev/null
+++ b/filter/wiris/integration/test.php
@@ -0,0 +1,12 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+<?php
+// ${license.statement}
+require_once ('pluginbuilder.php');
+
+// Adding - if necessary - CORS headers.
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+$render = $pluginBuilder->newTest();
+echo $render->getTestPage();
diff --git a/filter/wiris/integration/testfilter.php b/filter/wiris/integration/testfilter.php
new file mode 100644
index 0000000..c2ac189
--- /dev/null
+++ b/filter/wiris/integration/testfilter.php
@@ -0,0 +1,18 @@
+<?php
+// ${license.statement}
+
+// Please, set if called from the command line.
+// $_SERVER['SCRIPT_NAME'] = "/generic/integration/filter.php";
+require_once ('pluginbuilder.php');
+$text = $pluginBuilder->newTextService();
+$input = "<html><body><b>Formula: </b><math><mfrac><mi>x</mi><mn>1000</mn></mfrac></math></body></html>";
+$params = null;
+$output = $text->filter($input, $params);
+
+// Adding - if necessary - CORS headers
+$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : "";
+$res = new com_wiris_system_service_HttpResponse();
+$pluginBuilder->addCorsHeaders($res, $origin);
+
+header('Content-Type: text/html;charset=UTF-8');
+echo $output;
diff --git a/filter/wiris/integration/update.php b/filter/wiris/integration/update.php
new file mode 100644
index 0000000..ef7fa93
--- /dev/null
+++ b/filter/wiris/integration/update.php
@@ -0,0 +1,34 @@
+<?php
+/**
+ * This script makes the necessary changes to saved data files so they 
+ * perfectly work with the current version of WIRIS plugin. You should run it
+ * once after updating WIRIS plugin. You can safely run it more than one time.
+ * This file shouln't be publicly available.
+ *
+ * - It updates the folder structure so it increases the filesystem access
+ *   efficiency creating a file hierarchy instead of having all files in the
+ *   root of formula and cache directories.
+ *
+ **/
+ 
+// WARNING: Comment the following line before using this script, and re-comment
+// it once done.
+header('HTTP/1.0 403 Forbidden'); 
+echo '<h3>Forbidden</h3><p>If you are the server administrator, comment the first code line in update.php script.</p>'; 
+die();
+  
+// Load WIRIS plugin.
+require_once ('pluginbuilder.php');
+// Set PHP environment.
+set_time_limit(0); 
+error_reporting(E_ALL); 
+ini_set("display_errors", 1);
+// Load the file handler object.
+$store = $pluginBuilder->getStorageAndCache();
+// Do the update.
+if (method_exists($store, 'updateFoldersStructure')) {
+    $store->updateFoldersStructure();
+}
+// Finish script.
+echo '<h3>WIRIS plugin data successfully updated</h3>';
+echo '<p>Remember to uncomment the security line in update.php file to forbid the access to this script to the public.</p>';
diff --git a/filter/wiris/lang/en/filter_wiris.php b/filter/wiris/lang/en/filter_wiris.php
new file mode 100644
index 0000000..eb34fe4
--- /dev/null
+++ b/filter/wiris/lang/en/filter_wiris.php
@@ -0,0 +1,71 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+//
+
+$string['alloweditorpluginactive'] = 'Allow WIRIS Editor always active';
+$string['alloweditorpluginactive_help'] = 'WIRIS Editor plugin would be enabled regardless of WIRIS filter is disabled at course or activity level. By default if WIRIS filter is disabled in a course/activity, WIRIS Editor is also disabled in the same course/activity.';
+$string['area'] = 'area';
+$string['arenotinstalled'] = 'are not installed. ';
+$string['atto'] = 'Atto';
+$string['button1'] = 'WIRIS plugin for tests';
+$string['button2'] = 'WIRIS quizzes tests';
+$string['cachedef_images'] = 'WIRIS Plugin images';
+$string['clearcache'] = 'Clear cache';
+$string['clearcachedesc'] = 'Clear wiris filter cache';
+$string['clickwirisplugincorrectlyinstalled'] = 'Click the following button to test if the WIRIS plugin is correctly installed.';
+$string['clickwirisquizzescorrectlyinstalled'] = 'Click the following button to test if the WIRIS quizzes is correctly installed.';
+$string['contact'] = 'For more information or if you have any doubt contact WIRIS Support:';
+$string['editornameexpected'] = 'Editor name is expected';
+$string['enabled'] = 'Enabled';
+$string['disabled'] = 'Disabled';
+$string['error'] = 'Error';
+$string['errordeletingcache'] = 'Error deleting cache on {$a} area';
+$string['errorsavingcache'] = 'Error saving cache on {$a} area';
+$string['filtername'] = 'Math & Science by WIRIS';
+$string['filter_standalone'] = 'WIRIS filter only';
+$string['filter_standalonedesc'] = 'You will be able to display existing formulas but creation of new formulas is not available. It also removes the warning message.';
+$string['filtermustbeinstalled'] = 'Filter must be installed in Moodle filter folder.';
+$string['furtherinformation'] = 'For further information see our documentation page ';
+$string['havesameversion'] = ' have the same version';
+$string['impossibletofindwirisfilterversion'] = 'Impossible to find WIRIS plugin filter version file.';
+$string['lookingforcorrectfolder'] = 'Looking for correct folder';
+$string['lookingforfilterfiles'] = 'Looking for filter files';
+$string['lookingforwirisfilterversion'] = 'Looking for WIRIS plugin filter version';
+$string['lookingforwirisplugin'] = 'Looking for WIRIS plugin for ';
+$string['lookingforwirispluginenabled'] = 'Looking for WIRIS plugin enabled for  ';
+$string['mustbeinstalled'] = ' must be installed.';
+$string['noteditorspluginsinstalled'] = 'There are not editors plugins installed';
+$string['notsupportededitor'] = ' is not a supported editor.';
+$string['ok'] = 'Ok';
+$string['oldconfiguration'] = 'An old configuration.ini file has been detected on {$a}. Please move it to /filter/wiris/configuration.ini.';
+$string['onlytextareaeditorinstalled'] = 'There are only a textarea editors plugin installed';
+$string['or'] = 'or ';
+$string['pluginname'] = 'WIRIS filter';
+$string['title'] = 'Moodle 2.x WIRIS plugin filter test page';
+$string['tinymce'] = 'TinyMCE';
+$string['uninstallmode'] = 'Uninstall mode';
+$string['uninstallmodedesc'] = 'Allows WIRIS plugin to be uninstalled';
+$string['version'] = 'version';
+$string['versionsdontmatch'] = ' versions don\'t match';
+$string['wirisfilterversion'] = 'WIRIS Filter version = ';
+$string['wirispluginfilterfor'] = 'WIRIS plugin filter and WIRIS plugin for ';
+$string['wirispluginfor'] = 'WIRIS plugin for ';
+$string['wirispluginforatto'] = 'WIRIS PLUGIN for Atto ';
+$string['wirispluginfortinymce'] = 'WIRIS PLUGIN for TinyMCE ';
+$string['wirismatheditor'] = 'Math editor';
+$string['wirispluginfiltermustbeinstalled'] = 'WIRIS plugin filter for Moodle 2.x must be installed.';
+$string['wirischemeditor'] = 'Chemistry editor';
+$string['wiriscas'] = 'Calculator';
diff --git a/filter/wiris/lib.php b/filter/wiris/lib.php
new file mode 100644
index 0000000..99504f4
--- /dev/null
+++ b/filter/wiris/lib.php
@@ -0,0 +1,176 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Library functions for WIRIS filter.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * Return an array with the position of the tags named $name on $code variable.
+ * @param  String  $code       html code.
+ * @param  String  $name       tag name.
+ * @param  String  $autoclosed indicates if the tag is autoclosed.
+ * @param  boolean $all        indicates if the array should contain all the tags or only the first one.
+ * @param  int     $offset      search will start this number of characters counted from the beginning of the string
+ * @return array
+ */
+function wrs_getelementsbynamefromstring($code, $name, $autoclosed, $all = false, $offset = 0) {
+    $elements = array();
+    $code = strtolower($code);
+    $name = strtolower($name);
+    $start = strpos($code, "<" . $name . " ", $offset);
+
+    $i = 0;
+    while ($start) {
+        if ($autoclosed) {
+            $endstring = '>';
+        } else {
+            $endstring = '</' . $name . '>';
+        }
+
+        $end = strpos($code, $endstring, $start);
+
+        if ($end) {
+            $end += strlen($endstring);
+            $element = array();
+            $element['start'] = $start;
+            $element['end'] = $end;
+            $elements[$i] = $element;
+            $i++;
+        } else {
+            $end = $start + 1;
+        }
+
+        $start = strpos($code, '<' . $name . ' ', $end);
+        if (!$all) {
+            break;
+        }
+
+    }
+
+    return $elements;
+}
+
+/**
+ * Create CAS initial session id.
+ * @return String
+ */
+function wrs_createsessionid() {
+    $template = array(8, 4, 4, 4, 12);
+    $id = '';
+    for ($j = 0; $j < count($template); $j++) {
+        if ($j > 0) {
+            $id .= '-';
+        }
+        for ($i = 0; $i <= $template[$j]; $i++) {
+            $c = strtoupper(dechex((int)floor(mt_rand() / mt_getrandmax() * 16)));
+            $id .= $c;
+        }
+    }
+    return $id;
+}
+
+/**
+ * Set initial session on server
+ * @param  String $sessionid WIRIS Cas session id.
+ * @param  String $xml       xml session.
+ */
+function wrs_setinitialsession($sessionid, $xml) {
+    $wrap = com_wiris_system_CallWrapper::getInstance();
+    $wrap->start();
+    $h = new com_wiris_plugin_impl_HttpImpl('https://stateful.wiris.net/wiris/set', null);
+    $h->setParameter('session_id', $sessionid);
+    $h->setParameter('value', $xml);
+    $h->setParameter('revision', 1);
+    $post = true;
+    $h->request($post);
+    $wrap->stop();
+}
+
+/**
+ * Includes a <nonapplet> tag on all the <APPLET> tags with an image linking a WIRIS cas jnlp containing the applet session.
+ * This allows to download WIRIS cas jnlp for chrome browsers.
+ * @param  String $text with <APPLET_TAGS>
+ * @return String Filtered text.
+ */
+function wrs_filterapplettojnlp($text) {
+
+    // An array containing the first applet tag. Don't get all because we use recursion on
+    // $text and the long of the $text changes dynamically.
+    $appletlist = wrs_getelementsbynamefromstring($text, 'applet', false, false);
+
+    $i = 0;
+    while (count($appletlist) != 0) {
+        $output = '';
+        $appletcode = htmlspecialchars_decode(substr($text, $appletlist[$i]['start'], $appletlist[$i]['end']));
+        if (strpos($appletcode, ' src="') && strpos($appletcode, 'value="<session')) {
+            $sessionid = wrs_createsessionid();
+            $srcstart = strpos($appletcode, ' src="') + strlen(' src="');
+            $srcend = strpos($appletcode, '.png"', 0);
+            $src = substr($appletcode, $srcstart, $srcend - $srcstart + 4);
+            $hreflink = 'http://stateful.wiris.net/demo/wiris/wiriscas.jnlp?session_id=' . $sessionid;
+            $output .= html_writer::start_tag('a', array('href' => $hreflink));
+            $img = '';
+            if (method_exists('html_writer', 'img')) {
+                $img = html_writer::img($src, 'WIRIS CAS');
+            } else {
+                $img .= html_writer::start_tag('img', array('src' => $src));
+                $img .= html_writer::end_tag('img');
+            }
+            $output .= $img;
+            $output .= html_writer::end_tag('a');
+            // We add noapplet tag in order to see CAS image on Chrome browser.
+            $output = '<noapplet>' . $output . '</noapplet>' . '</APPLET>';
+            // Searching applet without </applet> close tag.
+            $appletsubstring = substr($text, $appletlist[$i]['start'], $appletlist[$i]['end'] - $appletlist[$i]['start'] - 9);
+            // Applet substring to be replaced.
+            $search = substr($text, $appletlist[$i]['start'], $appletlist[$i]['end'] - $appletlist[$i]['start']);
+            $output = $appletsubstring . $output;
+            $text = str_replace($search, $output, $text);
+
+            $xmlstart = strpos($appletcode, 'value="<session');
+            $xmlend = strpos($appletcode, '/session>"');
+            $xml = substr($appletcode, $xmlstart + 7, $xmlend - $xmlstart + 2);
+
+            wrs_setinitialsession($sessionid, $xml);
+        }
+        $appletlist = wrs_getelementsbynamefromstring($text, 'applet', false, false, $appletlist[$i]['end']);
+    }
+    return $text;
+}
+
+/**
+ * Automatic class loading not avaliable for Moodle 2.4 and 2.5.
+ * This method loads all files under "classes" folder.
+ *
+ */
+function wrs_loadclasses() {
+    global $CFG;
+
+    if ($CFG->version < 2013111800) {
+        require_once($CFG->dirroot . '/filter/wiris/classes/pluginwrapper.php');
+        require_once($CFG->dirroot . '/filter/wiris/classes/paramsprovider.php');
+        require_once($CFG->dirroot . '/filter/wiris/classes/configurationupdater.php');
+        require_once($CFG->dirroot . '/filter/wiris/classes/pluginwrapperconfigurationupdater.php');
+    }
+}
diff --git a/filter/wiris/pix/icon.png b/filter/wiris/pix/icon.png
new file mode 100644
index 0000000000000000000000000000000000000000..0457614714c81fb6bda350c5ce8b5d6b74fa0182
GIT binary patch
literal 406
zcmeAS@N?(olHy`uVBq!ia0vp^0wB!61|;P_|4#%`EX7WqAsj$Z!;#Vf<Z~8yL>2?p
zUk71ECym(^Ktah8*NBqf{Irtt#G+J&^73-M%)IR4<ivthz5Jr|+3#$m7#J9ZJzX3_
zEP9VlSm<}eL7;8_%>+H&Ht`3X6|6@zJro?9-d}5C+0NNmT-p)K-{kDj<?x__*&t)m
zwZ<n$RCjYk6`5S$>n+eT`{(ojpUxkspZ<mO+AUr|&Bm|urg9dnsyeBpE@*s!!D1e_
zMpqKU8<#V=Q?;+%vK6#sIc0O6yTQbFd&AYVOerS`t)*(RpVOzMu75PAn*G|W8?&Qc
zt3SUZT5#cv+?H#%YXwC<Tr*Q-xqRgQ+?l<}<{Akmm-#2FSh8O-+ZXi8jBCZ~Uu+eb
z>`Fx@i|x}QzX`HRB=6~%b5__@MM{33|AJMk3_sktxJ;>NyT}2F$BlVitsm<d81BY1
xT<<=!pW&Fq`@Q$s-#K%LE4G|YWvE}Lzwb|2^Q4nMPXfb`!PC{xWt~$(69Adapkx35

literal 0
HcmV?d00001

diff --git a/filter/wiris/settings.php b/filter/wiris/settings.php
new file mode 100644
index 0000000..4378cd3
--- /dev/null
+++ b/filter/wiris/settings.php
@@ -0,0 +1,117 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * WIRIS Filter settings.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+if ($ADMIN->fulltree) {
+    global $CFG;
+    global $wirisconfigurationclass;
+
+    require_once("$CFG->dirroot/filter/wiris/lib.php");
+    // Automatic class loading not avaliable for Moodle 2.4 and 2.5.
+    wrs_loadclasses();
+    $wirisplugin = new filter_wiris_pluginwrapper();
+
+    $editorplugininstalled = filter_wiris_pluginwrapper::get_wiris_plugin();
+    if (!empty($editorplugininstalled)) {
+        // Editor checkbox.
+        $output = '';
+        $wirisplugin->begin();
+        $waseditorenabled = $wirisplugin->was_editor_enabled();
+        $waschemeditorenabled = $wirisplugin->was_chem_editor_enabled();
+        $conf = $wirisplugin->get_instance()->getConfiguration();
+        $wirisplugin->end();
+
+        // Backwards compatibility: some old installations could have the configuration
+        // file into the editor plugin inestad of filter. Show a notification to advise
+        // users to copy the file from the older location to the new one.
+        if ($oldconfile = filter_wiris_pluginwrapper::get_old_configuration()) {
+            $warningoutput = get_string('oldconfiguration', 'filter_wiris', $oldconfile);
+
+            \core\notification::warning($warningoutput);
+            $settings->add(new admin_setting_heading('filter_wiris_old_configuration', '', $warningoutput));
+        }
+
+        if ($waseditorenabled) {
+            $settings->add(new admin_setting_configcheckbox('filter_wiris_editor_enable',
+                                                            get_string('wirismatheditor', 'filter_wiris'), '', '1'));
+        }
+
+        if ($waschemeditorenabled) {
+            $settings->add(new admin_setting_configcheckbox('filter_wiris_chem_editor_enable',
+                                                            get_string('wirischemeditor', 'filter_wiris'), '', '0'));
+        }
+
+        // Allow WIRIS Editor plugin be enabled despite of the filter is disabled on a course.
+        $settings->add(new admin_setting_configcheckbox('filter_wiris/allow_editorplugin_active_course',
+                                                            get_string('alloweditorpluginactive', 'filter_wiris'),
+                                                            get_string('alloweditorpluginactive_help', 'filter_wiris'), '0'));
+
+    } else {
+        if (!get_config('filter_wiris', 'filter_standalone')) {
+
+            // Moodle notification API since Moodel 3.1.
+            if ($CFG->version >= 2016052300) {
+                // Due to Moodle doesn't support circular dependencies between plugins, if any editor plugin is installed
+                // a warning message is shown as a notification.
+                $message = '';
+                $tinyurl = 'https://moodle.org/plugins/tinymce_tiny_mce_wiris';
+                $attourl = 'https://moodle.org/plugins/atto_wiris';
+                $linkattributes = array('target' => '_blank');
+                $message .= html_writer::link($attourl, get_string('wirispluginforatto', 'filter_wiris'), $attributes);
+                $message .= get_string('or', 'filter_wiris');
+                $message .= html_writer::link($tinyurl, get_string('wirispluginfortinymce', 'filter_wiris'), $attributes);
+                $message .= get_string('arenotinstalled', 'filter_wiris');
+                $message .= get_string('furtherinformation', 'filter_wiris');
+
+                $imageurl = "https://www.wiris.com/system/files/attachments/1689/WIRIS_manual_icon_17_17.png";
+                $image = html_writer::empty_tag('img', array('src' => $imageurl, 'style' => 'vertical-align:-3px;'));
+                $troubleshootingurl = 'http://www.wiris.com/plugins/docs/moodle/troubleshooting';
+                $imagelink = html_writer::link($troubleshootingurl, $image, $linkattributes);
+
+                $message .= $imagelink;
+
+                // Moodle notification API: https://docs.moodle.org/dev/Notifications.
+                \core\notification::warning($message);
+            }
+
+        }
+        $settings->add(new admin_setting_configcheckbox('filter_wiris/filter_standalone',
+                                                        get_string('filter_standalone',
+                                                        'filter_wiris'),
+                                                        get_string('filter_standalonedesc',
+                                                        'filter_wiris'), false, true, false));
+    }
+
+    $wirisquizzes = dirname(__FILE__) . '/../../question/type/wq/';
+    $quizzesinstalled = file_exists($wirisquizzes);
+
+    if ($quizzesinstalled) {
+        $url = $CFG->wwwroot . '/admin/settings.php?section=qtypesettingwq';
+        $url = '<a href="' . $url . '">WIRIS quizzes settings</a>';
+        $settings->add(new admin_setting_heading('filter_wirisquizzesheading', $url, ''));
+    }
+
+}
diff --git a/filter/wiris/styles.css b/filter/wiris/styles.css
new file mode 100644
index 0000000..faa4d18
--- /dev/null
+++ b/filter/wiris/styles.css
@@ -0,0 +1,23 @@
+body.wrs_plugin.wrs_filter {
+    font-family: Arial;
+}
+span.wrs_plugin.wrs_filter {
+    font-weight: bold;
+}
+span.wrs_ok.wrs_plugin.wrs_filter {
+    color: #009900;
+}
+span.wrs_error.wrs_plugin.wrs_filter {
+    color: #dd0000;
+}
+table.wrs_plugin.wrs_filter, th.wrs_plugin.wrs_filter, td.wrs_plugin.wrs_filter, tr.wrs_plugin.wrs_filter {
+    border: solid 1px #000000;
+    border-collapse: collapse;
+    padding: 5px;
+}
+th.wrs_plugin.wrs_filter {
+    background-color: #eeeeee;
+}
+img.wrs_plugin.wrs_filter {
+    border: none;
+}
diff --git a/filter/wiris/test.html b/filter/wiris/test.html
new file mode 100644
index 0000000..af7fde3
--- /dev/null
+++ b/filter/wiris/test.html
@@ -0,0 +1,163 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+    <head>
+        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
+        <meta name="keywords" content="math,science" />
+        <script type="text/javascript">
+            String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g, '');};
+            function getParameter(name) {
+                var value = new RegExp(name+"=([^&]*)","i").exec(window.location);
+                if (value!=null && value.length>1) {
+                    value = decodeURIComponent(value[1].replace(/\+/g,' '));
+                } else {
+                    value = null;
+                }
+                return value;
+            }
+            function insertHtml(content) {
+                if (content!=null && content.length>0) {
+                    document.write(content);
+                }
+            }
+            function setValue(id, content) {
+                if (content!=null && content.length>0) {
+                    document.getElementById(id).value = content;
+                }
+            }
+
+            var con = new XMLHttpRequest();
+            con.open("GET", "tech.txt", false);
+            con.send(null);
+            var s = con.responseText;
+            WIRISplugins_js = "integration/WIRISplugins.js";
+            tech = s.split("#")[0].trim();
+            window._wrs_int_path = window._wrs_int_path == null ? "" : window._wrs_int_path;
+            if (tech=="php") {
+                _wrs_int_conf_file_override = _wrs_int_path > 0 ?
+                                              _wrs_int_path + "/configurationjs.php" :
+                                              "integration/configurationjs.php";
+            } else if (tech=="aspx") {
+                _wrs_int_conf_file_override = _wrs_int_path > 0 ?
+                                              _wrs_int_path + "/configurationjs.aspx" :
+                                              "integration/configurationjs.aspx";
+            } else if (tech=="local-java") {
+                _wrs_int_conf_file_override = "app/configurationjs";
+            } else if (tech=="java") {
+                _wrs_int_conf_file_override = "/pluginwiris_engineapp/configurationjs";
+            } else if (tech=="nodejs") {
+                _wrs_int_conf_file_override = "integration/configurationjs";
+                WIRISplugins_js = "/integration/WIRISplugins.js";
+            }
+            var script = document.createElement('script');
+            script.type = 'text/javascript';
+            script.src = WIRISplugins_js + "?viewer=image";
+            document.getElementsByTagName('head')[0].appendChild(script);
+
+            var content = getParameter("content");
+        </script>
+        <script type="text/javascript" src="core/display.js"></script>
+        <script type="text/javascript" src="wirisplugin-generic.js"></script>
+
+        <script type="text/javascript">
+            function wrs_addEvent(element, event, func) {
+                if (element.addEventListener) {
+                    element.addEventListener(event, func, false);
+                }
+                else if (element.attachEvent) {
+                    element.attachEvent('on' + event, func);
+                }
+            }
+
+            wrs_addEvent(window, 'load', function () {
+                // Hide the textarea
+                var textarea = document.getElementById('example');
+                textarea.style.display = 'none';
+
+                // Create the toolbar
+                var toolbar = document.createElement('div');
+                toolbar.id = textarea.id + '_toolbar';
+
+                // Create the WYSIWYG editor
+                var iframe = document.createElement('iframe');
+                iframe.id = textarea.id + '_iframe';
+
+                wrs_addEvent(iframe, 'load', function () {
+                    // Setting design mode ON
+                    iframe.contentWindow.document.designMode = 'on';
+
+                    // Setting the content
+                    if (iframe.contentWindow.document.body) {
+                        iframe.contentWindow.document.body.innerHTML = textarea.value;
+
+                        // WE INIT THE WIRIS PLUGIN HERE
+                        wrs_int_init(iframe,toolbar);
+                    }
+                });
+
+                // We set an empty document instead of about:blank for use relative paths for images
+                iframe.src = 'tests/generic_demo.html';
+                iframe.width = 500;
+                iframe.height = 200;
+
+                // Insert the WYSIWYG editor before the textarea
+                textarea.parentNode.insertBefore(iframe, textarea);
+
+                // Insert the toolbar before the WYSIWYG editor
+                iframe.parentNode.insertBefore(toolbar, iframe);
+
+                // When the user submits the form, set the textarea value with the WYSIWYG editor content
+                var form = document.getElementById('exampleForm');
+
+                wrs_addEvent(form, 'submit', function () {
+                    // Set the textarea content and call "wrs_endParse"
+                    textarea.value = wrs_endParse(iframe.contentWindow.document.body.innerHTML);
+                });
+            });
+
+            function changeDPI() {
+                ls = document.getElementsByClassName('Wirisformula');
+                for (i=0;i<ls.length;i++) {
+                    img = ls[i];
+                    img.width = img.clientWidth;
+                    img.src = img.src + "&dpi=600";
+                }
+            }
+        </script>
+
+        <title>WIRIS Plugin generic integration on PHP | Educational mathematics</title>
+    </head>
+    <body>
+        <h1><a href="http://www.wiris.com">
+                <img src="https://www.wiris.com/en/system/files/attachments/889/wiris_50.png" title="WIRIS" />
+            </a>
+            Test page for WIRIS plugins
+            "<script>
+            document.write(tech);
+            </script>"
+
+        </h1>
+
+        <form id="exampleForm" method="GET">
+            <textarea id="example" name="content" cols="50" rows="10"><!-- content value --></textarea>
+            <br />
+            <script>setValue("example",content);</script>
+
+            <input id="previewButton" type="submit" value="Preview"/>
+        </form>
+
+        <h2>Preview</h2>
+
+        <div id="previewBox">
+            <script>insertHtml(content);</script>
+        </div>
+
+        <script>
+            var value = document.getElementById("example").value;
+            if (value.length==0 || value=="<!-- content "+"value -->") {
+                document.getElementById("previewBox").innerHTML = '<span id="previewMessage">Press the "Preview" button.</span>';
+            }
+        </script>
+
+        </script>
+    </body>
+</html>
diff --git a/filter/wiris/tests/filter_performance_png_test.php b/filter/wiris/tests/filter_performance_png_test.php
new file mode 100644
index 0000000..32abae1
--- /dev/null
+++ b/filter/wiris/tests/filter_performance_png_test.php
@@ -0,0 +1,79 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Unit tests for WIRIS filter.
+ *
+ * @package    filter_wiris
+ * @group filter_wiris
+ * @copyright  2016
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later.
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+global $CFG;
+require_once($CFG->dirroot . '/filter/wiris/filter.php');
+require_once($CFG->dirroot . '/filter/wiris/integration/lib/com/wiris/system/CallWrapper.class.php');
+
+class filter_wiris_filter_performance_png_testcase extends advanced_testcase
+{   protected $wirisfilter;
+    protected $safexml;
+    protected $xml;
+    protected $imagepng;
+
+    protected function setUp() {
+        global $CFG;
+        parent::setUp();
+        $this->resetAfterTest(true);
+        filter_wiris_pluginwrapper::set_configuration(array('wirispluginperformance' => 'true',
+                                                            'wirisimageformat' => 'png'));
+        $this->wirisfilter = new filter_wiris(context_system::instance(), array());
+        $this->safexml = 'math xmlns=http://www.w3.org/1998/Math/MathMLmn1/mnmo+/momn2/mn/math';
+        $this->xml = '<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>+</mo><mn>2</mn></math>';
+
+        // Simple images of "1+2".
+
+        // Png format.
+        $testsiteprotocol = strrpos($CFG->wwwroot, 'https') !== false ? 'https' : 'http';
+
+        $this->imagepng = '<img src="' . $testsiteprotocol. '://www.example.com/moodle/filter/wiris/integration/showimage.php';
+        $this->imagepng .= '?formula=cd345a63d1346d7a11b5e73bb97e5bb7&refererquery=?course=1/category=0"';
+        $this->imagepng .= ' class="Wirisformula" alt="1 plus 2" width="37" height="13" style="vertical-align:-1px"';
+        $this->imagepng .= ' data-mathml=\'math ';
+        $this->imagepng .= 'xmlns=http://www.w3.org/1998/Math/MathMLmn1/mnmo+/momn2/mn/math\'/>';
+
+    }
+
+    public function test_filter_safexml_with_performance_png() {
+        global $CFG;
+        $output = $this->wirisfilter->filter($this->safexml);
+        $this->assertEquals($output, $this->imagepng);
+    }
+
+    public function test_filter_xml_with_performance_png() {
+        $output = $this->wirisfilter->filter($this->xml);
+        $this->assertEquals($output, $this->imagepng);
+    }
+
+    public function test_filter_safexml_with_performance_png_cache() {
+        $output = $this->wirisfilter->filter($this->safexml);
+        $cachefile = new moodlefilecache('filter_wiris', 'images');
+        $md5 = 'cd345a63d1346d7a11b5e73bb97e5bb7';
+        $data = $cachefile->get($md5);
+        $this->assertEquals($output, $this->imagepng);
+    }
+}
diff --git a/filter/wiris/tests/filter_performance_svg_test.php b/filter/wiris/tests/filter_performance_svg_test.php
new file mode 100644
index 0000000..5b35ccc
--- /dev/null
+++ b/filter/wiris/tests/filter_performance_svg_test.php
@@ -0,0 +1,114 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Unit tests for WIRIS filter.
+ *
+ * @package    filter_wiris
+ * @group filter_wiris
+ * @copyright  2016
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later.
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+global $CFG;
+require_once($CFG->dirroot . '/filter/wiris/filter.php');
+require_once($CFG->dirroot . '/filter/wiris/integration/lib/com/wiris/system/CallWrapper.class.php');
+
+class filter_wiris_filter_performance_svg_testcase extends advanced_testcase
+{   protected $wirisfilter;
+    protected $safexml;
+    protected $xml;
+    protected $image;
+    protected $cachetable;
+
+    protected function setUp() {
+        parent::setUp();
+        $this->resetAfterTest(true);
+        filter_wiris_pluginwrapper::set_configuration(array('wirispluginperformance' => 'true',
+                                                            'wirisimageformat' => 'svg'));
+        $this->wirisfilter = new filter_wiris(context_system::instance(), array());
+        $this->cachetable = 'filter_wiris_formulas';
+        $this->safexml = 'math xmlns=http://www.w3.org/1998/Math/MathMLmn1/mnmo+/momn2/mn/math';
+        $this->xml = '<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>+</mo><mn>2</mn></math>';
+
+        // Image: print("asd");//
+        $this->specialcharsimagesafexml = 'math xmlns=http://www.w3.org/1998/Math/MathMLmip/mimir/mimii/mi';
+        $this->specialcharsimagesafexml .= 'min/mimit/mimo(/momo#34;/momia/mimis/mimid/mimo#34;';
+        $this->specialcharsimagesafexml .= '/momo)/momo;/momo//momo//mo/math';
+
+        // Special image svg
+        $this->imagesvgspecialchars = 'data:image/svg+xml;charset=utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2F';
+        $this->imagesvgspecialchars .= 'svg%22%20xmlns%3Awrs%3D%22http%3A%2F%2Fwww.wiris.com%2Fxml%2Fcvs-extension%22%20height';
+        $this->imagesvgspecialchars .= '%3D%2221%22%20width%3D%22117%22%20wrs%3Abaseline%3D%2216%22%3E%3C!--MathML%3A%20%3Cmat';
+
+        // Special chars alt
+        $this->specialcharsalt = '{"result":{"text":"p r i n t left parenthesis \" a s d \" right parenthesis semicolon divided by divided by"},"status":"ok"}';
+
+        // Simple images of "1+2".
+
+        // Svg performance.
+        $this->imagesvgperformance = 'data:image/svg+xml;charset=utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3';
+        $this->imagesvgperformance .= 'Awrs%3D%22http%3A%2F%2Fwww.wiris.com%2Fxml%2Fcvs-extension%22%20height%3D%2220';
+        $this->imagesvgperformance .= '%22%20width%3D%2234%22%20wrs%3Abaseline%3D%2216%22%3E%3C!--MathML%3A%20%3Cmath%20xmlns%3D%22http%3A%2F%2Fww';
+        $this->imagesvgperformance .= 'w.w3.org%2F1998%2FMath%2FMathML%22%3E%3Cmn%3E1%3C%2Fmn%3E%3Cmo%3E%2B%3C%2';
+
+        $this->svg = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:wrs="http://www.wiris.com/xml/cvs-extension" height="20"';
+        $this->svg .= ' width="34" wrs:baseline="16"><!--MathML: <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>';
+        $this->svg .= '+</mo><mn>2</mn></math>--><defs><style type="text/css">@font-face{font-family:';
+
+    }
+
+    public function test_filter_safexml_with_performance_svg() {
+        $output = $this->wirisfilter->filter($this->safexml);
+        $assertion = strrpos($output, $this->imagesvgperformance) !== false;
+        $this->assertTrue($assertion);
+    }
+
+    public function test_filter_xml_with_performance() {
+        $output = $this->wirisfilter->filter($this->xml);
+        $assertion = strrpos($output, $this->imagesvgperformance) !== false;
+        $this->assertTrue($assertion);
+    }
+
+    public function test_filter_safexml_with_performance_jsonconent_db() {
+        $this->wirisfilter = new filter_wiris(context_system::instance(), array());
+        $this->wirisfilter->filter($this->safexml);
+
+        global $DB;
+        $record = $DB->get_record($this->cachetable, array('md5' => 'cd345a63d1346d7a11b5e73bb97e5bb7'));
+        $assertion = strrpos($record->jsoncontent, $this->svg) !== false;
+
+        $this->assertTrue($assertion);
+    }
+
+    public function test_filter_safexml_with_performance_alt_db() {
+        $this->wirisfilter = new filter_wiris(context_system::instance(), array());
+        $this->wirisfilter->filter($this->specialcharsimagesafexml);
+
+        global $DB;
+        $record = $DB->get_record($this->cachetable, array('md5' => 'fc13b6ac6aec34845457b164dd4af76a'));
+
+        $this->assertEquals($this->specialcharsalt, $record->alt);
+    }
+
+    public function test_filter_xml_with_performance_special_chars() {
+        $output = $this->wirisfilter->filter($this->specialcharsimagesafexml);
+        $assertion = strrpos($output, $this->imagesvgspecialchars) !== false;
+        $this->assertTrue($assertion);
+    }
+}
diff --git a/filter/wiris/tests/filter_without_performance_png_test.php b/filter/wiris/tests/filter_without_performance_png_test.php
new file mode 100644
index 0000000..b908b52
--- /dev/null
+++ b/filter/wiris/tests/filter_without_performance_png_test.php
@@ -0,0 +1,88 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Unit tests for WIRIS filter.
+ *
+ * @package    filter_wiris
+ * @group filter_wiris
+ * @copyright  2016
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later.
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+global $CFG;
+require_once($CFG->dirroot . '/filter/wiris/filter.php');
+
+class filter_wiris_filter_noperformance_png_testcase extends advanced_testcase
+{   protected $wirisfilter;
+    protected $safexml;
+    protected $xml;
+    protected $image;
+    protected $instance;
+    protected $cachetable;
+
+    protected function setUp() {
+        global $CFG;
+        parent::setUp();
+        $this->resetAfterTest(true);
+        filter_wiris_pluginwrapper::set_configuration(array('wirispluginperformance' => 'false',
+                                                            'wirisimageformat' => 'png'));
+        $this->wirisfilter = new filter_wiris(context_system::instance(), array());
+        $this->cachetable = 'filter_wiris_formulas';
+        $this->safexml = 'math xmlns=http://www.w3.org/1998/Math/MathMLmn1/mnmo+/momn2/mn/math';
+        $this->xml = '<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>+</mo><mn>2</mn></math>';
+
+        // Simple images of "1+2".
+
+        // Png format.
+        $testsiteprotocol = strrpos($CFG->wwwroot, 'https') !== false ? 'https' : 'http';
+        $this->imagepng = '<img src="' . $testsiteprotocol . '://www.example.com/moodle/filter/wiris/integration/showimage.php';
+        $this->imagepng .= '?formula=cd345a63d1346d7a11b5e73bb97e5bb7&refererquery=?course=1/category=0"';
+        $this->imagepng .= ' class="Wirisformula" alt="1 plus 2" width="37" height="13" style="vertical-align:-1px"';
+        $this->imagepng .= ' data-mathml=\'math ';
+        $this->imagepng .= 'xmlns=http://www.w3.org/1998/Math/MathMLmn1/mnmo+/momn2/mn/math\'/>';
+
+        // Svg format.
+        $this->imagesvg = '<img src="' . $testsiteprotocol . ' ://www.example.com/moodle/filter/wiris/integration/showimage.php';
+        $this->imagesvg .= '?formula=cd345a63d1346d7a11b5e73bb97e5bb7&refererquery=?course=1/category=0"';
+        $this->imagesvg .= ' class="Wirisformula" alt="1 plus 2" width="34" height="20" style="vertical-align:-4px"';
+        $this->imagesvg .= ' data-mathml=\'math ';
+        $this->imagesvg .= 'xmlns=http://www.w3.org/1998/Math/MathMLmn1/mnmo+/momn2/mn/math\'/>';
+
+        $wirispluginwrapper = new filter_wiris_pluginwrapper();
+        $this->instance = $wirispluginwrapper->get_instance();
+    }
+
+    public function test_filter_safexml_without_performance_png() {
+        $output = $this->wirisfilter->filter($this->safexml);
+        $this->assertEquals($output, $this->imagepng);
+    }
+
+    public function test_filter_xml_without_performance_png() {
+        $output = $this->wirisfilter->filter($this->xml);
+        $this->assertEquals($output, $this->imagepng);
+    }
+
+    public function test_filter_safexml_without_performance_png_cache() {
+        $output = $this->wirisfilter->filter($this->safexml);
+        $cachefile = new moodlefilecache('filter_wiris', 'images');
+        $md5 = 'cd345a63d1346d7a11b5e73bb97e5bb7';
+        $data = $cachefile->get($md5);
+        $this->assertEquals($output, $this->imagepng);
+    }
+}
diff --git a/filter/wiris/tests/filter_without_performance_svg_test.php b/filter/wiris/tests/filter_without_performance_svg_test.php
new file mode 100644
index 0000000..b717092
--- /dev/null
+++ b/filter/wiris/tests/filter_without_performance_svg_test.php
@@ -0,0 +1,77 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Unit tests for WIRIS filter.
+ * @group filter_wiris
+ *
+ * @package    filter_wiris
+ * @copyright  2016
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later.
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+global $CFG;
+require_once($CFG->dirroot . '/filter/wiris/filter.php');
+
+class filter_wiris_filter_noperformance_svg_testcase extends advanced_testcase
+{   protected $wirisfilter;
+    protected $safexml;
+    protected $xml;
+    protected $instance;
+
+    protected function setUp() {
+        global $CFG;
+        parent::setUp();
+        $this->resetAfterTest(true);
+        filter_wiris_pluginwrapper::set_configuration(array('wirispluginperformance' => 'false',
+                                                            'wirisimageformat' => 'svg'));
+        $this->wirisfilter = new filter_wiris(context_system::instance(), array());
+        $this->safexml = 'math xmlns=http://www.w3.org/1998/Math/MathMLmn1/mnmo+/momn2/mn/math';
+        $this->xml = '<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>+</mo><mn>2</mn></math>';
+
+        $testsiteprotocol = strrpos($CFG->wwwroot, 'https') !== false ? 'https' : 'http';
+        // Simple image "1+2".
+        // Svg format.
+        $this->imagesvg = '<img src="' . $testsiteprotocol . '://www.example.com/moodle/filter/wiris/integration/showimage.php';
+        $this->imagesvg .= '?formula=cd345a63d1346d7a11b5e73bb97e5bb7&refererquery=?course=1/category=0"';
+        $this->imagesvg .= ' class="Wirisformula" alt="1 plus 2" width="34" height="20" style="vertical-align:-4px"';
+        $this->imagesvg .= ' data-mathml=\'math ';
+        $this->imagesvg .= 'xmlns=http://www.w3.org/1998/Math/MathMLmn1/mnmo+/momn2/mn/math\'/>';
+
+        $wirispluginwrapper = new filter_wiris_pluginwrapper();
+        $this->instance = $wirispluginwrapper->get_instance();
+    }
+
+    public function test_filter_safexml_without_performance_svg() {
+        $output = $this->wirisfilter->filter($this->safexml);
+        $this->assertEquals($output, $this->imagesvg);
+    }
+
+    public function test_filter_xml_without_performance_svg() {
+        $output = $this->wirisfilter->filter($this->xml);
+        $this->assertEquals($output, $this->imagesvg);
+    }
+
+    public function test_filter_safexml_without_performance_svg_cache() {
+        $output = $this->wirisfilter->filter($this->safexml);
+        $cachefile = new moodlefilecache('filter_wiris', 'images');
+        $md5 = 'cd345a63d1346d7a11b5e73bb97e5bb7';
+        $data = $cachefile->get($md5);
+        $this->assertEquals($output, $this->imagesvg);
+    }
+}
diff --git a/filter/wiris/thirdpartylibs.xml b/filter/wiris/thirdpartylibs.xml
new file mode 100644
index 0000000..c5f3ff9
--- /dev/null
+++ b/filter/wiris/thirdpartylibs.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0"?>
+<libraries>
+    <library>
+        <location>integration</location>
+        <name>WIRIS PLUGIN Engine</name>
+        <version>4.7.0.1374</version>
+        <license>GPL</license>
+        <licenseversion>3.0+</licenseversion>
+    </library>
+</libraries>
diff --git a/filter/wiris/version.php b/filter/wiris/version.php
new file mode 100644
index 0000000..8701d99
--- /dev/null
+++ b/filter/wiris/version.php
@@ -0,0 +1,33 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Version details.
+ *
+ * @package    filter
+ * @subpackage wiris
+ * @copyright  Maths for More S.L. <info@wiris.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+$plugin->version = 2017090500;
+$plugin->release = '4.7.0.1374';
+$plugin->requires = 2011120511;
+$plugin->maturity = MATURITY_STABLE;
+$plugin->component = 'filter_wiris';
+$plugin->dependencies = array();
-- 
1.8.3.1

