From a2a5104f749a6d8202db50652a1386f7ecde5f05 Mon Sep 17 00:00:00 2001
From: Nadav Kavalerchik <nadavkav@gmail.com>
Date: Wed, 11 Oct 2017 21:30:41 +0300
Subject: [PATCH 48/95] mod/questionnaire (new)

---
 mod/questionnaire/.travis.yml                      |   47 +
 mod/questionnaire/CHANGES.txt                      |   19 +
 mod/questionnaire/README.txt                       |   41 +
 mod/questionnaire/backup/moodle1/lib.php           |  152 +
 .../backup_questionnaire_activity_task.class.php   |   71 +
 .../moodle2/backup_questionnaire_settingslib.php   |   28 +
 .../moodle2/backup_questionnaire_stepslib.php      |  211 +
 .../restore_questionnaire_activity_task.class.php  |  118 +
 .../moodle2/restore_questionnaire_stepslib.php     |  344 ++
 mod/questionnaire/classes/db/bulk_sql_config.php   |   81 +
 mod/questionnaire/classes/edit_question_form.php   |   76 +
 .../classes/event/all_responses_deleted.php        |   66 +
 .../classes/event/all_responses_saved_as_text.php  |   79 +
 .../classes/event/all_responses_viewed.php         |   99 +
 .../classes/event/attempt_resumed.php              |   76 +
 mod/questionnaire/classes/event/attempt_saved.php  |   97 +
 .../classes/event/attempt_submitted.php            |   97 +
 .../event/course_module_instance_list_viewed.php   |   40 +
 .../classes/event/course_module_viewed.php         |   57 +
 .../classes/event/non_respondents_viewed.php       |   78 +
 .../classes/event/question_created.php             |   67 +
 .../classes/event/question_deleted.php             |   68 +
 .../classes/event/questionnaire_previewed.php      |   77 +
 .../classes/event/response_deleted.php             |   66 +
 .../classes/event/response_viewed.php              |   90 +
 mod/questionnaire/classes/feedback_form.php        |  222 ++
 .../classes/generator/question_response.php        |   35 +
 .../classes/generator/question_response_rank.php   |   35 +
 mod/questionnaire/classes/output/completepage.php  |   71 +
 .../classes/output/fbsectionspage.php              |   67 +
 .../classes/output/nonrespondentspage.php          |   67 +
 mod/questionnaire/classes/output/previewpage.php   |   71 +
 mod/questionnaire/classes/output/qsettingspage.php |   67 +
 mod/questionnaire/classes/output/questionspage.php |   67 +
 mod/questionnaire/classes/output/renderer.php      |  348 ++
 mod/questionnaire/classes/output/reportpage.php    |   71 +
 mod/questionnaire/classes/output/viewpage.php      |   67 +
 mod/questionnaire/classes/question/base.php        |  996 +++++
 mod/questionnaire/classes/question/check.php       |  297 ++
 mod/questionnaire/classes/question/date.php        |  127 +
 mod/questionnaire/classes/question/drop.php        |  173 +
 mod/questionnaire/classes/question/essay.php       |  104 +
 mod/questionnaire/classes/question/numerical.php   |  155 +
 mod/questionnaire/classes/question/pagebreak.php   |   49 +
 mod/questionnaire/classes/question/radio.php       |  290 ++
 mod/questionnaire/classes/question/rate.php        |  565 +++
 mod/questionnaire/classes/question/sectiontext.php |   71 +
 mod/questionnaire/classes/question/text.php        |  110 +
 mod/questionnaire/classes/question/yesno.php       |  178 +
 mod/questionnaire/classes/questions_form.php       |  367 ++
 mod/questionnaire/classes/response/base.php        |  216 ++
 mod/questionnaire/classes/response/boolean.php     |  143 +
 mod/questionnaire/classes/response/date.php        |  110 +
 .../classes/response/display_support.php           |  627 +++
 mod/questionnaire/classes/response/multiple.php    |  151 +
 mod/questionnaire/classes/response/rank.php        |  228 ++
 mod/questionnaire/classes/response/single.php      |  190 +
 mod/questionnaire/classes/response/text.php        |  130 +
 mod/questionnaire/classes/search/activity.php      |   77 +
 mod/questionnaire/classes/search/question.php      |  160 +
 mod/questionnaire/classes/settings_form.php        |  224 ++
 mod/questionnaire/classes/task/cleanup.php         |   45 +
 mod/questionnaire/complete.php                     |   80 +
 mod/questionnaire/db/access.php                    |  240 ++
 mod/questionnaire/db/install.php                   |  110 +
 mod/questionnaire/db/install.xml                   |  263 ++
 mod/questionnaire/db/log.php                       |   32 +
 mod/questionnaire/db/messages.php                  |   33 +
 mod/questionnaire/db/tasks.php                     |   39 +
 mod/questionnaire/db/upgrade.php                   |  675 ++++
 mod/questionnaire/drawchart.php                    |  569 +++
 mod/questionnaire/fbsections.php                   |  266 ++
 mod/questionnaire/fbsettings.php                   |  153 +
 mod/questionnaire/grade.php                        |   44 +
 mod/questionnaire/images/hbar.gif                  |  Bin 0 -> 64 bytes
 mod/questionnaire/images/hbar_l.gif                |  Bin 0 -> 155 bytes
 mod/questionnaire/images/hbar_r.gif                |  Bin 0 -> 105 bytes
 mod/questionnaire/images/print.gif                 |  Bin 0 -> 905 bytes
 mod/questionnaire/images/thbar.gif                 |  Bin 0 -> 89 bytes
 mod/questionnaire/images/thbar_l.gif               |  Bin 0 -> 840 bytes
 mod/questionnaire/images/thbar_r.gif               |  Bin 0 -> 105 bytes
 mod/questionnaire/index.php                        |  215 ++
 mod/questionnaire/javascript/RGraph/RGraph.bar.js  | 2721 +++++++++++++
 .../javascript/RGraph/RGraph.bipolar.js            | 1155 ++++++
 .../javascript/RGraph/RGraph.common.core.js        | 4057 ++++++++++++++++++++
 mod/questionnaire/javascript/RGraph/RGraph.hbar.js | 1374 +++++++
 .../javascript/RGraph/RGraph.radar.js              | 1534 ++++++++
 mod/questionnaire/javascript/RGraph/RGraph.rose.js | 1366 +++++++
 .../javascript/RGraph/RGraph.vprogress.js          | 1077 ++++++
 mod/questionnaire/javascript/RGraph/license.txt    |   35 +
 mod/questionnaire/lang/en/questionnaire.php        |  556 +++
 mod/questionnaire/lib.php                          | 1158 ++++++
 mod/questionnaire/locallib.php                     | 1064 +++++
 mod/questionnaire/mod_form.php                     |  195 +
 mod/questionnaire/module.js                        |  240 ++
 mod/questionnaire/myreport.php                     |  284 ++
 mod/questionnaire/pix/icon.gif                     |  Bin 0 -> 897 bytes
 mod/questionnaire/pix/icon.svg                     |  668 ++++
 mod/questionnaire/preview.php                      |  160 +
 mod/questionnaire/print.php                        |   71 +
 mod/questionnaire/qsettings.php                    |  197 +
 mod/questionnaire/questionnaire.class.php          | 3609 +++++++++++++++++
 mod/questionnaire/questions.php                    |  440 +++
 mod/questionnaire/report.php                       |  747 ++++
 mod/questionnaire/settings.php                     |   50 +
 mod/questionnaire/show_nonrespondents.php          |  516 +++
 mod/questionnaire/styles.css                       |  352 ++
 mod/questionnaire/tabs.php                         |  246 ++
 mod/questionnaire/templates/completepage.mustache  |   76 +
 .../templates/fbsectionspage.mustache              |   44 +
 mod/questionnaire/templates/navbaralpha.mustache   |   71 +
 mod/questionnaire/templates/navbaruser.mustache    |   64 +
 .../templates/nonrespondentspage.mustache          |   41 +
 mod/questionnaire/templates/previewpage.mustache   |   75 +
 mod/questionnaire/templates/qsettingspage.mustache |   41 +
 .../templates/question_check.mustache              |   65 +
 .../templates/question_container.mustache          |   70 +
 mod/questionnaire/templates/question_date.mustache |   50 +
 mod/questionnaire/templates/question_drop.mustache |   66 +
 .../templates/question_numeric.mustache            |   50 +
 .../templates/question_radio.mustache              |   76 +
 mod/questionnaire/templates/question_rate.mustache |  150 +
 mod/questionnaire/templates/question_text.mustache |   50 +
 .../templates/question_yesno.mustache              |   63 +
 mod/questionnaire/templates/questionspage.mustache |   41 +
 mod/questionnaire/templates/reportpage.mustache    |   86 +
 .../templates/response_check.mustache              |   62 +
 .../templates/response_container.mustache          |  106 +
 mod/questionnaire/templates/response_date.mustache |   39 +
 mod/questionnaire/templates/response_drop.mustache |   59 +
 .../templates/response_numeric.mustache            |   39 +
 .../templates/response_radio.mustache              |   67 +
 mod/questionnaire/templates/response_rate.mustache |   92 +
 mod/questionnaire/templates/response_text.mustache |   39 +
 .../templates/response_yesno.mustache              |   55 +
 mod/questionnaire/templates/responselist.mustache  |   69 +
 mod/questionnaire/templates/viewpage.mustache      |   56 +
 .../tests/behat/add_questionnaire.feature          |   26 +
 .../tests/behat/add_questions.feature              |  102 +
 .../tests/behat/anonymous_questionnaire.feature    |   50 +
 .../tests/behat/behat_mod_questionnaire.php        |  372 ++
 .../tests/behat/check_responses.feature            |   83 +
 .../tests/behat/checkbox_min_max_responses.feature |   52 +
 .../tests/behat/numeric_question_digits.feature    |   51 +
 .../tests/behat/radio_question_other.feature       |   61 +
 .../tests/behat/rate_question_na.feature           |   62 +
 .../tests/behat/rate_question_named.feature        |   51 +
 .../tests/behat/rate_question_ranking.feature      |   48 +
 .../tests/behat/view_questionnaire.feature         |  111 +
 mod/questionnaire/tests/generator/lib.php          |  750 ++++
 mod/questionnaire/tests/generator_test.php         |   94 +
 mod/questionnaire/tests/lib_test.php               |  260 ++
 mod/questionnaire/tests/questiontypes_test.php     |  151 +
 mod/questionnaire/tests/responsetypes_test.php     |  320 ++
 mod/questionnaire/thirdpartylibs.xml               |   10 +
 mod/questionnaire/version.php                      |   34 +
 mod/questionnaire/view.php                         |  178 +
 157 files changed, 40535 insertions(+)
 create mode 100644 mod/questionnaire/.travis.yml
 create mode 100644 mod/questionnaire/CHANGES.txt
 create mode 100644 mod/questionnaire/README.txt
 create mode 100644 mod/questionnaire/backup/moodle1/lib.php
 create mode 100644 mod/questionnaire/backup/moodle2/backup_questionnaire_activity_task.class.php
 create mode 100644 mod/questionnaire/backup/moodle2/backup_questionnaire_settingslib.php
 create mode 100644 mod/questionnaire/backup/moodle2/backup_questionnaire_stepslib.php
 create mode 100644 mod/questionnaire/backup/moodle2/restore_questionnaire_activity_task.class.php
 create mode 100644 mod/questionnaire/backup/moodle2/restore_questionnaire_stepslib.php
 create mode 100644 mod/questionnaire/classes/db/bulk_sql_config.php
 create mode 100644 mod/questionnaire/classes/edit_question_form.php
 create mode 100644 mod/questionnaire/classes/event/all_responses_deleted.php
 create mode 100644 mod/questionnaire/classes/event/all_responses_saved_as_text.php
 create mode 100644 mod/questionnaire/classes/event/all_responses_viewed.php
 create mode 100644 mod/questionnaire/classes/event/attempt_resumed.php
 create mode 100644 mod/questionnaire/classes/event/attempt_saved.php
 create mode 100644 mod/questionnaire/classes/event/attempt_submitted.php
 create mode 100644 mod/questionnaire/classes/event/course_module_instance_list_viewed.php
 create mode 100644 mod/questionnaire/classes/event/course_module_viewed.php
 create mode 100644 mod/questionnaire/classes/event/non_respondents_viewed.php
 create mode 100644 mod/questionnaire/classes/event/question_created.php
 create mode 100644 mod/questionnaire/classes/event/question_deleted.php
 create mode 100644 mod/questionnaire/classes/event/questionnaire_previewed.php
 create mode 100644 mod/questionnaire/classes/event/response_deleted.php
 create mode 100644 mod/questionnaire/classes/event/response_viewed.php
 create mode 100644 mod/questionnaire/classes/feedback_form.php
 create mode 100644 mod/questionnaire/classes/generator/question_response.php
 create mode 100644 mod/questionnaire/classes/generator/question_response_rank.php
 create mode 100644 mod/questionnaire/classes/output/completepage.php
 create mode 100644 mod/questionnaire/classes/output/fbsectionspage.php
 create mode 100644 mod/questionnaire/classes/output/nonrespondentspage.php
 create mode 100644 mod/questionnaire/classes/output/previewpage.php
 create mode 100644 mod/questionnaire/classes/output/qsettingspage.php
 create mode 100644 mod/questionnaire/classes/output/questionspage.php
 create mode 100644 mod/questionnaire/classes/output/renderer.php
 create mode 100644 mod/questionnaire/classes/output/reportpage.php
 create mode 100644 mod/questionnaire/classes/output/viewpage.php
 create mode 100644 mod/questionnaire/classes/question/base.php
 create mode 100644 mod/questionnaire/classes/question/check.php
 create mode 100644 mod/questionnaire/classes/question/date.php
 create mode 100644 mod/questionnaire/classes/question/drop.php
 create mode 100644 mod/questionnaire/classes/question/essay.php
 create mode 100644 mod/questionnaire/classes/question/numerical.php
 create mode 100644 mod/questionnaire/classes/question/pagebreak.php
 create mode 100644 mod/questionnaire/classes/question/radio.php
 create mode 100644 mod/questionnaire/classes/question/rate.php
 create mode 100644 mod/questionnaire/classes/question/sectiontext.php
 create mode 100644 mod/questionnaire/classes/question/text.php
 create mode 100644 mod/questionnaire/classes/question/yesno.php
 create mode 100644 mod/questionnaire/classes/questions_form.php
 create mode 100644 mod/questionnaire/classes/response/base.php
 create mode 100644 mod/questionnaire/classes/response/boolean.php
 create mode 100644 mod/questionnaire/classes/response/date.php
 create mode 100644 mod/questionnaire/classes/response/display_support.php
 create mode 100644 mod/questionnaire/classes/response/multiple.php
 create mode 100644 mod/questionnaire/classes/response/rank.php
 create mode 100644 mod/questionnaire/classes/response/single.php
 create mode 100644 mod/questionnaire/classes/response/text.php
 create mode 100644 mod/questionnaire/classes/search/activity.php
 create mode 100644 mod/questionnaire/classes/search/question.php
 create mode 100644 mod/questionnaire/classes/settings_form.php
 create mode 100644 mod/questionnaire/classes/task/cleanup.php
 create mode 100644 mod/questionnaire/complete.php
 create mode 100644 mod/questionnaire/db/access.php
 create mode 100644 mod/questionnaire/db/install.php
 create mode 100644 mod/questionnaire/db/install.xml
 create mode 100644 mod/questionnaire/db/log.php
 create mode 100644 mod/questionnaire/db/messages.php
 create mode 100644 mod/questionnaire/db/tasks.php
 create mode 100644 mod/questionnaire/db/upgrade.php
 create mode 100644 mod/questionnaire/drawchart.php
 create mode 100644 mod/questionnaire/fbsections.php
 create mode 100644 mod/questionnaire/fbsettings.php
 create mode 100644 mod/questionnaire/grade.php
 create mode 100644 mod/questionnaire/images/hbar.gif
 create mode 100644 mod/questionnaire/images/hbar_l.gif
 create mode 100644 mod/questionnaire/images/hbar_r.gif
 create mode 100644 mod/questionnaire/images/print.gif
 create mode 100644 mod/questionnaire/images/thbar.gif
 create mode 100644 mod/questionnaire/images/thbar_l.gif
 create mode 100644 mod/questionnaire/images/thbar_r.gif
 create mode 100644 mod/questionnaire/index.php
 create mode 100644 mod/questionnaire/javascript/RGraph/RGraph.bar.js
 create mode 100644 mod/questionnaire/javascript/RGraph/RGraph.bipolar.js
 create mode 100644 mod/questionnaire/javascript/RGraph/RGraph.common.core.js
 create mode 100644 mod/questionnaire/javascript/RGraph/RGraph.hbar.js
 create mode 100644 mod/questionnaire/javascript/RGraph/RGraph.radar.js
 create mode 100644 mod/questionnaire/javascript/RGraph/RGraph.rose.js
 create mode 100644 mod/questionnaire/javascript/RGraph/RGraph.vprogress.js
 create mode 100644 mod/questionnaire/javascript/RGraph/license.txt
 create mode 100644 mod/questionnaire/lang/en/questionnaire.php
 create mode 100644 mod/questionnaire/lib.php
 create mode 100644 mod/questionnaire/locallib.php
 create mode 100644 mod/questionnaire/mod_form.php
 create mode 100644 mod/questionnaire/module.js
 create mode 100644 mod/questionnaire/myreport.php
 create mode 100644 mod/questionnaire/pix/icon.gif
 create mode 100644 mod/questionnaire/pix/icon.svg
 create mode 100644 mod/questionnaire/preview.php
 create mode 100644 mod/questionnaire/print.php
 create mode 100644 mod/questionnaire/qsettings.php
 create mode 100644 mod/questionnaire/questionnaire.class.php
 create mode 100644 mod/questionnaire/questions.php
 create mode 100644 mod/questionnaire/report.php
 create mode 100644 mod/questionnaire/settings.php
 create mode 100644 mod/questionnaire/show_nonrespondents.php
 create mode 100644 mod/questionnaire/styles.css
 create mode 100644 mod/questionnaire/tabs.php
 create mode 100644 mod/questionnaire/templates/completepage.mustache
 create mode 100644 mod/questionnaire/templates/fbsectionspage.mustache
 create mode 100644 mod/questionnaire/templates/navbaralpha.mustache
 create mode 100644 mod/questionnaire/templates/navbaruser.mustache
 create mode 100644 mod/questionnaire/templates/nonrespondentspage.mustache
 create mode 100644 mod/questionnaire/templates/previewpage.mustache
 create mode 100644 mod/questionnaire/templates/qsettingspage.mustache
 create mode 100644 mod/questionnaire/templates/question_check.mustache
 create mode 100644 mod/questionnaire/templates/question_container.mustache
 create mode 100644 mod/questionnaire/templates/question_date.mustache
 create mode 100644 mod/questionnaire/templates/question_drop.mustache
 create mode 100644 mod/questionnaire/templates/question_numeric.mustache
 create mode 100644 mod/questionnaire/templates/question_radio.mustache
 create mode 100644 mod/questionnaire/templates/question_rate.mustache
 create mode 100644 mod/questionnaire/templates/question_text.mustache
 create mode 100644 mod/questionnaire/templates/question_yesno.mustache
 create mode 100644 mod/questionnaire/templates/questionspage.mustache
 create mode 100644 mod/questionnaire/templates/reportpage.mustache
 create mode 100644 mod/questionnaire/templates/response_check.mustache
 create mode 100644 mod/questionnaire/templates/response_container.mustache
 create mode 100644 mod/questionnaire/templates/response_date.mustache
 create mode 100644 mod/questionnaire/templates/response_drop.mustache
 create mode 100644 mod/questionnaire/templates/response_numeric.mustache
 create mode 100644 mod/questionnaire/templates/response_radio.mustache
 create mode 100644 mod/questionnaire/templates/response_rate.mustache
 create mode 100644 mod/questionnaire/templates/response_text.mustache
 create mode 100644 mod/questionnaire/templates/response_yesno.mustache
 create mode 100644 mod/questionnaire/templates/responselist.mustache
 create mode 100644 mod/questionnaire/templates/viewpage.mustache
 create mode 100644 mod/questionnaire/tests/behat/add_questionnaire.feature
 create mode 100644 mod/questionnaire/tests/behat/add_questions.feature
 create mode 100644 mod/questionnaire/tests/behat/anonymous_questionnaire.feature
 create mode 100644 mod/questionnaire/tests/behat/behat_mod_questionnaire.php
 create mode 100644 mod/questionnaire/tests/behat/check_responses.feature
 create mode 100644 mod/questionnaire/tests/behat/checkbox_min_max_responses.feature
 create mode 100644 mod/questionnaire/tests/behat/numeric_question_digits.feature
 create mode 100644 mod/questionnaire/tests/behat/radio_question_other.feature
 create mode 100644 mod/questionnaire/tests/behat/rate_question_na.feature
 create mode 100644 mod/questionnaire/tests/behat/rate_question_named.feature
 create mode 100644 mod/questionnaire/tests/behat/rate_question_ranking.feature
 create mode 100644 mod/questionnaire/tests/behat/view_questionnaire.feature
 create mode 100644 mod/questionnaire/tests/generator/lib.php
 create mode 100644 mod/questionnaire/tests/generator_test.php
 create mode 100644 mod/questionnaire/tests/lib_test.php
 create mode 100644 mod/questionnaire/tests/questiontypes_test.php
 create mode 100644 mod/questionnaire/tests/responsetypes_test.php
 create mode 100644 mod/questionnaire/thirdpartylibs.xml
 create mode 100644 mod/questionnaire/version.php
 create mode 100644 mod/questionnaire/view.php

diff --git a/mod/questionnaire/.travis.yml b/mod/questionnaire/.travis.yml
new file mode 100644
index 0000000..8e87b93
--- /dev/null
+++ b/mod/questionnaire/.travis.yml
@@ -0,0 +1,47 @@
+language: php
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.composer/cache
+
+php:
+# - 5.6 Disaabling for release because of weired Behat error.
+ - 7.0
+
+addons:
+  postgresql: 9.3
+
+env:
+ global:
+  - MOODLE_BRANCH=master
+# Temporarily turn off checking for this file. It will be replaced.
+  - IGNORE_PATHS=module.js,tests
+ matrix:
+  - DB=pgsql
+  - DB=mysqli
+
+before_install:
+  - phpenv config-rm xdebug.ini
+  - cd ../..
+  - composer selfupdate
+  - composer create-project -n --no-dev --prefer-dist moodlerooms/moodle-plugin-ci ci dev-poet
+  - export PATH="$(cd ci/bin; pwd):$(cd ci/vendor/bin; pwd):$PATH"
+
+install:
+  - moodle-plugin-ci install
+
+script:
+  - moodle-plugin-ci phplint
+  - moodle-plugin-ci phpcpd
+  - moodle-plugin-ci phpmd
+  - moodle-plugin-ci codechecker
+  - moodle-plugin-ci codechecker --standard poet
+  - moodle-plugin-ci csslint
+  - moodle-plugin-ci shifter
+  - moodle-plugin-ci jshint
+  - moodle-plugin-ci validate
+  - moodle-plugin-ci phpunit
+  - moodle-plugin-ci behat
+  - moodle-plugin-ci phpunit --coverage-text
diff --git a/mod/questionnaire/CHANGES.txt b/mod/questionnaire/CHANGES.txt
new file mode 100644
index 0000000..2bc14cc
--- /dev/null
+++ b/mod/questionnaire/CHANGES.txt
@@ -0,0 +1,19 @@
+Release Notes
+
+Version 3.3.1 (Build - 2017051800)
+Bug fixes:
+CONTRIB-6903 For very old installations, response.username field may contain "Anonymous". Make this numeric before modifying field.
+
+Version 3.3.0 (Build - 2017050100)
+New Features:
+CONTRIB-6136 Assigned roles can receive Moodle notifications when a new submission is made.
+CONTRIB-5615 'Never' can be assigned to a questionnaire for viewing other users' responses.
+
+Improvements / Bug fixes:
+CONTRIB-6896 Changed future reserved word 'numeric' to 'numerical' to avoid future problems.
+CONTRIB-6892 'owner' field is now properly 'courseid' and integer.
+CONTRIB-5655 Allowed for more text formatting for trusted users.
+CONTRIB-4761 Changed 'username' to 'userid' for response data.
+
+
+(see CHANGES.TXT in release 3.2 for earlier changes.)
\ No newline at end of file
diff --git a/mod/questionnaire/README.txt b/mod/questionnaire/README.txt
new file mode 100644
index 0000000..8b6d78e
--- /dev/null
+++ b/mod/questionnaire/README.txt
@@ -0,0 +1,41 @@
+The questionnaire module allows you to construct questionnaires (surveys) from a
+variety of question type. It was originally based on phpESP, and Open Source
+survey tool.
+
+--------------------------------------------------------------------------------
+To Install:
+
+1. Load the questionnaire module directory into your "mod" subdirectory.
+2. Visit your admin page to create all of the necessary data tables.
+
+--------------------------------------------------------------------------------
+To Upgrade:
+
+1. Copy all of the files into your 'mod/questionnaire' directory.
+2. Visit your admin page. The database will be updated.
+3. As part of the update, all existing surveys are assigned as either 'private',
+   'public' or 'temmplate'. Surveys assigned to a single questionnaire are set
+   to 'private' with the questionnaire's course as the owner. Surveys assigned
+   to multiple questionnaires in the same course are set to 'public' with the
+   questionnaire's course as the owner. Surveys assigned to multiple
+   questionnaires in multiple courses are set to 'public' with the site ID as
+   the owner. Surveys that are not deleted but have no associated questionnaires
+   are set to 'template' with the site ID as the owner.
+
+*** IMPORTANT ***
+
+IF YOU ARE UPGRADING TO MOODLE 2.3...
+
+Make sure that you upgrade the questionnaire module to the latest 2.2 version in
+a Moodle 2.2 install first.
+
+--------------------------------------------------------------------------------
+Version 2.4.1 - Release date 20130519
+
+In accordance with current Moodle languages policy, all language folders other than English have been
+removed from the lang folder. All translations are now available from AMOS.
+
+--------------------------------------------------------------------------------
+Please read the releasenotes.txt file for more info about successive changes
+--------------------------------------------------------------------------------
+
diff --git a/mod/questionnaire/backup/moodle1/lib.php b/mod/questionnaire/backup/moodle1/lib.php
new file mode 100644
index 0000000..c84ce0c
--- /dev/null
+++ b/mod/questionnaire/backup/moodle1/lib.php
@@ -0,0 +1,152 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Provides support for the conversion of moodle1 backup to the moodle2 format
+ *
+ * @package    mod
+ * @subpackage questionnaire
+ * @copyright  2011 Robin de Vries <robin@celp.nl>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * Choice conversion handler
+ */
+class moodle1_mod_questionnaire_handler extends moodle1_mod_handler {
+
+    /**
+     * Declare the paths in moodle.xml we are able to convert
+     *
+     * The method returns list of {@link convert_path} instances. For each path returned,
+     * at least one of on_xxx_start(), process_xxx() and on_xxx_end() methods must be
+     * defined. The method process_xxx() is not executed if the associated path element is
+     * empty (i.e. it contains none elements or sub-paths only).
+     *
+     * Note that the path /MOODLE_BACKUP/COURSE/MODULES/MOD/CHOICE does not
+     * actually exist in the file. The last element with the module name was
+     * appended by the moodle1_converter class.
+     *
+     * @return array of {@link convert_path} instances
+     */
+    public function get_paths() {
+        return array(
+            new convert_path(
+                'questionnaire', '/MOODLE_BACKUP/COURSE/MODULES/MOD/QUESTIONNAIRE',
+                array(
+                    'renamefields' => array(
+                        'summary' => 'intro',
+                    ),
+                    'newfields' => array(
+                        'introformat' => 0,
+                    ),
+                )
+            ),
+            new convert_path('survey', '/MOODLE_BACKUP/COURSE/MODULES/MOD/QUESTIONNAIRE/SURVEY'),
+            new convert_path('question', '/MOODLE_BACKUP/COURSE/MODULES/MOD/QUESTIONNAIRE/SURVEY/QUESTION'),
+            new convert_path('question_choice', '/MOODLE_BACKUP/COURSE/MODULES/MOD/QUESTIONNAIRE/SURVEY/QUESTION/QUESTION_CHOICE'),
+        );
+    }
+    /**
+     * This is executed every time we have one /MOODLE_BACKUP/COURSE/MODULES/MOD/QUESTIONNAIRE
+     * data available
+     */
+    public function process_questionnaire($data) {
+        // Get the course module id and context id.
+        $instanceid = $data['id'];
+        $cminfo     = $this->get_cminfo($instanceid);
+        $moduleid   = $cminfo['id'];
+        $contextid  = $this->converter->get_contextid(CONTEXT_MODULE, $moduleid);
+
+        // We now have all information needed to start writing into the file.
+        $this->open_xml_writer("activities/questionnaire_{$moduleid}/questionnaire.xml");
+        $this->xmlwriter->begin_tag('activity', array('id' => $instanceid, 'moduleid' => $moduleid,
+            'modulename' => 'questionnaire', 'contextid' => $contextid));
+        $this->xmlwriter->begin_tag('questionnaire', array('id' => $instanceid));
+
+        unset($data['id']); // We already write it as attribute, do not repeat it as child element.
+        foreach ($data as $field => $value) {
+            $this->xmlwriter->full_tag($field, $value);
+        }
+        $this->xmlwriter->begin_tag('surveys');
+    }
+    /**
+     * This is executed when we reach the closing </MOD> tag of our 'questionnaire' path
+     */
+
+    public function on_questionnaire_end() {
+        // Close questionnaire.xml.
+        $this->xmlwriter->end_tag('surveys');
+        $this->xmlwriter->end_tag('questionnaire');
+        $this->xmlwriter->end_tag('activity');
+        $this->close_xml_writer();
+    }
+    /**
+     * This is executed every time we have one /MOODLE_BACKUP/COURSE/MODULES/MOD/QUESTIONNAIRE/SURVEY
+     * data available
+     */
+    public function process_survey($data) {
+        $this->xmlwriter->begin_tag('survey', array('id' => $data['id']));
+        unset($data['id']); // We already write it as attribute, do not repeat it as child element.
+        foreach ($data as $field => $value) {
+            $this->xmlwriter->full_tag($field, $value);
+        }
+        $this->xmlwriter->begin_tag('questions');
+    }
+
+    /**
+     * This is executed when we reach the closing </SURVEY> tag
+     */
+    public function on_survey_end() {
+        $this->xmlwriter->end_tag('questions');
+        $this->xmlwriter->end_tag('survey');
+    }
+
+    /**
+     * This is executed every time we have one /MOODLE_BACKUP/COURSE/MODULES/MOD/QUESTIONNAIRE/SURVEY/QUESTION
+     * data available
+     */
+    public function process_question($data) {
+
+        $this->xmlwriter->begin_tag('question', array('id' => $data['id']));
+
+        unset($data['id']); // We already write it as attribute, do not repeat it as child element.
+        foreach ($data as $field => $value) {
+            $this->xmlwriter->full_tag($field, $value);
+        }
+
+        $this->xmlwriter->begin_tag('quest_choices');
+    }
+    /**
+     * This is executed when we reach the closing </QUESTION> tag
+     */
+    public function on_question_end() {
+        $this->xmlwriter->end_tag('quest_choices');
+        $this->xmlwriter->end_tag('question');
+
+    }
+
+    /**
+     * This is executed every time we have one /MOODLE_BACKUP/COURSE/MODULES/MOD/QUESTIONNAIRE/SURVEY/QUESTION/QUESTION_CHOICE
+     * data available
+     */
+    public function process_question_choice($data) {
+        $this->write_xml('quest_choice', $data, array('/question_choice/id'));
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/backup/moodle2/backup_questionnaire_activity_task.class.php b/mod/questionnaire/backup/moodle2/backup_questionnaire_activity_task.class.php
new file mode 100644
index 0000000..f1473e2
--- /dev/null
+++ b/mod/questionnaire/backup/moodle2/backup_questionnaire_activity_task.class.php
@@ -0,0 +1,71 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+// Because it exists (must).
+require_once($CFG->dirroot . '/mod/questionnaire/backup/moodle2/backup_questionnaire_stepslib.php');
+// Because it exists (optional).
+require_once($CFG->dirroot . '/mod/questionnaire/backup/moodle2/backup_questionnaire_settingslib.php');
+
+/**
+ * questionnaire backup task that provides all the settings and steps to perform one
+ * complete backup of the activity
+ */
+class backup_questionnaire_activity_task extends backup_activity_task {
+
+    /**
+     * Define (add) particular settings this activity can have
+     */
+    protected function define_my_settings() {
+        // No particular settings for this activity.
+    }
+
+    /**
+     * Define (add) particular steps this activity can have
+     */
+    protected function define_my_steps() {
+        // Choice only has one structure step.
+        $this->add_step(new backup_questionnaire_activity_structure_step('questionnaire_structure', 'questionnaire.xml'));
+    }
+
+    /**
+     * Code the transformations to perform in the activity in
+     * order to get transportable (encoded) links
+     */
+    static public function encode_content_links($content) {
+        global $CFG;
+
+        $base = preg_quote($CFG->wwwroot, "/");
+
+        // Link to the list of questionnaires.
+        $search = "/(".$base."\/mod\/questionnaire\/index.php\?id\=)([0-9]+)/";
+        $content = preg_replace($search, '$@QUESTIONNAIREINDEX*$2@$', $content);
+
+        // Link to questionnaire view by moduleid.
+        $search = "/(".$base."\/mod\/questionnaire\/view.php\?id\=)([0-9]+)/";
+        $content = preg_replace($search, '$@QUESTIONNAIREVIEWBYID*$2@$', $content);
+
+        return $content;
+    }
+}
diff --git a/mod/questionnaire/backup/moodle2/backup_questionnaire_settingslib.php b/mod/questionnaire/backup/moodle2/backup_questionnaire_settingslib.php
new file mode 100644
index 0000000..8c7fd05
--- /dev/null
+++ b/mod/questionnaire/backup/moodle2/backup_questionnaire_settingslib.php
@@ -0,0 +1,28 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+ // This activity has no particular settings but the inherited from the generic
+ // backup_activity_task so here there isn't any class definition, like the ones
+ // existing in /backup/moodle2/backup_settingslib.php (activities section).
diff --git a/mod/questionnaire/backup/moodle2/backup_questionnaire_stepslib.php b/mod/questionnaire/backup/moodle2/backup_questionnaire_stepslib.php
new file mode 100644
index 0000000..c481fc2
--- /dev/null
+++ b/mod/questionnaire/backup/moodle2/backup_questionnaire_stepslib.php
@@ -0,0 +1,211 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * Define all the backup steps that will be used by the backup_questionnaire_activity_task
+ */
+
+/**
+ * Define the complete choice structure for backup, with file and id annotations
+ */
+class backup_questionnaire_activity_structure_step extends backup_activity_structure_step {
+
+    protected function define_structure() {
+        global $DB;
+        // To know if we are including userinfo.
+        $userinfo = $this->get_setting_value('userinfo');
+
+        // Define each element separated.
+        $questionnaire = new backup_nested_element('questionnaire', array('id'), array(
+            'course', 'name', 'intro', 'introformat', 'qtype',
+            'respondenttype', 'resp_eligible', 'resp_view', 'opendate',
+            'closedate', 'resume', 'navigate', 'grade', 'sid', 'timemodified', 'completionsubmit', 'autonum'));
+
+        $surveys = new backup_nested_element('surveys');
+
+        $survey = new backup_nested_element('survey', array('id'), array(
+            'name', 'courseid', 'realm', 'status', 'title', 'email', 'subtitle',
+            'info', 'theme', 'thanks_page', 'thank_head', 'thank_body', 'feedbacksections',
+            'feedbacknotes', 'feedbackscores', 'chart_type'));
+
+        $questions = new backup_nested_element('questions');
+
+        $question = new backup_nested_element('question', array('id'), array(
+            'survey_id', 'name', 'type_id', 'result_id', 'length', 'precise',
+            'position', 'content', 'required', 'deleted', 'dependquestion', 'dependchoice'));
+
+        $questchoices = new backup_nested_element('quest_choices');
+
+        $questchoice = new backup_nested_element('quest_choice', array('id'), array(
+            'question_id', 'content', 'value'));
+
+        $fbsections = new backup_nested_element('fb_sections');
+
+        $fbsection = new backup_nested_element('fb_section', array('id'), array(
+                'survey_id', 'section', 'scorecalculation', 'sectionlabel', 'sectionheading', 'sectionheadingformat'));
+
+        $feedbacks = new backup_nested_element('feedbacks');
+
+        $feedback = new backup_nested_element('feedback', array('id'), array(
+                'section_id', 'feedbacklabel', 'feedbacktext', 'feedbacktextformat', 'minscore', 'maxscore'));
+
+        $attempts = new backup_nested_element('attempts');
+
+        $attempt = new backup_nested_element('attempt', array('id'), array(
+            'qid', 'userid', 'rid', 'timemodified'));
+
+        $responses = new backup_nested_element('responses');
+
+        $response = new backup_nested_element('response', array('id'), array(
+            'survey_id', 'submitted', 'complete', 'grade', 'userid'));
+
+        $responsebools = new backup_nested_element('response_bools');
+
+        $responsebool = new backup_nested_element('response_bool', array('id'), array(
+            'response_id', 'question_id', 'choice_id'));
+
+        $responsedates = new backup_nested_element('response_dates');
+
+        $responsedate = new backup_nested_element('response_date', array('id'), array(
+            'response_id', 'question_id', 'response'));
+
+        $responsemultiples = new backup_nested_element('response_multiples');
+
+        $responsemultiple = new backup_nested_element('response_multiple', array('id'), array(
+            'response_id', 'question_id', 'choice_id'));
+
+        $responseothers = new backup_nested_element('response_others');
+
+        $responseother = new backup_nested_element('response_other', array('id'), array(
+            'response_id', 'question_id', 'choice_id', 'response'));
+
+        $responseranks = new backup_nested_element('response_ranks');
+
+        $responserank = new backup_nested_element('response_rank', array('id'), array(
+            'response_id', 'question_id', 'choice_id', 'rank'));
+
+        $responsesingles = new backup_nested_element('response_singles');
+
+        $responsesingle = new backup_nested_element('response_single', array('id'), array(
+            'response_id', 'question_id', 'choice_id'));
+
+        $responsetexts = new backup_nested_element('response_texts');
+
+        $responsetext = new backup_nested_element('response_text', array('id'), array(
+            'response_id', 'question_id', 'response'));
+
+        // Build the tree.
+        $questionnaire->add_child($surveys);
+        $surveys->add_child($survey);
+
+        $survey->add_child($questions);
+        $questions->add_child($question);
+
+        $question->add_child($questchoices);
+        $questchoices->add_child($questchoice);
+        $survey->add_child($fbsections);
+        $fbsections->add_child($fbsection);
+
+        $fbsection->add_child($feedbacks);
+        $feedbacks->add_child($feedback);
+
+        $questionnaire->add_child($attempts);
+        $attempts->add_child($attempt);
+
+        $attempt->add_child($responses);
+        $responses->add_child($response);
+
+        $response->add_child($responsebools);
+        $responsebools->add_child($responsebool);
+
+        $response->add_child($responsedates);
+        $responsedates->add_child($responsedate);
+
+        $response->add_child($responsemultiples);
+        $responsemultiples->add_child($responsemultiple);
+
+        $response->add_child($responseothers);
+        $responseothers->add_child($responseother);
+
+        $response->add_child($responseranks);
+        $responseranks->add_child($responserank);
+
+        $response->add_child($responsesingles);
+        $responsesingles->add_child($responsesingle);
+
+        $response->add_child($responsetexts);
+        $responsetexts->add_child($responsetext);
+
+        // Define sources.
+        $questionnaire->set_source_table('questionnaire', array('id' => backup::VAR_ACTIVITYID));
+
+        // Is current questionnaire based on a public questionnaire?
+        $qid = $this->task->get_activityid();
+        $currentquestionnaire = $DB->get_record("questionnaire", array ("id" => $qid));
+        $currentsurvey = $DB->get_record("questionnaire_survey", array ("id" => $currentquestionnaire->sid));
+        $haspublic = false;
+        if ($currentsurvey->realm == 'public' && $currentsurvey->courseid != $currentquestionnaire->course) {
+            $haspublic = true;
+        }
+
+        // If current questionnaire is based on a public one, do not include survey nor questions in backup.
+        if (!$haspublic) {
+            $survey->set_source_table('questionnaire_survey', array('id' => '../../sid'));
+            $question->set_source_table('questionnaire_question', array('survey_id' => backup::VAR_PARENTID));
+            $fbsection->set_source_table('questionnaire_fb_sections', array('survey_id' => backup::VAR_PARENTID));
+            $feedback->set_source_table('questionnaire_feedback', array('section_id' => backup::VAR_PARENTID));
+            $questchoice->set_source_table('questionnaire_quest_choice', array('question_id' => backup::VAR_PARENTID));
+
+            // All the rest of elements only happen if we are including user info.
+            if ($userinfo) {
+                $attempt->set_source_table('questionnaire_attempts', array('qid' => backup::VAR_PARENTID));
+                $response->set_source_table('questionnaire_response', array('id' => '../../rid'));
+                $responsebool->set_source_table('questionnaire_response_bool', array('response_id' => backup::VAR_PARENTID));
+                $responsedate->set_source_table('questionnaire_response_date', array('response_id' => backup::VAR_PARENTID));
+                $responsemultiple->set_source_table('questionnaire_resp_multiple', array('response_id' => backup::VAR_PARENTID));
+                $responseother->set_source_table('questionnaire_response_other', array('response_id' => backup::VAR_PARENTID));
+                $responserank->set_source_table('questionnaire_response_rank', array('response_id' => backup::VAR_PARENTID));
+                $responsesingle->set_source_table('questionnaire_resp_single', array('response_id' => backup::VAR_PARENTID));
+                $responsetext->set_source_table('questionnaire_response_text', array('response_id' => backup::VAR_PARENTID));
+            }
+
+            // Define id annotations.
+            $attempt->annotate_ids('user', 'userid');
+        }
+        // Define file annotations
+        $questionnaire->annotate_files('mod_questionnaire', 'intro', null); // This file area hasn't itemid.
+
+        $survey->annotate_files('mod_questionnaire', 'info', 'id'); // By survey->id
+        $survey->annotate_files('mod_questionnaire', 'thankbody', 'id'); // By survey->id.
+
+        $question->annotate_files('mod_questionnaire', 'question', 'id'); // By question->id.
+
+        $fbsection->annotate_files('mod_questionnaire', 'sectionheading', 'id'); // By feedback->id.
+        $feedback->annotate_files('mod_questionnaire', 'feedback', 'id'); // By feedback->id.
+
+        // Return the root element, wrapped into standard activity structure.
+        return $this->prepare_activity_structure($questionnaire);
+    }
+}
diff --git a/mod/questionnaire/backup/moodle2/restore_questionnaire_activity_task.class.php b/mod/questionnaire/backup/moodle2/restore_questionnaire_activity_task.class.php
new file mode 100644
index 0000000..da6b7d5
--- /dev/null
+++ b/mod/questionnaire/backup/moodle2/restore_questionnaire_activity_task.class.php
@@ -0,0 +1,118 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+// Because it exists (must).
+require_once($CFG->dirroot . '/mod/questionnaire/backup/moodle2/restore_questionnaire_stepslib.php');
+
+/**
+ * questionnaire restore task that provides all the settings and steps to perform one
+ * complete restore of the activity
+ */
+class restore_questionnaire_activity_task extends restore_activity_task {
+
+    /**
+     * Define (add) particular settings this activity can have
+     */
+    protected function define_my_settings() {
+        // No particular settings for this activity.
+    }
+
+    /**
+     * Define (add) particular steps this activity can have
+     */
+    protected function define_my_steps() {
+        // Choice only has one structure step.
+        $this->add_step(new restore_questionnaire_activity_structure_step('questionnaire_structure', 'questionnaire.xml'));
+    }
+
+    /**
+     * Define the contents in the activity that must be
+     * processed by the link decoder
+     */
+    static public function define_decode_contents() {
+        $contents = array();
+
+        $contents[] = new restore_decode_content('questionnaire', array('intro'), 'questionnaire');
+        $contents[] = new restore_decode_content('questionnaire_survey',
+                        array('info', 'thank_head', 'thank_body', 'thanks_page'), 'questionnaire_survey');
+        $contents[] = new restore_decode_content('questionnaire_question', array('content'), 'questionnaire_question');
+
+        return $contents;
+    }
+
+    /**
+     * Define the decoding rules for links belonging
+     * to the activity to be executed by the link decoder
+     */
+    static public function define_decode_rules() {
+        $rules = array();
+
+        $rules[] = new restore_decode_rule('QUESTIONNAIREVIEWBYID', '/mod/questionnaire/view.php?id=$1', 'course_module');
+        $rules[] = new restore_decode_rule('QUESTIONNAIREINDEX', '/mod/questionnaire/index.php?id=$1', 'course');
+
+        return $rules;
+
+    }
+
+    /**
+     * Define the restore log rules that will be applied
+     * by the {@link restore_logs_processor} when restoring
+     * questionnaire logs. It must return one array
+     * of {@link restore_log_rule} objects
+     */
+    static public function define_restore_log_rules() {
+        $rules = array();
+
+        $rules[] = new restore_log_rule('questionnaire', 'add', 'view.php?id={course_module}', '{questionnaire}');
+        $rules[] = new restore_log_rule('questionnaire', 'update', 'view.php?id={course_module}', '{questionnaire}');
+        $rules[] = new restore_log_rule('questionnaire', 'view', 'view.php?id={course_module}', '{questionnaire}');
+        $rules[] = new restore_log_rule('questionnaire', 'choose', 'view.php?id={course_module}', '{questionnaire}');
+        $rules[] = new restore_log_rule('questionnaire', 'choose again', 'view.php?id={course_module}', '{questionnaire}');
+        $rules[] = new restore_log_rule('questionnaire', 'report', 'report.php?id={course_module}', '{questionnaire}');
+
+        return $rules;
+    }
+
+    /**
+     * Define the restore log rules that will be applied
+     * by the {@link restore_logs_processor} when restoring
+     * course logs. It must return one array
+     * of {@link restore_log_rule} objects
+     *
+     * Note this rules are applied when restoring course logs
+     * by the restore final task, but are defined here at
+     * activity level. All them are rules not linked to any module instance (cmid = 0)
+     */
+    static public function define_restore_log_rules_for_course() {
+        $rules = array();
+
+        // Fix old wrong uses (missing extension).
+        $rules[] = new restore_log_rule('questionnaire', 'view all', 'index?id={course}', null,
+                                        null, null, 'index.php?id={course}');
+        $rules[] = new restore_log_rule('questionnaire', 'view all', 'index.php?id={course}', null);
+
+        return $rules;
+    }
+}
diff --git a/mod/questionnaire/backup/moodle2/restore_questionnaire_stepslib.php b/mod/questionnaire/backup/moodle2/restore_questionnaire_stepslib.php
new file mode 100644
index 0000000..9df4647
--- /dev/null
+++ b/mod/questionnaire/backup/moodle2/restore_questionnaire_stepslib.php
@@ -0,0 +1,344 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * Define all the restore steps that will be used by the restore_questionnaire_activity_task
+ */
+
+/**
+ * Structure step to restore one questionnaire activity
+ */
+class restore_questionnaire_activity_structure_step extends restore_activity_structure_step {
+
+    /**
+     * @var array $olddependquestions Contains any question id's with dependencies.
+     */
+    protected $olddependquestions = [];
+
+    /**
+     * @var array $olddependchoices Contains any choice id's for questions with dependencies.
+     */
+    protected $olddependchoices = [];
+
+    protected function define_structure() {
+
+        $paths = array();
+        $userinfo = $this->get_setting_value('userinfo');
+
+        $paths[] = new restore_path_element('questionnaire', '/activity/questionnaire');
+        $paths[] = new restore_path_element('questionnaire_survey', '/activity/questionnaire/surveys/survey');
+        $paths[] = new restore_path_element('questionnaire_fb_sections',
+                        '/activity/questionnaire/surveys/survey/fb_sections/fb_section');
+        $paths[] = new restore_path_element('questionnaire_feedback',
+                        '/activity/questionnaire/surveys/survey/fb_sections/fb_section/feedbacks/feedback');
+        $paths[] = new restore_path_element('questionnaire_question',
+                        '/activity/questionnaire/surveys/survey/questions/question');
+        $paths[] = new restore_path_element('questionnaire_quest_choice',
+                        '/activity/questionnaire/surveys/survey/questions/question/quest_choices/quest_choice');
+
+        if ($userinfo) {
+            $paths[] = new restore_path_element('questionnaire_attempt', '/activity/questionnaire/attempts/attempt');
+            $paths[] = new restore_path_element('questionnaire_response',
+                            '/activity/questionnaire/attempts/attempt/responses/response');
+            $paths[] = new restore_path_element('questionnaire_response_bool',
+                            '/activity/questionnaire/attempts/attempt/responses/response/response_bools/response_bool');
+            $paths[] = new restore_path_element('questionnaire_response_date',
+                            '/activity/questionnaire/attempts/attempt/responses/response/response_dates/response_date');
+            $paths[] = new restore_path_element('questionnaire_response_multiple',
+                            '/activity/questionnaire/attempts/attempt/responses/response/response_multiples/response_multiple');
+            $paths[] = new restore_path_element('questionnaire_response_other',
+                            '/activity/questionnaire/attempts/attempt/responses/response/response_others/response_other');
+            $paths[] = new restore_path_element('questionnaire_response_rank',
+                            '/activity/questionnaire/attempts/attempt/responses/response/response_ranks/response_rank');
+            $paths[] = new restore_path_element('questionnaire_response_single',
+                            '/activity/questionnaire/attempts/attempt/responses/response/response_singles/response_single');
+            $paths[] = new restore_path_element('questionnaire_response_text',
+                            '/activity/questionnaire/attempts/attempt/responses/response/response_texts/response_text');
+        }
+
+        // Return the paths wrapped into standard activity structure.
+        return $this->prepare_activity_structure($paths);
+    }
+
+    protected function process_questionnaire($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $data->course = $this->get_courseid();
+
+        $data->opendate = $this->apply_date_offset($data->opendate);
+        $data->closedate = $this->apply_date_offset($data->closedate);
+        $data->timemodified = $this->apply_date_offset($data->timemodified);
+
+        // Insert the questionnaire record.
+        $newitemid = $DB->insert_record('questionnaire', $data);
+        // Immediately after inserting "activity" record, call this.
+        $this->apply_activity_instance($newitemid);
+    }
+
+    protected function process_questionnaire_survey($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $oldid = $data->id;
+        $data->courseid = $this->get_courseid();
+
+        // Insert the questionnaire_survey record.
+        $newitemid = $DB->insert_record('questionnaire_survey', $data);
+        $this->set_mapping('questionnaire_survey', $oldid, $newitemid, true);
+
+        // Update the questionnaire record we just created with the new survey id.
+        $DB->set_field('questionnaire', 'sid', $newitemid, array('id' => $this->get_new_parentid('questionnaire')));
+    }
+
+    protected function process_questionnaire_question($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $oldid = $data->id;
+        $data->survey_id = $this->get_new_parentid('questionnaire_survey');
+
+        // Insert the questionnaire_question record.
+        $newitemid = $DB->insert_record('questionnaire_question', $data);
+        $this->set_mapping('questionnaire_question', $oldid, $newitemid, true);
+
+        if (isset($data->dependquestion)) {
+            // We'll need to process dependent questions in after_execute, after we have processed all questions,
+            // to ensure the id's are available. See CONTRIB-6787.
+            $this->olddependquestions[$newitemid] = $data->dependquestion;
+            $this->olddependchoices[$newitemid] = $data->dependchoice;
+        }
+    }
+
+    /**
+     * $qid is unused, but is needed in order to get the $key elements of the array. Suppress PHPMD warning.
+     *
+     * @SuppressWarnings(PHPMD.UnusedLocalVariable)
+     */
+    protected function process_questionnaire_fb_sections($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $oldid = $data->id;
+        $data->survey_id = $this->get_new_parentid('questionnaire_survey');
+
+        // If this questionnaire has separate sections feedbacks.
+        if (isset($data->scorecalculation)) {
+            $scorecalculation = unserialize($data->scorecalculation);
+            $newscorecalculation = array();
+            foreach ($scorecalculation as $key => $qid) {
+                $newqid = $this->get_mappingid('questionnaire_question', $key);
+                $newscorecalculation[$newqid] = null;
+            }
+            $data->scorecalculation = serialize($newscorecalculation);
+        }
+
+        // Insert the questionnaire_fb_sections record.
+        $newitemid = $DB->insert_record('questionnaire_fb_sections', $data);
+        $this->set_mapping('questionnaire_fb_sections', $oldid, $newitemid, true);
+    }
+
+    protected function process_questionnaire_feedback($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $oldid = $data->id;
+        $data->section_id = $this->get_new_parentid('questionnaire_fb_sections');
+
+        // Insert the questionnaire_feedback record.
+        $newitemid = $DB->insert_record('questionnaire_feedback', $data);
+        $this->set_mapping('questionnaire_feedback', $oldid, $newitemid, true);
+    }
+
+    protected function process_questionnaire_quest_choice($data) {
+        global $CFG, $DB;
+
+        $data = (object)$data;
+
+        // Replace the = separator with :: separator in quest_choice content.
+        // This fixes radio button options using old "value"="display" formats.
+        require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+        if (($data->value == null || $data->value == 'NULL') && !preg_match("/^([0-9]{1,3}=.*|!other=.*)$/", $data->content)) {
+            $content = questionnaire_choice_values($data->content);
+            if (strpos($content->text, '=')) {
+                $data->content = str_replace('=', '::', $content->text);
+            }
+        }
+
+        $oldid = $data->id;
+        $data->question_id = $this->get_new_parentid('questionnaire_question');
+
+        // Insert the questionnaire_quest_choice record.
+        $newitemid = $DB->insert_record('questionnaire_quest_choice', $data);
+        $this->set_mapping('questionnaire_quest_choice', $oldid, $newitemid);
+    }
+
+    protected function process_questionnaire_attempt($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $oldid = $data->id;
+        $data->qid = $this->get_new_parentid('questionnaire');
+        $data->userid = $this->get_mappingid('user', $data->userid);
+
+        // Insert the questionnaire_attempts record.
+        $newitemid = $DB->insert_record('questionnaire_attempts', $data);
+        $this->set_mapping('questionnaire_attempt', $oldid, $newitemid);
+    }
+
+    protected function process_questionnaire_response($data) {
+        global $DB;
+
+        $data = (object)$data;
+
+        // Older versions of questionnaire used 'username' instead of 'userid'. If 'username' exists, change it to 'userid'.
+        if (isset($data->username) && !isset($data->userid)) {
+            $data->userid = $data->username;
+        }
+
+        $oldid = $data->id;
+        $data->survey_id = $this->get_mappingid('questionnaire_survey', $data->survey_id);
+        $data->userid = $this->get_mappingid('user', $data->userid);
+
+        // Insert the questionnaire_response record.
+        $newitemid = $DB->insert_record('questionnaire_response', $data);
+        $this->set_mapping('questionnaire_response', $oldid, $newitemid);
+
+        // Update the questionnaire_attempts record we just created with the new response id.
+        $DB->set_field('questionnaire_attempts', 'rid', $newitemid,
+                        array('id' => $this->get_new_parentid('questionnaire_attempt')));
+    }
+
+    protected function process_questionnaire_response_bool($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $data->response_id = $this->get_new_parentid('questionnaire_response');
+        $data->question_id = $this->get_mappingid('questionnaire_question', $data->question_id);
+
+        // Insert the questionnaire_response_bool record.
+        $DB->insert_record('questionnaire_response_bool', $data);
+    }
+
+    protected function process_questionnaire_response_date($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $data->response_id = $this->get_new_parentid('questionnaire_response');
+        $data->question_id = $this->get_mappingid('questionnaire_question', $data->question_id);
+
+        // Insert the questionnaire_response_date record.
+        $DB->insert_record('questionnaire_response_date', $data);
+    }
+
+    protected function process_questionnaire_response_multiple($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $data->response_id = $this->get_new_parentid('questionnaire_response');
+        $data->question_id = $this->get_mappingid('questionnaire_question', $data->question_id);
+        $data->choice_id = $this->get_mappingid('questionnaire_quest_choice', $data->choice_id);
+
+        // Insert the questionnaire_resp_multiple record.
+        $DB->insert_record('questionnaire_resp_multiple', $data);
+    }
+
+    protected function process_questionnaire_response_other($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $data->response_id = $this->get_new_parentid('questionnaire_response');
+        $data->question_id = $this->get_mappingid('questionnaire_question', $data->question_id);
+        $data->choice_id = $this->get_mappingid('questionnaire_quest_choice', $data->choice_id);
+
+        // Insert the questionnaire_response_other record.
+        $DB->insert_record('questionnaire_response_other', $data);
+    }
+
+    protected function process_questionnaire_response_rank($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $data->response_id = $this->get_new_parentid('questionnaire_response');
+        $data->question_id = $this->get_mappingid('questionnaire_question', $data->question_id);
+        $data->choice_id = $this->get_mappingid('questionnaire_quest_choice', $data->choice_id);
+
+        // Insert the questionnaire_response_rank record.
+        $DB->insert_record('questionnaire_response_rank', $data);
+    }
+
+    protected function process_questionnaire_response_single($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $data->response_id = $this->get_new_parentid('questionnaire_response');
+        $data->question_id = $this->get_mappingid('questionnaire_question', $data->question_id);
+        $data->choice_id = $this->get_mappingid('questionnaire_quest_choice', $data->choice_id);
+
+        // Insert the questionnaire_resp_single record.
+        $DB->insert_record('questionnaire_resp_single', $data);
+    }
+
+    protected function process_questionnaire_response_text($data) {
+        global $DB;
+
+        $data = (object)$data;
+        $data->response_id = $this->get_new_parentid('questionnaire_response');
+        $data->question_id = $this->get_mappingid('questionnaire_question', $data->question_id);
+
+        // Insert the questionnaire_response_text record.
+        $DB->insert_record('questionnaire_response_text', $data);
+    }
+
+    protected function after_execute() {
+        global $DB;
+
+        // Process any question dependencies after all questions and choices have already been processed to ensure we have all of
+        // the new id's.
+        foreach ($this->olddependquestions as $newid => $olddependid) {
+            $newdependid = $this->get_mappingid('questionnaire_question', $olddependid);
+            $DB->set_field('questionnaire_question', 'dependquestion', $newdependid, ['id' => $newid]);
+            // Dependchoice.
+            // Only change mapping for RADIO and DROP question types, not for YESNO question.
+            $dependquestion = $DB->get_record('questionnaire_question', array('id' => $newdependid), 'type_id');
+            if (is_object($dependquestion)) {
+                if ($dependquestion->type_id != 1) {
+                    $newdependchoice = $this->get_mappingid('questionnaire_quest_choice', $this->olddependchoices[$newid]);
+                    $DB->set_field('questionnaire_question', 'dependchoice', $newdependchoice, ['id' => $newid]);
+                }
+            }
+        }
+
+        // Add questionnaire related files, no need to match by itemname (just internally handled context).
+        $this->add_related_files('mod_questionnaire', 'intro', null);
+        $this->add_related_files('mod_questionnaire', 'info', 'questionnaire_survey');
+        $this->add_related_files('mod_questionnaire', 'thankbody', 'questionnaire_survey');
+        $this->add_related_files('mod_questionnaire', 'feedbacknotes', 'questionnaire_survey');
+        $this->add_related_files('mod_questionnaire', 'question', 'questionnaire_question');
+        $this->add_related_files('mod_questionnaire', 'sectionheading', 'questionnaire_fb_sections');
+        $this->add_related_files('mod_questionnaire', 'feedback', 'questionnaire_feedback');
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/db/bulk_sql_config.php b/mod/questionnaire/classes/db/bulk_sql_config.php
new file mode 100644
index 0000000..edc6593
--- /dev/null
+++ b/mod/questionnaire/classes/db/bulk_sql_config.php
@@ -0,0 +1,81 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+namespace mod_questionnaire\db;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * For bulk sql operations on useresponses.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2015 Guy Thomas <gthomas@moodlerooms.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class bulk_sql_config  {
+
+    /**
+     * @var string $table
+     */
+    public $table = '';
+
+    /**
+     * @var string $tablealias
+     */
+    public $tablealias = '';
+
+    /**
+     * @var bool $usechoiceid
+     */
+    protected $usechoiceid = false;
+
+    /**
+     * @var bool $useresponse
+     */
+    protected $useresponse = false;
+
+    /**
+     * @var bool $userank
+     */
+    protected $userank = false;
+
+    /**
+     * @param string $table
+     * @param string $tablealias
+     * @param bool $usechoiceid
+     * @param bool $useresponse
+     * @param bool $userank
+     */
+    public function __construct($table, $tablealias, $usechoiceid = false, $useresponse = false, $userank = false) {
+        $this->table = $table;
+        $this->tablealias = $tablealias;
+        $this->usechoiceid = $usechoiceid;
+        $this->useresponse = $useresponse;
+        $this->userank = $userank;
+    }
+
+    /**
+     * Fields that need to be included for extra select.
+     * @return array
+     */
+    public function get_extra_select() {
+        return [
+            'choice_id' => $this->usechoiceid,
+            'response' => $this->useresponse,
+            'rank' => $this->userank
+        ];
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/edit_question_form.php b/mod/questionnaire/classes/edit_question_form.php
new file mode 100644
index 0000000..e9feac9
--- /dev/null
+++ b/mod/questionnaire/classes/edit_question_form.php
@@ -0,0 +1,76 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author Mike Churchward & Joseph Rézeau
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questionnaire
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->libdir . '/formslib.php');
+
+class mod_questionnaire_edit_question_form extends moodleform {
+
+    public function definition() {
+        global $questionnaire, $question, $SESSION;
+
+        // The 'sticky' required response value for further new questions.
+        if (isset($SESSION->questionnaire->required) && !isset($question->qid)) {
+            $question->required = $SESSION->questionnaire->required;
+        }
+        if (!isset($question->type_id)) {
+            print_error('undefinedquestiontype', 'questionnaire');
+        }
+
+        $mform =& $this->_form;
+
+        // Each question can provide its own form elements to the provided form, or use the default ones.
+        if (!$question->edit_form($mform, $questionnaire, $this->_customdata['modcontext'])) {
+            print_error("Question type had an unknown error in the edit_form method.");
+        }
+    }
+
+    public function validation($data, $files) {
+        $errors = parent::validation($data, $files);
+
+        // If this is a rate question.
+        if ($data['type_id'] == QUESRATE) {
+            if ($data['length'] < 2) {
+                $errors["length"] = get_string('notenoughscaleitems', 'questionnaire');
+            }
+            // If this is a rate question with no duplicates option.
+            if ($data['precise'] == 2 ) {
+                $allchoices = $data['allchoices'];
+                $allchoices = explode("\n", $allchoices);
+                $nbvalues = 0;
+                foreach ($allchoices as $choice) {
+                    if ($choice && !preg_match("/^[0-9]{1,3}=/", $choice)) {
+                            $nbvalues++;
+                    }
+                }
+                if ($nbvalues < 2) {
+                    $errors["allchoices"] = get_string('noduplicateschoiceserror', 'questionnaire');
+                }
+            }
+        }
+
+        return $errors;
+    }
+}
diff --git a/mod/questionnaire/classes/event/all_responses_deleted.php b/mod/questionnaire/classes/event/all_responses_deleted.php
new file mode 100644
index 0000000..ce634f0
--- /dev/null
+++ b/mod/questionnaire/classes/event/all_responses_deleted.php
@@ -0,0 +1,66 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire all responses deleted event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire all responses deleted event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class all_responses_deleted extends \core\event\base {
+
+    /**
+     * Init method.
+     */
+    protected function init() {
+        $this->data['objecttable'] = 'questionnaire';
+        $this->data['crud'] = 'd';
+        $this->data['edulevel'] = self::LEVEL_TEACHING;
+    }
+
+    /**
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_all_responses_deleted', 'mod_questionnaire');
+    }
+
+    /**
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        return "The user with id '$this->userid' deleted all the responses for the questionnaire
+            with course module id '$this->contextinstanceid'.";
+    }
+}
diff --git a/mod/questionnaire/classes/event/all_responses_saved_as_text.php b/mod/questionnaire/classes/event/all_responses_saved_as_text.php
new file mode 100644
index 0000000..867982a
--- /dev/null
+++ b/mod/questionnaire/classes/event/all_responses_saved_as_text.php
@@ -0,0 +1,79 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire all_responses_saved_as_text event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire all_responses_saved_as_text event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class all_responses_saved_as_text extends \core\event\base {
+
+    /**
+     * Init method.
+     */
+    protected function init() {
+        $this->data['objecttable'] = 'questionnaire';
+        $this->data['crud'] = 'c';
+        $this->data['edulevel'] = self::LEVEL_TEACHING;
+    }
+
+    /**
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_all_responses_saved_as_text', 'mod_questionnaire');
+    }
+
+    /**
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        return "The user with id '$this->userid' saved as text the responses
+            to the questionnaire with course module id '$this->contextinstanceid'.";
+    }
+
+    /**
+     * Get URL related to the action.
+     *
+     * @return \moodle_url
+     */
+    public function get_url() {
+        $params = array();
+        $params['action'] = 'vall';
+        $params['group'] = $this->other['currentgroupid'];
+        return new \moodle_url("/mod/questionnaire/report.php", $params);
+    }
+
+}
diff --git a/mod/questionnaire/classes/event/all_responses_viewed.php b/mod/questionnaire/classes/event/all_responses_viewed.php
new file mode 100644
index 0000000..4496141
--- /dev/null
+++ b/mod/questionnaire/classes/event/all_responses_viewed.php
@@ -0,0 +1,99 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire all_responses_viewed event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire all_responses_viewed event class.
+ *
+ * @property-read array $other {
+ *      Extra information about the event.
+ *
+ *      - string action: (optional) report view.
+ *      - int groupid: (optional) report for groupid.
+ * }
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class all_responses_viewed extends \core\event\base {
+
+    /**
+     * Set basic properties for the event.
+     */
+    protected function init() {
+        $this->data['objecttable'] = 'questionnaire';
+        $this->data['crud'] = 'r';
+        $this->data['edulevel'] = self::LEVEL_OTHER;
+    }
+
+    /**
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_all_responses_viewed', 'mod_questionnaire');
+    }
+
+    /**
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        return "The user with id '$this->userid' viewed the all responses report for the questionnaire
+            with course module id '$this->contextinstanceid'.";
+    }
+
+    /**
+     * Get URL related to the action.
+     *
+     * @return \moodle_url
+     */
+    public function get_url() {
+        $params = array();
+        $params['id'] = $this->contextinstanceid;
+        if (isset($this->other['action'])) {
+            $params['action'] = $this->other['action'];
+            $params['instance'] = $this->other['instance'];
+            $params['group'] = $this->other['groupid'];
+        }
+        return new \moodle_url("/mod/questionnaire/report.php", $params);
+    }
+
+    /**
+     * Return the legacy event log data.
+     *
+     * @return array
+     */
+    protected function get_legacy_logdata() {
+        return array($this->courseid, "questionnaire", "view report", "report.php?id=" . $this->contextinstanceid, $this->objectid,
+                     $this->contextinstanceid);
+    }
+}
diff --git a/mod/questionnaire/classes/event/attempt_resumed.php b/mod/questionnaire/classes/event/attempt_resumed.php
new file mode 100644
index 0000000..ba4efcc
--- /dev/null
+++ b/mod/questionnaire/classes/event/attempt_resumed.php
@@ -0,0 +1,76 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire attempt_resumed event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire attempt_resumed event.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class attempt_resumed extends \core\event\base {
+
+    /**
+     * Set basic properties for the event.
+     */
+    protected function init() {
+        $this->data['objecttable'] = 'questionnaire';
+        $this->data['crud'] = 'u';
+        $this->data['edulevel'] = self::LEVEL_OTHER;
+    }
+
+    /**
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_resumed', 'mod_questionnaire');
+    }
+
+    /**
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        return "The user with id '$this->userid' resumed an attempt for the questionnaire
+        with course module id '$this->contextinstanceid'.";
+    }
+
+    /**
+     * Get URL related to the action.
+     *
+     * @return \moodle_url
+     */
+    public function get_url() {
+        return new \moodle_url("/mod/questionnaire/view.php", array('id' => $this->contextinstanceid));
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/event/attempt_saved.php b/mod/questionnaire/classes/event/attempt_saved.php
new file mode 100644
index 0000000..95d2801
--- /dev/null
+++ b/mod/questionnaire/classes/event/attempt_saved.php
@@ -0,0 +1,97 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire attempt_saved event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire attempt_saved event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class attempt_saved extends \core\event\base {
+
+    /**
+     * Set basic properties for the event.
+     */
+    protected function init() {
+        $this->data['crud'] = 'c';
+        $this->data['edulevel'] = self::LEVEL_PARTICIPATING;
+    }
+
+    /**
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_saved', 'mod_questionnaire');
+    }
+
+    /**
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        return "The user with id '$this->userid' saved a response for the questionnaire
+            with course module id '$this->contextinstanceid'.";
+    }
+
+    /**
+     * Get URL related to the action.
+     *
+     * @return \moodle_url
+     */
+    public function get_url() {
+        return new \moodle_url("/mod/questionnaire/view.php", array('id' => $this->contextinstanceid));
+    }
+
+    /**
+     * Return the legacy event log data.
+     *
+     * @return array
+     */
+    protected function get_legacy_logdata() {
+        return array($this->courseid, "questionnaire", "save", "view.php?id=" .
+                        $this->contextinstanceid, $this->other['questionnaireid'], $this->contextinstanceid);
+    }
+
+    /**
+     * Custom validation.
+     *
+     * @throws \coding_exception
+     * @return void
+     */
+    protected function validate_data() {
+        parent::validate_data();
+        if (empty($this->other['questionnaireid'])) {
+            throw new \coding_exception('The \'questionnaireid\' value must be set in other.');
+        }
+    }
+}
diff --git a/mod/questionnaire/classes/event/attempt_submitted.php b/mod/questionnaire/classes/event/attempt_submitted.php
new file mode 100644
index 0000000..d36366e
--- /dev/null
+++ b/mod/questionnaire/classes/event/attempt_submitted.php
@@ -0,0 +1,97 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire attempt_submitted event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire attempt_submitted event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class attempt_submitted extends \core\event\base {
+
+    /**
+     * Set basic properties for the event.
+     */
+    protected function init() {
+        $this->data['crud'] = 'c';
+        $this->data['edulevel'] = self::LEVEL_PARTICIPATING;
+    }
+
+    /**
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_submitted', 'mod_questionnaire');
+    }
+
+    /**
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        return "The user with id '$this->userid' submitted a response for the questionnaire
+            with course module id '$this->contextinstanceid'.";
+    }
+
+    /**
+     * Get URL related to the action.
+     *
+     * @return \moodle_url
+     */
+    public function get_url() {
+        return new \moodle_url("/mod/questionnaire/view.php", array('id' => $this->contextinstanceid));
+    }
+
+    /**
+     * Return the legacy event log data.
+     *
+     * @return array
+     */
+    protected function get_legacy_logdata() {
+        return array($this->courseid, "questionnaire", "submit", "view.php?id=" .
+                        $this->contextinstanceid, $this->other['questionnaireid'], $this->contextinstanceid);
+    }
+
+    /**
+     * Custom validation.
+     *
+     * @throws \coding_exception
+     * @return void
+     */
+    protected function validate_data() {
+        parent::validate_data();
+        if (empty($this->other['questionnaireid'])) {
+            throw new \coding_exception('The \'questionnaireid\' value must be set in other.');
+        }
+    }
+}
diff --git a/mod/questionnaire/classes/event/course_module_instance_list_viewed.php b/mod/questionnaire/classes/event/course_module_instance_list_viewed.php
new file mode 100644
index 0000000..c7797f4
--- /dev/null
+++ b/mod/questionnaire/classes/event/course_module_instance_list_viewed.php
@@ -0,0 +1,40 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire instance list viewed event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2013 Ankit Agarwal
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire instance list viewed event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2013 onwards Ankit Agarwal
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class course_module_instance_list_viewed extends \core\event\course_module_instance_list_viewed {
+    // No code required here as the parent class handles it all.
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/event/course_module_viewed.php b/mod/questionnaire/classes/event/course_module_viewed.php
new file mode 100644
index 0000000..2f39845
--- /dev/null
+++ b/mod/questionnaire/classes/event/course_module_viewed.php
@@ -0,0 +1,57 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire course module viewed event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_survery course module viewed event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class course_module_viewed extends \core\event\course_module_viewed {
+
+    /**
+     * Set basic properties for the event.
+     */
+    protected function init() {
+        $this->data['objecttable'] = 'questionnaire';
+        $this->data['crud'] = 'r';
+        $this->data['edulevel'] = self::LEVEL_PARTICIPATING;
+    }
+
+    /**
+     * Return the legacy event log data.
+     *
+     * @return array
+     */
+    protected function get_legacy_logdata() {
+        return array($this->courseid, $this->objecttable, 'view '. $this->other['viewed'], 'view.php?id=' .
+            $this->contextinstanceid, $this->objectid, $this->contextinstanceid);
+    }
+}
diff --git a/mod/questionnaire/classes/event/non_respondents_viewed.php b/mod/questionnaire/classes/event/non_respondents_viewed.php
new file mode 100644
index 0000000..462bec2
--- /dev/null
+++ b/mod/questionnaire/classes/event/non_respondents_viewed.php
@@ -0,0 +1,78 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire non_respondents_viewed event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire non_respondents_viewed event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class non_respondents_viewed extends \core\event\base {
+
+    /**
+     * Set basic properties for the event.
+     */
+    protected function init() {
+        $this->data['objecttable'] = 'questionnaire';
+        $this->data['crud'] = 'r';
+        $this->data['edulevel'] = self::LEVEL_OTHER;
+    }
+
+    /**
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_non_respondents_viewed', 'mod_questionnaire');
+    }
+
+    /**
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        return "The user with id '$this->userid' viewed the list of non-respondents to
+            questionnaire with course module id '$this->contextinstanceid'.";
+    }
+
+    /**
+     * Get URL related to the action.
+     *
+     * @return \moodle_url
+     */
+    public function get_url() {
+        $params = array();
+        $params['id'] = $this->contextinstanceid;
+        return new \moodle_url("/mod/questionnaire/show_nonrespondents.php", $params);
+    }
+
+}
diff --git a/mod/questionnaire/classes/event/question_created.php b/mod/questionnaire/classes/event/question_created.php
new file mode 100644
index 0000000..69aff13
--- /dev/null
+++ b/mod/questionnaire/classes/event/question_created.php
@@ -0,0 +1,67 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire question_created event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire question_created event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+class question_created extends \core\event\base {
+    /*
+     * Set basic properties for the event.
+     */
+
+    protected function init() {
+        $this->data['crud'] = 'c';
+        $this->data['edulevel'] = self::LEVEL_TEACHING;
+    }
+
+    /*
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_question_created', 'mod_questionnaire');
+    }
+
+    /*
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        $questiontype = $this->other['questiontype'];
+        return "The user with id '$this->userid' has created or modified a question of type '$questiontype' for
+            the questionnaire with course module id '$this->contextinstanceid'.";
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/event/question_deleted.php b/mod/questionnaire/classes/event/question_deleted.php
new file mode 100644
index 0000000..456d469
--- /dev/null
+++ b/mod/questionnaire/classes/event/question_deleted.php
@@ -0,0 +1,68 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire question_deleted event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire question_deleted event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+
+class question_deleted extends \core\event\base {
+    /*
+     * Set basic properties for the event.
+     */
+
+    protected function init() {
+        $this->data['crud'] = 'd';
+        $this->data['edulevel'] = self::LEVEL_TEACHING;
+    }
+
+    /*
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_question_deleted', 'mod_questionnaire');
+    }
+
+    /*
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        $questiontype = $this->other['questiontype'];
+        return "The user with id '$this->userid' has deleted a question of type '$questiontype' for
+            the questionnaire with course module id '$this->contextinstanceid'.";
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/event/questionnaire_previewed.php b/mod/questionnaire/classes/event/questionnaire_previewed.php
new file mode 100644
index 0000000..296b19f
--- /dev/null
+++ b/mod/questionnaire/classes/event/questionnaire_previewed.php
@@ -0,0 +1,77 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire questionnaire_previewed event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire questionnaire_previewed event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class questionnaire_previewed extends \core\event\base {
+
+    /**
+     * Set basic properties for the event.
+     */
+    protected function init() {
+        $this->data['objecttable'] = 'questionnaire';
+        $this->data['crud'] = 'r';
+        $this->data['edulevel'] = self::LEVEL_OTHER;
+    }
+
+    /**
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_previewed', 'mod_questionnaire');
+    }
+
+    /**
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        return "The user with id '$this->userid' previewed the questionnaire with course module id '$this->contextinstanceid'.";
+    }
+
+    /**
+     * Get URL related to the action.
+     *
+     * @return \moodle_url
+     */
+    public function get_url() {
+        $params = array();
+        $params['id'] = $this->contextinstanceid;
+        return new \moodle_url("/mod/questionnaire/preview.php", $params);
+    }
+
+}
diff --git a/mod/questionnaire/classes/event/response_deleted.php b/mod/questionnaire/classes/event/response_deleted.php
new file mode 100644
index 0000000..393c62c
--- /dev/null
+++ b/mod/questionnaire/classes/event/response_deleted.php
@@ -0,0 +1,66 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire response_deleted viewed event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire response_deleted event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class response_deleted extends \core\event\base {
+
+    /**
+     * Set basic properties for the event.
+     */
+    protected function init() {
+        $this->data['objecttable'] = 'questionnaire';
+        $this->data['crud'] = 'd';
+        $this->data['edulevel'] = self::LEVEL_OTHER;
+    }
+
+    /**
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_response_deleted', 'mod_questionnaire');
+    }
+
+    /**
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        return "The user with id '$this->userid' deleted the response by the user with id '$this->relateduserid'
+            to the questionnaire with course module id '$this->contextinstanceid'.";
+    }
+}
diff --git a/mod/questionnaire/classes/event/response_viewed.php b/mod/questionnaire/classes/event/response_viewed.php
new file mode 100644
index 0000000..2ae67a8
--- /dev/null
+++ b/mod/questionnaire/classes/event/response_viewed.php
@@ -0,0 +1,90 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * The mod_questionnaire response_viewed event.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\event;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * The mod_questionnaire response_viewed event class.
+ *
+ * @package    mod_questionnaire
+ * @since      Moodle 2.7
+ * @copyright  2014 Joseph Rézeau <moodle@rezeau.org>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class response_viewed extends \core\event\base {
+
+    /**
+     * Set basic properties for the event.
+     */
+    protected function init() {
+        $this->data['objecttable'] = 'questionnaire';
+        $this->data['crud'] = 'r';
+        $this->data['edulevel'] = self::LEVEL_OTHER;
+    }
+
+    /**
+     * Return localised event name.
+     *
+     * @return string
+     */
+    public static function get_name() {
+        return get_string('event_individual_responses_viewed', 'mod_questionnaire');
+    }
+
+    /**
+     * Returns description of what happened.
+     *
+     * @return string
+     */
+    public function get_description() {
+        return "The user with id '$this->userid' viewed the individual responses report for user with id '$this->relateduserid'
+            to the questionnaire with course module id '$this->contextinstanceid'.";
+    }
+
+    /**
+     * Get URL related to the action.
+     *
+     * @return \moodle_url
+     */
+    public function get_url() {
+        $params = array();
+        $params['action'] = 'vresp';
+        $params['individualresponse'] = 1;
+        $params['rid'] = $this->other['rid'];
+        $params['group'] = $this->other['currentgroupid'];
+        return new \moodle_url("/mod/questionnaire/report.php", $params);
+    }
+
+    /**
+     * Return the legacy event log data.
+     *
+     * @return array
+     */
+    protected function get_legacy_logdata() {
+        return array($this->courseid, "questionnaire", "view report", "report.php?id=" . $this->contextinstanceid, $this->objectid,
+                     $this->contextinstanceid);
+    }
+}
diff --git a/mod/questionnaire/classes/feedback_form.php b/mod/questionnaire/classes/feedback_form.php
new file mode 100644
index 0000000..093f92b
--- /dev/null
+++ b/mod/questionnaire/classes/feedback_form.php
@@ -0,0 +1,222 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Print the form to add or edit a questionnaire-instance
+ *
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author Joseph Rezeau (based on Quiz by Tim Hunt)
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->libdir . '/formslib.php');
+require_once($CFG->dirroot.'/mod/questionnaire/lib.php');
+
+class mod_questionnaire_feedback_form extends moodleform {
+
+    protected $_feedbacks;
+
+    public function definition() {
+        global $questionnaire, $DB, $SESSION;
+        $currentsection   = $SESSION->questionnaire->currentfbsection;
+        $sectionid   = $this->_customdata['sectionid'];
+        $feedbacksections = $questionnaire->survey->feedbacksections;
+        $this->_feedbacks = $DB->get_records('questionnaire_feedback',
+                array('section_id' => $sectionid),
+                'minscore DESC');
+        $this->context = $questionnaire->context;
+        $mform    =& $this->_form;
+
+        if ($feedbacksections == 1) {
+            $feedbackheading = get_string('feedbackglobalheading', 'questionnaire');
+            $feedbackmessages = get_string('feedbackglobalmessages', 'questionnaire');
+        } else {
+            $feedbackheading = get_string('feedbacksectionheading', 'questionnaire', $currentsection.'/'.$feedbacksections);
+            $feedbackmessages = get_string('feedbackmessages', 'questionnaire', $currentsection.'/'.$feedbacksections);
+        }
+
+        $mform->addElement('header', 'contenthdr', $feedbackheading);
+
+        $questions = $questionnaire->questions;
+        $fbsection = $DB->get_record('questionnaire_fb_sections',
+                        array('survey_id' => $questionnaire->survey->id, 'section' => $currentsection));
+        $questionslist = '';
+        if (isset($fbsection->scorecalculation)) {
+            $scorecalculation = unserialize($fbsection->scorecalculation);
+            $questionslist = '<ul style="float: left;">';
+            foreach ($scorecalculation as $qid => $key) {
+                $questionslist .= '<li>'.$questions[$qid]->name.'</li>';
+            }
+            $questionslist .= '</ul>';
+        }
+        $mform->addElement('static', 'questionsinsectionlist', get_string('questionsinsection', 'questionnaire'), $questionslist);
+        $mform->addElement('text', 'sectionlabel', get_string('feedbacksectionlabel', 'questionnaire'),
+                        array('size' => '50', 'maxlength' => '50'));
+        $mform->setType('sectionlabel', PARAM_TEXT);
+        $mform->addRule('sectionlabel', null, 'required', null, 'client');
+        $mform->addHelpButton('sectionlabel', 'feedbacksectionlabel', 'questionnaire');
+
+        $editoroptions = array('maxfiles' => EDITOR_UNLIMITED_FILES, 'trusttext' => true);
+        $mform->addElement('editor', 'sectionheading', get_string('feedbacksectionheadingtext', 'questionnaire'),
+                        null, $editoroptions);
+        $mform->setType('info', PARAM_RAW);
+
+        $mform->addHelpButton('sectionheading', 'feedbackheading', 'questionnaire');
+
+        // FEEDBACK FIELDS.
+
+        $mform->addElement('header', 'feedbackhdr', $feedbackmessages);
+        $mform->addHelpButton('feedbackhdr', 'feedback', 'questionnaire');
+
+        $mform->addElement('static', 'scoreboundarystatic1', get_string('feedbackscoreboundary', 'questionnaire'), '100%');
+
+        $repeatarray = array();
+        $repeatedoptions = array();
+
+        $repeatarray[] = $mform->createElement(
+            'editor', 'feedbacktext', get_string('feedback', 'questionnaire'), null,
+            array('maxfiles' => EDITOR_UNLIMITED_FILES, 'noclean' => true, 'context' => $questionnaire->context)
+        );
+        $repeatarray[] = $mform->createElement(
+            'text', 'feedbackboundaries', get_string('feedbackscoreboundary', 'questionnaire'), array('size' => 10)
+        );
+        $repeatedoptions['feedbacklabel']['type'] = PARAM_RAW;
+        $repeatedoptions['feedbacktext']['type'] = PARAM_RAW;
+        $repeatedoptions['feedbackboundaries']['type'] = PARAM_RAW;
+
+        $numfeedbacks = max(count($this->_feedbacks) * 1, 3);
+
+        $nextel = $this->repeat_elements($repeatarray, $numfeedbacks - 1,
+                        $repeatedoptions, 'boundary_repeats', 'boundary_add_fields', 2,
+                        get_string('feedbackaddmorefeedbacks', 'questionnaire'), true);
+
+        // Put some extra elements in before the button.
+        $mform->insertElementBefore(
+            $mform->createElement('editor', "feedbacktext[$nextel]", get_string('feedback', 'questionnaire'), null,
+                array('maxfiles' => EDITOR_UNLIMITED_FILES, 'noclean' => true, 'context' => $questionnaire->context)),
+            'boundary_add_fields');
+        $mform->insertElementBefore(
+            $mform->createElement('static', 'scoreboundarystatic2', get_string('feedbackscoreboundary', 'questionnaire'), '0%'),
+            'boundary_add_fields');
+
+        // Hidden fields.
+        $mform->addElement('hidden', 'id', 0);
+        $mform->setType('id', PARAM_INT);
+        $mform->addElement('hidden', 'sid', 0);
+        $mform->setType('sid', PARAM_INT);
+
+        // Buttons.
+        if ($currentsection < $feedbacksections) {
+            $currentsection ++;
+            $sectionsnav = ' ('.$currentsection.'/'.$feedbacksections.')';
+            $buttonarray[] = &$mform->createElement('submit', 'submitbutton',
+                get_string('feedbacknextsection', 'questionnaire', $sectionsnav));
+        } else {
+            $buttonarray[] = &$mform->createElement('submit', 'savesettings', get_string('savesettings', 'questionnaire'));
+        }
+
+        $buttonarray[] = &$mform->createElement('cancel');
+        $mform->addGroup($buttonarray, 'buttonar', '', array(' '), false);
+    }
+
+    public function data_preprocessing(&$toform) {
+        if (count($this->_feedbacks)) {
+            $key = 0;
+            foreach ($this->_feedbacks as $feedback) {
+                $draftid = file_get_submitted_draft_itemid('feedbacktext['.$key.']');
+                $toform['feedbacktext['.$key.']']['text'] = file_prepare_draft_area(
+                    $draftid,               // Draftid.
+                    $this->context->id,     // Context.
+                    'mod_questionnaire',    // Component.
+                    'feedback',             // Filarea.
+                    !empty($feedback->id) ? (int)$feedback->id : null, // Itemid.
+                    null,
+                    $feedback->feedbacktext // Text.
+                );
+                $toform['feedbacktext['.$key.']']['format'] = 1;
+                $toform['feedbacklabel['.$key.']'] = $feedback->feedbacklabel;
+                $toform['feedbacktext['.$key.']']['itemid'] = $draftid;
+
+                if ($feedback->minscore > 0) {
+                    $toform['feedbackboundaries['.$key.']'] = (100.0 * $feedback->minscore / 100 ) . '%';
+                }
+                $key++;
+            }
+        }
+    }
+    public function validation($data, $files) {
+        $errors = parent::validation($data, $files);
+
+        // Check the boundary value is a number or a percentage, and in range.
+        $i = 0;
+        while (!empty($data['feedbackboundaries'][$i])) {
+            $boundary = trim($data['feedbackboundaries'][$i]);
+            if (strlen($boundary) > 0 && $boundary[strlen($boundary) - 1] == '%') {
+                $boundary = trim(substr($boundary, 0, -1));
+                if (is_numeric($boundary)) {
+                    $boundary = $boundary * 100 / 100.0;
+                } else {
+                    $errors["feedbackboundaries[$i]"] = get_string('feedbackerrorboundaryformat', 'quiz', $i + 1);
+                }
+            }
+            if (is_numeric($boundary) && $boundary <= 0) {
+                $errors["feedbackboundaries[$i]"] = get_string('feedbackerrorboundaryoutofrange', 'questionnaire', $i + 1);
+            }
+            if (is_numeric($boundary) && $i > 0 &&
+                    $boundary >= $data['feedbackboundaries'][$i - 1]) {
+                $errors["feedbackboundaries[$i]"] = get_string('feedbackerrororder', 'questionnaire', $i + 1);
+            }
+            $data['feedbackboundaries'][$i] = $boundary;
+            $i += 1;
+        }
+        $numboundaries = $i;
+
+        // Check there is nothing in the remaining unused fields.
+        if (!empty($data['feedbackboundaries'])) {
+            for ($i = $numboundaries; $i < count($data['feedbackboundaries']); $i += 1) {
+                if (!empty($data['feedbackboundaries'][$i] ) &&
+                        trim($data['feedbackboundaries'][$i] ) != '') {
+                    $errors["feedbackboundaries[$i]"] = get_string('feedbackerrorjunkinboundary', 'questionnaire', $i + 1);
+                }
+            }
+        }
+        for ($i = $numboundaries + 1; $i < count($data['feedbacktext']); $i += 1) {
+            if (!empty($data['feedbacktext'][$i]['text']) &&
+                    trim($data['feedbacktext'][$i]['text'] ) != '') {
+                $errors["feedbacktext[$i]"] = get_string('feedbackerrorjunkinfeedback', 'questionnaire', $i + 1);
+            }
+        }
+        return $errors;
+    }
+
+    /**
+     * Load in existing data as form defaults. Usually new entry defaults are stored directly in
+     * form definition (new entry form); this function is used to load in data where values
+     * already exist and data is being edited (edit entry form).
+     *
+     * @param mixed $default_values object or array of default values
+     */
+    public function set_data($defaultvalues) {
+        if (is_object($defaultvalues)) {
+            $defaultvalues = (array)$defaultvalues;
+        }
+        $this->data_preprocessing($defaultvalues);
+        parent::set_data($defaultvalues);
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/generator/question_response.php b/mod/questionnaire/classes/generator/question_response.php
new file mode 100644
index 0000000..7705082
--- /dev/null
+++ b/mod/questionnaire/classes/generator/question_response.php
@@ -0,0 +1,35 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Question response class
+ * @author    gthomas2
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\generator;
+
+defined('MOODLE_INTERNAL') || die();
+
+class question_response {
+    public $questionid;
+    public $response;
+
+    public function __construct($questionid, $response) {
+        $this->questionid = $questionid;
+        $this->response = $response;
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/generator/question_response_rank.php b/mod/questionnaire/classes/generator/question_response_rank.php
new file mode 100644
index 0000000..e9dbe55
--- /dev/null
+++ b/mod/questionnaire/classes/generator/question_response_rank.php
@@ -0,0 +1,35 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Question response rank class
+ * @author    gthomas2
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\generator;
+
+defined('MOODLE_INTERNAL') || die();
+
+class question_response_rank {
+    public $choice;
+    public $rank;
+
+    public function __construct($choice, $rank) {
+        $this->choice = $choice;
+        $this->rank = $rank;
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/output/completepage.php b/mod/questionnaire/classes/output/completepage.php
new file mode 100644
index 0000000..d3edd3d
--- /dev/null
+++ b/mod/questionnaire/classes/output/completepage.php
@@ -0,0 +1,71 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Contains class mod_questionnaire\output\viewpage
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\output;
+
+defined('MOODLE_INTERNAL') || die();
+
+class completepage implements \renderable, \templatable {
+
+    /**
+     * The data to be exported.
+     * @var array
+     */
+    protected $data;
+
+    /**
+     * Construct the renderable.
+     * @param object $data The template data for export.
+     */
+    public function __construct($data = null) {
+        if ($data !== null) {
+            $this->data = $data;
+        } else {
+            $this->data = new \stdClass();
+        }
+    }
+
+    /**
+     * Add data for export.
+     * @param string The index for the data.
+     * @param string The content for the index.
+     */
+    public function add_to_page($element, $content) {
+        if ($element !== 'questions') {
+            $this->data->{$element} = empty($this->data->{$element}) ? $content : ($this->data->{$element} . $content);
+        } else {
+            $this->data->{$element}[] = $content;
+        }
+    }
+
+    /**
+     * Export the data for template.
+     * @param \renderer_base $output
+     */
+    public function export_for_template(\renderer_base $output) {
+        return $this->data;
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/output/fbsectionspage.php b/mod/questionnaire/classes/output/fbsectionspage.php
new file mode 100644
index 0000000..ccacc49
--- /dev/null
+++ b/mod/questionnaire/classes/output/fbsectionspage.php
@@ -0,0 +1,67 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Contains class mod_questionnaire\output\fbsectionspage
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\output;
+
+defined('MOODLE_INTERNAL') || die();
+
+class fbsectionspage implements \renderable, \templatable {
+
+    /**
+     * The data to be exported.
+     * @var array
+     */
+    protected $data;
+
+    /**
+     * Construct the renderable.
+     * @param object $data The template data for export.
+     */
+    public function __construct($data = null) {
+        if ($data !== null) {
+            $this->data = $data;
+        } else {
+            $this->data = new \stdClass();
+        }
+    }
+
+    /**
+     * Add data for export.
+     * @param string The index for the data.
+     * @param string The content for the index.
+     */
+    public function add_to_page($element, $content) {
+        $this->data->{$element} = empty($this->data->{$element}) ? $content : ($this->data->{$element} . $content);
+    }
+
+    /**
+     * Export the data for template.
+     * @param \renderer_base $output
+     */
+    public function export_for_template(\renderer_base $output) {
+        return $this->data;
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/output/nonrespondentspage.php b/mod/questionnaire/classes/output/nonrespondentspage.php
new file mode 100644
index 0000000..2f8b631
--- /dev/null
+++ b/mod/questionnaire/classes/output/nonrespondentspage.php
@@ -0,0 +1,67 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Contains class mod_questionnaire\output\viewpage
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\output;
+
+defined('MOODLE_INTERNAL') || die();
+
+class nonrespondentspage implements \renderable, \templatable {
+
+    /**
+     * The data to be exported.
+     * @var array
+     */
+    protected $data;
+
+    /**
+     * Construct the renderable.
+     * @param object $data The template data for export.
+     */
+    public function __construct($data = null) {
+        if ($data !== null) {
+            $this->data = $data;
+        } else {
+            $this->data = new \stdClass();
+        }
+    }
+
+    /**
+     * Add data for export.
+     * @param string The index for the data.
+     * @param string The content for the index.
+     */
+    public function add_to_page($element, $content) {
+        $this->data->{$element} = empty($this->data->{$element}) ? $content : ($this->data->{$element} . $content);
+    }
+
+    /**
+     * Export the data for template.
+     * @param \renderer_base $output
+     */
+    public function export_for_template(\renderer_base $output) {
+        return $this->data;
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/output/previewpage.php b/mod/questionnaire/classes/output/previewpage.php
new file mode 100644
index 0000000..af2c5ba
--- /dev/null
+++ b/mod/questionnaire/classes/output/previewpage.php
@@ -0,0 +1,71 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Contains class mod_questionnaire\output\viewpage
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\output;
+
+defined('MOODLE_INTERNAL') || die();
+
+class previewpage implements \renderable, \templatable {
+
+    /**
+     * The data to be exported.
+     * @var array
+     */
+    protected $data;
+
+    /**
+     * Construct the renderable.
+     * @param object $data The template data for export.
+     */
+    public function __construct($data = null) {
+        if ($data !== null) {
+            $this->data = $data;
+        } else {
+            $this->data = new \stdClass();
+        }
+    }
+
+    /**
+     * Add data for export.
+     * @param string The index for the data.
+     * @param string The content for the index.
+     */
+    public function add_to_page($element, $content) {
+        if ($element === 'questions') {
+            $this->data->{$element}[] = $content;
+        } else {
+            $this->data->{$element} = empty($this->data->{$element}) ? $content : ($this->data->{$element} . $content);
+        }
+    }
+
+    /**
+     * Export the data for template.
+     * @param \renderer_base $output
+     */
+    public function export_for_template(\renderer_base $output) {
+        return $this->data;
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/output/qsettingspage.php b/mod/questionnaire/classes/output/qsettingspage.php
new file mode 100644
index 0000000..7b4be1a
--- /dev/null
+++ b/mod/questionnaire/classes/output/qsettingspage.php
@@ -0,0 +1,67 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Contains class mod_questionnaire\output\viewpage
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\output;
+
+defined('MOODLE_INTERNAL') || die();
+
+class qsettingspage implements \renderable, \templatable {
+
+    /**
+     * The data to be exported.
+     * @var array
+     */
+    protected $data;
+
+    /**
+     * Construct the renderable.
+     * @param object $data The template data for export.
+     */
+    public function __construct($data = null) {
+        if ($data !== null) {
+            $this->data = $data;
+        } else {
+            $this->data = new \stdClass();
+        }
+    }
+
+    /**
+     * Add data for export.
+     * @param string The index for the data.
+     * @param string The content for the index.
+     */
+    public function add_to_page($element, $content) {
+        $this->data->{$element} = empty($this->data->{$element}) ? $content : ($this->data->{$element} . $content);
+    }
+
+    /**
+     * Export the data for template.
+     * @param \renderer_base $output
+     */
+    public function export_for_template(\renderer_base $output) {
+        return $this->data;
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/output/questionspage.php b/mod/questionnaire/classes/output/questionspage.php
new file mode 100644
index 0000000..5125df4
--- /dev/null
+++ b/mod/questionnaire/classes/output/questionspage.php
@@ -0,0 +1,67 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Contains class mod_questionnaire\output\viewpage
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\output;
+
+defined('MOODLE_INTERNAL') || die();
+
+class questionspage implements \renderable, \templatable {
+
+    /**
+     * The data to be exported.
+     * @var array
+     */
+    protected $data;
+
+    /**
+     * Construct the renderable.
+     * @param object $data The template data for export.
+     */
+    public function __construct($data = null) {
+        if ($data !== null) {
+            $this->data = $data;
+        } else {
+            $this->data = new \stdClass();
+        }
+    }
+
+    /**
+     * Add data for export.
+     * @param string The index for the data.
+     * @param string The content for the index.
+     */
+    public function add_to_page($element, $content) {
+        $this->data->{$element} = empty($this->data->{$element}) ? $content : ($this->data->{$element} . $content);
+    }
+
+    /**
+     * Export the data for template.
+     * @param \renderer_base $output
+     */
+    public function export_for_template(\renderer_base $output) {
+        return $this->data;
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/output/renderer.php b/mod/questionnaire/classes/output/renderer.php
new file mode 100644
index 0000000..e5c4b12
--- /dev/null
+++ b/mod/questionnaire/classes/output/renderer.php
@@ -0,0 +1,348 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Contains class mod_questionnaire\output\renderer
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\output;
+
+defined('MOODLE_INTERNAL') || die();
+
+class renderer extends \plugin_renderer_base {
+    /**
+     * Main view page.
+     * @param \templateable $page
+     * @return string | boolean
+     */
+    public function render_viewpage($page) {
+        $data = $page->export_for_template($this);
+        return $this->render_from_template('mod_questionnaire/viewpage', $data);
+    }
+
+    /**
+     * Fill out the questionnaire (complete) page.
+     * @param \templateable $page
+     * @return string | boolean
+     */
+    public function render_completepage($page) {
+        $data = $page->export_for_template($this);
+        return $this->render_from_template('mod_questionnaire/completepage', $data);
+    }
+
+    /**
+     * Fill out the report page.
+     * @param \templateable $page
+     * @return string | boolean
+     */
+    public function render_reportpage($page) {
+        $data = $page->export_for_template($this);
+        return $this->render_from_template('mod_questionnaire/reportpage', $data);
+    }
+
+    /**
+     * Fill out the qsettings page.
+     * @param \templateable $page
+     * @return string | boolean
+     */
+    public function render_qsettingspage($page) {
+        $data = $page->export_for_template($this);
+        return $this->render_from_template('mod_questionnaire/qsettingspage', $data);
+    }
+
+    /**
+     * Fill out the questions page.
+     * @param \templateable $page
+     * @return string | boolean
+     */
+    public function render_questionspage($page) {
+        $data = $page->export_for_template($this);
+        return $this->render_from_template('mod_questionnaire/questionspage', $data);
+    }
+
+    /**
+     * Fill out the preview page.
+     * @param \templateable $page
+     * @return string | boolean
+     */
+    public function render_previewpage($page) {
+        $data = $page->export_for_template($this);
+        return $this->render_from_template('mod_questionnaire/previewpage', $data);
+    }
+
+    /**
+     * Fill out the non-respondents page.
+     * @param \templateable $page
+     * @return string | boolean
+     */
+    public function render_nonrespondentspage($page) {
+        $data = $page->export_for_template($this);
+        return $this->render_from_template('mod_questionnaire/nonrespondentspage', $data);
+    }
+
+    /**
+     * Fill out the fbsections page.
+     * @param \templateable $page
+     * @return string | boolean
+     */
+    public function render_fbsectionspage($page) {
+        $data = $page->export_for_template($this);
+        return $this->render_from_template('mod_questionnaire/fbsectionspage', $data);
+    }
+
+    /**
+     * Render the respondent information line.
+     * @param string $text The respondent information.
+     */
+    public function respondent_info($text) {
+        return \html_writer::tag('span', $text, ['class' => 'respondentinfo']);
+    }
+
+    /**
+     * Render the completion form start HTML.
+     * @param string $action The action URL.
+     * @param array $hiddeninputs Name/value pairs of hidden inputs used by the form.
+     * @return string The output for the page.
+     */
+    public function complete_formstart($action, $hiddeninputs=[]) {
+        $output = '';
+        $output .= \html_writer::start_tag('form', ['id' => 'phpesp_response', 'method' => 'post', 'action' => $action]) . "\n";
+        foreach ($hiddeninputs as $name => $value) {
+            $output .= \html_writer::empty_tag('input', ['type' => 'hidden', 'name' => $name, 'value' => $value]) . "\n";
+        }
+        return $output;
+    }
+
+    /**
+     * Render the completion form end HTML.
+     * @param array $inputs Type/attribute array of inputs and values used by the form.
+     * @return string The output for the page.
+     */
+    public function complete_formend($inputs=[]) {
+        $output = '';
+        foreach ($inputs as $type => $attributes) {
+            $output .= \html_writer::empty_tag('input', array_merge(['type' => $type], $attributes)) . "\n";
+        }
+        $output .= \html_writer::end_tag('form') . "\n";
+        return $output;
+    }
+
+    /**
+     * Render the completion form control buttons.
+     * @param array | string $inputs Name/(Type/attribute) array of input types and values used by the form.
+     * @return string The output for the page.
+     */
+    public function complete_controlbuttons($inputs=null) {
+        $output = '';
+        if (is_array($inputs)) {
+            foreach ($inputs as $name => $attributes) {
+                $output .= \html_writer::empty_tag('input', array_merge(['name' => $name], $attributes));
+            }
+        } else if (is_string($inputs)) {
+            $output .= \html_writer::tag('p', $inputs);
+        }
+        return $output;
+    }
+
+    /**
+     * Render a question for a survey.
+     * @param mod_questionnaire\question\base $question The question object.
+     * @param array $formdata Any returned form data.
+     * @param array $descendantsdata Question dependency data.
+     * @param int $qnum The question number.
+     * @param boolean $blankquestionnaire Used for printing a blank one.
+     * @return string The output for the page.
+     */
+    public function question_output($question, $formdata, $descendantsdata, $qnum, $blankquestionnaire) {
+
+        $pagetags = $question->question_output($formdata, $descendantsdata, $qnum, $blankquestionnaire);
+
+        // If the question has a template, then render it from the 'qformelement' context. If no template, then 'qformelement'
+        // already contains HTML.
+        if (($template = $question->question_template())) {
+            $pagetags->qformelement = $this->render_from_template($template, $pagetags->qformelement);
+        }
+
+        // Calling "question_output" may generate per question notifications. If present, add them to the question output.
+        if (($notifications = $question->get_notifications()) !== false) {
+            foreach ($notifications as $notification) {
+                $pagetags->notifications = $this->notification($notification, \core\output\notification::NOTIFY_ERROR);
+            }
+        }
+        return $this->render_from_template('mod_questionnaire/question_container', $pagetags);
+    }
+
+    /**
+     * Render a question response.
+     * @param mod_questionnaire\question\base $question The question object.
+     * @param stdClass $data All of the response data.
+     * @param int $qnum The question number.
+     * @return string The output for the page.
+     */
+    public function response_output($question, $data, $qnum=null) {
+        $pagetags = $question->response_output($data, $qnum);
+
+        // If the response has a template, then render it from the 'qformelement' context. If no template, then 'qformelement'
+        // already contains HTML.
+        if (($template = $question->response_template())) {
+            $pagetags->qformelement = $this->render_from_template($template, $pagetags->qformelement);
+        }
+
+        // Calling "question_output" may generate per question notifications. If present, add them to the question output.
+        if (($notifications = $question->get_notifications()) !== false) {
+            foreach ($notifications as $notification) {
+                $pagetags->notifications = $this->notification($notification, \core\output\notification::NOTIFY_ERROR);
+            }
+        }
+        return $this->render_from_template('mod_questionnaire/question_container', $pagetags);
+    }
+
+    /**
+     * Render all responses for a question.
+     * @param stdClass $data All of the response data.
+     * @return string The output for the page.
+     */
+    public function all_response_output($data=null) {
+        $output = '';
+        if (is_string($data)) {
+            $output .= $data;
+        } else {
+            foreach ($data as $qnum => $responses) {
+                $question = $responses['question'];
+                $pagetags = $question->questionstart_survey_display($qnum);
+                foreach ($responses as $item => $response) {
+                    if ($item !== 'question') {
+                        $resptags = $question->response_output($response['respdata']);
+                        // If the response has a template, then render it from the 'qformelement' context.
+                        // If no template, then 'qformelement' already contains HTML.
+                        if (($template = $question->response_template())) {
+                            $resptags->qformelement = $this->render_from_template($template, $resptags->qformelement);
+                        }
+                        $resptags->respdate = $response['respdate'];
+                        $pagetags->responses[] = $resptags;
+                    }
+                }
+                $output .= $this->render_from_template('mod_questionnaire/response_container', $pagetags);
+            }
+        }
+        return $output;
+    }
+
+    /**
+     * Render a question results summary.
+     * @param mod_questionnaire\question\base $question The question object.
+     * @param array $rids The response ids.
+     * @param string $sort The sort order being used.
+     * @param string $anonymous The value of the anonymous setting.
+     * @return string The output for the page.
+     */
+    public function results_output($question, $rids, $sort, $anonymous) {
+        return $question->display_results($rids, $sort, $anonymous);
+    }
+
+    /**
+     * Render the reporting navigation bar.
+     * @param array $navbar All of the data needed for the template.
+     * @return string The rendered HTML.
+     */
+    public function navigationbar($navbar) {
+        return $this->render_from_template('mod_questionnaire/navbaralpha', $navbar);
+    }
+
+    /**
+     * Render the reporting navigation bar for one user.
+     * @param array $navbar All of the data needed for the template.
+     * @return string The rendered HTML.
+     */
+    public function usernavigationbar($navbar) {
+        return $this->render_from_template('mod_questionnaire/navbaruser', $navbar);
+    }
+
+    /**
+     * Render the response list for a number of users.
+     * @param array $navbar All of the data needed for the template.
+     * @return string The rendered HTML.
+     */
+    public function responselist($navbar) {
+        return $this->render_from_template('mod_questionnaire/responselist', $navbar);
+    }
+
+    /**
+     * Render a print/preview page number line.
+     * @param string $content The content to render.
+     * @return string The rendered HTML.
+     */
+    public function print_preview_pagenumber($content) {
+        return \html_writer::tag('div', $content, ['class' => 'surveyPage']);
+    }
+
+    /**
+     * Render the print/preview completion form end HTML.
+     * @param string $url The url to call.
+     * @param string $submitstr The submit text.
+     * @param string $resetstr The reset text.
+     * @return string The output for the page.
+     */
+    public function print_preview_formend($url, $submitstr, $resetstr) {
+        $output = '';
+        $output .= \html_writer::start_tag('div');
+        $output .= \html_writer::empty_tag('input', ['type' => 'submit', 'name' => 'submit', 'value' => $submitstr]);
+        $output .= ' ';
+        $output .= \html_writer::tag('a', $resetstr, ['href' => $url]);
+        $output .= \html_writer::end_tag('div') . "\n";
+        $output .= \html_writer::end_tag('form') . "\n";
+        return $output;
+    }
+
+    /**
+     * Render the back to home link on the save page.
+     * @param string $url The url to link to.
+     * @param string $text The text to apply the link to.
+     * @return string The rendered HTML.
+     */
+    public function homelink($url, $text) {
+        $output = '';
+        $output .= \html_writer::start_tag('div', ['class' => 'homelink']);
+        $output .= \html_writer::tag('a', $text, ['href' => $url]);
+        $output .= \html_writer::end_tag('div');
+        return $output;
+    }
+
+    /**
+     * Helper method dealing with the fact we can not just fetch the output of flexible_table
+     *
+     * @param flexible_table $table
+     * @param boolean $buffering True if already buffering.
+     * @return string HTML
+     */
+    public function flexible_table(\flexible_table $table, $buffering = false) {
+
+        $o = '';
+        if (!$buffering) {
+            ob_start();
+        }
+        $table->finish_output();
+        $o = ob_get_contents();
+        ob_end_clean();
+
+        return $o;
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/output/reportpage.php b/mod/questionnaire/classes/output/reportpage.php
new file mode 100644
index 0000000..0d7c52b
--- /dev/null
+++ b/mod/questionnaire/classes/output/reportpage.php
@@ -0,0 +1,71 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Contains class mod_questionnaire\output\viewpage
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\output;
+
+defined('MOODLE_INTERNAL') || die();
+
+class reportpage implements \renderable, \templatable {
+
+    /**
+     * The data to be exported.
+     * @var array
+     */
+    protected $data;
+
+    /**
+     * Construct the renderable.
+     * @param object $data The template data for export.
+     */
+    public function __construct($data = null) {
+        if ($data !== null) {
+            $this->data = $data;
+        } else {
+            $this->data = new \stdClass();
+        }
+    }
+
+    /**
+     * Add data for export.
+     * @param string The index for the data.
+     * @param string The content for the index.
+     */
+    public function add_to_page($element, $content) {
+        if ($element === 'responses') {
+            $this->data->{$element}[] = $content;
+        } else {
+            $this->data->{$element} = empty($this->data->{$element}) ? $content : ($this->data->{$element} . $content);
+        }
+    }
+
+    /**
+     * Export the data for template.
+     * @param \renderer_base $output
+     */
+    public function export_for_template(\renderer_base $output) {
+        return $this->data;
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/output/viewpage.php b/mod/questionnaire/classes/output/viewpage.php
new file mode 100644
index 0000000..3939810
--- /dev/null
+++ b/mod/questionnaire/classes/output/viewpage.php
@@ -0,0 +1,67 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Contains class mod_questionnaire\output\viewpage
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\output;
+
+defined('MOODLE_INTERNAL') || die();
+
+class viewpage implements \renderable, \templatable {
+
+    /**
+     * The data to be exported.
+     * @var array
+     */
+    protected $data;
+
+    /**
+     * Construct the renderable.
+     * @param object $data The template data for export.
+     */
+    public function __construct($data = null) {
+        if ($data !== null) {
+            $this->data = $data;
+        } else {
+            $this->data = new \stdClass();
+        }
+    }
+
+    /**
+     * Add data for export.
+     * @param string The index for the data.
+     * @param string The content for the index.
+     */
+    public function add_to_page($element, $content) {
+        $this->data->{$element} = empty($this->data->{$element}) ? $content : ($this->data->{$element} . $content);
+    }
+
+    /**
+     * Export the data for template.
+     * @param \renderer_base $output
+     */
+    public function export_for_template(\renderer_base $output) {
+        return $this->data;
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/base.php b/mod/questionnaire/classes/question/base.php
new file mode 100644
index 0000000..0429817
--- /dev/null
+++ b/mod/questionnaire/classes/question/base.php
@@ -0,0 +1,996 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+use \html_writer;
+
+/**
+ * This file contains the parent class for questionnaire question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+/**
+ * Class for describing a question
+ *
+ * @author Mike Churchward
+ * @package questiontypes
+ */
+
+ // Constants.
+define('QUESCHOOSE', 0);
+define('QUESYESNO', 1);
+define('QUESTEXT', 2);
+define('QUESESSAY', 3);
+define('QUESRADIO', 4);
+define('QUESCHECK', 5);
+define('QUESDROP', 6);
+define('QUESRATE', 8);
+define('QUESDATE', 9);
+define('QUESNUMERIC', 10);
+define('QUESPAGEBREAK', 99);
+define('QUESSECTIONTEXT', 100);
+
+global $idcounter, $CFG;
+$idcounter = 0;
+
+require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+abstract class base {
+
+    // Class Properties.
+    /** @var int $id The database id of this question. */
+    public $id          = 0;
+
+    /** @var int $survey_id The database id of the survey this question belongs to. */
+    // public $survey_id   = 0;  Commenting out for now, as '_' not allowed.
+
+    /** @var string $name The name of this question. */
+    public $name        = '';
+
+    /** @var string $type The name of the question type. */
+    public $type        = '';
+
+    /** @var array $choices Array holding any choices for this question. */
+    public $choices     = [];
+
+    /** @var string $response_table The table name for responses. */
+    public $responsetable = '';
+
+    /** @var int $length The length field. */
+    public $length      = 0;
+
+    /** @var int $precise The precision field. */
+    public $precise     = 0;
+
+    /** @var int $position Position in the questionnaire */
+    public $position    = 0;
+
+    /** @var string $content The question's content. */
+    public $content     = '';
+
+    /** @var string $allchoices The list of all question's choices. */
+    public $allchoices  = '';
+
+    /** @var boolean $required The required flag. */
+    public $required    = 'n';
+
+    /** @var boolean $deleted The deleted flag. */
+    public $deleted     = 'n';
+
+    /** @var array $qtypenames List of all question names. */
+    private static $qtypenames = [
+        QUESYESNO => 'yesno',
+        QUESTEXT => 'text',
+        QUESESSAY => 'essay',
+        QUESRADIO => 'radio',
+        QUESCHECK => 'check',
+        QUESDROP => 'drop',
+        QUESRATE => 'rate',
+        QUESDATE => 'date',
+        QUESNUMERIC => 'numerical',
+        QUESPAGEBREAK => 'pagebreak',
+        QUESSECTIONTEXT => 'sectiontext'
+    ];
+
+    /** @var array $notifications Array of extra messages for display purposes. */
+    private $notifications = [];
+
+    // Class Methods.
+
+    /**
+     * The class constructor
+     *
+     */
+    public function __construct($id = 0, $question = null, $context = null, $params = array()) {
+        global $DB;
+        static $qtypes = null;
+
+        if ($qtypes === null) {
+            $qtypes = $DB->get_records('questionnaire_question_type', [], 'typeid',
+                                       'typeid, type, has_choices, response_table');
+        }
+
+        if ($id) {
+            $question = $DB->get_record('questionnaire_question', ['id' => $id]);
+        }
+
+        if (is_object($question)) {
+            $this->id = $question->id;
+            $this->survey_id = $question->survey_id;
+            $this->name = $question->name;
+            // Added for skip feature.
+            $this->dependquestion = $question->dependquestion;
+            $this->dependchoice = $question->dependchoice;
+            $this->length = $question->length;
+            $this->precise = $question->precise;
+            $this->position = $question->position;
+            $this->content = $question->content;
+            $this->required = $question->required;
+            $this->deleted = $question->deleted;
+
+            $this->type_id = $question->type_id;
+            $this->type = $qtypes[$this->type_id]->type;
+            $this->response_table = $qtypes[$this->type_id]->response_table;
+            if ($qtypes[$this->type_id]->has_choices == 'y') {
+                $this->get_choices();
+            }
+        }
+        $this->context = $context;
+
+        foreach ($params as $property => $value) {
+            $this->$property = $value;
+        }
+
+        if ($respclass = $this->responseclass()) {
+            $this->response = new $respclass($this);
+        }
+    }
+
+    /**
+     * Short name for this question type - no spaces, etc..
+     * @return string
+     */
+    abstract public function helpname();
+
+    /**
+     * Build a question from data.
+     * @var int $qtype The question type code.
+     * @var int|array|object $qdata Either the id of the record, or a structure containing the question data, or null.
+     * @var object $context The context for the question.
+     * @return A question object.
+     */
+    static public function question_builder($qtype, $qdata = null, $context = null) {
+        $qclassname = '\\mod_questionnaire\\question\\'.self::qtypename($qtype);
+        $qid = 0;
+        if (!empty($qdata) && is_array($qdata)) {
+            $qdata = (object)$qdata;
+        } else if (!empty($qdata) && is_int($qdata)) {
+            $qid = $qdata;
+        }
+        return new $qclassname($qid, $qdata, $context, ['type_id' => $qtype]);
+    }
+
+    /**
+     * Return the different question type names.
+     * @return array
+     */
+    static public function qtypename($qtype) {
+        if (array_key_exists($qtype, self::$qtypenames)) {
+            return self::$qtypenames[$qtype];
+        } else {
+            return('');
+        }
+    }
+
+    /**
+     * Override and return true if the question has choices.
+     */
+    public function has_choices() {
+        return false;
+    }
+
+    private function get_choices() {
+        global $DB;
+
+        if ($choices = $DB->get_records('questionnaire_quest_choice', ['question_id' => $this->id], 'id ASC')) {
+            foreach ($choices as $choice) {
+                $this->choices[$choice->id] = new \stdClass();
+                $this->choices[$choice->id]->content = $choice->content;
+                $this->choices[$choice->id]->value = $choice->value;
+            }
+        } else {
+            $this->choices = [];
+        }
+    }
+
+    /**
+     * Insert response data method.
+     */
+    public function insert_response($rid, $val) {
+        if (isset ($this->response) && is_object($this->response) &&
+            is_subclass_of($this->response, '\\mod_questionnaire\\response\\base')) {
+            return $this->response->insert_response($rid, $val);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Get results data method.
+     */
+    public function get_results($rids = false) {
+        if (isset ($this->response) && is_object($this->response) &&
+            is_subclass_of($this->response, '\\mod_questionnaire\\response\\base')) {
+            return $this->response->get_results($rids);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Display results method.
+     */
+    public function display_results($rids=false, $sort='', $anonymous=false) {
+        if (isset ($this->response) && is_object($this->response) &&
+            is_subclass_of($this->response, '\\mod_questionnaire\\response\\base')) {
+            return $this->response->display_results($rids, $sort, $anonymous);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Add a notification.
+     * @param string $message
+     */
+    public function add_notification($message) {
+        $this->notifications[] = $message;
+    }
+
+    /**
+     * Get any notifications.
+     * @return array | boolean The notifications array or false.
+     */
+    public function get_notifications() {
+        if (empty($this->notifications)) {
+            return false;
+        } else {
+            return $this->notifications;
+        }
+    }
+
+    /**
+     * Each question type must define its response class.
+     *
+     * @return object The response object based off of questionnaire_response_base.
+     *
+     */
+    abstract protected function responseclass();
+
+    /**
+     * Check question's form data for complete response.
+     *
+     * @param object $responsedata The data entered into the response.
+     * @return boolean
+     */
+    public function response_complete($responsedata) {
+        return !(($this->required == 'y') && ($this->deleted == 'n') &&
+                 (!isset($responsedata->{'q'.$this->id}) || $responsedata->{'q'.$this->id} == ''));
+    }
+
+    /**
+     * Check question's form data for valid response. Override this if type has specific format requirements.
+     *
+     * @param object $responsedata The data entered into the response.
+     * @return boolean
+     */
+    public function response_valid($responsedata) {
+        return true;
+    }
+
+    /**
+     * Update data record from object or optional question data.
+     *
+     * @param object $questionrecord An object with all updated question record data.
+     * @param boolean $updatechoices True if choices should also be updated.
+     */
+    public function update($questionrecord = null, $updatechoices = true) {
+        global $DB;
+
+        if ($questionrecord === null) {
+            $questionrecord = new \stdClass();
+            $questionrecord->id = $this->id;
+            $questionrecord->survey_id = $this->survey_id;
+            $questionrecord->name = $this->name;
+            $questionrecord->type_id = $this->type_id;
+            $questionrecord->result_id = $this->result_id;
+            $questionrecord->length = $this->length;
+            $questionrecord->precise = $this->precise;
+            $questionrecord->position = $this->position;
+            $questionrecord->content = $this->content;
+            $questionrecord->required = $this->required;
+            $questionrecord->deleted = $this->deleted;
+            $questionrecord->dependquestion = $this->dependquestion;
+            $questionrecord->dependchoice = $this->dependchoice;
+        } else {
+            // Make sure the "id" field is this question's.
+            if (isset($this->qid) && ($this->qid > 0)) {
+                $questionrecord->id = $this->qid;
+            } else {
+                $questionrecord->id = $this->id;
+            }
+        }
+        $DB->update_record('questionnaire_question', $questionrecord);
+
+        if ($updatechoices && $this->has_choices()) {
+            $this->update_choices();
+        }
+    }
+
+    /**
+     * Add the question to the database from supplied arguments.
+     * @param object $questionrecord The required data for adding the question.
+     * @param array $choicerecords An array of choice records with 'content' and 'value' properties.
+     * @param boolean $calcposition Whether or not to calculate the next available position in the survey.
+     */
+    public function add($questionrecord, array $choicerecords = null, boolean $calcposition = null) {
+        global $DB;
+
+        // Default boolean parameter to "true".
+        if ($calcposition === null) {
+            $calcposition = true;
+        }
+
+        // Create new question.
+        if ($calcposition) {
+            // Set the position to the end.
+            $sql = 'SELECT MAX(position) as maxpos '.
+                   'FROM {questionnaire_question} '.
+                   'WHERE survey_id = ? AND deleted = ?';
+            $params = ['survey_id' => $questionrecord->survey_id, 'deleted' => 'n'];
+            if ($record = $DB->get_record_sql($sql, $params)) {
+                $questionrecord->position = $record->maxpos + 1;
+            } else {
+                $questionrecord->position = 1;
+            }
+        }
+
+        // Make sure we add all necessary data.
+        if (!isset($questionrecord->type_id) || empty($questionrecord->type_id)) {
+            $questionrecord->type_id = $this->type_id;
+        }
+
+        $this->qid = $DB->insert_record('questionnaire_question', $questionrecord);
+
+        if ($this->has_choices() && !empty($choicerecords)) {
+            foreach ($choicerecords as $choicerecord) {
+                $choicerecord->question_id = $this->qid;
+                $this->add_choice($choicerecord);
+            }
+        }
+    }
+
+    public function update_choices() {
+        global $DB;
+
+        $retvalue = true;
+        if ($this->has_choices() && isset($this->choices)) {
+            // Need to fix this messed-up qid/id issue.
+            if (isset($this->qid) && ($this->qid > 0)) {
+                $qid = $this->qid;
+            } else {
+                $qid = $this->id;
+            }
+            foreach ($this->choices as $key => $choice) {
+                $choicrecord = new \stdClass();
+                $choicerecord->id = $key;
+                $choicerecord->question_id = $qid;
+                $choicerecord->content = $choice->content;
+                $choicerecord->value = $choice->value;
+                $retvalue &= $this->update_choice($choicerecord);
+            }
+        }
+        return $retvalue;
+    }
+
+    public function update_choice($choicerecord) {
+        global $DB;
+        return $DB->update_record('questionnaire_quest_choice', $choicerecord);
+    }
+
+    public function add_choice($choicerecord) {
+        global $DB;
+        $retvalue = true;
+        if ($cid = $DB->insert_record('questionnaire_quest_choice', $choicerecord)) {
+            $this->choices[$cid] = new \stdClass();
+            $this->choices[$cid]->content = $choicerecord->content;
+            $this->choices[$cid]->value = isset($choicerecord->value) ? $choicerecord->value : null;
+        } else {
+            $retvalue = false;
+        }
+        return $retvalue;
+    }
+
+    /**
+     * Delete the choice from the question object and the database.
+     *
+     * @param integer|object $choice Either the integer id of the choice, or the choice record.
+     */
+    public function delete_choice($choice) {
+        global $DB;
+        $retvalue = true;
+        if (is_int($choice)) {
+            $cid = $choice;
+        } else {
+            $cid = $choice->id;
+        }
+        if ($DB->delete_records('questionnaire_quest_choice', ['id' => $cid])) {
+            unset($this->choices[$cid]);
+        } else {
+            $retvalue = false;
+        }
+        return $retvalue;
+    }
+
+    /**
+     * Set the question required field in the object and database.
+     *
+     * @param boolean $required Whether question should be required or not.
+     */
+    public function set_required($required) {
+        global $DB;
+        $rval = $required ? 'y' : 'n';
+        // Need to fix this messed-up qid/id issue.
+        if (isset($this->qid) && ($this->qid > 0)) {
+            $qid = $this->qid;
+        } else {
+            $qid = $this->id;
+        }
+        $this->required = $rval;
+        return $DB->set_field('questionnaire_question', 'required', $rval, ['id' => $qid]);
+    }
+
+    /**
+     * Question specific display method.
+     *
+     * @param object $formdata
+     * @param string $descendantdata
+     * @param boolean $blankquestionnaire
+     *
+     */
+    abstract protected function question_survey_display($formdata, $descendantsdata, $blankquestionnaire);
+
+    /**
+     * Question specific response display method.
+     *
+     * @param object $data
+     * @param integer $qnum
+     *
+     */
+    abstract protected function response_survey_display($data);
+
+    /**
+     * Override and return a form template if provided. Output of question_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function question_template() {
+        return false;
+    }
+
+    /**
+     * Override and return a form template if provided. Output of response_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function response_template() {
+        return false;
+    }
+
+    /**
+     * Get the output for question renderers / templates.
+     * @param object $formdata
+     * @param string $descendantdata
+     * @param integer $qnum
+     * @param boolean $blankquestionnaire
+     */
+    public function question_output($formdata, $descendantsdata, $qnum='', $blankquestionnaire) {
+        $pagetags = $this->questionstart_survey_display($qnum, $formdata);
+        $pagetags->qformelement = $this->question_survey_display($formdata, $descendantsdata, $blankquestionnaire);
+        return $pagetags;
+    }
+
+    /**
+     * Get the output for question renderers / templates.
+     * @param object $formdata
+     * @param string $descendantdata
+     * @param integer $qnum
+     * @param boolean $blankquestionnaire
+     */
+    public function response_output($data, $qnum='') {
+        $pagetags = $this->questionstart_survey_display($qnum, $data);
+        $pagetags->qformelement = $this->response_survey_display($data);
+        return $pagetags;
+    }
+
+    /**
+     * Get the output for the start of the questions in a survey.
+     * @param integer $qnum
+     * @param object $formdata
+     */
+    public function questionstart_survey_display($qnum, $formdata='') {
+        global $OUTPUT, $SESSION, $questionnaire, $PAGE;
+
+        $pagetags = new \stdClass();
+        $currenttab = $SESSION->questionnaire->current_tab;
+        $pagetype = $PAGE->pagetype;
+        $skippedquestion = false;
+        $skippedclass = '';
+        $autonum = $questionnaire->autonum;
+        // If no questions autonumbering.
+        $nonumbering = false;
+        if ($autonum != 1 && $autonum != 3) {
+            $qnum = '';
+            $nonumbering = true;
+        }
+        // If we are on report page and this questionnaire has dependquestions and this question was skipped.
+        if ( ($pagetype == 'mod-questionnaire-myreport' || $pagetype == 'mod-questionnaire-report')
+                        && $nonumbering == false
+                        && $formdata
+                        && $this->dependquestion != 0 && !array_key_exists('q'.$this->id, $formdata)) {
+            $skippedquestion = true;
+            $skippedclass = ' unselected';
+            $qnum = '<span class="'.$skippedclass.'">('.$qnum.')</span>';
+        }
+        // In preview mode, hide children questions that have not been answered.
+        // In report mode, If questionnaire is set to no numbering,
+        // also hide answers to questions that have not been answered.
+        $displayclass = 'qn-container';
+        if ($pagetype == 'mod-questionnaire-preview' || ($nonumbering
+                        && ($currenttab == 'mybyresponse' || $currenttab == 'individualresp'))) {
+            $parent = questionnaire_get_parent ($this);
+            if ($parent) {
+                $dependquestion = $parent[$this->id]['qdependquestion'];
+                $dependchoice = $parent[$this->id]['qdependchoice'];
+                $parenttype = $parent[$this->id]['parenttype'];
+                $displayclass = 'hidedependquestion';
+                if (isset($formdata->{'q'.$this->id}) && $formdata->{'q'.$this->id}) {
+                    $displayclass = 'qn-container';
+                }
+
+                if ($this->type_id == QUESRATE) {
+                    foreach ($this->choices as $key => $choice) {
+                        if (isset($formdata->{'q'.$this->id.'_'.$key})) {
+                            $displayclass = 'qn-container';
+                            break;
+                        }
+                    }
+                }
+
+                if (isset($formdata->$dependquestion) && $formdata->$dependquestion == $dependchoice) {
+                    $displayclass = 'qn-container';
+                }
+
+                if ($parenttype == QUESDROP) {
+                    $qnid = preg_quote('qn-'.$this->id, '/');
+                    if (isset($formdata->$dependquestion) && preg_match("/$qnid/", $formdata->$dependquestion)) {
+                        $displayclass = 'qn-container';
+                    }
+                }
+            }
+        }
+
+        $pagetags->fieldset = (object)['id' => $this->id, 'class' => $displayclass];
+
+        // Do not display the info box for the label question type.
+        if ($this->type_id != QUESSECTIONTEXT) {
+            if (!$nonumbering) {
+                $pagetags->qnum = $qnum;
+            }
+            $required = '';
+            if ($this->required == 'y') {
+                $required = html_writer::start_tag('div', ['class' => 'accesshide']);
+                $required .= get_string('required', 'questionnaire');
+                $required .= html_writer::end_tag('div');
+                $required .= html_writer::empty_tag('img', ['class' => 'req', 'title' => get_string('required', 'questionnaire'),
+                    'alt' => get_string('required', 'questionnaire'), 'src' => $OUTPUT->image_url('req')]);
+            }
+            $pagetags->required = $required; // Need to replace this with better renderer / template?
+        }
+        // If question text is "empty", i.e. 2 non-breaking spaces were inserted, empty it.
+        if ($this->content == '<p>  </p>') {
+            $this->content = '';
+        }
+        $pagetags->skippedclass = $skippedclass;
+        if ($this->type_id == QUESNUMERIC || $this->type_id == QUESTEXT ||
+            $this->type_id == QUESDROP) {
+            $pagetags->label = (object)['for' => $this->type . $this->id];
+        }
+        if ($this->type_id == QUESESSAY) {
+            $pagetags->label = (object)['for' => 'edit-q' . $this->id];
+        }
+        $options = ['noclean' => true, 'para' => false, 'filter' => true, 'context' => $this->context, 'overflowdiv' => true];
+        $content = format_text(file_rewrite_pluginfile_urls($this->content, 'pluginfile.php',
+            $this->context->id, 'mod_questionnaire', 'question', $this->id), FORMAT_HTML, $options);
+        $pagetags->qcontent = $content;
+
+        return $pagetags;
+    }
+
+    private function response_check_required ($data) {
+        // JR check all question types
+        if ($this->type_id == QUESRATE) { // Rate is a special case.
+            foreach ($this->choices as $cid => $choice) {
+                $str = 'q'."{$this->id}_$cid";
+                if (isset($data->$str)) {
+                    return ('&nbsp;');
+                }
+            }
+        }
+        if ( ($this->required == 'y') &&  empty($data->{'q'.$this->id}) ) {
+            return ('*');
+        } else {
+            return ('&nbsp;');
+        }
+    }
+
+    // This section contains functions for editing the specific question types.
+    // There are required methods that must be implemented, and helper functions that can be used.
+
+    // Required functions that can be overridden by the question type.
+
+    /**
+     * Override this, or any of the internal methods, to provide specific form data for editing the question type.
+     * The structure of the elements here is the default layout for the question form.
+     */
+    public function edit_form(\MoodleQuickForm $mform, $questionnaire, $modcontext) {
+        $this->form_header($mform);
+        $this->form_name($mform);
+        $this->form_required($mform);
+        $this->form_length($mform);
+        $this->form_precise($mform);
+        $this->form_dependencies($mform, $questionnaire);
+        $this->form_question_text($mform, $modcontext);
+
+        if ($this->has_choices()) {
+            $this->allchoices = $this->form_choices($mform, $this->choices);
+        }
+
+        // Hidden fields.
+        $mform->addElement('hidden', 'id', 0);
+        $mform->setType('id', PARAM_INT);
+        $mform->addElement('hidden', 'qid', 0);
+        $mform->setType('qid', PARAM_INT);
+        $mform->addElement('hidden', 'sid', 0);
+        $mform->setType('sid', PARAM_INT);
+        $mform->addElement('hidden', 'type_id', $this->type_id);
+        $mform->setType('type_id', PARAM_INT);
+        $mform->addElement('hidden', 'action', 'question');
+        $mform->setType('action', PARAM_ALPHA);
+
+        // Buttons.
+        $buttonarray[] = &$mform->createElement('submit', 'submitbutton', get_string('savechanges'));
+        if (isset($this->qid)) {
+            $buttonarray[] = &$mform->createElement('submit', 'makecopy', get_string('saveasnew', 'questionnaire'));
+        }
+        $buttonarray[] = &$mform->createElement('cancel');
+        $mform->addGroup($buttonarray, 'buttonar', '', [' '], false);
+
+        return true;
+    }
+
+    protected function form_header(\MoodleQuickForm $mform, $helpname = '') {
+        // Display different messages for new question creation and existing question modification.
+        if (isset($this->qid) && !empty($this->qid)) {
+            $header = get_string('editquestion', 'questionnaire', questionnaire_get_type($this->type_id));
+        } else {
+            $header = get_string('addnewquestion', 'questionnaire', questionnaire_get_type($this->type_id));
+        }
+        if (empty($helpname)) {
+            $helpname = $this->helpname();
+        }
+
+        $mform->addElement('header', 'questionhdredit', $header);
+        $mform->addHelpButton('questionhdredit', $helpname, 'questionnaire');
+    }
+
+    protected function form_name(\MoodleQuickForm $mform) {
+        $mform->addElement('text', 'name', get_string('optionalname', 'questionnaire'),
+                        ['size' => '30', 'maxlength' => '30']);
+        $mform->setType('name', PARAM_TEXT);
+        $mform->addHelpButton('name', 'optionalname', 'questionnaire');
+        return $mform;
+    }
+
+    protected function form_required(\MoodleQuickForm $mform) {
+        $reqgroup = [];
+        $reqgroup[] =& $mform->createElement('radio', 'required', '', get_string('yes'), 'y');
+        $reqgroup[] =& $mform->createElement('radio', 'required', '', get_string('no'), 'n');
+        $mform->addGroup($reqgroup, 'reqgroup', get_string('required', 'questionnaire'), ' ', false);
+        $mform->addHelpButton('reqgroup', 'required', 'questionnaire');
+        return $mform;
+    }
+
+    protected function form_length(\MoodleQuickForm $mform, $helpname = '') {
+        self::form_length_text($mform, $helpname);
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helpname = '') {
+        self::form_precise_text($mform, $helpname);
+    }
+
+    protected function form_dependencies(\MoodleQuickForm $mform, $questionnaire) {
+        // Dependence fields.
+
+        if ($questionnaire->navigate) {
+            $position = ($this->position !== 0) ? $this->position : count($questionnaire->questions) + 1;
+            $dependencies = questionnaire_get_dependencies($questionnaire->questions, $position);
+            $canchangeparent = true;
+            if (count($dependencies) > 1) {
+                if (isset($this->qid)) {
+                    $haschildren = questionnaire_get_descendants ($questionnaire->questions, $this->qid);
+                    if (count($haschildren) !== 0) {
+                        $canchangeparent = false;
+                        $parent = questionnaire_get_parent ($this);
+                        $fixeddependency = $parent [$this->id]['parent'];
+                    }
+                }
+                if ($canchangeparent) {
+                    $this->dependquestion = isset($this->dependquestion) ? $this->dependquestion.','.
+                                    $this->dependchoice : '0,0';
+                    $group = [$mform->createElement('selectgroups', 'dependquestion', '', $dependencies)];
+                    $mform->addGroup($group, 'selectdependency', get_string('dependquestion', 'questionnaire'), '', false);
+                    $mform->addHelpButton('selectdependency', 'dependquestion', 'questionnaire');
+                } else {
+                    $mform->addElement('static', 'selectdependency', get_string('dependquestion', 'questionnaire'),
+                                    '<div class="dimmed_text">'.$fixeddependency.'</div>');
+                }
+                $mform->addHelpButton('selectdependency', 'dependquestion', 'questionnaire');
+            }
+        }
+    }
+
+    protected function form_question_text(\MoodleQuickForm $mform, $context) {
+        $editoroptions = ['maxfiles' => EDITOR_UNLIMITED_FILES, 'trusttext' => true, 'context' => $context];
+        $mform->addElement('editor', 'content', get_string('text', 'questionnaire'), null, $editoroptions);
+        $mform->setType('content', PARAM_RAW);
+        $mform->addRule('content', null, 'required', null, 'client');
+        return $mform;
+    }
+
+    protected function form_choices(\MoodleQuickForm $mform, array $choices, $helpname = '') {
+        $numchoices = count($choices);
+        $allchoices = '';
+        foreach ($choices as $choice) {
+            if (!empty($allchoices)) {
+                $allchoices .= "\n";
+            }
+            $allchoices .= $choice->content;
+        }
+        if (empty($helpname)) {
+            $helpname = $this->helpname();
+        }
+
+        $mform->addElement('html', '<div class="qoptcontainer">');
+        $options = array('wrap' => 'virtual', 'class' => 'qopts');
+        $mform->addElement('textarea', 'allchoices', get_string('possibleanswers', 'questionnaire'), $options);
+        $mform->setType('allchoices', PARAM_RAW);
+        $mform->addRule('allchoices', null, 'required', null, 'client');
+        $mform->addHelpButton('allchoices', $helpname, 'questionnaire');
+        $mform->addElement('html', '</div>');
+        $mform->addElement('hidden', 'num_choices', $numchoices);
+        $mform->setType('num_choices', PARAM_INT);
+        return $allchoices;
+    }
+
+    // Helper functions for commonly used editing functions.
+
+    static public function form_length_hidden(\MoodleQuickForm $mform, $value = 0) {
+        $mform->addElement('hidden', 'length', $value);
+        $mform->setType('length', PARAM_INT);
+        return $mform;
+    }
+
+    static public function form_length_text(\MoodleQuickForm $mform, $helpname = '', $value = 0) {
+        $mform->addElement('text', 'length', get_string($helpname, 'questionnaire'), ['size' => '1'], $value);
+        $mform->setType('length', PARAM_INT);
+        if (!empty($helpname)) {
+            $mform->addHelpButton('length', $helpname, 'questionnaire');
+        }
+        return $mform;
+    }
+
+    static public function form_precise_hidden(\MoodleQuickForm $mform, $value = 0) {
+        $mform->addElement('hidden', 'precise', $value);
+        $mform->setType('precise', PARAM_INT);
+        return $mform;
+    }
+
+    static public function form_precise_text(\MoodleQuickForm $mform, $helpname = '', $value = 0) {
+        $mform->addElement('text', 'precise', get_string($helpname, 'questionnaire'), ['size' => '1']);
+        $mform->setType('precise', PARAM_INT);
+        if (!empty($helpname)) {
+            $mform->addHelpButton('precise', $helpname, 'questionnaire');
+        }
+        return $mform;
+    }
+
+    /**
+     * Create and update question data from the forms.
+     */
+    public function form_update($formdata, $questionnaire) {
+        global $DB;
+
+        $this->form_preprocess_data($formdata);
+
+        if (!empty($formdata->qid)) {
+
+            // Update existing question.
+            // Handle any attachments in the content.
+            $formdata->itemid  = $formdata->content['itemid'];
+            $formdata->format  = $formdata->content['format'];
+            $formdata->content = $formdata->content['text'];
+            $formdata->content = file_save_draft_area_files($formdata->itemid, $questionnaire->context->id, 'mod_questionnaire',
+                'question', $formdata->qid, ['subdirs' => true], $formdata->content);
+
+            $fields = ['name', 'type_id', 'length', 'precise', 'required', 'content', 'dependquestion', 'dependchoice'];
+            $questionrecord = new \stdClass();
+            $questionrecord->id = $formdata->qid;
+            foreach ($fields as $f) {
+                if (isset($formdata->$f)) {
+                    $questionrecord->$f = trim($formdata->$f);
+                }
+            }
+            $result = $this->update($questionrecord, false);
+
+            if (questionnaire_has_dependencies($questionnaire->questions)) {
+                questionnaire_check_page_breaks($questionnaire);
+            }
+        } else {
+            // Create new question:
+            // Need to update any image content after the question is created, so create then update the content.
+            $formdata->survey_id = $formdata->sid;
+            $fields = ['survey_id', 'name', 'type_id', 'length', 'precise', 'required', 'position', 'dependquestion',
+                'dependchoice'];
+            $questionrecord = new \stdClass();
+            foreach ($fields as $f) {
+                if (isset($formdata->$f)) {
+                    $questionrecord->$f = trim($formdata->$f);
+                }
+            }
+            $questionrecord->content = '';
+
+            $this->add($questionrecord);
+
+            // Handle any attachments in the content.
+            $formdata->itemid  = $formdata->content['itemid'];
+            $formdata->format  = $formdata->content['format'];
+            $formdata->content = $formdata->content['text'];
+            $content           = file_save_draft_area_files($formdata->itemid, $questionnaire->context->id, 'mod_questionnaire',
+                'question', $this->qid, ['subdirs' => true], $formdata->content);
+            $result = $DB->set_field('questionnaire_question', 'content', $content, ['id' => $this->qid]);
+        }
+
+        if ($this->has_choices()) {
+            // Now handle any choice updates.
+            $cidx = 0;
+            if (isset($this->choices) && !isset($formdata->makecopy)) {
+                $oldcount = count($this->choices);
+                $echoice = reset($this->choices);
+                $ekey = key($this->choices);
+            } else {
+                $oldcount = 0;
+            }
+
+            $newchoices = explode("\n", $formdata->allchoices);
+            $nidx = 0;
+            $newcount = count($newchoices);
+
+            while (($nidx < $newcount) && ($cidx < $oldcount)) {
+                if ($newchoices[$nidx] != $echoice->content) {
+                    $choicerecord = new \stdClass();
+                    $choicerecord->id = $ekey;
+                    $choicerecord->question_id = $this->qid;
+                    $choicerecord->content = trim($newchoices[$nidx]);
+                    $r = preg_match_all("/^(\d{1,2})(=.*)$/", $newchoices[$nidx], $matches);
+                    // This choice has been attributed a "score value" OR this is a rate question type.
+                    if ($r) {
+                        $newscore = $matches[1][0];
+                        $choicerecord->value = $newscore;
+                    } else {     // No score value for this choice.
+                        $choicerecord->value = null;
+                    }
+                    $this->update_choice($choicerecord);
+                }
+                $nidx++;
+                $echoice = next($this->choices);
+                $ekey = key($this->choices);
+                $cidx++;
+            }
+
+            while ($nidx < $newcount) {
+                // New choices...
+                $choicerecord = new \stdClass();
+                $choicerecord->question_id = $this->qid;
+                $choicerecord->content = trim($newchoices[$nidx]);
+                $r = preg_match_all("/^(\d{1,2})(=.*)$/", $choicerecord->content, $matches);
+                // This choice has been attributed a "score value" OR this is a rate question type.
+                if ($r) {
+                    $choicerecord->value = $matches[1][0];
+                }
+                $this->add_choice($choicerecord);
+                $nidx++;
+            }
+
+            while ($cidx < $oldcount) {
+                end($this->choices);
+                $ekey = key($this->choices);
+                $this->delete_choice($ekey);
+                $cidx++;
+            }
+        }
+    }
+
+    /**
+     * Any preprocessing of general data.
+     */
+    protected function form_preprocess_data($formdata) {
+        if ($this->has_choices()) {
+            // Eliminate trailing blank lines.
+            $formdata->allchoices = preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", "\n", $formdata->allchoices);
+            // Trim to eliminate potential trailing carriage return.
+            $formdata->allchoices = trim($formdata->allchoices);
+            $this->form_preprocess_choicedata($formdata);
+        }
+        $dependency = [];
+        if (isset($formdata->dependquestion) && $formdata->dependquestion != 0) {
+            $dependency = explode(",", $formdata->dependquestion);
+            $formdata->dependquestion = $dependency[0];
+            $formdata->dependchoice = $dependency[1];
+        }
+        return true;
+    }
+
+    /**
+     * Override this function for question specific choice preprocessing.
+     */
+    protected function form_preprocess_choicedata($formdata) {
+        if (empty($formdata->allchoices)) {
+            error (get_string('enterpossibleanswers', 'questionnaire'));
+        }
+        return false;
+    }
+
+    /**
+     * Return all the fields to be used for users in questionnaire sql.
+     *
+     * @author: Guy Thomas
+     * @return string
+     */
+    protected function user_fields_sql() {
+        $userfieldsarr = get_all_user_name_fields();
+        $userfieldsarr = array_merge($userfieldsarr, ['username', 'department', 'institution']);
+        $userfields = '';
+        foreach ($userfieldsarr as $field) {
+            $userfields .= $userfields === '' ? '' : ', ';
+            $userfields .= 'u.'.$field;
+        }
+        $userfields .= ', u.id as uid';
+        return $userfields;
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/check.php b/mod/questionnaire/classes/question/check.php
new file mode 100644
index 0000000..a5f4674
--- /dev/null
+++ b/mod/questionnaire/classes/question/check.php
@@ -0,0 +1,297 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for check question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+use \html_writer;
+
+class check extends base {
+
+    protected function responseclass() {
+        return '\\mod_questionnaire\\response\\multiple';
+    }
+
+    public function helpname() {
+        return 'checkboxes';
+    }
+
+    /**
+     * Return true if the question has choices.
+     */
+    public function has_choices() {
+        return true;
+    }
+
+    /**
+     * Override and return a form template if provided. Output of question_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function question_template() {
+        return 'mod_questionnaire/question_check';
+    }
+
+    /**
+     * Override and return a form template if provided. Output of response_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function response_template() {
+        return 'mod_questionnaire/response_check';
+    }
+
+    /**
+     * Return the context tags for the check question template.
+     * @param object $data
+     * @param string $descendantdata
+     * @param boolean $blankquestionnaire
+     * @return object The check question context tags.
+     *
+     */
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        // Check boxes.
+        $otherempty = false;
+        if (!empty($data) ) {
+            if (!isset($data->{'q'.$this->id}) || !is_array($data->{'q'.$this->id})) {
+                $data->{'q'.$this->id} = array();
+            }
+            // Verify that number of checked boxes (nbboxes) is within set limits (length = min; precision = max).
+            if ( $data->{'q'.$this->id} ) {
+                $otherempty = false;
+                $boxes = $data->{'q'.$this->id};
+                $nbboxes = count($boxes);
+                foreach ($boxes as $box) {
+                    $pos = strpos($box, 'other_');
+                    if (is_int($pos) == true) {
+                        $otherchoice = substr($box, 6);
+                        $resp = 'q'.$this->id.''.substr($box, 5);
+                        if (!$data->$resp) {
+                            $otherempty = true;
+                        }
+                    }
+                }
+                $nbchoices = count($this->choices);
+                $min = $this->length;
+                $max = $this->precise;
+                if ($max == 0) {
+                    $max = $nbchoices;
+                }
+                if ($min > $max) {
+                    $min = $max; // Sanity check.
+                }
+                $min = min($nbchoices, $min);
+                $msg = '';
+                if ($nbboxes < $min || $nbboxes > $max) {
+                    $msg = get_string('boxesnbreq', 'questionnaire');
+                    if ($min == $max) {
+                        $msg .= '&nbsp;'.get_string('boxesnbexact', 'questionnaire', $min);
+                    } else {
+                        if ($min && ($nbboxes < $min)) {
+                            $msg .= get_string('boxesnbmin', 'questionnaire', $min);
+                            if ($nbboxes > $max) {
+                                $msg .= ' & ' .get_string('boxesnbmax', 'questionnaire', $max);
+                            }
+                        } else {
+                            if ($nbboxes > $max ) {
+                                $msg .= get_string('boxesnbmax', 'questionnaire', $max);
+                            }
+                        }
+                    }
+                    $this->add_notification($msg);
+                }
+            }
+        }
+
+        $choicetags = new \stdClass();
+        $choicetags->qelements = [];
+        foreach ($this->choices as $id => $choice) {
+
+            $other = strpos($choice->content, '!other');
+            $checkbox = new \stdClass();
+            if ($other !== 0) { // This is a normal check box.
+                $contents = questionnaire_choice_values($choice->content);
+                $checked = false;
+                if (!empty($data) ) {
+                    $checked = in_array($id, $data->{'q'.$this->id});
+                }
+                $checkbox->name = 'q'.$this->id.'[]';
+                $checkbox->value = $id;
+                $checkbox->id = 'checkbox_'.$id;
+                $checkbox->label = format_text($contents->text, FORMAT_HTML, ['noclean' => true]).$contents->image;
+                if ($checked) {
+                    $checkbox->checked = $checked;
+                }
+            } else {             // Check box with associated !other text field.
+                // In case length field has been used to enter max number of choices, set it to 20.
+                $othertext = preg_replace(
+                        array("/^!other=/", "/^!other/"),
+                        array('', get_string('other', 'questionnaire')),
+                        $choice->content);
+                $cid = 'q'.$this->id.'_'.$id;
+                if (!empty($data) && !empty($data->$cid)) {
+                    $checked = true;
+                } else {
+                    $checked = false;
+                }
+                $name = 'q'.$this->id.'[]';
+                $value = 'other_'.$id;
+
+                $checkbox->name = $name;
+                $checkbox->oname = $cid;
+                $checkbox->value = $value;
+                $checkbox->ovalue = (!empty($data->$cid) ? stripslashes($data->$cid) : '');
+                $checkbox->id = 'checkbox_'.$id;
+                $checkbox->label = format_text($othertext.'', FORMAT_HTML, ['noclean' => true]);
+                if ($checked) {
+                    $checkbox->checked = $checked;
+                }
+            }
+            $choicetags->qelements[] = (object)['choice' => $checkbox];
+        }
+        if ($otherempty) {
+            $this->add_notification(get_string('otherempty', 'questionnaire'));
+        }
+
+        return $choicetags;
+    }
+
+    /**
+     * Return the context tags for the check response template.
+     * @param object $data
+     * @return object The check question response context tags.
+     *
+     */
+    protected function response_survey_display($data) {
+        static $uniquetag = 0;  // To make sure all radios have unique names.
+
+        $resptags = new \stdClass();
+        $resptags->choices = [];
+
+        if (!isset($data->{'q'.$this->id}) || !is_array($data->{'q'.$this->id})) {
+            $data->{'q'.$this->id} = array();
+        }
+
+        foreach ($this->choices as $id => $choice) {
+            $chobj = new \stdClass();
+            if (strpos($choice->content, '!other') !== 0) {
+                $contents = questionnaire_choice_values($choice->content);
+                $choice->content = $contents->text.$contents->image;
+                if (in_array($id, $data->{'q'.$this->id})) {
+                    $chobj->selected = 1;
+                }
+                $chobj->name = $id.$uniquetag++;
+                $chobj->content = (($choice->content === '') ? $id : format_text($choice->content, FORMAT_HTML,
+                    ['noclean' => true]));
+            } else {
+                $othertext = preg_replace(
+                        array("/^!other=/", "/^!other/"),
+                        array('', get_string('other', 'questionnaire')),
+                        $choice->content);
+                $cid = 'q'.$this->id.'_'.$id;
+
+                if (isset($data->$cid)) {
+                    $chobj->selected = 1;
+                    $chobj->othercontent = (!empty($data->$cid) ? htmlspecialchars($data->$cid) : '&nbsp;');
+                }
+                $chobj->name = $id.$uniquetag++;
+                $chobj->content = (($othertext === '') ? $id : $othertext);
+            }
+            $resptags->choices[] = $chobj;
+        }
+        return $resptags;
+    }
+
+    /**
+     * Check question's form data for valid response. Override this is type has specific format requirements.
+     *
+     * @param object $responsedata The data entered into the response.
+     * @return boolean
+     */
+    public function response_valid($responsedata) {
+        $valid = true;
+        if (isset($responsedata->{'q'.$this->id})) {
+            $nbrespchoices = 0;
+            foreach ($responsedata->{'q'.$this->id} as $resp) {
+                if (strpos($resp, 'other_') !== false) {
+                    // ..."other" choice is checked but text box is empty.
+                    $othercontent = "q".$this->id.substr($resp, 5);
+                    if (empty($responsedata->$othercontent)) {
+                        $valid = false;
+                        break;
+                    }
+                    $nbrespchoices++;
+                } else if (is_numeric($resp)) {
+                    $nbrespchoices++;
+                }
+            }
+            $nbquestchoices = count($this->choices);
+            $min = $this->length;
+            $max = $this->precise;
+            if ($max == 0) {
+                $max = $nbquestchoices;
+            }
+            if ($min > $max) {
+                $min = $max;     // Sanity check.
+            }
+            $min = min($nbquestchoices, $min);
+            if ( $nbrespchoices && ($nbrespchoices < $min || $nbrespchoices > $max) ) {
+                // Number of ticked boxes is not within min and max set limits.
+                $valid = false;
+            }
+        } else {
+            $valid = parent::response_valid($responsedata);
+        }
+
+        return $valid;
+    }
+
+    protected function form_length(\MoodleQuickForm $mform, $helptext = '') {
+        return parent::form_length($mform, 'minforcedresponses');
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helptext = '') {
+        return parent::form_precise($mform, 'maxforcedresponses');
+    }
+
+    /**
+     * Preprocess choice data.
+     */
+    protected function form_preprocess_choicedata($formdata) {
+        if (empty($formdata->allchoices)) {
+            error (get_string('enterpossibleanswers', 'questionnaire'));
+        } else {
+            // Sanity checks for min and max checked boxes.
+            $allchoices = $formdata->allchoices;
+            $allchoices = explode("\n", $allchoices);
+            $nbvalues = count($allchoices);
+
+            if ($formdata->length > $nbvalues) {
+                $formdata->length = $nbvalues;
+            }
+            if ($formdata->precise > $nbvalues) {
+                $formdata->precise = $nbvalues;
+            }
+            $formdata->precise = max($formdata->length, $formdata->precise);
+        }
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/date.php b/mod/questionnaire/classes/question/date.php
new file mode 100644
index 0000000..1462d06
--- /dev/null
+++ b/mod/questionnaire/classes/question/date.php
@@ -0,0 +1,127 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for date question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+use \html_writer;
+
+class date extends base {
+
+    protected function responseclass() {
+        return '\\mod_questionnaire\\response\\date';
+    }
+
+    public function helpname() {
+        return 'date';
+    }
+
+    /**
+     * Override and return a form template if provided. Output of question_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function question_template() {
+        return 'mod_questionnaire/question_date';
+    }
+
+    /**
+     * Override and return a form template if provided. Output of response_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function response_template() {
+        return 'mod_questionnaire/response_date';
+    }
+
+    /**
+     * Return the context tags for the check question template.
+     * @param object $data
+     * @param string $descendantdata
+     * @param boolean $blankquestionnaire
+     * @return object The check question context tags.
+     *
+     */
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        // Date.
+        $questiontags = new \stdClass();
+        if (!empty($data->{'q'.$this->id})) {
+            $dateentered = $data->{'q'.$this->id};
+            $setdate = questionnaire_check_date ($dateentered, false);
+            if ($setdate == 'wrongdateformat') {
+                $msg = get_string('wrongdateformat', 'questionnaire', $dateentered);
+                $this->add_notification($msg);
+            } else if ($setdate == 'wrongdaterange') {
+                $msg = get_string('wrongdaterange', 'questionnaire');
+                $this->add_notification($msg);
+            } else {
+                $data->{'q'.$this->id} = $setdate;
+            }
+        }
+        $choice = new \stdClass();
+        $choice->onkeypress = 'return event.keyCode != 13;';
+        $choice->name = 'q'.$this->id;
+        $choice->value = (isset($data->{'q'.$this->id}) ? $data->{'q'.$this->id} : '');
+        $questiontags->qelements = new \stdClass();
+        $questiontags->qelements->choice = $choice;
+        return $questiontags;
+    }
+
+    /**
+     * Return the context tags for the check response template.
+     * @param object $data
+     * @return object The check question response context tags.
+     *
+     */
+    protected function response_survey_display($data) {
+        $resptags = new \stdClass();
+        if (isset($data->{'q'.$this->id})) {
+            $resptags->content = $data->{'q'.$this->id};
+        }
+        return $resptags;
+    }
+
+    /**
+     * Check question's form data for valid response. Override this is type has specific format requirements.
+     *
+     * @param object $responsedata The data entered into the response.
+     * @return boolean
+     */
+    public function response_valid($responsedata) {
+        if (isset($responsedata->{'q'.$this->id})) {
+            $checkdateresult = '';
+            if ($responsedata->{'q'.$this->id} != '') {
+                $checkdateresult = questionnaire_check_date($responsedata->{'q'.$this->id});
+            }
+            return (substr($checkdateresult, 0, 5) != 'wrong');
+        } else {
+            return parent::response_valid($responsedata);
+        }
+    }
+
+    protected function form_length(\MoodleQuickForm $mform, $helpname = '') {
+        return base::form_length_hidden($mform);
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helpname = '') {
+        return base::form_precise_hidden($mform);
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/drop.php b/mod/questionnaire/classes/question/drop.php
new file mode 100644
index 0000000..faa68e2
--- /dev/null
+++ b/mod/questionnaire/classes/question/drop.php
@@ -0,0 +1,173 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for drop question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+use \html_writer;
+
+class drop extends base {
+
+    protected function responseclass() {
+        return '\\mod_questionnaire\\response\\single';
+    }
+
+    public function helpname() {
+        return 'dropdown';
+    }
+
+    /**
+     * Return true if the question has choices.
+     */
+    public function has_choices() {
+        return true;
+    }
+
+    /**
+     * Override and return a form template if provided. Output of question_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function question_template() {
+        return 'mod_questionnaire/question_drop';
+    }
+
+    /**
+     * Override and return a form template if provided. Output of response_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function response_template() {
+        return 'mod_questionnaire/response_drop';
+    }
+
+    /**
+     * Return the context tags for the check question template.
+     * @param object $data
+     * @param string $descendantdata
+     * @param boolean $blankquestionnaire
+     * @return object The check question context tags.
+     *
+     */
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        // Drop.
+        $output = '';
+        $options = [];
+
+        $choicetags = new \stdClass();
+        $choicetags->qelements = new \stdClass();
+        $selected = isset($data->{'q'.$this->id}) ? $data->{'q'.$this->id} : false;
+        // To display or hide dependent questions on Preview page.
+        if ($descendantsdata) {
+            $qdropid = 'q'.$this->id;
+            $descendants = implode(',', $descendantsdata['descendants']);
+            foreach ($descendantsdata['choices'] as $key => $choice) {
+                $choices[$key] = implode(',', $choice);
+            }
+            $options[] = (object)['value' => '', 'label' => get_string('choosedots')];
+            foreach ($this->choices as $key => $choice) {
+                if ($pos = strpos($choice->content, '=')) {
+                    $choice->content = substr($choice->content, $pos + 1);
+                }
+                if (isset($choices[$key])) {
+                    $value = $choices[$key];
+                } else {
+                    $value = $key;
+                }
+                $option = new \stdClass();
+                $option->value = $value;
+                $option->label = $choice->content;
+                if (($selected !== false) && ($value == $selected)) {
+                    $option->selected = true;
+                }
+                $options[] = $option;
+            }
+            $dependdrop = "dependdrop('$qdropid', '$descendants')";
+            $chobj = new \stdClass();
+            $chobj->name = $qdropid;
+            $chobj->id = $qdropid;
+            $chobj->class = 'select custom-select menu'.$qdropid;
+            $chobj->onchange = $dependdrop;
+            $chobj->options = $options;
+            $choicetags->qelements->choice = $chobj;
+            // End dependents.
+        } else {
+            $options[] = (object)['value' => '', 'label' => get_string('choosedots')];
+            foreach ($this->choices as $key => $choice) {
+                if ($pos = strpos($choice->content, '=')) {
+                    $choice->content = substr($choice->content, $pos + 1);
+                }
+                $option = new \stdClass();
+                $option->value = $key;
+                $option->label = $choice->content;
+                if (($selected !== false) && ($key == $selected)) {
+                    $option->selected = true;
+                }
+                $options[] = $option;
+            }
+            $chobj = new \stdClass();
+            $chobj->name = 'q'.$this->id;
+            $chobj->id = $this->type . $this->id;
+            $chobj->class = 'select custom-select menu q'.$this->id;
+            $chobj->options = $options;
+            $choicetags->qelements->choice = $chobj;
+        }
+
+        return $choicetags;
+    }
+
+    /**
+     * Return the context tags for the drop response template.
+     * @param object $data
+     * @return object The check question response context tags.
+     *
+     */
+    protected function response_survey_display($data) {
+        static $uniquetag = 0;  // To make sure all radios have unique names.
+
+        $resptags = new \stdClass();
+        $resptags->name = 'q' . $this->id.$uniquetag++;
+        $resptags->id = 'menu' . $resptags->name;
+        $resptags->class = 'select custom-select ' . $resptags->id;
+        $resptags->options = [];
+        foreach ($this->choices as $id => $choice) {
+            $contents = questionnaire_choice_values($choice->content);
+            $chobj = new \stdClass();
+            $chobj->value = $id;
+            $chobj->label = format_text($contents->text, FORMAT_HTML, ['noclean' => true]);
+            if (isset($data->{'q'.$this->id}) && ($id == $data->{'q'.$this->id})) {
+                $chobj->selected = 1;
+                $resptags->selectedlabel = $chobj->label;
+            }
+            $resptags->options[] = $chobj;
+        }
+
+        return $resptags;
+    }
+
+    protected function form_length(\MoodleQuickForm $mform, $helpname = '') {
+        return base::form_length_hidden($mform);
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helpname = '') {
+        return base::form_precise_hidden($mform);
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/essay.php b/mod/questionnaire/classes/question/essay.php
new file mode 100644
index 0000000..e5279f7
--- /dev/null
+++ b/mod/questionnaire/classes/question/essay.php
@@ -0,0 +1,104 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for essay question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+use \html_writer;
+
+class essay extends base {
+
+    protected function responseclass() {
+        return '\\mod_questionnaire\\response\\text';
+    }
+
+    public function helpname() {
+        return 'essaybox';
+    }
+
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        $output = '';
+
+        // Essay.
+        // Columns and rows default values.
+        $cols = 80;
+        $rows = 15;
+        // Use HTML editor or not?
+        if ($this->precise == 0) {
+            $canusehtmleditor = true;
+            $rows = $this->length == 0 ? $rows : $this->length;
+        } else {
+            $canusehtmleditor = false;
+            // Prior to version 2.6, "precise" was used for rows number.
+            $rows = $this->precise > 1 ? $this->precise : $this->length;
+        }
+        $name = 'q'.$this->id;
+        if (isset($data->{'q'.$this->id})) {
+            $value = $data->{'q'.$this->id};
+        } else {
+            $value = '';
+        }
+        if ($canusehtmleditor) {
+            $editor = editors_get_preferred_editor();
+            $editor->use_editor($name, questionnaire_get_editor_options($this->context));
+            $texteditor = html_writer::tag('textarea', $value,
+                            array('id' => $name, 'name' => $name, 'rows' => $rows, 'cols' => $cols));
+        } else {
+            $editor = FORMAT_PLAIN;
+            $texteditor = html_writer::tag('textarea', $value,
+                            array('id' => $name, 'name' => $name, 'rows' => $rows, 'cols' => $cols));
+        }
+        $output .= $texteditor;
+
+        return $output;
+    }
+
+    protected function response_survey_display($data) {
+        $output = '';
+        $output .= '<div class="response text">';
+        $output .= !empty($data->{'q'.$this->id}) ? format_text($data->{'q'.$this->id}, FORMAT_HTML) : '&nbsp;';
+        $output .= '</div>';
+        return $output;
+    }
+
+    // Note - intentianally returning 'precise' for length and 'length' for precise.
+
+    protected function form_length(\MoodleQuickForm $mform, $helptext = '') {
+        $responseformats = array(
+                        "0" => get_string('formateditor', 'questionnaire'),
+                        "1" => get_string('formatplain', 'questionnaire'));
+        $mform->addElement('select', 'precise', get_string('responseformat', 'questionnaire'), $responseformats);
+        $mform->setType('precise', PARAM_INT);
+        return $mform;
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helptext = '') {
+        $choices = array();
+        for ($lines = 5; $lines <= 40; $lines += 5) {
+            $choices[$lines] = get_string('nlines', 'questionnaire', $lines);
+        }
+        $mform->addElement('select', 'length', get_string('responsefieldlines', 'questionnaire'), $choices);
+        $mform->setType('length', PARAM_INT);
+        return $mform;
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/numerical.php b/mod/questionnaire/classes/question/numerical.php
new file mode 100644
index 0000000..ea79200
--- /dev/null
+++ b/mod/questionnaire/classes/question/numerical.php
@@ -0,0 +1,155 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for numeric question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+
+class numerical extends base {
+
+    /**
+     * Constructor. Use to set any default properties.
+     *
+     */
+    public function __construct($id = 0, $question = null, $context = null, $params = []) {
+        $this->length = 10;
+        return parent::__construct($id, $question, $context, $params);
+    }
+
+    protected function responseclass() {
+        return '\\mod_questionnaire\\response\\text';
+    }
+
+    public function helpname() {
+        return 'numeric';
+    }
+
+    /**
+     * Override and return a form template if provided. Output of question_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function question_template() {
+        return 'mod_questionnaire/question_numeric';
+    }
+
+    /**
+     * Override and return a response template if provided. Output of response_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function response_template() {
+        return 'mod_questionnaire/response_numeric';
+    }
+
+    /**
+     * Return the context tags for the check question template.
+     * @param object $data
+     * @param string $descendantdata
+     * @param boolean $blankquestionnaire
+     * @return object The check question context tags.
+     *
+     */
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        // Numeric.
+        $questiontags = new \stdClass();
+        $precision = $this->precise;
+        $a = '';
+        if (isset($data->{'q'.$this->id})) {
+            $mynumber = $data->{'q'.$this->id};
+            if ($mynumber != '') {
+                $mynumber0 = $mynumber;
+                if (!is_numeric($mynumber) ) {
+                    $msg = get_string('notanumber', 'questionnaire', $mynumber);
+                    $this->add_notification($msg);
+                } else {
+                    if ($precision) {
+                        $pos = strpos($mynumber, '.');
+                        if (!$pos) {
+                            if (strlen($mynumber) > $this->length) {
+                                $mynumber = substr($mynumber, 0 , $this->length);
+                            }
+                        }
+                        $this->length += (1 + $precision); // To allow for n numbers after decimal point.
+                    }
+                    $mynumber = number_format($mynumber, $precision , '.', '');
+                    if ( $mynumber != $mynumber0) {
+                        $a->number = $mynumber0;
+                        $a->precision = $precision;
+                        $msg = get_string('numberfloat', 'questionnaire', $a);
+                        $this->add_notification($msg);
+                    }
+                }
+            }
+            if ($mynumber != '') {
+                $data->{'q'.$this->id} = $mynumber;
+            }
+        }
+
+        $choice = new \stdClass();
+        $choice->onkeypress = 'return event.keyCode != 13;';
+        $choice->size = $this->length;
+        $choice->name = 'q'.$this->id;
+        $choice->maxlength = $this->length;
+        $choice->value = (isset($data->{'q'.$this->id}) ? $data->{'q'.$this->id} : '');
+        $choice->id = $this->type . $this->id;
+        $questiontags->qelements = new \stdClass();
+        $questiontags->qelements->choice = $choice;
+        return $questiontags;
+    }
+
+    /**
+     * Return the context tags for the numeric response template.
+     * @param object $data
+     * @return object The numeric question response context tags.
+     *
+     */
+    protected function response_survey_display($data) {
+        $resptags = new \stdClass();
+        if (isset($data->{'q'.$this->id})) {
+            $resptags->content = $data->{'q'.$this->id};
+        }
+        return $resptags;
+    }
+
+    /**
+     * Check question's form data for valid response. Override this is type has specific format requirements.
+     *
+     * @param object $responsedata The data entered into the response.
+     * @return boolean
+     */
+    public function response_valid($responsedata) {
+        if (isset($responsedata->{'q'.$this->id})) {
+            return (($responsedata->{'q'.$this->id} == '') || is_numeric($responsedata->{'q'.$this->id}));
+        } else {
+            return parent::response_valid($responsedata);
+        }
+    }
+
+    protected function form_length(\MoodleQuickForm $mform, $helptext = '') {
+        $this->length = isset($this->length) ? $this->length : 10;
+        return parent::form_length($mform, 'maxdigitsallowed');
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helptext = '') {
+        return parent::form_precise($mform, 'numberofdecimaldigits');
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/pagebreak.php b/mod/questionnaire/classes/question/pagebreak.php
new file mode 100644
index 0000000..d80bd59
--- /dev/null
+++ b/mod/questionnaire/classes/question/pagebreak.php
@@ -0,0 +1,49 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for pagebreak question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+
+class pagebreak extends base {
+
+    protected function responseclass() {
+        return '';
+    }
+
+    public function helpname() {
+        return '';
+    }
+
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        return '';
+    }
+
+    protected function response_survey_display($data) {
+        return '';
+    }
+
+    public function edit_form(\MoodleQuickForm $qform, $questionnaire, $modcontext) {
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/radio.php b/mod/questionnaire/classes/question/radio.php
new file mode 100644
index 0000000..5271f63
--- /dev/null
+++ b/mod/questionnaire/classes/question/radio.php
@@ -0,0 +1,290 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for radio question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+
+class radio extends base {
+
+    protected function responseclass() {
+        return '\\mod_questionnaire\\response\\single';
+    }
+
+    public function helpname() {
+        return 'radiobuttons';
+    }
+
+    /**
+     * Return true if the question has choices.
+     */
+    public function has_choices() {
+        return true;
+    }
+
+    /**
+     * Override and return a form template if provided. Output of question_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function question_template() {
+        return 'mod_questionnaire/question_radio';
+    }
+
+    /**
+     * Override and return a response template if provided. Output of response_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function response_template() {
+        return 'mod_questionnaire/response_radio';
+    }
+
+    /**
+     * Return the context tags for the check question template.
+     * @param object $data
+     * @param string $descendantdata
+     * @param boolean $blankquestionnaire
+     * @return object The check question context tags.
+     *
+     */
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        // Radio buttons
+        global $idcounter;  // To make sure all radio buttons have unique ids. // JR 20 NOV 2007.
+
+        $otherempty = false;
+        // Find out which radio button is checked (if any); yields choice ID.
+        if (isset($data->{'q'.$this->id})) {
+            $checked = $data->{'q'.$this->id};
+        } else {
+            $checked = '';
+        }
+        $horizontal = $this->length;
+        $ischecked = false;
+
+        // To display or hide dependent questions on Preview page.
+        $onclickdepend = [];
+        if ($descendantsdata) {
+            $descendants = implode(',', $descendantsdata['descendants']);
+            foreach ($descendantsdata['choices'] as $key => $choice) {
+                $choices[$key] = implode(',', $choice);
+                $onclickdepend[$key] = 'depend(\''.$descendants.'\', \''.$choices[$key].'\')';
+            }
+        } // End dependents.
+
+        $choicetags = new \stdClass();
+        $choicetags->qelements = [];
+        foreach ($this->choices as $id => $choice) {
+            $radio = new \stdClass();
+            $other = strpos($choice->content, '!other');
+            if ($horizontal) {
+                $radio->horizontal = $horizontal;
+            }
+
+            // To display or hide dependent questions on Preview page.
+            if ($onclickdepend) {
+                if (isset($onclickdepend[$id])) {
+                    $radio->onclick = $onclickdepend[$id];
+                } else {
+                    // In case this dependchoice is not used by any child question.
+                    $radio->onclick = 'depend(\''.$descendants.'\', \'\')';
+                }
+
+            } else {
+                $radio->onclick = 'other_check_empty(name, value)';
+            } // End dependents.
+
+            if ($other !== 0) { // This is a normal radio button.
+                $htmlid = 'auto-rb'.sprintf('%04d', ++$idcounter);
+
+                $radio->name = 'q'.$this->id;
+                $radio->id = $htmlid;
+                $radio->value = $id;
+                if ($id == $checked) {
+                    $radio->checked = true;
+                    $ischecked = true;
+                }
+                $value = '';
+                if ($blankquestionnaire) {
+                    $radio->disabled = true;
+                    $value = ' ('.$choice->value.') ';
+                }
+                $content = $choice->content;
+                $contents = questionnaire_choice_values($choice->content);
+                $radio->label = $value.format_text($contents->text, FORMAT_HTML, ['noclean' => true]).$contents->image;
+            } else {             // Radio button with associated !other text field.
+                $othertext = preg_replace(["/^!other=/", "/^!other/"], ['', get_string('other', 'questionnaire')],
+                    $choice->content);
+                $cid = 'q'.$this->id.'_'.$id;
+                $otherempty = false;
+                $otherid = 'q'.$this->id.'_'.$checked;
+                if (substr($checked, 0, 6) == 'other_') { // Fix bug CONTRIB-222.
+                    $checked = substr($checked, 6);
+                }
+                $htmlid = 'auto-rb'.sprintf('%04d', ++$idcounter);
+
+                $radio->name = 'q'.$this->id;
+                $radio->id = $htmlid;
+                $radio->value = 'other_'.$id;
+                if (($id == $checked) || !empty($data->$cid)) {
+                    $radio->checked = true;
+                    $ischecked = true;
+                    if (!$data->$cid) {
+                        $otherempty = true;
+                    }
+                }
+                $radio->label = format_text($othertext, FORMAT_HTML, ['noclean' => true]);
+                $radio->oname = $cid;
+                $radio->oid = $htmlid.'-other';
+                if (isset($data->$cid)) {
+                    $radio->ovalue = stripslashes($data->$cid);
+                }
+                $radio->olabel = 'Text for '.format_text($othertext, FORMAT_HTML, ['noclean' => true]);
+            }
+            $choicetags->qelements[] = (object)['choice' => $radio];
+        }
+
+        // CONTRIB-846.
+        if ($this->required == 'n') {
+            $radio = new \stdClass();
+            $id = '';
+            $htmlid = 'auto-rb'.sprintf('%04d', ++$idcounter);
+            if ($horizontal) {
+                $radio->horizontal = $horizontal;
+            }
+
+            // To display or hide dependent questions on Preview page.
+            $onclick = '';
+            if ($onclickdepend) {
+                $onclick = 'depend(\''.$descendants.'\', \'\')';
+            } else {
+                $onclick = 'other_check_empty(name, value)';
+            } // End dependents.
+            $radio->name = 'q'.$this->id;
+            $radio->id = $htmlid;
+            $radio->value = $id;
+            $radio->onclick = $onclick;
+
+            if (!$ischecked && !$blankquestionnaire) {
+                $radio->checked = true;
+            }
+            $content = get_string('noanswer', 'questionnaire');
+            $radio->label = format_text($content, FORMAT_HTML, ['noclean' => true]);
+
+            $choicetags->qelements[] = (object)['choice' => $radio];
+        }
+        // End CONTRIB-846.
+
+        if ($otherempty) {
+            $this->add_notification(get_string('otherempty', 'questionnaire'));
+        }
+        return $choicetags;
+    }
+
+    /**
+     * Return the context tags for the radio response template.
+     * @param object $data
+     * @return object The radio question response context tags.
+     *
+     */
+    protected function response_survey_display($data) {
+        static $uniquetag = 0;  // To make sure all radios have unique names.
+
+        $resptags = new \stdClass();
+        $resptags->choices = [];
+        $output = '';
+
+        $horizontal = $this->length;
+        $checked = (isset($data->{'q'.$this->id}) ? $data->{'q'.$this->id} : '');
+        foreach ($this->choices as $id => $choice) {
+            $chobj = new \stdClass();
+            if ($horizontal) {
+                $chobj->horizontal = 1;
+            }
+            $chobj->name = $id.$uniquetag++;
+            if (strpos($choice->content, '!other') !== 0) {
+                $contents = questionnaire_choice_values($choice->content);
+                $choice->content = $contents->text.$contents->image;
+                if ($id == $checked) {
+                    $chobj->selected = 1;
+                }
+                $chobj->content = ($choice->content === '' ? $id : format_text($choice->content, FORMAT_HTML, ['noclean' => true]));
+            } else {
+                $othertext = preg_replace(["/^!other=/", "/^!other/"], ['', get_string('other', 'questionnaire')],
+                    $choice->content);
+                $cid = 'q'.$this->id.'_'.$id;
+                if (isset($data->{'q'.$this->id.'_'.$id})) {
+                    $chobj->selected = 1;
+                    $chobj->othercontent = (!empty($data->$cid) ? htmlspecialchars($data->$cid) : '&nbsp;');
+                }
+                $chobj->content = $othertext;
+            }
+            $resptags->choices[] = $chobj;
+        }
+
+        return $resptags;
+    }
+
+    /**
+     * Check question's form data for complete response.
+     *
+     * @param object $responsedata The data entered into the response.
+     * @return boolean
+     */
+    public function response_complete($responsedata) {
+        if (isset($responsedata->{'q'.$this->id}) && ($this->required == 'y') &&
+                (strpos($responsedata->{'q'.$this->id}, 'other_') !== false)) {
+            return !empty($responsedata->{'q'.$this->id.''.substr($responsedata->{'q'.$this->id}, 5)});
+        } else {
+            return parent::response_complete($responsedata);
+        }
+    }
+
+    /**
+     * Check question's form data for valid response. Override this is type has specific format requirements.
+     *
+     * @param object $responsedata The data entered into the response.
+     * @return boolean
+     */
+    public function response_valid($responsedata) {
+        if (isset($responsedata->{'q'.$this->id}) && (strpos($responsedata->{'q'.$this->id}, 'other_') !== false)) {
+            // False if "other" choice is checked but text box is empty.
+            return !empty($responsedata->{'q'.$this->id.''.substr($responsedata->{'q'.$this->id}, 5)});
+        } else {
+            return parent::response_valid($responsedata);
+        }
+    }
+
+    protected function form_length(\MoodleQuickForm $mform, $helptext = '') {
+        $lengroup = [];
+        $lengroup[] =& $mform->createElement('radio', 'length', '', get_string('vertical', 'questionnaire'), '0');
+        $lengroup[] =& $mform->createElement('radio', 'length', '', get_string('horizontal', 'questionnaire'), '1');
+        $mform->addGroup($lengroup, 'lengroup', get_string('alignment', 'questionnaire'), ' ', false);
+        $mform->addHelpButton('lengroup', 'alignment', 'questionnaire');
+        $mform->setType('length', PARAM_INT);
+
+        return $mform;
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helptext = '') {
+        return base::form_precise_hidden($mform);
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/rate.php b/mod/questionnaire/classes/question/rate.php
new file mode 100644
index 0000000..0d64a94
--- /dev/null
+++ b/mod/questionnaire/classes/question/rate.php
@@ -0,0 +1,565 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for rate question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+use \html_writer;
+
+class rate extends base {
+
+    /**
+     * Constructor. Use to set any default properties.
+     *
+     */
+    public function __construct($id = 0, $question = null, $context = null, $params = array()) {
+        $this->length = 5;
+        return parent::__construct($id, $question, $context, $params);
+    }
+
+    protected function responseclass() {
+        return '\\mod_questionnaire\\response\\rank';
+    }
+
+    public function helpname() {
+        return 'ratescale';
+    }
+
+    /**
+     * Return true if the question has choices.
+     */
+    public function has_choices() {
+        return true;
+    }
+
+    /**
+     * Override and return a form template if provided. Output of question_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function question_template() {
+        return 'mod_questionnaire/question_rate';
+    }
+
+    /**
+     * Override and return a response template if provided. Output of response_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function response_template() {
+        return 'mod_questionnaire/response_rate';
+    }
+
+    /**
+     * Return the context tags for the check question template.
+     * @param object $data
+     * @param string $descendantdata
+     * @param boolean $blankquestionnaire
+     * @return object The check question context tags.
+     *
+     */
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        $choicetags = new \stdClass();
+        $choicetags->qelements = [];
+
+        $disabled = '';
+        if ($blankquestionnaire) {
+            $disabled = ' disabled="disabled"';
+        }
+        if (!empty($data) && ( !isset($data->{'q'.$this->id}) || !is_array($data->{'q'.$this->id}) ) ) {
+            $data->{'q'.$this->id} = array();
+        }
+
+        $isna = $this->precise == 1;
+        $osgood = $this->precise == 3;
+
+        // Check if rate question has one line only to display full width columns of choices.
+        $nocontent = false;
+        $nameddegrees = 0;
+        $n = array();
+        $v = array();
+        $mods = array();
+        $maxndlen = 0;
+        foreach ($this->choices as $cid => $choice) {
+            $content = $choice->content;
+            if (!$nocontent && $content == '') {
+                $nocontent = true;
+            }
+            // Check for number from 1 to 3 digits, followed by the equal sign = (to accomodate named degrees).
+            if (preg_match("/^([0-9]{1,3})=(.*)$/", $content, $ndd)) {
+                $n[$nameddegrees] = format_text($ndd[2], FORMAT_HTML, ['noclean' => true]);
+                if (strlen($n[$nameddegrees]) > $maxndlen) {
+                    $maxndlen = strlen($n[$nameddegrees]);
+                }
+                $v[$nameddegrees] = $ndd[1];
+                $this->choices[$cid] = '';
+                $nameddegrees++;
+            } else {
+                // Something wrong here. $choice->content is being set, but it will never be used. This code exists as far back as
+                // 2.0.
+                $contents = questionnaire_choice_values($content);
+                if ($contents->modname) {
+                    $choice->content = $contents->text;
+                }
+            }
+        }
+
+        // The 0.1% right margin is needed to avoid the horizontal scrollbar in Chrome!
+        // A one-line rate question (no content) does not need to span more than 50%.
+        $width = $nocontent ? "50%" : "99.9%";
+        $choicetags->qelements['twidth'] = $width;
+        $choicetags->qelements['headerrow'] = [];
+        // If Osgood, adjust central columns to width of named degrees if any.
+        if ($osgood) {
+            if ($maxndlen < 4) {
+                $width = '45%';
+            } else if ($maxndlen < 13) {
+                $width = '40%';
+            } else {
+                $width = '30%';
+            }
+            $nn = 100 - ($width * 2);
+            $colwidth = ($nn / $this->length).'%';
+            $textalign = 'right';
+        } else if ($nocontent) {
+            $width = '0%';
+            $colwidth = (100 / $this->length).'%';
+            $textalign = 'right';
+        } else {
+            $width = '59%';
+            $colwidth = (40 / $this->length).'%';
+            $textalign = 'left';
+        }
+
+        $choicetags->qelements['headerrow']['col1width'] = $width;
+
+        if ($isna) {
+            $na = get_string('notapplicable', 'questionnaire');
+        } else {
+            $na = '';
+        }
+        if ($this->precise == 2) {
+            $order = 'other_rate_uncheck(name, value)';
+        } else {
+            $order = '';
+        }
+
+        if ($this->precise != 2) {
+            $nbchoices = count($this->choices) - $nameddegrees;
+        } else { // If "No duplicate choices", can restrict nbchoices to number of rate items specified.
+            $nbchoices = $this->length;
+        }
+
+        // Display empty td for Not yet answered column.
+        if ($nbchoices > 1 && $this->precise != 2 && !$blankquestionnaire) {
+            $choicetags->qelements['headerrow']['colnya'] = true;
+        }
+
+        for ($j = 0; $j < $this->length; $j++) {
+            $col = [];
+            if (isset($n[$j])) {
+                $str = $n[$j];
+                $val = $v[$j];
+            } else {
+                $str = $j + 1;
+                $val = $j + 1;
+            }
+            if ($blankquestionnaire) {
+                $val = '<br />('.$val.')';
+            } else {
+                $val = '';
+            }
+            $col['colwidth'] = $colwidth;
+            $col['coltext'] = $str.$val;
+            $choicetags->qelements['headerrow']['cols'][] = $col;
+        }
+        if ($na) {
+            $choicetags->qelements['headerrow']['cols'][] = ['colwidth' => $colwidth, 'coltext' => $na];
+        }
+
+        $num = 0;
+        foreach ($this->choices as $cid => $choice) {
+            $str = 'q'."{$this->id}_$cid";
+            $num += (isset($data->$str) && ($data->$str != -999));
+        }
+
+        $notcomplete = false;
+        if ( ($num != $nbchoices) && ($num != 0) ) {
+            $this->add_notification(get_string('checkallradiobuttons', 'questionnaire', $nbchoices));
+            $notcomplete = true;
+        }
+
+        $row = 0;
+        $choicetags->qelements['rows'] = [];
+        foreach ($this->choices as $cid => $choice) {
+            $cols = [];
+            if (isset($choice->content)) {
+                $row++;
+                $str = 'q'."{$this->id}_$cid";
+                $content = $choice->content;
+                if ($osgood) {
+                    list($content, $contentright) = array_merge(preg_split('/[|]/', $content), array(' '));
+                }
+                $cols[] = ['colstyle' => 'text-align: '.$textalign.';',
+                           'coltext' => format_text($content, FORMAT_HTML, ['noclean' => true]).'&nbsp;'];
+
+                $bg = 'c0 raterow';
+                if ($nbchoices > 1 && $this->precise != 2  && !$blankquestionnaire) {
+                    $checked = ' checked="checked"';
+                    $completeclass = 'notanswered';
+                    $title = '';
+                    if ($notcomplete && isset($data->$str) && ($data->$str == -999)) {
+                        $completeclass = 'notcompleted';
+                        $title = get_string('pleasecomplete', 'questionnaire');
+                    }
+                    // Set value of notanswered button to -999 in order to eliminate it from form submit later on.
+                    $colinput = ['name' => $str, 'value' => -999];
+                    if (!empty($checked)) {
+                        $colinput['checked'] = true;
+                    }
+                    if (!empty($order)) {
+                        $colinput['onclick'] = $order;
+                    }
+                    $cols[] = ['colstyle' => 'width:1%;', 'colclass' => $completeclass, 'coltitle' => $title,
+                        'colinput' => $colinput];
+                }
+                for ($j = 0; $j < $this->length + $isna; $j++) {
+                    $col = [];
+                    $checked = ((isset($data->$str) && ($j == $data->$str ||
+                                 $j == $this->length && $data->$str == -1)) ? ' checked="checked"' : '');
+                    $checked = '';
+                    if (isset($data->$str) && ($j == $data->$str || $j == $this->length && $data->$str == -1)) {
+                        $checked = ' checked="checked"';
+                    }
+                    $col['colstyle'] = 'text-align:center';
+                    $col['colclass'] = $bg;
+                    $i = $j + 1;
+                    $col['colhiddentext'] = get_string('option', 'questionnaire', $i);
+                    // If isna column then set na choice to -1 value.
+                    $value = ($j < $this->length ? $j : - 1);
+                    $col['colinput']['name'] = $str;
+                    $col['colinput']['value'] = $value;
+                    $col['colinput']['id'] = $str.'_'.$value;
+                    if (!empty($checked)) {
+                        $col['colinput']['checked'] = true;
+                    }
+                    if (!empty($disabled)) {
+                        $col['colinput']['disabled'] = true;
+                    }
+                    if (!empty($order)) {
+                        $col['colinput']['onclick'] = $order;
+                    }
+                    $col['colinput']['label'] = 'Choice '.$i.' for row '.$row;
+                    if ($bg == 'c0 raterow') {
+                        $bg = 'c1 raterow';
+                    } else {
+                        $bg = 'c0 raterow';
+                    }
+                    $cols[] = $col;
+                }
+                if ($osgood) {
+                    $cols[] = ['coltext' => '&nbsp;'.format_text($contentright, FORMAT_HTML, ['noclean' => true])];
+                }
+                $choicetags->qelements['rows'][] = ['cols' => $cols];
+            }
+        }
+
+        return $choicetags;
+    }
+
+    /**
+     * Return the context tags for the rate response template.
+     * @param object $data
+     * @return object The rate question response context tags.
+     *
+     */
+    protected function response_survey_display($data) {
+        static $uniquetag = 0;  // To make sure all radios have unique names.
+
+        $resptags = new \stdClass();
+        $resptags->headers = [];
+        $resptags->rows = [];
+
+        if (!isset($data->{'q'.$this->id}) || !is_array($data->{'q'.$this->id})) {
+            $data->{'q'.$this->id} = array();
+        }
+        // Check if rate question has one line only to display full width columns of choices.
+        $nocontent = false;
+        foreach ($this->choices as $cid => $choice) {
+            $content = $choice->content;
+            if ($choice->content == '') {
+                $nocontent = true;
+                break;
+            }
+        }
+        $resptags->twidth = $nocontent ? "50%" : "99.9%";
+
+        $osgood = $this->precise == 3;
+        $bg = 'c0';
+        $nameddegrees = 0;
+        $cidnamed = array();
+        $n = array();
+        // Max length of potential named degree in column head.
+        $maxndlen = 0;
+        foreach ($this->choices as $cid => $choice) {
+            $content = $choice->content;
+            if (preg_match("/^[0-9]{1,3}=/", $content, $ndd)) {
+                $ndd = format_text(substr($content, strlen($ndd[0])), FORMAT_HTML, ['noclean' => true]);
+                $n[$nameddegrees] = $ndd;
+                if (strlen($ndd) > $maxndlen) {
+                    $maxndlen = strlen($ndd);
+                }
+                $cidnamed[$cid] = true;
+                $nameddegrees++;
+            }
+        }
+        if ($osgood) {
+            $resptags->osgood = 1;
+            if ($maxndlen < 4) {
+                $sidecolwidth = '45%';
+            } else if ($maxndlen < 13) {
+                $sidecolwidth = '40%';
+            } else {
+                $sidecolwidth = '30%';
+            }
+            $nn = 100 - ($sidecolwidth * 2);
+            $resptags->sidecolwidth = $sidecolwidth;
+            $resptags->colwidth = ($nn / $this->length).'%';
+            $resptags->textalign = 'right';
+        } else {
+            $resptags->sidecolwidth = '49%';
+            $resptags->colwidth = (50 / $this->length).'%';
+            $resptags->textalign = 'left';
+        }
+        for ($j = 0; $j < $this->length; $j++) {
+            $cellobj = new \stdClass();
+            $cellobj->bg = $bg;
+            if (isset($n[$j])) {
+                $cellobj->str = $n[$j];
+            } else {
+                $cellobj->str = $j + 1;
+            }
+            if ($bg == 'c0') {
+                $bg = 'c1';
+            } else {
+                $bg = 'c0';
+            }
+            $resptags->headers[] = $cellobj;
+        }
+        if ($this->precise == 1) {
+            $cellobj = new \stdClass();
+            $cellobj->bg = $bg;
+            $cellobj->str = get_string('notapplicable', 'questionnaire');
+            $resptags->headers[] = $cellobj;
+        }
+
+        foreach ($this->choices as $cid => $choice) {
+            $rowobj = new \stdClass();
+            // Do not print column names if named column exist.
+            if (!array_key_exists($cid, $cidnamed)) {
+                $str = 'q'."{$this->id}_$cid";
+                $content = $choice->content;
+                $contents = questionnaire_choice_values($content);
+                if ($contents->modname) {
+                    $content = $contents->text;
+                }
+                if ($osgood) {
+                    list($content, $contentright) = array_merge(preg_split('/[|]/', $content), array(' '));
+                }
+                $rowobj->content = format_text($content, FORMAT_HTML, ['noclean' => true]).'&nbsp;';
+                $bg = 'c0';
+                $cols = [];
+                for ($j = 0; $j < $this->length; $j++) {
+                    $cellobj = new \stdClass();
+                    if (isset($data->$str) && ($j == $data->$str)) {
+                        $cellobj->checked = 1;
+                    }
+                    $cellobj->str = $str.$j.$uniquetag++;
+                    $cellobj->bg = $bg;
+                    // N/A column checked.
+                    $checkedna = (isset($data->$str) && ($data->$str == -1));
+                    if ($bg == 'c0') {
+                        $bg = 'c1';
+                    } else {
+                        $bg = 'c0';
+                    }
+                    $cols[] = $cellobj;
+                }
+                if ($this->precise == 1) { // N/A column.
+                    $cellobj = new \stdClass();
+                    if ($checkedna) {
+                        $cellobj->checked = 1;
+                    }
+                    $cellobj->str = $str.$j.$uniquetag++.'na';
+                    $cellobj->bg = $bg;
+                    $cols[] = $cellobj;
+                }
+                $rowobj->cols = $cols;
+                if ($osgood) {
+                    $rowobj->osgoodstr = '&nbsp;'.format_text($contentright, FORMAT_HTML, ['noclean' => true]);
+                }
+                $resptags->rows[] = $rowobj;
+            }
+        }
+        return $resptags;
+    }
+
+    /**
+     * Check question's form data for complete response.
+     *
+     * @param object $responsedata The data entered into the response.
+     * @return boolean
+     *
+     */
+    public function response_complete($responsedata) {
+        $num = 0;
+        $nbchoices = count($this->choices);
+        $na = get_string('notapplicable', 'questionnaire');
+        $complete = true;
+        foreach ($this->choices as $cid => $choice) {
+            // In case we have named degrees on the Likert scale, count them to substract from nbchoices.
+            $nameddegrees = 0;
+            $content = $choice->content;
+            if (preg_match("/^[0-9]{1,3}=/", $content)) {
+                $nameddegrees++;
+            } else {
+                $str = 'q'."{$this->id}_$cid";
+                if (isset($responsedata->$str) && $responsedata->$str == $na) {
+                    $responsedata->$str = -1;
+                }
+                // If choice value == -999 this is a not yet answered choice.
+                $num += (isset($responsedata->$str) && ($responsedata->$str != -999));
+            }
+            $nbchoices -= $nameddegrees;
+        }
+
+        if ($num == 0) {
+            if ($this->dependquestion == 0) {
+                if ($this->required == 'y') {
+                    $complete = false;
+                }
+            } else {
+                if (isset($responsedata->{'q'.$this->dependquestion})
+                        && $responsedata->{'q'.$this->dependquestion} == $this->dependchoice) {
+                    $complete = false;
+                }
+            }
+        }
+        return $complete;
+    }
+
+    /**
+     * Check question's form data for valid response. Override this is type has specific format requirements.
+     *
+     * @param object $responsedata The data entered into the response.
+     * @return boolean
+     */
+    public function response_valid($responsedata) {
+        $num = 0;
+        $nbchoices = count($this->choices);
+        $na = get_string('notapplicable', 'questionnaire');
+        foreach ($this->choices as $cid => $choice) {
+            // In case we have named degrees on the Likert scale, count them to substract from nbchoices.
+            $nameddegrees = 0;
+            $content = $choice->content;
+            if (preg_match("/^[0-9]{1,3}=/", $content)) {
+                $nameddegrees++;
+            } else {
+                $str = 'q'."{$this->id}_$cid";
+                if (isset($responsedata->$str) && ($responsedata->$str == $na)) {
+                    $responsedata->$str = -1;
+                }
+                // If choice value == -999 this is a not yet answered choice.
+                $num += (isset($responsedata->$str) && ($responsedata->$str != -999));
+            }
+            $nbchoices -= $nameddegrees;
+        }
+        // If nodupes and nb choice restricted, nbchoices may be > actual choices, so limit it to $question->length.
+        $isrestricted = ($this->length < count($this->choices)) && ($this->precise == 2);
+        if ($isrestricted) {
+            $nbchoices = min ($nbchoices, $this->length);
+        }
+        if (($num != $nbchoices) && ($num != 0)) {
+            return false;
+        } else {
+            return parent::response_valid($responsedata);
+        }
+    }
+
+    protected function form_length(\MoodleQuickForm $mform, $helptext = '') {
+        return parent::form_length($mform, 'numberscaleitems');
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helptext = '') {
+        $precoptions = array("0" => get_string('normal', 'questionnaire'),
+                             "1" => get_string('notapplicablecolumn', 'questionnaire'),
+                             "2" => get_string('noduplicates', 'questionnaire'),
+                             "3" => get_string('osgood', 'questionnaire'));
+        $mform->addElement('select', 'precise', get_string('kindofratescale', 'questionnaire'), $precoptions);
+        $mform->addHelpButton('precise', 'kindofratescale', 'questionnaire');
+        $mform->setType('precise', PARAM_INT);
+
+        return $mform;
+    }
+
+    /**
+     * Preprocess choice data.
+     */
+    protected function form_preprocess_choicedata($formdata) {
+        if (empty($formdata->allchoices)) {
+            // Add dummy blank space character for empty value.
+            $formdata->allchoices = " ";
+        } else {
+            $allchoices = $formdata->allchoices;
+            $allchoices = explode("\n", $allchoices);
+            $ispossibleanswer = false;
+            $nbnameddegrees = 0;
+            $nbvalues = 0;
+            foreach ($allchoices as $choice) {
+                if ($choice) {
+                    // Check for number from 1 to 3 digits, followed by the equal sign =.
+                    if (preg_match("/^[0-9]{1,3}=/", $choice)) {
+                        $nbnameddegrees++;
+                    } else {
+                        $nbvalues++;
+                        $ispossibleanswer = true;
+                    }
+                }
+            }
+            // Add carriage return and dummy blank space character for empty value.
+            if (!$ispossibleanswer) {
+                $formdata->allchoices .= "\n ";
+            }
+
+            // Sanity checks for correct number of values in $formdata->length.
+
+            // Sanity check for named degrees.
+            if ($nbnameddegrees && $nbnameddegrees != $formdata->length) {
+                $formdata->length = $nbnameddegrees;
+            }
+            // Sanity check for "no duplicate choices"".
+            if ($formdata->precise == 2 && ($formdata->length > $nbvalues || !$formdata->length)) {
+                $formdata->length = $nbvalues;
+            }
+        }
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/sectiontext.php b/mod/questionnaire/classes/question/sectiontext.php
new file mode 100644
index 0000000..ea856e8
--- /dev/null
+++ b/mod/questionnaire/classes/question/sectiontext.php
@@ -0,0 +1,71 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for sectiontext question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+
+class sectiontext extends base {
+
+    protected function responseclass() {
+        return '';
+    }
+
+    public function helpname() {
+        return 'sectiontext';
+    }
+
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        return '';
+    }
+
+    protected function response_survey_display($data) {
+        return '';
+    }
+
+    /**
+     * Check question's form data for complete response.
+     *
+     * @param object $responsedata The data entered into the response.
+     * @return boolean
+     */
+    public function response_complete($responsedata) {
+        return true;
+    }
+
+    protected function form_name(\MoodleQuickForm $mform) {
+        return $mform;
+    }
+
+    protected function form_required(\MoodleQuickForm $mform) {
+        return $mform;
+    }
+
+    protected function form_length(\MoodleQuickForm $mform, $helpname = '') {
+        return base::form_length_hidden($mform);
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helpname = '') {
+        return base::form_precise_hidden($mform);
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/text.php b/mod/questionnaire/classes/question/text.php
new file mode 100644
index 0000000..d53b3fd
--- /dev/null
+++ b/mod/questionnaire/classes/question/text.php
@@ -0,0 +1,110 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for text question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+
+class text extends base {
+
+    /**
+     * Constructor. Use to set any default properties.
+     *
+     */
+    public function __construct($id = 0, $question = null, $context = null, $params = []) {
+        $this->length = 20;
+        $this->precise = 25;
+        return parent::__construct($id, $question, $context, $params);
+    }
+
+    protected function responseclass() {
+        return '\\mod_questionnaire\\response\\text';
+    }
+
+    public function helpname() {
+        return 'textbox';
+    }
+
+    /**
+     * Override and return a form template if provided. Output of question_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function question_template() {
+        return 'mod_questionnaire/question_text';
+    }
+
+    /**
+     * Override and return a response template if provided. Output of response_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function response_template() {
+        return 'mod_questionnaire/response_text';
+    }
+
+    /**
+     * Return the context tags for the check question template.
+     * @param object $data
+     * @param string $descendantdata
+     * @param boolean $blankquestionnaire
+     * @return object The check question context tags.
+     *
+     */
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        // Text Box.
+        $questiontags = new \stdClass();
+        $questiontags->qelements = new \stdClass();
+        $choice = new \stdClass();
+        $choice->onkeypress = 'return event.keyCode != 13;';
+        $choice->size = $this->length;
+        $choice->name = 'q'.$this->id;
+        if ($this->precise > 0) {
+            $choice->maxlength = $this->precise;
+        }
+        $choice->value = (isset($data->{'q'.$this->id}) ? stripslashes($data->{'q'.$this->id}) : '');
+        $choice->id = $this->type . $this->id;
+        $questiontags->qelements->choice = $choice;
+        return $questiontags;
+    }
+
+    /**
+     * Return the context tags for the text response template.
+     * @param object $data
+     * @return object The radio question response context tags.
+     *
+     */
+    protected function response_survey_display($data) {
+        $resptags = new \stdClass();
+        if (isset($data->{'q'.$this->id})) {
+            $resptags->content = format_text($data->{'q'.$this->id}, FORMAT_HTML);
+        }
+        return $resptags;
+    }
+
+    protected function form_length(\MoodleQuickForm $mform, $helptext = '') {
+        return parent::form_length($mform, 'fieldlength');
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helptext = '') {
+        return parent::form_precise($mform, 'maxtextlength');
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/question/yesno.php b/mod/questionnaire/classes/question/yesno.php
new file mode 100644
index 0000000..3675091
--- /dev/null
+++ b/mod/questionnaire/classes/question/yesno.php
@@ -0,0 +1,178 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for yesno question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\question;
+defined('MOODLE_INTERNAL') || die();
+
+class yesno extends base {
+
+    protected function responseclass() {
+        return '\\mod_questionnaire\\response\\boolean';
+    }
+
+    public function helpname() {
+        return 'yesno';
+    }
+
+    /**
+     * Override and return a form template if provided. Output of question_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function question_template() {
+        return 'mod_questionnaire/question_yesno';
+    }
+
+    /**
+     * Override and return a response template if provided. Output of question_survey_display is iterpreted based on this.
+     * @return boolean | string
+     */
+    public function response_template() {
+        return 'mod_questionnaire/response_yesno';
+    }
+
+    /**
+     * Return the context tags for the check question template.
+     * @param object $data
+     * @param string $descendantdata
+     * @param boolean $blankquestionnaire
+     * @return object The check question context tags.
+     *
+     */
+    protected function question_survey_display($data, $descendantsdata, $blankquestionnaire=false) {
+        global $idcounter;  // To make sure all radio buttons have unique ids. // JR 20 NOV 2007.
+
+        // To display or hide dependent questions on Preview page.
+        $onclickdepend = [];
+        if ($descendantsdata) {
+            $descendants = implode(',', $descendantsdata['descendants']);
+            if (isset($descendantsdata['choices'][0])) {
+                $choices['y'] = implode(',', $descendantsdata['choices'][0]);
+            } else {
+                $choices['y'] = '';
+            }
+            if (isset($descendantsdata['choices'][1])) {
+                $choices['n'] = implode(',', $descendantsdata['choices'][1]);
+            } else {
+                $choices['n'] = '';
+            }
+            $onclickdepend['y'] = 'depend(\''.$descendants.'\', \''.$choices['y'].'\')';
+            $onclickdepend['n'] = 'depend(\''.$descendants.'\', \''.$choices['n'].'\')';
+        }
+
+        $stryes = get_string('yes');
+        $strno = get_string('no');
+
+        $val1 = 'y';
+        $val2 = 'n';
+
+        if ($blankquestionnaire) {
+            $stryes = ' (1) '.$stryes;
+            $strno = ' (0) '.$strno;
+        }
+
+        $options = [$val1 => $stryes, $val2 => $strno];
+        $name = 'q'.$this->id;
+        $checked = (isset($data->{'q'.$this->id}) ? $data->{'q'.$this->id} : '');
+        $output = '';
+        $ischecked = false;
+
+        $choicetags = new \stdClass();
+        $choicetags->qelements = new \stdClass();
+        $choicetags->qelements->choice = [];
+
+        foreach ($options as $value => $label) {
+            $htmlid = 'auto-rb'.sprintf('%04d', ++$idcounter);
+            $option = new \stdClass();
+            $option->name = $name;
+            $option->id = $htmlid;
+            $option->value = $value;
+            $option->label = $label;
+            if ($value == $checked) {
+                $option->checked = true;
+                $ischecked = true;
+            }
+            if ($blankquestionnaire) {
+                $option->disabled = true;
+            }
+            if (isset($onclickdepend[$value])) {
+                $option->onclick = $onclickdepend[$value];
+            }
+            $choicetags->qelements->choice[] = $option;
+        }
+        // CONTRIB-846.
+        if ($this->required == 'n') {
+            $id = '';
+            $htmlid = 'auto-rb'.sprintf('%04d', ++$idcounter);
+            $content = get_string('noanswer', 'questionnaire');
+            $option = new \stdClass();
+            $option->name = $name;
+            $option->id = $htmlid;
+            $option->value = $id;
+            $option->label = format_text($content, FORMAT_HTML, ['noclean' => true]);
+            if (!$ischecked && !$blankquestionnaire) {
+                $option->checked = true;
+            }
+            if ($onclickdepend) {
+                $option->onclick = 'depend(\''.$descendants.'\', \'\')';
+            }
+            $choicetags->qelements->choice[] = $option;
+        }
+        // End CONTRIB-846.
+
+        return $choicetags;
+    }
+
+    /**
+     * Return the context tags for the text response template.
+     * @param object $data
+     * @return object The radio question response context tags.
+     *
+     */
+    protected function response_survey_display($data) {
+        static $uniquetag = 0;  // To make sure all radios have unique names.
+
+        $resptags = new \stdClass();
+
+        $resptags->yesname = 'q'.$this->id.$uniquetag++.'y';
+        $resptags->noname = 'q'.$this->id.$uniquetag++.'n';
+        $resptags->stryes = get_string('yes');
+        $resptags->strno = get_string('no');
+        if (isset($data->{'q'.$this->id}) && ($data->{'q'.$this->id} == 'y')) {
+            $resptags->yesselected = 1;
+        }
+        if (isset($data->{'q'.$this->id}) && ($data->{'q'.$this->id} == 'n')) {
+            $resptags->noselected = 1;
+        }
+
+        return $resptags;
+    }
+
+    protected function form_length(\MoodleQuickForm $mform, $helpname = '') {
+        return base::form_length_hidden($mform);
+    }
+
+    protected function form_precise(\MoodleQuickForm $mform, $helpname = '') {
+        return base::form_precise_hidden($mform);
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/questions_form.php b/mod/questionnaire/classes/questions_form.php
new file mode 100644
index 0000000..b2db795
--- /dev/null
+++ b/mod/questionnaire/classes/questions_form.php
@@ -0,0 +1,367 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author Mike Churchward & Joseph Rézeau
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->libdir . '/formslib.php');
+
+class mod_questionnaire_questions_form extends moodleform {
+
+    public function __construct($action, $moveq=false) {
+        $this->moveq = $moveq;
+        return parent::__construct($action);
+    }
+
+    public function definition() {
+        global $CFG, $questionnaire, $SESSION;
+        global $DB;
+
+        $sid = $questionnaire->survey->id;
+        $mform    =& $this->_form;
+
+        $mform->addElement('header', 'questionhdr', get_string('addquestions', 'questionnaire'));
+        $mform->addHelpButton('questionhdr', 'questiontypes', 'questionnaire');
+
+        $strremove = get_string('remove', 'questionnaire');
+        $strmove = get_string('move');
+        $strmovehere = get_string('movehere');
+        $strposition = get_string('position', 'questionnaire');
+
+        if (!isset($questionnaire->questions)) {
+            $questionnaire->questions = array();
+        }
+        if ($this->moveq) {
+            $moveqposition = $questionnaire->questions[$this->moveq]->position;
+        }
+
+        $pos = 0;
+        $select = '';
+        if (!($qtypes = $DB->get_records_select_menu('questionnaire_question_type', $select, null, '', 'typeid,type'))) {
+            $qtypes = array();
+        }
+        // Get the names of each question type in the appropriate language.
+        foreach ($qtypes as $key => $qtype) {
+            // Do not allow "Page Break" to be selected as first element of a Questionnaire.
+            if (empty($questionnaire->questions) && ($qtype == 'Page Break')) {
+                unset($qtypes[$key]);
+            } else {
+                $qtypes[$key] = questionnaire_get_type($key);
+            }
+        }
+        natsort($qtypes);
+        $addqgroup = array();
+        $addqgroup[] =& $mform->createElement('select', 'type_id', '', $qtypes);
+
+        // The 'sticky' type_id value for further new questions.
+        if (isset($SESSION->questionnaire->type_id)) {
+                $mform->setDefault('type_id', $SESSION->questionnaire->type_id);
+        }
+
+        $addqgroup[] =& $mform->createElement('submit', 'addqbutton', get_string('addselqtype', 'questionnaire'));
+
+        $questionnairehasdependencies = questionnaire_has_dependencies($questionnaire->questions);
+
+        $mform->addGroup($addqgroup, 'addqgroup', '', ' ', false);
+
+        if (isset($SESSION->questionnaire->validateresults) &&  $SESSION->questionnaire->validateresults != '') {
+            $mform->addElement('static', 'validateresult', '', '<div class="qdepend warning">'.
+                $SESSION->questionnaire->validateresults.'</div>');
+            $SESSION->questionnaire->validateresults = '';
+        }
+
+        $qnum = 0;
+
+        // JR skip logic :: to prevent moving child higher than parent OR parent lower than child
+        // we must get now the parent and child positions.
+
+        if ($questionnairehasdependencies) {
+            $parentpositions = questionnaire_get_parent_positions ($questionnaire->questions);
+            $childpositions = questionnaire_get_child_positions ($questionnaire->questions);
+        }
+
+        $mform->addElement('header', 'manageq', get_string('managequestions', 'questionnaire'));
+        $mform->addHelpButton('manageq', 'managequestions', 'questionnaire');
+
+        $mform->addElement('html', '<div class="qcontainer">');
+
+        foreach ($questionnaire->questions as $question) {
+
+            $manageqgroup = array();
+
+            $qid = $question->id;
+            $tid = $question->type_id;
+            $qtype = $question->type;
+            $required = $question->required;
+
+            // Does this questionnaire contain branching questions already?
+            $dependency = '';
+            if ($questionnairehasdependencies) {
+                if ($question->dependquestion != 0) {
+                    $parent = questionnaire_get_parent ($question);
+                    $dependency = '<strong>'.get_string('dependquestion', 'questionnaire').'</strong> : '.
+                        $strposition.' '.$parent[$qid]['parentposition'].' ('.$parent[$qid]['parent'].')';
+                }
+            }
+
+            $pos = $question->position;
+
+            // No page break in first position!
+            if ($tid == QUESPAGEBREAK && $pos == 1) {
+                $DB->set_field('questionnaire_question', 'deleted', 'y', array('id' => $qid, 'survey_id' => $sid));
+                if ($records = $DB->get_records_select('questionnaire_question', $select, null, 'position ASC')) {
+                    foreach ($records as $record) {
+                        $DB->set_field('questionnaire_question', 'position', $record->position - 1, array('id' => $record->id));
+                    }
+                }
+                redirect($CFG->wwwroot.'/mod/questionnaire/questions.php?id='.$questionnaire->cm->id);
+            }
+
+            if ($tid != QUESPAGEBREAK && $tid != QUESSECTIONTEXT) {
+                $qnum++;
+            }
+
+            // Needed for non-English languages JR.
+            $qtype = '['.questionnaire_get_type($tid).']';
+            $content = '';
+            // If question text is "empty", i.e. 2 non-breaking spaces were inserted, do not display any question text.
+            if ($question->content == '<p>  </p>') {
+                $question->content = '';
+            }
+            if ($tid != QUESPAGEBREAK) {
+                // Needed to print potential media in question text.
+                $content = format_text(file_rewrite_pluginfile_urls($question->content, 'pluginfile.php',
+                    $question->context->id, 'mod_questionnaire', 'question', $question->id), FORMAT_HTML, ['noclean' => true]);
+            }
+            $moveqgroup = array();
+
+            $spacer = $questionnaire->renderer->image_url('spacer');
+
+            if (!$this->moveq) {
+                $mform->addElement('html', '<div class="qn-container">'); // Begin div qn-container.
+                $mextra = array('value' => $question->id,
+                                'alt' => $strmove,
+                                'title' => $strmove);
+                $eextra = array('value' => $question->id,
+                                'alt' => get_string('edit', 'questionnaire'),
+                                'title' => get_string('edit', 'questionnaire'));
+                $rextra = array('value' => $question->id,
+                                'alt' => $strremove,
+                                'title' => $strremove);
+
+                if ($tid == QUESPAGEBREAK) {
+                    $esrc = $CFG->wwwroot.'/mod/questionnaire/images/editd.gif';
+                    $eextra = array('disabled' => 'disabled');
+                } else {
+                    $esrc = $CFG->wwwroot.'/mod/questionnaire/images/edit.gif';
+                }
+
+                if ($tid == QUESPAGEBREAK) {
+                    $esrc = $spacer;
+                    $eextra = array('disabled' => 'disabled');
+                } else {
+                    $esrc = $questionnaire->renderer->image_url('t/edit');
+                }
+                $rsrc = $questionnaire->renderer->image_url('t/delete');
+
+                // Question numbers.
+                $manageqgroup[] =& $mform->createElement('static', 'qnums', '',
+                                '<div class="qnums">'.$strposition.' '.$pos.'</div>');
+
+                // Need to index by 'id' since IE doesn't return assigned 'values' for image inputs.
+                $manageqgroup[] =& $mform->createElement('static', 'opentag_'.$question->id, '', '');
+                $msrc = $questionnaire->renderer->image_url('t/move');
+
+                if ($questionnairehasdependencies) {
+                    // Do not allow moving parent question at position #1 to be moved down if it has a child at position < 4.
+                    if ($pos == 1) {
+                        if (isset($childpositions[$qid])) {
+                            $maxdown = $childpositions[$qid];
+                            if ($maxdown < 4) {
+                                $strdisabled = get_string('movedisabled', 'questionnaire');
+                                $msrc = $questionnaire->renderer->image_url('t/block');
+                                $mextra = array('value' => $question->id,
+                                                'alt' => $strdisabled,
+                                                'title' => $strdisabled);
+                                $mextra += array('disabled' => 'disabled');
+                            }
+                        }
+                    }
+                    // Do not allow moving or deleting a page break if immediately followed by a child question
+                    // or immediately preceded by a question with a dependency and followed by a non-dependent question.
+                    if ($tid == QUESPAGEBREAK) {
+                        if ($nextquestion = $DB->get_record('questionnaire_question', array('survey_id' => $sid,
+                                        'position' => $pos + 1, 'deleted' => 'n' ), $fields = 'dependquestion, name, content') ) {
+                            if ($previousquestion = $DB->get_record('questionnaire_question', array('survey_id' => $sid,
+                                            'position' => $pos - 1, 'deleted' => 'n' ),
+                                            $fields = 'dependquestion, name, content')) {
+                                if ($nextquestion->dependquestion != 0
+                                                || ($previousquestion->dependquestion != 0
+                                                    && $nextquestion->dependquestion == 0) ) {
+                                    $strdisabled = get_string('movedisabled', 'questionnaire');
+                                    $msrc = $questionnaire->renderer->image_url('t/block');
+                                    $mextra = array('value' => $question->id,
+                                                    'alt' => $strdisabled,
+                                                    'title' => $strdisabled);
+                                    $mextra += array('disabled' => 'disabled');
+
+                                    $rsrc = $msrc;
+                                    $strdisabled = get_string('deletedisabled', 'questionnaire');
+                                    $rextra = array('value' => $question->id,
+                                                    'alt' => $strdisabled,
+                                                    'title' => $strdisabled);
+                                    $rextra += array('disabled' => 'disabled');
+                                }
+                            }
+                        }
+                    }
+                }
+                $manageqgroup[] =& $mform->createElement('image', 'movebutton['.$question->id.']',
+                                $msrc, $mextra);
+                $manageqgroup[] =& $mform->createElement('image', 'editbutton['.$question->id.']', $esrc, $eextra);
+                $manageqgroup[] =& $mform->createElement('image', 'removebutton['.$question->id.']', $rsrc, $rextra);
+
+                if ($tid != QUESPAGEBREAK && $tid != QUESSECTIONTEXT) {
+                    if ($required == 'y') {
+                        $reqsrc = $questionnaire->renderer->image_url('t/stop');
+                        $strrequired = get_string('required', 'questionnaire');
+                    } else {
+                        $reqsrc = $questionnaire->renderer->image_url('t/go');
+                        $strrequired = get_string('notrequired', 'questionnaire');
+                    }
+                    $strrequired .= ' '.get_string('clicktoswitch', 'questionnaire');
+                    $reqextra = array('value' => $question->id,
+                                    'alt' => $strrequired,
+                                    'title' => $strrequired);
+                    $manageqgroup[] =& $mform->createElement('image', 'requiredbutton['.$question->id.']', $reqsrc, $reqextra);
+                }
+                $manageqgroup[] =& $mform->createElement('static', 'closetag_'.$question->id, '', '');
+
+            } else {
+                $manageqgroup[] =& $mform->createElement('static', 'qnum', '',
+                                '<div class="qnums">'.$strposition.' '.$pos.'</div>');
+                $moveqgroup[] =& $mform->createElement('static', 'qnum', '', '');
+
+                $display = true;
+                if ($questionnairehasdependencies) {
+                    // Prevent moving child to higher position than its parent.
+                    if (isset($parentpositions[$this->moveq])) {
+                        $maxup = $parentpositions[$this->moveq];
+                        if ($pos <= $maxup) {
+                            $display = false;
+                        }
+                    }
+                    // Prevent moving parent to lower position than its (first) child.
+                    if (isset($childpositions[$this->moveq])) {
+                        $maxdown = $childpositions[$this->moveq];
+                        if ($pos >= $maxdown) {
+                            $display = false;
+                        }
+                    }
+                }
+
+                $typeid = $DB->get_field('questionnaire_question', 'type_id', array('id' => $this->moveq));
+
+                if ($display) {
+                    // Do not move a page break to first position.
+                    if ($typeid == QUESPAGEBREAK && $pos == 1) {
+                        $manageqgroup[] =& $mform->createElement('static', 'qnums', '', '');
+                    } else {
+                        if ($this->moveq == $question->id) {
+                            $moveqgroup[] =& $mform->createElement('cancel', 'cancelbutton', get_string('cancel'));
+                        } else {
+                            $mextra = array('value' => $question->id,
+                                            'alt' => $strmove,
+                                            'title' => $strmovehere.' (position '.$pos.')');
+                            $msrc = $questionnaire->renderer->image_url('movehere');
+                            $moveqgroup[] =& $mform->createElement('static', 'opentag_'.$question->id, '', '');
+                            $moveqgroup[] =& $mform->createElement('image', 'moveherebutton['.$pos.']', $msrc, $mextra);
+                            $moveqgroup[] =& $mform->createElement('static', 'closetag_'.$question->id, '', '');
+                        }
+                    }
+                } else {
+                    $manageqgroup[] =& $mform->createElement('static', 'qnums', '', '');
+                    $moveqgroup[] =& $mform->createElement('static', 'qnums', '', '');
+                }
+            }
+            if ($question->name) {
+                $qname = '('.$question->name.')';
+            } else {
+                $qname = '';
+            }
+            $manageqgroup[] =& $mform->createElement('static', 'qinfo_'.$question->id, '', $qtype.' '.$qname);
+
+            if ($dependency) {
+                $mform->addElement('static', 'qdepend_'.$question->id, '', '<div class="qdepend">'.$dependency.'</div>');
+            }
+            if ($tid != QUESPAGEBREAK) {
+                if ($tid != QUESSECTIONTEXT) {
+                    $qnumber = '<div class="qn-info"><h2 class="qn-number">'.$qnum.'</h2></div>';
+                } else {
+                    $qnumber = '';
+                }
+            }
+
+            if ($this->moveq && $pos < $moveqposition) {
+                $mform->addGroup($moveqgroup, 'moveqgroup', '', '', false);
+            }
+            if ($this->moveq) {
+                if ($this->moveq == $question->id && $display) {
+                    $mform->addElement('html', '<div class="moving" title="'.$strmove.'">'); // Begin div qn-container.
+                } else {
+                    $mform->addElement('html', '<div class="qn-container">'); // Begin div qn-container.
+                }
+            }
+            $mform->addGroup($manageqgroup, 'manageqgroup', '', '&nbsp;', false);
+            if ($tid != QUESPAGEBREAK) {
+                $mform->addElement('static', 'qcontent_'.$question->id, '',
+                    $qnumber.'<div class="qn-question">'.$content.'</div>');
+            }
+            $mform->addElement('html', '</div>'); // End div qn-container.
+
+            if ($this->moveq && $pos >= $moveqposition) {
+                $mform->addGroup($moveqgroup, 'moveqgroup', '', '', false);
+            }
+        }
+
+        if ($this->moveq) {
+            $mform->addElement('hidden', 'moveq', $this->moveq);
+        }
+
+        // Hidden fields.
+        $mform->addElement('hidden', 'id', 0);
+        $mform->setType('id', PARAM_INT);
+        $mform->addElement('hidden', 'sid', 0);
+        $mform->setType('sid', PARAM_INT);
+        $mform->addElement('hidden', 'action', 'main');
+        $mform->setType('action', PARAM_RAW);
+        $mform->setType('moveq', PARAM_RAW);
+
+        $mform->addElement('html', '</div>');
+    }
+
+    public function validation($data, $files) {
+        $errors = parent::validation($data, $files);
+        return $errors;
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/response/base.php b/mod/questionnaire/classes/response/base.php
new file mode 100644
index 0000000..aade68c
--- /dev/null
+++ b/mod/questionnaire/classes/response/base.php
@@ -0,0 +1,216 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for questionnaire question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\response;
+defined('MOODLE_INTERNAL') || die();
+use \html_writer;
+use \html_table;
+
+use mod_questionnaire\db\bulk_sql_config;
+
+/**
+ * Class for describing a response.
+ *
+ * @author Mike Churchward
+ * @package response
+ */
+
+abstract class base {
+
+    public function __construct($question) {
+        $this->question = $question;
+    }
+
+    /**
+     * Provide the necessary response data table name.
+     *
+     * @return string response table name.
+     */
+    abstract public function response_table();
+
+    /**
+     * Insert a provided response to the question.
+     *
+     * @param integer $rid - The data id of the response table id.
+     * @param mixed $val - The response data provided.
+     * @return int|bool - on error the subtype should call set_error and return false.
+     */
+    abstract public function insert_response($rid, $val);
+
+    /**
+     * Provide the result information for the specified result records.
+     *
+     * @param int|array $rids - A single response id, or array.
+     * @param boolean $anonymous - Whether or not responses are anonymous.
+     * @return array - Array of data records.
+     */
+    abstract protected function get_results($rids=false, $anonymous=false);
+
+    /**
+     * Provide the result information for the specified result records.
+     *
+     * @param int|array $rids - A single response id, or array.
+     * @param string $sort - Optional display sort.
+     * @param boolean $anonymous - Whether or not responses are anonymous.
+     * @return string - Display output.
+     */
+    abstract public function display_results($rids=false, $sort='', $anonymous=false);
+
+    protected function display_response_choice_results($rows, $rids, $sort) {
+        $output = '';
+        if (is_array($rids)) {
+            $prtotal = 1;
+        } else if (is_int($rids)) {
+            $prtotal = 0;
+        }
+        if ($rows) {
+            foreach ($rows as $idx => $row) {
+                if (strpos($idx, 'other') === 0) {
+                    $answer = $row->response;
+                    $ccontent = $row->content;
+                    $content = preg_replace(array('/^!other=/', '/^!other/'),
+                            array('', get_string('other', 'questionnaire')), $ccontent);
+                    $content .= ' ' . clean_text($answer);
+                    $textidx = $content;
+                    $this->counts[$textidx] = !empty($this->counts[$textidx]) ? ($this->counts[$textidx] + 1) : 1;
+                } else {
+                    $contents = questionnaire_choice_values($row->content);
+                    $this->choice = $contents->text.$contents->image;
+                    $textidx = $this->choice;
+                    $this->counts[$textidx] = !empty($this->counts[$textidx]) ? ($this->counts[$textidx] + 1) : 1;
+                }
+            }
+            $output .= \mod_questionnaire\response\display_support::mkrespercent($this->counts, count($rids),
+                $this->question->precise, $prtotal, $sort);
+        } else {
+            $output .= '<p class="generaltable">&nbsp;'.get_string('noresponsedata', 'questionnaire').'</p>';
+        }
+        return $output;
+    }
+
+    /**
+     * Return all the fields to be used for users in bulk questionnaire sql.
+     *
+     * @author: Guy Thomas
+     * @return string
+     */
+    protected function user_fields_sql() {
+        $userfieldsarr = get_all_user_name_fields();
+        $userfieldsarr = array_merge($userfieldsarr, ['username', 'department', 'institution']);
+        $userfields = '';
+        foreach ($userfieldsarr as $field) {
+            $userfields .= $userfields === '' ? '' : ', ';
+            $userfields .= 'u.'.$field;
+        }
+        $userfields .= ', u.id as uid';
+        return $userfields;
+    }
+
+    /**
+     * Return sql and params for getting responses in bulk.
+     * @author Guy Thomas
+     * @param int $surveyid
+     * @param bool|int $responseid
+     * @param bool|int $userid
+     * @param bool|int $groupid
+     * @return array
+     */
+    public function get_bulk_sql($surveyid, $responseid = false, $userid = false, $groupid = false) {
+        global $DB;
+
+        $sql = $this->bulk_sql($surveyid, $responseid, $userid);
+        $params = [];
+        if (($groupid !== false) && ($groupid > 0)) {
+            $groupsql = ' INNER JOIN {groups_members} gm ON gm.groupid = ? AND gm.userid = qr.userid ';
+            $gparams = [$groupid];
+        } else {
+            $groupsql = '';
+            $gparams = [];
+        }
+        $sql .= "
+            AND qr.survey_id = ? AND qr.complete = ?
+      LEFT JOIN {user} u ON u.id = qr.userid
+      $groupsql
+        ";
+        $params = array_merge([$surveyid, 'y'], $gparams);
+        if ($responseid) {
+            $sql .= " WHERE qr.id = ?";
+            $params[] = $responseid;
+        } else if ($userid) {
+            $sql .= " WHERE qr.userid = ?";
+            $params[] = $userid;
+        }
+
+        return [$sql, $params];
+    }
+
+    /**
+     * Configure bulk sql
+     * @return bulk_sql_config
+     */
+    protected function bulk_sql_config() {
+        return new bulk_sql_config('questionnaire_response_other', 'qro', true, true, false);
+    }
+
+    /**
+     * Return sql for getting responses in bulk.
+     * @author Guy Thomas
+     * @return string
+     */
+    protected function bulk_sql() {
+        global $DB;
+        $userfields = $this->user_fields_sql();
+
+        $config = $this->bulk_sql_config();
+        $alias = $config->tablealias;
+
+        $extraselectfields = $config->get_extra_select();
+        $extraselect = '';
+        foreach ($extraselectfields as $field => $include) {
+            $extraselect .= $extraselect === '' ? '' : ', ';
+            if ($include) {
+                // The 'response' field can be varchar or text, which doesn't work for all DB's (Oracle).
+                // So convert the text if needed.
+                if ($field === 'response') {
+                    $extraselect .= $DB->sql_order_by_text($alias . '.' . $field, 1000).' AS '.$field;
+                } else {
+                    $extraselect .= $alias . '.' . $field;
+                }
+            } else {
+                $default = $field === 'response' ? 'null' : 0;
+                $extraselect .= $default.' AS ' . $field;
+            }
+        }
+
+        return "
+            SELECT " . $DB->sql_concat_join("'_'", ['qr.id', "'".$this->question->helpname()."'", $alias.'.id']) . " AS id,
+                   qr.submitted, qr.complete, qr.grade, qr.userid, $userfields, qr.id AS rid, $alias.question_id,
+                   $extraselect
+              FROM {questionnaire_response} qr
+              JOIN {".$config->table."} $alias
+                ON $alias.response_id = qr.id
+        ";
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/response/boolean.php b/mod/questionnaire/classes/response/boolean.php
new file mode 100644
index 0000000..9c5eb17
--- /dev/null
+++ b/mod/questionnaire/classes/response/boolean.php
@@ -0,0 +1,143 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for questionnaire question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\response;
+defined('MOODLE_INTERNAL') || die();
+
+use mod_questionnaire\db\bulk_sql_config;
+
+/**
+ * Class for boolean response types.
+ *
+ * @author Mike Churchward
+ * @package response
+ */
+
+class boolean extends base {
+
+    public function response_table() {
+        return 'questionnaire_response_bool';
+    }
+
+    public function insert_response($rid, $val) {
+        global $DB;
+        if (!empty($val)) { // If "no answer" then choice is empty (CONTRIB-846).
+            $record = new \stdClass();
+            $record->response_id = $rid;
+            $record->question_id = $this->question->id;
+            $record->choice_id = $val;
+            return $DB->insert_record($this->response_table(), $record);
+        } else {
+            return false;
+        }
+    }
+
+    protected function get_results($rids=false, $anonymous=false) {
+        global $DB;
+
+        $rsql = '';
+        $params = array($this->question->id);
+        if (!empty($rids)) {
+            list($rsql, $rparams) = $DB->get_in_or_equal($rids);
+            $params = array_merge($params, $rparams);
+            $rsql = ' AND response_id ' . $rsql;
+        }
+        $params[] = '';
+
+        $sql = 'SELECT choice_id, COUNT(response_id) AS num ' .
+               'FROM {'.$this->response_table().'} ' .
+               'WHERE question_id= ? ' . $rsql . ' AND choice_id != ? ' .
+               'GROUP BY choice_id';
+        return $DB->get_records_sql($sql, $params);
+    }
+
+    public function display_results($rids=false, $sort='', $anonymous=false) {
+        $output = '';
+
+        if (empty($this->stryes)) {
+            $this->stryes = get_string('yes');
+            $this->strno = get_string('no');
+        }
+
+        if (is_array($rids)) {
+            $prtotal = 1;
+        } else if (is_int($rids)) {
+            $prtotal = 0;
+        }
+
+         $this->counts = array($this->stryes => 0, $this->strno => 0);
+        if ($rows = $this->get_results($rids, $anonymous)) {
+            foreach ($rows as $row) {
+                $this->choice = $row->choice_id;
+                $count = $row->num;
+                if ($this->choice == 'y') {
+                    $this->choice = $this->stryes;
+                } else {
+                    $this->choice = $this->strno;
+                }
+                $this->counts[$this->choice] = intval($count);
+            }
+            $output .= \mod_questionnaire\response\display_support::mkrespercent($this->counts, count($rids),
+                $this->question->precise, $prtotal, $sort = '');
+        } else {
+            $output .= '<p class="generaltable">&nbsp;'.get_string('noresponsedata', 'questionnaire').'</p>';
+        }
+        return $output;
+    }
+
+    /**
+     * Configure bulk sql
+     * @return bulk_sql_config
+     */
+    protected function bulk_sql_config() {
+        return new bulk_sql_config($this->response_table(), 'qrb', true, false, false);
+    }
+
+    /**
+     * Return sql for getting responses in bulk.
+     * @author Guy Thomas
+     * @author Mike Churchward
+     * @return string
+     */
+    protected function bulk_sql() {
+        global $DB;
+
+        $userfields = $this->user_fields_sql();
+        // Postgres requires all fields to be the same type. Boolean type returns a character value as "choice_id",
+        // while all others are an integer. So put the boolean response in "response" field instead (CONTRIB-6436).
+        // NOTE - the actual use of "boolean" should probably change to not use "choice_id" at all, or use it as
+        // numeric zero and one instead.
+        $extraselect = '0 AS choice_id, ' . $DB->sql_order_by_text('qrb.choice_id', 1000) . ' AS response, 0 AS rank';
+        $alias = 'qrb';
+
+        return "
+            SELECT " . $DB->sql_concat_join("'_'", ['qr.id', "'".$this->question->helpname()."'", $alias.'.id']) . " AS id,
+                   qr.submitted, qr.complete, qr.grade, qr.userid, $userfields, qr.id AS rid, $alias.question_id,
+                   $extraselect
+              FROM {questionnaire_response} qr
+              JOIN {".$this->response_table()."} $alias ON $alias.response_id = qr.id
+        ";
+    }
+}
+
diff --git a/mod/questionnaire/classes/response/date.php b/mod/questionnaire/classes/response/date.php
new file mode 100644
index 0000000..1349c13
--- /dev/null
+++ b/mod/questionnaire/classes/response/date.php
@@ -0,0 +1,110 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for questionnaire question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\response;
+defined('MOODLE_INTERNAL') || die();
+
+use mod_questionnaire\db\bulk_sql_config;
+
+/**
+ * Class for date response types.
+ *
+ * @author Mike Churchward
+ * @package responsetypes
+ */
+
+class date extends base {
+    public function response_table() {
+        return 'questionnaire_response_date';
+    }
+
+    public function insert_response($rid, $val) {
+        global $DB;
+        $checkdateresult = questionnaire_check_date($val);
+        $thisdate = $val;
+        if (substr($checkdateresult, 0, 5) == 'wrong') {
+            return false;
+        }
+        // Now use ISO date formatting.
+        $checkdateresult = questionnaire_check_date($thisdate, true);
+        $record = new \stdClass();
+        $record->response_id = $rid;
+        $record->question_id = $this->question->id;
+        $record->response = $checkdateresult;
+        return $DB->insert_record($this->response_table(), $record);
+    }
+
+    protected function get_results($rids=false, $anonymous=false) {
+        global $DB;
+
+        $rsql = '';
+        $params = array($this->question->id);
+        if (!empty($rids)) {
+            list($rsql, $rparams) = $DB->get_in_or_equal($rids);
+            $params = array_merge($params, $rparams);
+            $rsql = ' AND response_id ' . $rsql;
+        }
+
+        $sql = 'SELECT id, response ' .
+               'FROM {'.$this->response_table().'} ' .
+               'WHERE question_id= ? ' . $rsql;
+
+        return $DB->get_records_sql($sql, $params);
+    }
+
+    public function display_results($rids=false, $sort='', $anonymous=false) {
+        $output = '';
+        if (is_array($rids)) {
+            $prtotal = 1;
+        } else if (is_int($rids)) {
+            $prtotal = 0;
+        }
+        if ($rows = $this->get_results($rids, $anonymous)) {
+            foreach ($rows as $row) {
+                // Count identical answers (case insensitive).
+                $this->text = $row->response;
+                if (!empty($this->text)) {
+                    $dateparts = preg_split('/-/', $this->text);
+                    $this->text = make_timestamp($dateparts[0], $dateparts[1], $dateparts[2]); // Unix timestamp.
+                    $textidx = clean_text($this->text);
+                    $this->counts[$textidx] = !empty($this->counts[$textidx]) ? ($this->counts[$textidx] + 1) : 1;
+                }
+            }
+            $output .= \mod_questionnaire\response\display_support::mkreslistdate($this->counts, count($rids),
+                $this->question->precise, $prtotal);
+        } else {
+            $output .= '<p class="generaltable">&nbsp;'.get_string('noresponsedata', 'questionnaire').'</p>';
+        }
+        return $output;
+    }
+
+    /**
+     * Configure bulk sql
+     * @return bulk_sql_config
+     */
+    protected function bulk_sql_config() {
+        return new bulk_sql_config($this->response_table(), 'qrd', false, true, false);
+    }
+}
+
diff --git a/mod/questionnaire/classes/response/display_support.php b/mod/questionnaire/classes/response/display_support.php
new file mode 100644
index 0000000..c2cd278
--- /dev/null
+++ b/mod/questionnaire/classes/response/display_support.php
@@ -0,0 +1,627 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for questionnaire question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\response;
+defined('MOODLE_INTERNAL') || die();
+use \html_writer;
+use \html_table;
+
+/**
+ * Class for response display support.
+ *
+ * @author Mike Churchward
+ * @package display_support
+ */
+
+class display_support {
+    /* {{{ proto void mkrespercent(array weights, int total, int precision, bool show_totals)
+      Builds HTML showing PERCENTAGE results. */
+
+    public static function mkrespercent($weights, $total, $precision, $showtotals, $sort) {
+        global $CFG;
+        $precision = 0;
+        $i = 0;
+        $alt = '';
+        $imageurl = $CFG->wwwroot.'/mod/questionnaire/images/';
+        $strtotal = get_string('total', 'questionnaire');
+        $table = new html_table();
+        $table->size = array();
+
+        $table->align = array();
+        $table->head = array();
+        $table->wrap = array();
+        $table->size = array_merge($table->size, array('50%', '40%', '10%'));
+        $table->align = array_merge($table->align, array('left', 'left', 'right'));
+        $table->wrap = array_merge($table->wrap, array('', 'nowrap', ''));
+        $table->head = array_merge($table->head, array(get_string('response', 'questionnaire'),
+                       get_string('average', 'questionnaire'), get_string('total', 'questionnaire')));
+
+        if (!empty($weights) && is_array($weights)) {
+            $pos = 0;
+            switch ($sort) {
+                case 'ascending':
+                    asort($weights);
+                    break;
+                case 'descending':
+                    arsort($weights);
+                    break;
+            }
+            $numresponses = 0;
+            foreach ($weights as $key => $value) {
+                $numresponses = $numresponses + $value;
+            }
+            reset ($weights);
+            while (list($content, $num) = each($weights)) {
+                if ($num > 0) {
+                    $percent = $num / $numresponses * 100.0;
+                } else {
+                    $percent = 0;
+                }
+                if ($percent > 100) {
+                    $percent = 100;
+                }
+                if ($num) {
+                    if (!right_to_left()) {
+                        $out = '&nbsp;<img alt="'.$alt.'" src="'.$imageurl.'hbar_l.gif" />'.
+                            '<img style="height:9px; width:'.($percent * 1.4).'px;" alt="'.$alt.'" src="'.
+                            $imageurl.'hbar.gif" />'.'<img alt="'.$alt.'" src="'.$imageurl.'hbar_r.gif" />'.
+                            sprintf('&nbsp;%.'.$precision.'f%%', $percent);
+                    } else {
+                        $out = '&nbsp;<img alt="'.$alt.'" src="'.$imageurl.'hbar_r.gif" />'.
+                            '<img style="height:9px; width:'.($percent * 1.4).'px;" alt="'.$alt.'" src="'.
+                            $imageurl.'hbar.gif" />'.'<img alt="'.$alt.'" src="'.$imageurl.'hbar_l.gif" />'.
+                            sprintf('&nbsp;%.'.$precision.'f%%', $percent);
+                    }
+                } else {
+                    $out = '';
+                }
+
+                $tabledata = array();
+                $tabledata = array_merge($tabledata, array(format_text($content, FORMAT_HTML, ['noclean' => true]), $out, $num));
+                $table->data[] = $tabledata;
+                $i += $num;
+                $pos++;
+            } // End while.
+
+            if ($showtotals) {
+                if ($i > 0) {
+                    $percent = $i / $total * 100.0;
+                } else {
+                    $percent = 0;
+                }
+                if ($percent > 100) {
+                    $percent = 100;
+                }
+                if (!right_to_left()) {
+                    $out = '&nbsp;<img alt="'.$alt.'" src="'.$imageurl.'thbar_l.gif" />'.
+                        '<img style="height:9px;  width:'.($percent * 1.4).'px;" alt="'.$alt.'" src="'.
+                        $imageurl.'thbar.gif" />'.'<img alt="'.$alt.'" src="'.$imageurl.'thbar_r.gif" />'.
+                        sprintf('&nbsp;%.'.$precision.'f%%', $percent);
+                } else {
+                    $out = '&nbsp;<img alt="'.$alt.'" src="'.$imageurl.'thbar_r.gif" />'.
+                        '<img style="height:9px;  width:'.($percent * 1.4).'px;" alt="'.$alt.'" src="'.
+                        $imageurl.'thbar.gif" />'.'<img alt="'.$alt.'" src="'.$imageurl.'thbar_l.gif" />'.
+                        sprintf('&nbsp;%.'.$precision.'f%%', $percent);
+                }
+                $table->data[] = 'hr';
+                $tabledata = array();
+                $tabledata = array_merge($tabledata, array($strtotal, $out, "$i/$total"));
+                $table->data[] = $tabledata;
+            }
+        } else {
+            $tabledata = array();
+            $tabledata = array_merge($tabledata, array('', get_string('noresponsedata', 'questionnaire')));
+            $table->data[] = $tabledata;
+        }
+
+        return html_writer::table($table);
+    }
+
+    public static function mkreslisttext($rows) {
+        global $CFG, $SESSION, $questionnaire, $DB;
+        $strresponse = get_string('response', 'questionnaire');
+        $viewsingleresponse = $questionnaire->capabilities->viewsingleresponse;
+        $nonanonymous = $questionnaire->respondenttype != 'anonymous';
+        $table = new html_table();
+        if ($viewsingleresponse && $nonanonymous) {
+            $strrespondent = get_string('respondent', 'questionnaire');
+            $table->align = array('left', 'left');
+            $currentgroupid = '';
+            if (isset($SESSION->questionnaire->currentgroupid)) {
+                $currentgroupid = $SESSION->questionnaire->currentgroupid;
+            }
+            $url = $CFG->wwwroot.'/mod/questionnaire/report.php?action=vresp&amp;sid='.$questionnaire->survey->id.
+            '&currentgroupid='.$currentgroupid;
+            $table->head = array($strrespondent, $strresponse);
+            $table->size = array('*', '*');
+        } else {
+            $table->align = array('left');
+            $table->head = array($strresponse);
+            $table->size = array('*');
+        }
+        foreach ($rows as $row) {
+            $text = format_text($row->response, FORMAT_HTML, ['noclean' => true]);
+            if ($viewsingleresponse && $nonanonymous) {
+                $rurl = $url.'&amp;rid='.$row->rid.'&amp;individualresponse=1';
+                $title = userdate($row->submitted);
+                $user = $DB->get_record('user', array('id' => $row->userid));
+                $rusername = '<a href="'.$rurl.'" title="'.$title.'">'.fullname($user).'</a>';
+                $table->data[] = array($rusername, $text);
+            } else {
+                $table->data[] = array($text);
+            }
+        }
+        return html_writer::table($table);
+    }
+
+    public static function mkreslistdate($counts, $total, $precision, $showtotals) {
+        $dateformat = get_string('strfdate', 'questionnaire');
+
+        if ($total == 0) {
+            return '';
+        }
+        $strresponse = get_string('response', 'questionnaire');
+        $strnum = get_string('num', 'questionnaire');
+        $table = new html_table();
+        $table->align = array('left', 'right');
+        $table->head = array($strnum, $strresponse);
+        $table->size = array('*', '*');
+        $table->attributes['class'] = 'generaltable';
+
+        if (!empty($counts) && is_array($counts)) {
+            ksort ($counts); // Sort dates into chronological order.
+            while (list($text, $num) = each($counts)) {
+                $text = userdate ( $text, $dateformat, '', false);    // Change timestamp into readable dates.
+                $table->data[] = array($num, $text);
+            }
+        } else {
+            $table->data[] = array('', get_string('noresponsedata', 'questionnaire'));
+        }
+
+        return html_writer::table($table);
+    }
+
+    public static function mkreslistnumeric($counts, $total, $precision) {
+        if ($total == 0) {
+            return '';
+        }
+        $nbresponses = 0;
+        $sum = 0;
+        $strtotal = get_string('total', 'questionnaire');
+        $strresponse = get_string('response', 'questionnaire');
+        $strnum = get_string('num', 'questionnaire');
+        $strnoresponsedata = get_string('noresponsedata', 'questionnaire');
+        $straverage = get_string('average', 'questionnaire');
+        $table = new html_table();
+        $table->align = array('left', 'right');
+        $table->head = array($strnum, $strresponse);
+        $table->size = array('*', '*');
+        $table->attributes['class'] = 'generaltable';
+
+        if (!empty($counts) && is_array($counts)) {
+            ksort ($counts);
+            while (list($text, $num) = each($counts)) {
+                $table->data[] = array($num, $text);
+                $nbresponses += $num;
+                $sum += $text * $num;
+            }
+            $table->data[] = 'hr';
+            $table->data[] = array($strtotal , $sum);
+            $avg = $sum / $nbresponses;
+               $table->data[] = array($straverage , sprintf('%.'.$precision.'f', $avg));
+        } else {
+            $table->data[] = array('', $strnoresponsedata);
+        }
+
+        return html_writer::table($table);
+    }
+
+    /* {{{ proto void mkresavg(array weights, int total, int precision, bool show_totals)
+        Builds HTML showing AVG results. */
+
+    public static function mkresavg($counts, $total, $choices, $precision, $showtotals, $length, $sort, $stravgvalue='') {
+        global $CFG;
+        $stravgrank = get_string('averagerank', 'questionnaire');
+        $osgood = false;
+        if ($precision == 3) { // Osgood's semantic differential.
+            $osgood = true;
+            $stravgrank = get_string('averageposition', 'questionnaire');
+        }
+        $stravg = '<div style="text-align:right">'.$stravgrank.$stravgvalue.'</div>';
+
+        $isna = $precision == 1;
+        $isnahead = '';
+        $nbchoices = count ($counts);
+        $isrestricted = ($length < $nbchoices) && $precision == 2;
+
+        if ($isna) {
+            $isnahead = get_string('notapplicable', 'questionnaire');
+        }
+        $table = new html_table();
+
+        $table->align = array('', '', 'center', 'right');
+        $table->width = '    99%';
+        if ($isna) {
+            $table->head = array('', $stravg, '&dArr;', $isnahead);
+        } else {
+            if ($osgood) {
+                $stravg = '<div style="text-align:center">'.$stravgrank.'</div>';
+                $table->head = array('', $stravg, '');
+            } else {
+                $table->head = array('', $stravg, '&dArr;');
+            }
+        }
+        // TODO JR please calculate the correct width of the question text column (col #1).
+        $rightcolwidth = '5%';
+        $table->size = array('60%', '*', $rightcolwidth);
+        if ($isna) {
+            $table->size = array('55%', '*', $rightcolwidth, $rightcolwidth);
+        }
+        if ($osgood) {
+            $table->size = array('25%', '50%', '25%');
+        }
+
+        $imageurl = $CFG->wwwroot.'/mod/questionnaire/images/';
+        $llength = $length;
+        if (!$llength) {
+            $llength = 5;
+        }
+        // Add an extra column to accomodate lower ranks in this case.
+        $llength += $isrestricted;
+        $width = 100 / $llength;
+        $n = array();
+        $nameddegrees = 0;
+        foreach ($choices as $choice) {
+            // To take into account languages filter.
+            $content = (format_text($choice->content, FORMAT_HTML, ['noclean' => true]));
+            if (preg_match("/^[0-9]{1,3}=/", $content, $ndd)) {
+                $n[$nameddegrees] = substr($content, strlen($ndd[0]));
+                $nameddegrees++;
+            }
+        }
+        $nbchoices = $length;
+        for ($j = 0; $j < $length; $j++) {
+            if (isset($n[$j])) {
+                $str = $n[$j];
+            } else {
+                $str = $j + 1;
+            }
+        }
+        $out = '<table style="width:100%" cellpadding="2" cellspacing="0" border="1"><tr>';
+        for ($i = 0; $i <= $llength - 1; $i++) {
+            if (isset($n[$i])) {
+                $str = $n[$i];
+            } else {
+                $str = $i + 1;
+            }
+            if ($isrestricted && $i == $llength - 1) {
+                $str = "...";
+            }
+            $out .= '<td style="text-align: center; width:'.$width.'%" class="smalltext">'.$str.'</td>';
+        }
+        $out .= '</tr></table>';
+        $table->data[] = array('', $out, '');
+
+        switch ($sort) {
+            case 'ascending':
+                uasort($counts, 'self::sortavgasc');
+                break;
+            case 'descending':
+                uasort($counts, 'self::sortavgdesc');
+                break;
+        }
+        reset ($counts);
+
+        if (!empty($counts) && is_array($counts)) {
+            while (list($content) = each($counts)) {
+                // Eliminate potential named degrees on Likert scale.
+                if (!preg_match("/^[0-9]{1,3}=/", $content)) {
+
+                    if (isset($counts[$content]->avg)) {
+                        $avg = $counts[$content]->avg;
+                        if (isset($counts[$content]->avgvalue)) {
+                            $avgvalue = $counts[$content]->avgvalue;
+                        } else {
+                            $avgvalue = '';
+                        }
+                    } else {
+                        $avg = '';
+                    }
+                    $nbna = $counts[$content]->nbna;
+
+                    if ($avg) {
+                        $out = '';
+                        if (($j = $avg * $width) > 0) {
+                            $marginposition = ($avg - 0.5 ) / ($length + $isrestricted) * 100;
+                        }
+                        if (!right_to_left()) {
+                            $out .= '<img style="height:12px; width: 6px; margin-left: '.$marginposition.
+                                '%;" alt="" src="'.$imageurl.'hbar.gif" />';
+                        } else {
+                            $out .= '<img style="height:12px; width: 6px; margin-right: '.$marginposition.
+                                '%;" alt="" src="'.$imageurl.'hbar.gif" />';
+                        }
+                    } else {
+                            $out = '';
+                    }
+
+                    if ($osgood) {
+                        // Ensure there are two bits of content.
+                        list($content, $contentright) = array_merge(preg_split('/[|]/', $content), array(' '));
+                    } else {
+                        $contents = questionnaire_choice_values($content);
+                        if ($contents->modname) {
+                            $content = $contents->text;
+                        }
+                    }
+                    if ($osgood) {
+                        $table->data[] = array('<div class="mdl-right">'.
+                            format_text($content, FORMAT_HTML, ['noclean' => true]).'</div>', $out,
+                            '<div class="mdl-left">'.format_text($contentright, FORMAT_HTML, ['noclean' => true]).'</div>');
+                        // JR JUNE 2012 do not display meaningless average rank values for Osgood.
+                    } else {
+                        if ($avg) {
+                            $stravgval = '';
+                            if ($stravgvalue) {
+                                $stravgval = '('.sprintf('%.1f', $avgvalue).')';
+                            }
+                            if ($isna) {
+                                $table->data[] = [format_text($content, FORMAT_HTML, ['noclean' => true]), $out,
+                                    sprintf('%.1f', $avg).'&nbsp;'.$stravgval, $nbna];
+                            } else {
+                                $table->data[] = [format_text($content, FORMAT_HTML, ['noclean' => true]), $out,
+                                    sprintf('%.1f', $avg).'&nbsp;'.$stravgval];
+                            }
+                        } else if ($nbna != 0) {
+                            $table->data[] = array(format_text($content, FORMAT_HTML, ['noclean' => true]), $out, '', $nbna);
+                        }
+                    }
+                } // End if named degrees.
+            } // End while.
+        } else {
+            $table->data[] = array('', get_string('noresponsedata', 'questionnaire'));
+        }
+        return html_writer::table($table);
+    }
+
+    public static function mkrescount($counts, $rids, $rows, $question, $precision, $length, $sort) {
+        // Display number of responses to Rate questions - see http://moodle.org/mod/forum/discuss.php?d=185106.
+        global $DB;
+        $nbresponses = count($rids);
+        // Prepare data to be displayed.
+        $isrestricted = ($length < count($question->choices)) && $precision == 2;
+
+        $rsql = '';
+        if (!empty($rids)) {
+            list($rsql, $params) = $DB->get_in_or_equal($rids);
+            $rsql = ' AND response_id ' . $rsql;
+        }
+
+        array_unshift($params, $question->id); // This is question_id.
+        $sql = 'SELECT r.id, c.content, r.rank, c.id AS choiceid ' .
+                'FROM {questionnaire_quest_choice} c , ' .
+                     '{questionnaire_response_rank} r ' .
+                'WHERE c.question_id = ?' .
+                ' AND r.question_id = c.question_id' .
+                ' AND r.choice_id = c.id ' .
+                $rsql .
+                ' ORDER BY choiceid, rank ASC';
+        $choices = $DB->get_records_sql($sql, $params);
+
+        // Sort rows (results) by average value.
+        if ($sort != 'default') {
+            $sortarray = array();
+            foreach ($rows as $row) {
+                foreach ($row as $key => $value) {
+                    if (!isset($sortarray[$key])) {
+                        $sortarray[$key] = array();
+                    }
+                    $sortarray[$key][] = $value;
+                }
+            }
+            $orderby = "average";
+            switch ($sort) {
+                case 'ascending':
+                    array_multisort($sortarray[$orderby], SORT_ASC, $rows);
+                    break;
+                case 'descending':
+                    array_multisort($sortarray[$orderby], SORT_DESC, $rows);
+                    break;
+            }
+        }
+        $nbranks = $length;
+        $ranks = array();
+        foreach ($rows as $row) {
+            $choiceid = $row->id;
+            foreach ($choices as $choice) {
+                if ($choice->choiceid == $choiceid) {
+                    $n = 0;
+                    for ($i = 0; $i < $nbranks; $i++) {
+                        if ($choice->rank == $i) {
+                            $n++;
+                            if (!isset($ranks[$choice->content][$i])) {
+                                $ranks[$choice->content][$i] = 0;
+                            }
+                            $ranks[$choice->content][$i] += $n;
+                        }
+                    }
+                }
+            }
+        }
+
+        // Psettings for display.
+        $strtotal = '<strong>'.get_string('total', 'questionnaire').'</strong>';
+        $isna = $precision == 1;
+        $isnahead = '';
+        $osgood = false;
+        if ($precision == 3) { // Osgood's semantic differential.
+            $osgood = true;
+        }
+        if ($isna) {
+            $isnahead = get_string('notapplicable', 'questionnaire').'<br />(#)';
+        }
+        if ($precision == 1) {
+            $na = get_string('notapplicable', 'questionnaire');
+        } else {
+            $na = '';
+        }
+        $nameddegrees = 0;
+        $n = array();
+        foreach ($question->choices as $cid => $choice) {
+            $content = $choice->content;
+            // Check for number from 1 to 3 digits, followed by the equal sign = (to accomodate named degrees).
+            if (preg_match("/^([0-9]{1,3})=(.*)$/", $content, $ndd)) {
+                $n[$nameddegrees] = format_text($ndd[2], FORMAT_HTML, ['noclean' => true]);
+                $nameddegrees++;
+            } else {
+                $contents = questionnaire_choice_values($content);
+                if ($contents->modname) {
+                    $choice->content = $contents->text;
+                }
+            }
+        }
+
+        $headings = array('<span class="smalltext">'.get_string('responses', 'questionnaire').'</span>');
+        if ($osgood) {
+            $align = array('right');
+        } else {
+            $align = array('left');
+        }
+
+        // Display the column titles.
+        for ($j = 0; $j < $length; $j++) {
+            if (isset($n[$j])) {
+                $str = $n[$j];
+            } else {
+                $str = $j + 1;
+            }
+            array_push($headings, '<span class="smalltext">'.$str.'</span>');
+            array_push($align, 'center');
+        }
+        if ($osgood) {
+            array_push($headings, '');
+            array_push($align, 'left');
+        }
+        array_push($headings, $strtotal);
+        if ($isrestricted) {
+            array_push($headings, get_string('notapplicable', 'questionnaire'));
+            array_push($align, 'center');
+        }
+        array_push($align, 'center');
+        if ($na) {
+            array_push($headings, $na);
+            array_push($align, 'center');
+        }
+
+        $table = new html_table();
+        $table->head = $headings;
+        $table->align = $align;
+        $table->attributes['class'] = 'generaltable';
+        // Now display the responses.
+        foreach ($ranks as $content => $rank) {
+            $data = array();
+            // Eliminate potential named degrees on Likert scale.
+            if (!preg_match("/^[0-9]{1,3}=/", $content)) {
+                // First display the list of degrees (named or un-named)
+                // number of NOT AVAILABLE responses for this possible answer.
+                $nbna = $counts[$content]->nbna;
+                // TOTAL number of responses for this possible answer.
+                $total = $counts[$content]->num;
+                $nbresp = '<strong>'.$total.'<strong>';
+                if ($osgood) {
+                    // Ensure there are two bits of content.
+                    list($content, $contentright) = array_merge(preg_split('/[|]/', $content), array(' '));
+                    $data[] = format_text($content, FORMAT_HTML, ['noclean' => true]);
+                } else {
+                    // Eliminate potentially short-named choices.
+                    $contents = questionnaire_choice_values($content);
+                    if ($contents->modname) {
+                        $content = $contents->text;
+                    }
+                    $data[] = format_text($content, FORMAT_HTML, ['noclean' => true]);
+                }
+                // Display ranks/rates numbers.
+                $maxrank = max($rank);
+                for ($i = 0; $i <= $length - 1; $i++) {
+                    $percent = '';
+                    if (isset($rank[$i])) {
+                        $str = $rank[$i];
+                        if ($total !== 0 && $str !== 0) {
+                            $percent = ' (<span class="percent">'.number_format(($str * 100) / $total).'%</span>)';
+                        }
+                        // Emphasize responses with max rank value.
+                        if ($str == $maxrank) {
+                            $str = '<strong>'.$str.'</strong>';
+                        }
+                    } else {
+                        $str = 0;
+                    }
+                    $data[] = $str.$percent;
+                }
+                if ($osgood) {
+                    $data[] = format_text($contentright, FORMAT_HTML, ['noclean' => true]);
+                }
+                $data[] = $nbresp;
+                if ($isrestricted) {
+                    $data[] = $nbresponses - $total;
+                }
+                if (!$osgood) {
+                    if ($na) {
+                        $data[] = $nbna;
+                    }
+                }
+            } // End named degrees.
+            $table->data[] = $data;
+        }
+        return html_writer::table($table);
+    }
+
+    /**
+     * Sorting functions for ascending and descending.
+     *
+     */
+    static private function sortavgasc($a, $b) {
+        if (isset($a->avg) && isset($b->avg)) {
+            if ( $a->avg < $b->avg ) {
+                return -1;
+            } else if ($a->avg > $b->avg ) {
+                return 1;
+            } else {
+                return 0;
+            }
+        }
+    }
+
+    static private function sortavgdesc($a, $b) {
+        if (isset($a->avg) && isset($b->avg)) {
+            if ( $a->avg > $b->avg ) {
+                return -1;
+            } else if ($a->avg < $b->avg) {
+                return 1;
+            } else {
+                return 0;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/response/multiple.php b/mod/questionnaire/classes/response/multiple.php
new file mode 100644
index 0000000..1d5bab7
--- /dev/null
+++ b/mod/questionnaire/classes/response/multiple.php
@@ -0,0 +1,151 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for questionnaire question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\response;
+defined('MOODLE_INTERNAL') || die();
+
+use mod_questionnaire\db\bulk_sql_config;
+
+/**
+ * Class for multiple response types.
+ *
+ * @author Mike Churchward
+ * @package responsetypes
+ */
+
+class multiple extends single {
+    /**
+     * The only differences between multuple and single responses are the
+     * response table and the insert logic.
+     */
+    public function response_table() {
+        return 'questionnaire_resp_multiple';
+    }
+
+    public function insert_response($rid, $val) {
+        global $DB;
+        $resid = '';
+        foreach ($this->question->choices as $cid => $choice) {
+            if (strpos($choice->content, '!other') === 0) {
+                $other = optional_param('q'.$this->question->id.'_'.$cid, '', PARAM_CLEAN);
+                if (empty($other)) {
+                    continue;
+                }
+                if (!isset($val)) {
+                    $val = array($cid);
+                } else {
+                    array_push($val, $cid);
+                }
+                if (preg_match("/[^ \t\n]/", $other)) {
+                    $record = new \stdClass();
+                    $record->response_id = $rid;
+                    $record->question_id = $this->question->id;
+                    $record->choice_id = $cid;
+                    $record->response = $other;
+                    $resid = $DB->insert_record('questionnaire_response_other', $record);
+                }
+            }
+        }
+
+        if (!isset($val) || !is_array($val)) {
+            return false;
+        }
+
+        foreach ($val as $cid) {
+            $cid = clean_param($cid, PARAM_CLEAN);
+            if ($cid != 0) { // Do not save response if choice is empty.
+                if (preg_match("/other_q[0-9]+/", $cid)) {
+                    continue;
+                }
+                $record = new \stdClass();
+                $record->response_id = $rid;
+                $record->question_id = $this->question->id;
+                $record->choice_id = $cid;
+                $resid = $DB->insert_record($this->response_table(), $record);
+            }
+        }
+        return $resid;
+    }
+
+    /**
+     * Return sql and params for getting responses in bulk.
+     * @author Guy Thomas
+     * @param int $surveyid
+     * @param bool|int $responseid
+     * @param bool|int $userid
+     * @return array
+     */
+    public function get_bulk_sql($surveyid, $responseid = false, $userid = false, $groupid = false) {
+        global $DB;
+
+        $sql = $this->bulk_sql($surveyid, $responseid, $userid);
+
+        $params = [];
+        if (($groupid !== false) && ($groupid > 0)) {
+            $groupsql = ' INNER JOIN {groups_members} gm ON gm.groupid = ? AND gm.userid = qr.userid ';
+            $gparams = [$groupid];
+        } else {
+            $groupsql = '';
+            $gparams = [];
+        }
+        $sql .= "
+            AND qr.survey_id = ? AND qr.complete = ?
+      LEFT JOIN {questionnaire_response_other} qro ON qro.response_id = qr.id AND qro.choice_id = qrm.choice_id
+      LEFT JOIN {user} u ON u.id = qr.userid
+      $groupsql
+        ";
+        $params = array_merge([$surveyid, 'y'], $gparams);
+        if ($responseid) {
+            $sql .= " WHERE qr.id = ?";
+            $params[] = $responseid;
+        } else if ($userid) {
+            $sql .= " WHERE qr.userid = ?";
+            $params[] = $userid;
+        }
+
+        return [$sql, $params];
+    }
+
+    /**
+     * Return sql for getting responses in bulk.
+     * @author Guy Thomas
+     * @return string
+     */
+    protected function bulk_sql() {
+        global $DB;
+
+        $userfields = $this->user_fields_sql();
+        $extraselect = '';
+        $extraselect .= 'qrm.choice_id, ' . $DB->sql_order_by_text('qro.response', 1000) . ', 0 AS rank';
+        $alias = 'qrm';
+
+        return "
+            SELECT " . $DB->sql_concat_join("'_'", ['qr.id', "'".$this->question->helpname()."'", $alias.'.id']) . " AS id,
+                   qr.submitted, qr.complete, qr.grade, qr.userid, $userfields, qr.id AS rid, $alias.question_id,
+                   $extraselect
+              FROM {questionnaire_response} qr
+              JOIN {".$this->response_table()."} $alias ON $alias.response_id = qr.id
+        ";
+    }
+}
diff --git a/mod/questionnaire/classes/response/rank.php b/mod/questionnaire/classes/response/rank.php
new file mode 100644
index 0000000..5ce5da9
--- /dev/null
+++ b/mod/questionnaire/classes/response/rank.php
@@ -0,0 +1,228 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for questionnaire question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\response;
+defined('MOODLE_INTERNAL') || die();
+
+use mod_questionnaire\db\bulk_sql_config;
+
+/**
+ * Class for rank responses.
+ *
+ * @author Mike Churchward
+ * @package responsetypes
+ */
+
+class rank extends base {
+    public function response_table() {
+        return 'questionnaire_response_rank';
+    }
+
+    public function insert_response($rid, $val) {
+        global $DB;
+        if ($this->question->type_id == QUESRATE) {
+            $resid = false;
+            foreach ($this->question->choices as $cid => $choice) {
+                $other = optional_param('q'.$this->question->id.'_'.$cid, null, PARAM_CLEAN);
+                // Choice not set or not answered.
+                if (!isset($other) || $other == '') {
+                    continue;
+                }
+                if ($other == get_string('notapplicable', 'questionnaire')) {
+                    $rank = -1;
+                } else {
+                    $rank = intval($other);
+                }
+                $record = new \stdClass();
+                $record->response_id = $rid;
+                $record->question_id = $this->question->id;
+                $record->choice_id = $cid;
+                $record->rank = $rank;
+                $resid = $DB->insert_record($this->response_table(), $record);
+            }
+            return $resid;
+        } else { // THIS SHOULD NEVER HAPPEN.
+            if ($val == get_string('notapplicable', 'questionnaire')) {
+                $rank = -1;
+            } else {
+                $rank = intval($val);
+            }
+            $record = new \stdClass();
+            $record->response_id = $rid;
+            $record->question_id = $this->question->id;
+            $record->rank = $rank;
+            return $DB->insert_record($this->response_table(), $record);
+        }
+    }
+
+    protected function get_results($rids=false, $anonymous=false) {
+        global $DB;
+
+        $rsql = '';
+        if (!empty($rids)) {
+            list($rsql, $params) = $DB->get_in_or_equal($rids);
+            $rsql = ' AND response_id ' . $rsql;
+        }
+
+        if ($this->question->type_id == QUESRATE) {
+            // JR there can't be an !other field in rating questions ???
+            $rankvalue = array();
+            $select = 'question_id=' . $this->question->id . ' AND content NOT LIKE \'!other%\' ORDER BY id ASC';
+            if ($rows = $DB->get_records_select('questionnaire_quest_choice', $select)) {
+                foreach ($rows as $row) {
+                    $this->counts[$row->content] = new \stdClass();
+                    $nbna = $DB->count_records($this->response_table(), array('question_id' => $this->question->id,
+                                    'choice_id' => $row->id, 'rank' => '-1'));
+                    $this->counts[$row->content]->nbna = $nbna;
+                    // The $row->value may be null (i.e. empty) or have a 'NULL' value.
+                    if ($row->value !== null && $row->value !== 'NULL') {
+                        $rankvalue[] = $row->value;
+                    }
+                }
+            }
+
+            $isrestricted = ($this->question->length < count($this->question->choices)) && $this->question->precise == 2;
+            // Usual case.
+            if (!$isrestricted) {
+                if (!empty ($rankvalue)) {
+                    $sql = "SELECT r.id, c.content, r.rank, c.id AS choiceid
+                    FROM {questionnaire_quest_choice} c, {".$this->response_table()."} r
+                    WHERE r.choice_id = c.id
+                    AND c.question_id = " . $this->question->id . "
+                    AND r.rank >= 0{$rsql}
+                    ORDER BY choiceid";
+                    $results = $DB->get_records_sql($sql, $params);
+                    $value = array();
+                    foreach ($results as $result) {
+                        if (isset ($value[$result->choiceid])) {
+                            $value[$result->choiceid] += $rankvalue[$result->rank];
+                        } else {
+                            $value[$result->choiceid] = $rankvalue[$result->rank];
+                        }
+                    }
+                }
+
+                $sql = "SELECT c.id, c.content, a.average, a.num
+                        FROM {questionnaire_quest_choice} c
+                        INNER JOIN
+                             (SELECT c2.id, AVG(a2.rank+1) AS average, COUNT(a2.response_id) AS num
+                              FROM {questionnaire_quest_choice} c2, {".$this->response_table()."} a2
+                              WHERE c2.question_id = ? AND a2.question_id = ? AND a2.choice_id = c2.id AND a2.rank >= 0{$rsql}
+                              GROUP BY c2.id) a ON a.id = c.id
+                              order by c.id";
+                $results = $DB->get_records_sql($sql, array_merge(array($this->question->id, $this->question->id), $params));
+                if (!empty ($rankvalue)) {
+                    foreach ($results as $key => $result) {
+                        $result->averagevalue = $value[$key] / $result->num;
+                    }
+                }
+                // Reindex by 'content'. Can't do this from the query as it won't work with MS-SQL.
+                foreach ($results as $key => $result) {
+                    $results[$result->content] = $result;
+                    unset($results[$key]);
+                }
+                return $results;
+                // Case where scaleitems is less than possible choices.
+            } else {
+                $sql = "SELECT c.id, c.content, a.sum, a.num
+                        FROM {questionnaire_quest_choice} c
+                        INNER JOIN
+                             (SELECT c2.id, SUM(a2.rank+1) AS sum, COUNT(a2.response_id) AS num
+                              FROM {questionnaire_quest_choice} c2, {".$this->response_table()."} a2
+                              WHERE c2.question_id = ? AND a2.question_id = ? AND a2.choice_id = c2.id AND a2.rank >= 0{$rsql}
+                              GROUP BY c2.id) a ON a.id = c.id";
+                $results = $DB->get_records_sql($sql, array_merge(array($this->question->id, $this->question->id), $params));
+                // Formula to calculate the best ranking order.
+                $nbresponses = count($rids);
+                foreach ($results as $key => $result) {
+                    $result->average = ($result->sum + ($nbresponses - $result->num) * ($this->length + 1)) / $nbresponses;
+                    $results[$result->content] = $result;
+                    unset($results[$key]);
+                }
+                return $results;
+            }
+        } else {
+            $sql = 'SELECT A.rank, COUNT(A.response_id) AS num ' .
+                   'FROM {'.$this->response_table().'} A ' .
+                   'WHERE A.question_id= ? ' . $rsql . ' ' .
+                   'GROUP BY A.rank';
+            return $DB->get_records_sql($sql, array_merge(array($this->question->id), $params));
+        }
+    }
+
+    public function display_results($rids=false, $sort='', $anonymous=false) {
+        $output = '';
+
+        if (is_array($rids)) {
+            $prtotal = 1;
+        } else if (is_int($rids)) {
+            $prtotal = 0;
+        }
+
+        if ($rows = $this->get_results($rids, $sort, $anonymous)) {
+            $stravgvalue = ''; // For printing table heading.
+            foreach ($this->counts as $key => $value) {
+                $ccontent = $key;
+                $avgvalue = '';
+                if (array_key_exists($ccontent, $rows)) {
+                    $avg = $rows[$ccontent]->average;
+                    $this->counts[$ccontent]->num = $rows[$ccontent]->num;
+                    if (isset($rows[$ccontent]->averagevalue)) {
+                        $avgvalue = $rows[$ccontent]->averagevalue;
+                        $osgood = false;
+                        if ($this->question->precise == 3) { // Osgood's semantic differential.
+                            $osgood = true;
+                        }
+                        if ($stravgvalue == '' && !$osgood) {
+                            $stravgvalue = ' ('.get_string('andaveragevalues', 'questionnaire').')';
+                        }
+                    } else {
+                        $avgvalue = null;
+                    }
+                } else {
+                    $avg = 0;
+                }
+                $this->counts[$ccontent]->avg = $avg;
+                $this->counts[$ccontent]->avgvalue = $avgvalue;
+            }
+            $output .= \mod_questionnaire\response\display_support::mkresavg($this->counts, count($rids), $this->question->choices,
+                $this->question->precise, $prtotal, $this->question->length, $sort, $stravgvalue);
+
+            $output .= \mod_questionnaire\response\display_support::mkrescount($this->counts, $rids, $rows, $this->question,
+                $this->question->precise, $this->question->length, $sort);
+        } else {
+            $output .= '<p class="generaltable">&nbsp;'.get_string('noresponsedata', 'questionnaire').'</p>';
+        }
+        return $output;
+    }
+
+    /**
+     * Configure bulk sql
+     * @return bulk_sql_config
+     */
+    protected function bulk_sql_config() {
+        return new bulk_sql_config($this->response_table(), 'qrr', true, false, true);
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/response/single.php b/mod/questionnaire/classes/response/single.php
new file mode 100644
index 0000000..e82fbae
--- /dev/null
+++ b/mod/questionnaire/classes/response/single.php
@@ -0,0 +1,190 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for questionnaire question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\response;
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * Class for single response types.
+ *
+ * @author Mike Churchward
+ * @package responsetypes
+ */
+
+class single extends base {
+    public function response_table() {
+        return 'questionnaire_resp_single';
+    }
+
+    public function insert_response($rid, $val) {
+        global $DB;
+        if (!empty($val)) {
+            foreach ($this->question->choices as $cid => $choice) {
+                if (strpos($choice->content, '!other') === 0) {
+                    $other = optional_param('q'.$this->question->id.'_'.$cid, null, PARAM_TEXT);
+                    if (!isset($other)) {
+                        continue;
+                    }
+                    if (preg_match("/[^ \t\n]/", $other)) {
+                        $record = new \stdClass();
+                        $record->response_id = $rid;
+                        $record->question_id = $this->question->id;
+                        $record->choice_id = $cid;
+                        $record->response = $other;
+                        $resid = $DB->insert_record('questionnaire_response_other', $record);
+                        $val = $cid;
+                        break;
+                    }
+                }
+            }
+        }
+        if (preg_match("/other_q([0-9]+)/", (isset($val) ? $val : ''), $regs)) {
+            $cid = $regs[1];
+            if (!isset($other)) {
+                $other = optional_param('q'.$this->question->id.'_'.$cid, null, PARAM_TEXT);
+            }
+            if (preg_match("/[^ \t\n]/", $other)) {
+                $record = new \stdClass();
+                $record->response_id = $rid;
+                $record->question_id = $this->question->id;
+                $record->choice_id = $cid;
+                $record->response = $other;
+                $resid = $DB->insert_record('questionnaire_response_other', $record);
+                $val = $cid;
+            }
+        }
+        $record = new \stdClass();
+        $record->response_id = $rid;
+        $record->question_id = $this->question->id;
+        $record->choice_id = isset($val) ? $val : 0;
+        if ($record->choice_id) {// If "no answer" then choice_id is empty (CONTRIB-846).
+            return $DB->insert_record($this->response_table(), $record);
+        } else {
+            return false;
+        }
+    }
+
+    protected function get_results($rids=false, $anonymous=false) {
+        global $DB;
+
+        $rsql = '';
+        $params = array($this->question->id);
+        if (!empty($rids)) {
+            list($rsql, $rparams) = $DB->get_in_or_equal($rids);
+            $params = array_merge($params, $rparams);
+            $rsql = ' AND response_id ' . $rsql;
+        }
+        // Added qc.id to preserve original choices ordering.
+        $sql = 'SELECT rt.id, qc.id as cid, qc.content ' .
+               'FROM {questionnaire_quest_choice} qc, ' .
+               '{'.$this->response_table().'} rt ' .
+               'WHERE qc.question_id= ? AND qc.content NOT LIKE \'!other%\' AND ' .
+                     'rt.question_id=qc.question_id AND rt.choice_id=qc.id' . $rsql . ' ' .
+               'ORDER BY qc.id';
+
+        $rows = $DB->get_records_sql($sql, $params);
+
+        // Handle 'other...'.
+        $sql = 'SELECT rt.id, rt.response, qc.content ' .
+               'FROM {questionnaire_response_other} rt, ' .
+                    '{questionnaire_quest_choice} qc ' .
+               'WHERE rt.question_id= ? AND rt.choice_id=qc.id' . $rsql . ' ' .
+               'ORDER BY qc.id';
+
+        if ($recs = $DB->get_records_sql($sql, $params)) {
+            $i = 1;
+            foreach ($recs as $rec) {
+                $rows['other'.$i] = new \stdClass();
+                $rows['other'.$i]->content = $rec->content;
+                $rows['other'.$i]->response = $rec->response;
+                $i++;
+            }
+        }
+
+        return $rows;
+    }
+
+    public function display_results($rids=false, $sort='', $anonymous=false) {
+        return $this->display_response_choice_results($this->get_results($rids, $anonymous), $rids, $sort);
+    }
+
+    /**
+     * Return sql and params for getting responses in bulk.
+     * @author Guy Thomas
+     * @param int $surveyid
+     * @param bool|int $responseid
+     * @param bool|int $userid
+     * @return array
+     */
+    public function get_bulk_sql($surveyid, $responseid = false, $userid = false, $groupid = false) {
+        global $DB;
+
+        $sql = $this->bulk_sql($surveyid, $responseid, $userid);
+        $params = [];
+        if (($groupid !== false) && ($groupid > 0)) {
+            $groupsql = ' INNER JOIN {groups_members} gm ON gm.groupid = ? AND gm.userid = qr.userid ';
+            $gparams = [$groupid];
+        } else {
+            $groupsql = '';
+            $gparams = [];
+        }
+        $sql .= "
+            AND qr.survey_id = ? AND qr.complete = ?
+      LEFT JOIN {questionnaire_response_other} qro ON qro.response_id = qr.id AND qro.choice_id = qrs.choice_id
+      LEFT JOIN {user} u ON u.id = qr.userid
+      $groupsql
+        ";
+        $params = array_merge([$surveyid, 'y'], $gparams);
+        if ($responseid) {
+            $sql .= " WHERE qr.id = ?";
+            $params[] = $responseid;
+        } else if ($userid) {
+            $sql .= " WHERE qr.userid = ?";
+            $params[] = $userid;
+        }
+
+        return [$sql, $params];
+    }
+
+    /**
+     * Return sql for getting responses in bulk.
+     * @author Guy Thomas
+     * @return string
+     */
+    protected function bulk_sql() {
+        global $DB;
+
+        $userfields = $this->user_fields_sql();
+        $extraselect = 'qrs.choice_id, ' . $DB->sql_order_by_text('qro.response', 1000) . ', 0 AS rank';
+        $alias = 'qrs';
+
+        return "
+            SELECT " . $DB->sql_concat_join("'_'", ['qr.id', "'".$this->question->helpname()."'", $alias.'.id']) . " AS id,
+                   qr.submitted, qr.complete, qr.grade, qr.userid, $userfields, qr.id AS rid, $alias.question_id,
+                   $extraselect
+              FROM {questionnaire_response} qr
+              JOIN {".$this->response_table()."} $alias ON $alias.response_id = qr.id
+        ";
+    }
+}
diff --git a/mod/questionnaire/classes/response/text.php b/mod/questionnaire/classes/response/text.php
new file mode 100644
index 0000000..5a4d6bc
--- /dev/null
+++ b/mod/questionnaire/classes/response/text.php
@@ -0,0 +1,130 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains the parent class for questionnaire question types.
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questiontypes
+ */
+
+namespace mod_questionnaire\response;
+defined('MOODLE_INTERNAL') || die();
+
+use mod_questionnaire\db\bulk_sql_config;
+
+/**
+ * Class for text response types.
+ *
+ * @author Mike Churchward
+ * @package responsetypes
+ */
+
+class text extends base {
+    public function response_table() {
+        return 'questionnaire_response_text';
+    }
+
+    public function insert_response($rid, $val) {
+        global $DB;
+        // Only insert if non-empty content.
+        if ($this->question->type_id == QUESNUMERIC) {
+            $val = preg_replace("/[^0-9.\-]*(-?[0-9]*\.?[0-9]*).*/", '\1', $val);
+        }
+
+        if (preg_match("/[^ \t\n]/", $val)) {
+            $record = new \stdClass();
+            $record->response_id = $rid;
+            $record->question_id = $this->question->id;
+            $record->response = $val;
+            return $DB->insert_record($this->response_table(), $record);
+        } else {
+            return false;
+        }
+    }
+
+    protected function get_results($rids=false, $anonymous=false) {
+        global $DB;
+
+        $rsql = '';
+        if (!empty($rids)) {
+            list($rsql, $params) = $DB->get_in_or_equal($rids);
+            $rsql = ' AND response_id ' . $rsql;
+        }
+
+        if ($anonymous) {
+            $sql = 'SELECT t.id, t.response, r.submitted AS submitted, ' .
+                    'r.survey_id, r.id AS rid ' .
+                    'FROM {'.$this->response_table().'} t, ' .
+                    '{questionnaire_response} r ' .
+                    'WHERE question_id=' . $this->question->id . $rsql .
+                    ' AND t.response_id = r.id ' .
+                    'ORDER BY r.submitted DESC';
+        } else {
+            $sql = 'SELECT t.id, t.response, r.submitted AS submitted, r.userid, u.username AS username, ' .
+                    'u.id as uid, ' .
+                    'r.survey_id, r.id AS rid ' .
+                    'FROM {'.$this->response_table().'} t, ' .
+                    '{questionnaire_response} r, ' .
+                    '{user} u ' .
+                    'WHERE question_id=' . $this->question->id . $rsql .
+                    ' AND t.response_id = r.id' .
+                    ' AND u.id = r.userid ' .
+                    'ORDER BY u.lastname, u.firstname, r.submitted';
+        }
+        return $DB->get_records_sql($sql, $params);
+    }
+
+    public function display_results($rids=false, $sort='', $anonymous=false) {
+        $output = '';
+        if (is_array($rids)) {
+            $prtotal = 1;
+        } else if (is_int($rids)) {
+            $prtotal = 0;
+        }
+        if ($rows = $this->get_results($rids, $anonymous)) {
+            // Count identical answers (numeric questions only).
+            foreach ($rows as $row) {
+                if (!empty($row->response) || $row->response === "0") {
+                    $this->text = $row->response;
+                    $textidx = clean_text($this->text);
+                    $this->counts[$textidx] = !empty($this->counts[$textidx]) ? ($this->counts[$textidx] + 1) : 1;
+                    $this->userid[$textidx] = !empty($this->counts[$textidx]) ? ($this->counts[$textidx] + 1) : 1;
+                }
+            }
+            $isnumeric = $this->question->type_id == QUESNUMERIC;
+            if ($isnumeric) {
+                $output .= \mod_questionnaire\response\display_support::mkreslistnumeric($this->counts, count($rids),
+                    $this->question->precise);
+            } else {
+                $output .= \mod_questionnaire\response\display_support::mkreslisttext($rows);
+            }
+        } else {
+            $output .= '<p class="generaltable">&nbsp;'.get_string('noresponsedata', 'questionnaire').'</p>';
+        }
+        return $output;
+    }
+
+    /**
+     * Configure bulk sql
+     * @return bulk_sql_config
+     */
+    protected function bulk_sql_config() {
+        return new bulk_sql_config($this->response_table(), 'qrt', false, true, false);
+    }
+}
+
diff --git a/mod/questionnaire/classes/search/activity.php b/mod/questionnaire/classes/search/activity.php
new file mode 100644
index 0000000..1235776
--- /dev/null
+++ b/mod/questionnaire/classes/search/activity.php
@@ -0,0 +1,77 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Contains class mod_questionnaire\search\activity
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+namespace mod_questionnaire\search;
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * Search area for mod_questionnaire activities.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class activity extends \core_search\base_activity {
+
+    /**
+     * Returns recordset containing required data for indexing activities.
+     *
+     * @param int $modifiedfrom timestamp
+     * @return \moodle_recordset
+     */
+    public function get_recordset_by_timestamp($modifiedfrom = 0) {
+        global $DB;
+
+        $sql = 'SELECT q.*, s.subtitle, s.info ' .
+            'FROM {questionnaire} q ' .
+            'INNER JOIN {questionnaire_survey} s ON q.sid = s.id ' .
+            'WHERE q.timemodified >= ? ' .
+            'ORDER BY q.timemodified ASC';
+
+        return $DB->get_recordset_sql($sql, [$modifiedfrom]);
+    }
+
+    /**
+     * Returns the document associated with this activity.
+     *
+     * The default implementation for activities sets the activity name to title and the activity intro to
+     * content. This override takes that data and adds new fields to it for indexing.
+     *
+     * @param stdClass $record
+     * @param array    $options
+     * @return \core_search\document
+     */
+    public function get_document($record, $options = []) {
+        // Get the default implementation.
+        $doc = parent::get_document($record, $options);
+
+        // Add the subtitle and additional info fields.
+        $doc->set('description1', content_to_text($record->subtitle, false));
+        $doc->set('description2', content_to_text($record->info, $record->introformat));
+
+        return $doc;
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/search/question.php b/mod/questionnaire/classes/search/question.php
new file mode 100644
index 0000000..e983536
--- /dev/null
+++ b/mod/questionnaire/classes/search/question.php
@@ -0,0 +1,160 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+/**
+ * Contains class mod_questionnaire\search\question
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+namespace mod_questionnaire\search;
+defined('MOODLE_INTERNAL') || die();
+/**
+ * Search area for mod_questionnaire questions. Separated from the activity search so that admins can choose whether or not they
+ * want this part enabled.
+ *
+ * @package    mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class question extends \core_search\base_mod {
+    /**
+     * Returns recordset containing required data for indexing activities.
+     *
+     * @param int $modifiedfrom timestamp
+     * @return \moodle_recordset
+     */
+    public function get_recordset_by_timestamp($modifiedfrom = 0) {
+        global $DB;
+
+        // Join the survey record to ensure only questionnaires with questions are returned.
+        $sql = 'SELECT q.* ' .
+            'FROM {questionnaire} q ' .
+            'INNER JOIN {questionnaire_survey} s ON q.sid = s.id ' .
+            'WHERE q.timemodified >= ? ' .
+            'ORDER BY q.timemodified ASC';
+
+        return $DB->get_recordset_sql($sql, [$modifiedfrom]);
+    }
+
+    /**
+     * Returns the document for a particular question. In this case, the document created contains the question content for all
+     * questions associated with a questionnaire.
+     *
+     * @param \stdClass $record
+     * @param array    $options
+     * @return \core_search\document
+     */
+    public function get_document($record, $options = []) {
+        global $DB;
+
+        try {
+            $cm = $this->get_cm('questionnaire', $record->id, $record->course);
+            $context = \context_module::instance($cm->id);
+        } catch (\dml_missing_record_exception $ex) {
+            // Notify it as we run here as admin, we should see everything.
+            debugging('Error retrieving ' . $this->areaid . ' ' . $record->id . ' document, not all required data is available: ' .
+                $ex->getMessage(), DEBUG_DEVELOPER);
+            return false;
+        } catch (\dml_exception $ex) {
+            // Notify it as we run here as admin, we should see everything.
+            debugging('Error retrieving ' . $this->areaid . ' ' . $record->id . ' document: ' . $ex->getMessage(), DEBUG_DEVELOPER);
+            return false;
+        }
+
+        // Because there is no database agnostic way to combine all of the possible question content data into one record in
+        // get_recordset_by_timestamp, I need to grab it all now and add it to the document.
+        $recordset = $DB->get_recordset('questionnaire_question', ['survey_id' => $record->sid, 'deleted' => 'n'],
+            'id', 'id,content');
+
+        // If no question data, don't index this document.
+        if (empty($recordset)) {
+            return false;
+        }
+
+        $qcontent = '';
+        foreach ($recordset as $question) {
+            $qcontent .= $question->content . "\n";
+        }
+        $recordset->close();
+
+        // Prepare associative array with data from DB.
+        $doc = \core_search\document_factory::instance($record->id, $this->componentname, $this->areaname);
+        $doc->set('title', content_to_text($record->name, false));
+        $doc->set('content', content_to_text($qcontent, $record->introformat));
+        $doc->set('contextid', $context->id);
+        $doc->set('courseid', $record->course);
+        $doc->set('owneruserid', \core_search\manager::NO_OWNER_ID);
+        $doc->set('modified', $record->timemodified);
+
+        return $doc;
+    }
+
+    /**
+     * Can the current user edit questions in the document.
+     *
+     * @param int $id The internal search area entity id.
+     * @return bool True if the user can see it, false otherwise
+     */
+    public function check_access($id) {
+        global $DB;
+        try {
+            $activity = $DB->get_record('questionnaire', ['id' => $id], '*', MUST_EXIST);
+            $cminfo = $this->get_cm('questionnaire', $activity->id, $activity->course);
+            $cminfo->get_course_module_record();
+        } catch (\dml_missing_record_exception $ex) {
+            return \core_search\manager::ACCESS_DELETED;
+        } catch (\dml_exception $ex) {
+            return \core_search\manager::ACCESS_DENIED;
+        }
+
+        // Recheck uservisible although it should have already been checked in core_search.
+        if ($cminfo->uservisible === false) {
+            return \core_search\manager::ACCESS_DENIED;
+        }
+
+        // If the user has the ability to see questions beyond completing a questionnaire, grant access.
+        $context = \context_module::instance($cminfo->id);
+        if (!(has_capability('mod/questionnaire:readallresponses', $context) ||
+              has_capability('mod/questionnaire:readallresponseanytime', $context) ||
+              has_capability('mod/questionnaire:editquestions', $context))) {
+            return \core_search\manager::ACCESS_DENIED;
+        }
+        return \core_search\manager::ACCESS_GRANTED;
+    }
+
+    /**
+     * Link to the module instance.
+     *
+     * @param \core_search\document $doc
+     * @return \moodle_url
+     */
+    public function get_doc_url(\core_search\document $doc) {
+        return $this->get_context_url($doc);
+    }
+
+    /**
+     * Link to the module instance.
+     *
+     * @param \core_search\document $doc
+     * @return \moodle_url
+     */
+    public function get_context_url(\core_search\document $doc) {
+        $context = \context::instance_by_id($doc->get('contextid'));
+        return new \moodle_url('/mod/questionnaire/view.php', ['id' => $context->instanceid]);
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/settings_form.php b/mod/questionnaire/classes/settings_form.php
new file mode 100644
index 0000000..a552ca6
--- /dev/null
+++ b/mod/questionnaire/classes/settings_form.php
@@ -0,0 +1,224 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->libdir . '/formslib.php');
+
+class mod_questionnaire_settings_form extends moodleform {
+
+    public function definition() {
+        global $questionnaire, $questionnairerealms;
+
+        $mform    =& $this->_form;
+
+        $mform->addElement('header', 'contenthdr', get_string('contentoptions', 'questionnaire'));
+
+        $capabilities = questionnaire_load_capabilities($questionnaire->cm->id);
+        if (!$capabilities->createtemplates) {
+            unset($questionnairerealms['template']);
+        }
+        if (!$capabilities->createpublic) {
+            unset($questionnairerealms['public']);
+        }
+        if (isset($questionnairerealms['public']) || isset($questionnairerealms['template'])) {
+            $mform->addElement('select', 'realm', get_string('realm', 'questionnaire'), $questionnairerealms);
+            $mform->setDefault('realm', $questionnaire->survey->realm);
+            $mform->addHelpButton('realm', 'realm', 'questionnaire');
+        } else {
+            $mform->addElement('hidden', 'realm', 'private');
+        }
+        $mform->setType('realm', PARAM_RAW);
+
+        $mform->addElement('text', 'title', get_string('title', 'questionnaire'), array('size' => '60'));
+        $mform->setDefault('title', $questionnaire->survey->title);
+        $mform->setType('title', PARAM_TEXT);
+        $mform->addRule('title', null, 'required', null, 'client');
+        $mform->addHelpButton('title', 'title', 'questionnaire');
+
+        $mform->addElement('text', 'subtitle', get_string('subtitle', 'questionnaire'), array('size' => '60'));
+        $mform->setDefault('subtitle', $questionnaire->survey->subtitle);
+        $mform->setType('subtitle', PARAM_TEXT);
+        $mform->addHelpButton('subtitle', 'subtitle', 'questionnaire');
+
+        $editoroptions = array('maxfiles' => EDITOR_UNLIMITED_FILES, 'trusttext' => true);
+        $mform->addElement('editor', 'info', get_string('additionalinfo', 'questionnaire'), null, $editoroptions);
+        $mform->setDefault('info', $questionnaire->survey->info);
+        $mform->setType('info', PARAM_RAW);
+        $mform->addHelpButton('info', 'additionalinfo', 'questionnaire');
+
+        $mform->addElement('header', 'submithdr', get_string('submitoptions', 'questionnaire'));
+
+        $mform->addElement('text', 'thanks_page', get_string('url', 'questionnaire'), array('size' => '60'));
+        $mform->setType('thanks_page', PARAM_TEXT);
+        $mform->setDefault('thanks_page', $questionnaire->survey->thanks_page);
+        $mform->addHelpButton('thanks_page', 'url', 'questionnaire');
+
+        $mform->addElement('static', 'confmes', get_string('confalts', 'questionnaire'));
+        $mform->addHelpButton('confmes', 'confpage', 'questionnaire');
+
+        $mform->addElement('text', 'thank_head', get_string('headingtext', 'questionnaire'), array('size' => '30'));
+        $mform->setType('thank_head', PARAM_TEXT);
+        $mform->setDefault('thank_head', $questionnaire->survey->thank_head);
+
+        $editoroptions = array('maxfiles' => EDITOR_UNLIMITED_FILES, 'trusttext' => true);
+        $mform->addElement('editor', 'thank_body', get_string('bodytext', 'questionnaire'), null, $editoroptions);
+        $mform->setType('thank_body', PARAM_RAW);
+        $mform->setDefault('thank_body', $questionnaire->survey->thank_body);
+
+        $mform->addElement('text', 'email', get_string('email', 'questionnaire'), array('size' => '75'));
+        $mform->setType('email', PARAM_TEXT);
+        $mform->setDefault('email', $questionnaire->survey->email);
+        $mform->addHelpButton('email', 'sendemail', 'questionnaire');
+
+        $defaultsections = get_config('questionnaire', 'maxsections');
+
+        // We cannot have more sections than available (required) questions with a choice value.
+        $nbquestions = 0;
+        foreach ($questionnaire->questions as $question) {
+            $qtype = $question->type_id;
+            $qname = $question->name;
+            $required = $question->required;
+            // Question types accepted for feedback; QUESRATE ok except noduplicates.
+            if (($qtype == QUESRADIO || $qtype == QUESDROP || ($qtype == QUESRATE && $question->precise != 2))
+                            && $required == 'y' && $qname != '') {
+                foreach ($question->choices as $choice) {
+                    if (isset($choice->value) && $choice->value != null && $choice->value != 'NULL') {
+                        $nbquestions ++;
+                        break;
+                    }
+                }
+            }
+            if ($qtype == QUESYESNO && $required == 'y' && $qname != '') {
+                $nbquestions ++;
+            }
+        }
+
+        // Questionnaire Feedback Sections and Messages.
+        if ($nbquestions != 0) {
+            $maxsections = min ($nbquestions, $defaultsections);
+            $feedbackoptions = array();
+            $feedbackoptions[0] = get_string('feedbacknone', 'questionnaire');
+            $mform->addElement('header', 'submithdr', get_string('feedbackoptions', 'questionnaire'));
+            $feedbackoptions[1] = get_string('feedbackglobal', 'questionnaire');
+            for ($i = 2; $i <= $maxsections; ++$i) {
+                $feedbackoptions[$i] = get_string('feedbacksections', 'questionnaire', $i);
+            }
+            $mform->addElement('select', 'feedbacksections', get_string('feedbackoptions', 'questionnaire'), $feedbackoptions);
+            $mform->setDefault('feedbacksections', $questionnaire->survey->feedbacksections);
+            $mform->addHelpButton('feedbacksections', 'feedbackoptions', 'questionnaire');
+
+            $options = array('0' => get_string('no'), '1' => get_string('yes'));
+            $mform->addElement('select', 'feedbackscores', get_string('feedbackscores', 'questionnaire'), $options);
+            $mform->addHelpButton('feedbackscores', 'feedbackscores', 'questionnaire');
+
+            // Is the RGraph library enabled at level site?
+            $usergraph = get_config('questionnaire', 'usergraph');
+            if ($usergraph) {
+                $chartgroup = array();
+                $charttypes = array (null => get_string('none'),
+                        'bipolar' => get_string('chart:bipolar', 'questionnaire'),
+                        'vprogress' => get_string('chart:vprogress', 'questionnaire'));
+                $chartgroup[] = $mform->createElement('select', 'chart_type_global',
+                        get_string('chart:type', 'questionnaire').' ('.
+                                get_string('feedbackglobal', 'questionnaire').')', $charttypes);
+                if ($questionnaire->survey->feedbacksections == 1) {
+                    $mform->setDefault('chart_type_global', $questionnaire->survey->chart_type);
+                }
+                $mform->disabledIf('chart_type_global', 'feedbacksections', 'eq', 0);
+                $mform->disabledIf('chart_type_global', 'feedbacksections', 'neq', 1);
+
+                $charttypes = array (null => get_string('none'),
+                        'bipolar' => get_string('chart:bipolar', 'questionnaire'),
+                        'hbar' => get_string('chart:hbar', 'questionnaire'),
+                        'rose' => get_string('chart:rose', 'questionnaire'));
+                $chartgroup[] = $mform->createElement('select', 'chart_type_two_sections',
+                        get_string('chart:type', 'questionnaire').' ('.
+                                get_string('feedbackbysection', 'questionnaire').')', $charttypes);
+                if ($questionnaire->survey->feedbacksections > 1) {
+                    $mform->setDefault('chart_type_two_sections', $questionnaire->survey->chart_type);
+                }
+                $mform->disabledIf('chart_type_two_sections', 'feedbacksections', 'neq', 2);
+
+                $charttypes = array (null => get_string('none'),
+                        'bipolar' => get_string('chart:bipolar', 'questionnaire'),
+                        'hbar' => get_string('chart:hbar', 'questionnaire'),
+                        'radar' => get_string('chart:radar', 'questionnaire'),
+                        'rose' => get_string('chart:rose', 'questionnaire'));
+                $chartgroup[] = $mform->createElement('select', 'chart_type_sections',
+                        get_string('chart:type', 'questionnaire').' ('.
+                                get_string('feedbackbysection', 'questionnaire').')', $charttypes);
+                if ($questionnaire->survey->feedbacksections > 1) {
+                    $mform->setDefault('chart_type_sections', $questionnaire->survey->chart_type);
+                }
+                $mform->disabledIf('chart_type_sections', 'feedbacksections', 'eq', 0);
+                $mform->disabledIf('chart_type_sections', 'feedbacksections', 'eq', 1);
+                $mform->disabledIf('chart_type_sections', 'feedbacksections', 'eq', 2);
+
+                $mform->addGroup($chartgroup, 'chartgroup',
+                        get_string('chart:type', 'questionnaire'), null, false);
+                $mform->addHelpButton('chartgroup', 'chart:type', 'questionnaire');
+            }
+            $editoroptions = array('maxfiles' => EDITOR_UNLIMITED_FILES, 'trusttext' => true);
+            $mform->addElement('editor', 'feedbacknotes', get_string('feedbacknotes', 'questionnaire'), null, $editoroptions);
+            $mform->setType('feedbacknotes', PARAM_RAW);
+            $mform->setDefault('feedbacknotes', $questionnaire->survey->feedbacknotes);
+            $mform->addHelpButton('feedbacknotes', 'feedbacknotes', 'questionnaire');
+
+            $mform->addElement('submit', 'feedbackeditbutton', get_string('feedbackeditsections', 'questionnaire'));
+            $mform->disabledIf('feedbackeditbutton', 'feedbacksections', 'eq', 0);
+        }
+
+        // Hidden fields.
+        $mform->addElement('hidden', 'id', 0);
+        $mform->setType('id', PARAM_INT);
+        $mform->addElement('hidden', 'sid', 0);
+        $mform->setType('sid', PARAM_INT);
+        $mform->addElement('hidden', 'name', '');
+        $mform->setType('name', PARAM_TEXT);
+        $mform->addElement('hidden', 'courseid', '');
+        $mform->setType('courseid', PARAM_RAW);
+
+        // Buttons.
+
+        $submitlabel = get_string('savechangesanddisplay');
+        $submit2label = get_string('savechangesandreturntocourse');
+        $mform = $this->_form;
+
+        // Elements in a row need a group.
+        $buttonarray = array();
+        $buttonarray[] = &$mform->createElement('submit', 'submitbutton2', $submit2label);
+        $buttonarray[] = &$mform->createElement('submit', 'submitbutton', $submitlabel);
+        $buttonarray[] = &$mform->createElement('cancel');
+
+        $mform->addGroup($buttonarray, 'buttonar', '', array(' '), false);
+        $mform->setType('buttonar', PARAM_RAW);
+        $mform->closeHeaderBefore('buttonar');
+
+    }
+
+    public function validation($data, $files) {
+        $errors = parent::validation($data, $files);
+        return $errors;
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/classes/task/cleanup.php b/mod/questionnaire/classes/task/cleanup.php
new file mode 100644
index 0000000..1dc8396e
--- /dev/null
+++ b/mod/questionnaire/classes/task/cleanup.php
@@ -0,0 +1,45 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * A scheduled task for Questionnaire.
+ *
+ * @package mod_questionnaire
+ * @copyright 2015 The Open University
+ * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+namespace mod_questionnaire\task;
+
+defined('MOODLE_INTERNAL') || die();
+
+class cleanup extends \core\task\scheduled_task {
+
+    /**
+     * Get a descriptive name for this task (shown to admins).
+     *
+     * @return string
+     */
+    public function get_name() {
+        return get_string('crontask', 'mod_questionnaire');
+    }
+
+    public function execute() {
+        global $CFG;
+        require_once($CFG->dirroot . '/mod/questionnaire/locallib.php');
+
+        questionnaire_cleanup();
+    }
+}
diff --git a/mod/questionnaire/complete.php b/mod/questionnaire/complete.php
new file mode 100644
index 0000000..074ff29
--- /dev/null
+++ b/mod/questionnaire/complete.php
@@ -0,0 +1,80 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+// This page prints a particular instance of questionnaire.
+
+require_once("../../config.php");
+require_once($CFG->libdir . '/completionlib.php');
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+if (!isset($SESSION->questionnaire)) {
+    $SESSION->questionnaire = new stdClass();
+}
+$SESSION->questionnaire->current_tab = 'view';
+
+$id = optional_param('id', null, PARAM_INT);    // Course Module ID.
+$a = optional_param('a', null, PARAM_INT);      // questionnaire ID.
+
+$sid = optional_param('sid', null, PARAM_INT);  // Survey id.
+$resume = optional_param('resume', null, PARAM_INT);    // Is this attempt a resume of a saved attempt?
+
+list($cm, $course, $questionnaire) = questionnaire_get_standard_page_items($id, $a);
+
+// Check login and get context.
+require_course_login($course, true, $cm);
+$context = context_module::instance($cm->id);
+require_capability('mod/questionnaire:view', $context);
+
+$url = new moodle_url($CFG->wwwroot.'/mod/questionnaire/complete.php');
+if (isset($id)) {
+    $url->param('id', $id);
+} else {
+    $url->param('a', $a);
+}
+
+$PAGE->set_url($url);
+$PAGE->set_context($context);
+$questionnaire = new questionnaire(0, $questionnaire, $course, $cm);
+// Add renderer and page objects to the questionnaire object for display use.
+$questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+$questionnaire->add_page(new \mod_questionnaire\output\completepage());
+
+$questionnaire->strquestionnaires = get_string("modulenameplural", "questionnaire");
+$questionnaire->strquestionnaire  = get_string("modulename", "questionnaire");
+
+// Mark as viewed.
+$completion = new completion_info($course);
+$completion->set_module_viewed($cm);
+
+if ($resume) {
+    $context = context_module::instance($questionnaire->cm->id);
+    $anonymous = $questionnaire->respondenttype == 'anonymous';
+
+    $event = \mod_questionnaire\event\attempt_resumed::create(array(
+                    'objectid' => $questionnaire->id,
+                    'anonymous' => $anonymous,
+                    'context' => $context
+    ));
+    $event->trigger();
+}
+
+// Generate the view HTML in the page.
+$questionnaire->view();
+
+// Output the page.
+echo $questionnaire->renderer->header();
+echo $questionnaire->renderer->render($questionnaire->page);
+echo $questionnaire->renderer->footer($course);
\ No newline at end of file
diff --git a/mod/questionnaire/db/access.php b/mod/questionnaire/db/access.php
new file mode 100644
index 0000000..a055074
--- /dev/null
+++ b/mod/questionnaire/db/access.php
@@ -0,0 +1,240 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Capability definitions for the quiz module.
+ *
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+$capabilities = array(
+
+    // Ability to add a new questionnaire instance to the course.
+    'mod/questionnaire:addinstance' => array(
+
+        'riskbitmask' => RISK_XSS,
+        'captype' => 'write',
+        'contextlevel' => CONTEXT_COURSE,
+        'archetypes' => array(
+            'editingteacher' => CAP_ALLOW,
+            'manager' => CAP_ALLOW
+        ),
+        'clonepermissionsfrom' => 'moodle/course:manageactivities'
+    ),
+
+    // Ability to see that the questionnaire exists, and the basic information
+    // about it.
+    'mod/questionnaire:view' => array(
+
+        'captype' => 'read',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'student' => CAP_ALLOW,
+            'teacher' => CAP_ALLOW,
+            'editingteacher' => CAP_ALLOW,
+            'coursecreator' => CAP_ALLOW,
+            'manager' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to complete the questionnaire and submit.
+    'mod/questionnaire:submit' => array(
+
+        'captype' => 'write',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'student' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to view individual responses to the questionnaire.
+    'mod/questionnaire:viewsingleresponse' => array(
+
+        'captype' => 'read',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'teacher' => CAP_ALLOW,
+            'editingteacher' => CAP_ALLOW,
+            'manager' => CAP_ALLOW
+         )
+    ),
+
+    // Receive a notificaton for every submission.
+    'mod/questionnaire:submissionnotification' => array(
+
+        'captype' => 'read',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'teacher' => CAP_ALLOW,
+            'editingteacher' => CAP_ALLOW,
+            'manager' => CAP_ALLOW
+         )
+    ),
+
+    // Ability to download responses in a CSV file.
+    'mod/questionnaire:downloadresponses' => array(
+
+        'captype' => 'read',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'teacher' => CAP_ALLOW,
+            'editingteacher' => CAP_ALLOW,
+            'manager' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to delete someone's (or own) previous responses.
+    'mod/questionnaire:deleteresponses' => array(
+
+        'captype' => 'write',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'editingteacher' => CAP_ALLOW,
+            'manager' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to create and edit surveys.
+    'mod/questionnaire:manage' => array(
+
+        'captype' => 'write',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'editingteacher' => CAP_ALLOW,
+            'coursecreator' => CAP_ALLOW,
+            'manager' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to edit survey questions.
+    'mod/questionnaire:editquestions' => array(
+
+        'captype' => 'write',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'editingteacher' => CAP_ALLOW,
+            'coursecreator' => CAP_ALLOW,
+            'manager' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to create template surveys which can be copied, but not used.
+    'mod/questionnaire:createtemplates' => array(
+
+        'captype' => 'write',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'coursecreator' => CAP_ALLOW,
+            'manager' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to create public surveys which can be accessed from multiple places.
+    'mod/questionnaire:createpublic' => array(
+
+        'captype' => 'write',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'coursecreator' => CAP_ALLOW,
+            'manager' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to read own previous responses to questionnaires.
+    'mod/questionnaire:readownresponses' => array(
+
+        'captype' => 'read',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'manager' => CAP_ALLOW,
+            'student' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to read others' previous responses to questionnaires.
+    // Subject to constraints on whether responses can be viewed whilst
+    // questionnaire still open or user has not yet responded themselves.
+    'mod/questionnaire:readallresponses' => array(
+
+        'captype' => 'read',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'manager' => CAP_ALLOW,
+            'teacher' => CAP_ALLOW,
+            'editingteacher' => CAP_ALLOW,
+            'student' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to read others's responses without the above checks.
+    'mod/questionnaire:readallresponseanytime' => array(
+
+        'captype' => 'read',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'manager' => CAP_ALLOW,
+            'teacher' => CAP_ALLOW,
+            'editingteacher' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to print a blank questionnaire.
+    'mod/questionnaire:printblank' => array(
+
+        'captype' => 'read',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+            'manager' => CAP_ALLOW,
+            'coursecreator' => CAP_ALLOW,
+            'teacher' => CAP_ALLOW,
+            'editingteacher' => CAP_ALLOW,
+            'student' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to preview a questionnaire.
+    'mod/questionnaire:preview' => array(
+
+        'captype' => 'read',
+        'contextlevel' => CONTEXT_MODULE,
+        'legacy' => array(
+                        'manager' => CAP_ALLOW,
+                        'coursecreator' => CAP_ALLOW,
+                        'teacher' => CAP_ALLOW,
+                        'editingteacher' => CAP_ALLOW
+        )
+    ),
+
+    // Ability to message students from a questionnaire.
+    'mod/questionnaire:message' => array(
+
+        'riskbitmask' => RISK_SPAM,
+        'captype' => 'write',
+        'contextlevel' => CONTEXT_MODULE,
+        'archetypes' => array(
+                            'manager' => CAP_ALLOW,
+                            'teacher' => CAP_ALLOW,
+                            'editingteacher' => CAP_ALLOW
+        )
+    )
+
+);
+
diff --git a/mod/questionnaire/db/install.php b/mod/questionnaire/db/install.php
new file mode 100644
index 0000000..0a459a1
--- /dev/null
+++ b/mod/questionnaire/db/install.php
@@ -0,0 +1,110 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/*
+ *
+ * @package    mod
+ * @subpackage questionnaire
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ * This file is executed right after the install.xml
+ * @copyright  2010 Remote Learner (http://www.remote-learner.net)
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+function xmldb_questionnaire_install() {
+    global $DB;
+
+    // Initial insert of mnet applications info.
+    $questiontype = new stdClass();
+    $questiontype->typeid = 1;
+    $questiontype->type = 'Yes/No';
+    $questiontype->has_choices = 'n';
+    $questiontype->response_table = 'response_bool';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+    $questiontype = new stdClass();
+    $questiontype->typeid = 2;
+    $questiontype->type = 'Text Box';
+    $questiontype->has_choices = 'n';
+    $questiontype->response_table = 'response_text';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+    $questiontype = new stdClass();
+    $questiontype->typeid = 3;
+    $questiontype->type = 'Essay Box';
+    $questiontype->has_choices = 'n';
+    $questiontype->response_table = 'response_text';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+    $questiontype = new stdClass();
+    $questiontype->typeid = 4;
+    $questiontype->type = 'Radio Buttons';
+    $questiontype->has_choices = 'y';
+    $questiontype->response_table = 'resp_single';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+    $questiontype = new stdClass();
+    $questiontype->typeid = 5;
+    $questiontype->type = 'Check Boxes';
+    $questiontype->has_choices = 'y';
+    $questiontype->response_table = 'resp_multiple';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+    $questiontype = new stdClass();
+    $questiontype->typeid = 6;
+    $questiontype->type = 'Dropdown Box';
+    $questiontype->has_choices = 'y';
+    $questiontype->response_table = 'resp_single';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+    $questiontype = new stdClass();
+    $questiontype->typeid = 8;
+    $questiontype->type = 'Rate (scale 1..5)';
+    $questiontype->has_choices = 'y';
+    $questiontype->response_table = 'response_rank';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+    $questiontype = new stdClass();
+    $questiontype->typeid = 9;
+    $questiontype->type = 'Date';
+    $questiontype->has_choices = 'n';
+    $questiontype->response_table = 'response_date';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+    $questiontype = new stdClass();
+    $questiontype->typeid = 10;
+    $questiontype->type = 'Numeric';
+    $questiontype->has_choices = 'n';
+    $questiontype->response_table = 'response_text';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+    $questiontype = new stdClass();
+    $questiontype->typeid = 99;
+    $questiontype->type = 'Page Break';
+    $questiontype->has_choices = 'n';
+    $questiontype->response_table = '';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+    $questiontype = new stdClass();
+    $questiontype->typeid = 100;
+    $questiontype->type = 'Section Text';
+    $questiontype->has_choices = 'n';
+    $questiontype->response_table = '';
+    $id = $DB->insert_record('questionnaire_question_type', $questiontype);
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/db/install.xml b/mod/questionnaire/db/install.xml
new file mode 100644
index 0000000..ef99404
--- /dev/null
+++ b/mod/questionnaire/db/install.xml
@@ -0,0 +1,263 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<XMLDB PATH="mod/questionnaire/db" VERSION="20131005" COMMENT="XMLDB file for Moodle mod/questionnaire"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:noNamespaceSchemaLocation="../../../lib/xmldb/xmldb.xsd"
+>
+  <TABLES>
+    <TABLE NAME="questionnaire" COMMENT="Main questionnaire table.">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="course" TYPE="int" LENGTH="11" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Id of course"/>
+        <FIELD NAME="name" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false" COMMENT="Name for questionnaire."/>
+        <FIELD NAME="intro" TYPE="text" NOTNULL="true" SEQUENCE="false" COMMENT="Description text."/>
+        <FIELD NAME="introformat" TYPE="int" LENGTH="4" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="text format of intro field"/>
+        <FIELD NAME="qtype" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Questionnaire type code."/>
+        <FIELD NAME="respondenttype" TYPE="char" LENGTH="9" NOTNULL="true" DEFAULT="fullname" SEQUENCE="false" COMMENT="Eligible respondents"/>
+        <FIELD NAME="resp_eligible" TYPE="char" LENGTH="8" NOTNULL="true" DEFAULT="all" SEQUENCE="false" COMMENT="Eligible respondents."/>
+        <FIELD NAME="resp_view" TYPE="int" LENGTH="2" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Questionnaire viewed?"/>
+        <FIELD NAME="notifications" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Send submission notifications."/>
+        <FIELD NAME="opendate" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Timestamp to open access"/>
+        <FIELD NAME="closedate" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Timestamp to close access on"/>
+        <FIELD NAME="resume" TYPE="int" LENGTH="2" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Questionnaire can be saved and resumed."/>
+        <FIELD NAME="navigate" TYPE="int" LENGTH="2" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Questionnaire can have page branching."/>
+        <FIELD NAME="grade" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Assign a grade to be received on submission."/>
+        <FIELD NAME="sid" TYPE="int" LENGTH="11" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="The id entry in the questionnaire_survey field."/>
+        <FIELD NAME="timemodified" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="The timestamp record last modified."/>
+        <FIELD NAME="completionsubmit" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Questionnaire marked as 'complete' when submitted."/>
+        <FIELD NAME="autonum" TYPE="int" LENGTH="1" NOTNULL="true" DEFAULT="3" SEQUENCE="false" COMMENT="option for auto numbering questions and pages (both selected by default)"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+        <KEY NAME="sid" TYPE="foreign" FIELDS="sid" REFTABLE="questionnaire_survey" REFFIELDS="id"/>
+      </KEYS>
+    </TABLE>
+    <TABLE NAME="questionnaire_survey" COMMENT="questionnaire_survey table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="name" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false"/>
+        <FIELD NAME="courseid" TYPE="int" LENGTH="10" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="realm" TYPE="char" LENGTH="64" NOTNULL="true" SEQUENCE="false"/>
+        <FIELD NAME="status" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="title" TYPE="char" LENGTH="255" NOTNULL="true" SEQUENCE="false"/>
+        <FIELD NAME="email" TYPE="char" LENGTH="255" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="subtitle" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="info" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="theme" TYPE="char" LENGTH="64" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="thanks_page" TYPE="char" LENGTH="255" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="thank_head" TYPE="char" LENGTH="255" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="thank_body" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="feedbacksections" TYPE="int" LENGTH="2" NOTNULL="false" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="feedbacknotes" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="feedbackscores" TYPE="int" LENGTH="1" NOTNULL="false" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="chart_type" TYPE="char" LENGTH="64" NOTNULL="false" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+      <INDEXES>
+        <INDEX NAME="name" UNIQUE="false" FIELDS="name"/>
+        <INDEX NAME="courseid" UNIQUE="false" FIELDS="courseid"/>
+      </INDEXES>
+    </TABLE>
+    <TABLE NAME="questionnaire_attempts" COMMENT="questionnaire_attempts table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="11" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="qid" TYPE="int" LENGTH="11" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="userid" TYPE="int" LENGTH="11" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="rid" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="timemodified" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+    </TABLE>
+    <TABLE NAME="questionnaire_question" COMMENT="questionnaire_question table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="survey_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="name" TYPE="char" LENGTH="30" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="type_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="result_id" TYPE="int" LENGTH="10" NOTNULL="false" SEQUENCE="false"/>
+        <FIELD NAME="length" TYPE="int" LENGTH="11" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="precise" TYPE="int" LENGTH="11" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="position" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="content" TYPE="text" NOTNULL="true" SEQUENCE="false"/>
+        <FIELD NAME="required" TYPE="char" LENGTH="1" NOTNULL="true" DEFAULT="n" SEQUENCE="false"/>
+        <FIELD NAME="deleted" TYPE="char" LENGTH="1" NOTNULL="true" DEFAULT="n" SEQUENCE="false"/>
+        <FIELD NAME="dependquestion" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="dependchoice" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+    </TABLE>
+    <TABLE NAME="questionnaire_quest_choice" COMMENT="questionnaire_quest_choice table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="question_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="content" TYPE="text" NOTNULL="true" SEQUENCE="false"/>
+        <FIELD NAME="value" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+      <INDEXES>
+        <INDEX NAME="quest_choice_quesidx" UNIQUE="false" FIELDS="question_id" COMMENT="Index to reduce DB load on querying table by question_id"/>
+      </INDEXES>
+    </TABLE>
+    <TABLE NAME="questionnaire_question_type" COMMENT="questionnaire_question_type table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="typeid" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="The code for the type."/>
+        <FIELD NAME="type" TYPE="char" LENGTH="32" NOTNULL="true" SEQUENCE="false"/>
+        <FIELD NAME="has_choices" TYPE="char" LENGTH="1" NOTNULL="true" DEFAULT="y" SEQUENCE="false"/>
+        <FIELD NAME="response_table" TYPE="char" LENGTH="32" NOTNULL="false" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+        <KEY NAME="typeid" TYPE="unique" FIELDS="typeid"/>
+      </KEYS>
+    </TABLE>
+    <TABLE NAME="questionnaire_response" COMMENT="questionnaire_response table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="survey_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="submitted" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="complete" TYPE="char" LENGTH="1" NOTNULL="true" DEFAULT="n" SEQUENCE="false"/>
+        <FIELD NAME="grade" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false" COMMENT="Grade awarded"/>
+        <FIELD NAME="userid" TYPE="int" LENGTH="10" NOTNULL="false" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+    </TABLE>
+    <TABLE NAME="questionnaire_response_bool" COMMENT="questionnaire_response_bool table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="11" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="response_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="question_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="choice_id" TYPE="char" LENGTH="1" NOTNULL="true" DEFAULT="y" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+      <INDEXES>
+        <INDEX NAME="response_question" UNIQUE="false" FIELDS="response_id, question_id"/>
+      </INDEXES>
+    </TABLE>
+    <TABLE NAME="questionnaire_response_date" COMMENT="questionnaire_response_date table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="11" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="response_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="question_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="response" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+      <INDEXES>
+        <INDEX NAME="response_question" UNIQUE="false" FIELDS="response_id, question_id"/>
+      </INDEXES>
+    </TABLE>
+    <TABLE NAME="questionnaire_resp_multiple" COMMENT="questionnaire_resp_multiple table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="10" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="response_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="question_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="choice_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+      <INDEXES>
+        <INDEX NAME="response_question" UNIQUE="false" FIELDS="response_id, question_id, choice_id"/>
+      </INDEXES>
+    </TABLE>
+    <TABLE NAME="questionnaire_response_other" COMMENT="questionnaire_response_other table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="11" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="response_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="question_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="choice_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="response" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+      <INDEXES>
+        <INDEX NAME="response_question" UNIQUE="false" FIELDS="response_id, question_id, choice_id"/>
+      </INDEXES>
+    </TABLE>
+    <TABLE NAME="questionnaire_response_rank" COMMENT="questionnaire_response_rank table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="11" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="response_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="question_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="choice_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="rank" TYPE="int" LENGTH="11" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+      <INDEXES>
+        <INDEX NAME="response_question" UNIQUE="false" FIELDS="response_id, question_id, choice_id"/>
+      </INDEXES>
+    </TABLE>
+    <TABLE NAME="questionnaire_resp_single" COMMENT="questionnaire_resp_single table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="11" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="response_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="question_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="choice_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+      <INDEXES>
+        <INDEX NAME="response_question" UNIQUE="false" FIELDS="response_id, question_id"/>
+      </INDEXES>
+    </TABLE>
+    <TABLE NAME="questionnaire_response_text" COMMENT="questionnaire_response_text table retrofitted from MySQL">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="11" NOTNULL="true" SEQUENCE="true"/>
+        <FIELD NAME="response_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="question_id" TYPE="int" LENGTH="10" NOTNULL="true" DEFAULT="0" SEQUENCE="false"/>
+        <FIELD NAME="response" TYPE="text" NOTNULL="false" SEQUENCE="false"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+      <INDEXES>
+        <INDEX NAME="response_question" UNIQUE="false" FIELDS="response_id, question_id"/>
+      </INDEXES>
+    </TABLE>
+    <TABLE NAME="questionnaire_fb_sections" COMMENT="questionnaire_fb_sections table retrofitted from MySQL" PREVIOUS="questionnaire_response_text" NEXT="questionnaire_feedback">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="18" NOTNULL="true" SEQUENCE="true" NEXT="survey_id"/>
+        <FIELD NAME="survey_id" TYPE="int" LENGTH="18" NOTNULL="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="section"/>
+        <FIELD NAME="section" TYPE="int" LENGTH="2" NOTNULL="false" SEQUENCE="false" PREVIOUS="survey_id" NEXT="scorecalculation"/>
+        <FIELD NAME="scorecalculation" TYPE="text" NOTNULL="false" SEQUENCE="false" PREVIOUS="section" NEXT="sectionlabel"/>
+        <FIELD NAME="sectionlabel" TYPE="char" LENGTH="50" NOTNULL="false" SEQUENCE="false" PREVIOUS="scorecalculation" NEXT="sectionheading"/>
+        <FIELD NAME="sectionheading" TYPE="text" NOTNULL="false" SEQUENCE="false" PREVIOUS="sectionlabel" NEXT="sectionheadingformat"/>
+        <FIELD NAME="sectionheadingformat" TYPE="int" LENGTH="2" NOTNULL="false" DEFAULT="1" SEQUENCE="false" PREVIOUS="sectionheading"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+    </TABLE>
+    <TABLE NAME="questionnaire_feedback" COMMENT="questionnaire_feedback table retrofitted from MySQL" PREVIOUS="questionnaire_fb_sections">
+      <FIELDS>
+        <FIELD NAME="id" TYPE="int" LENGTH="18" NOTNULL="true" SEQUENCE="true" NEXT="section_id"/>
+        <FIELD NAME="section_id" TYPE="int" LENGTH="18" NOTNULL="true" DEFAULT="0" SEQUENCE="false" PREVIOUS="id" NEXT="feedbacklabel"/>
+        <FIELD NAME="feedbacklabel" TYPE="char" LENGTH="50" NOTNULL="false" SEQUENCE="false" PREVIOUS="section_id" NEXT="feedbacktext"/>
+        <FIELD NAME="feedbacktext" TYPE="text" NOTNULL="false" SEQUENCE="false" PREVIOUS="feedbacklabel" NEXT="feedbacktextformat"/>
+        <FIELD NAME="feedbacktextformat" TYPE="int" LENGTH="2" NOTNULL="false" DEFAULT="1" SEQUENCE="false" PREVIOUS="feedbacktext" NEXT="minscore"/>
+        <FIELD NAME="minscore" TYPE="number" LENGTH="10" NOTNULL="false" DEFAULT="0.00000" SEQUENCE="false" DECIMALS="5" PREVIOUS="feedbacktextformat" NEXT="maxscore"/>
+        <FIELD NAME="maxscore" TYPE="number" LENGTH="10" NOTNULL="false" DEFAULT="101.00000" SEQUENCE="false" DECIMALS="5" PREVIOUS="minscore"/>
+      </FIELDS>
+      <KEYS>
+        <KEY NAME="primary" TYPE="primary" FIELDS="id"/>
+      </KEYS>
+    </TABLE>
+  </TABLES>
+</XMLDB>
\ No newline at end of file
diff --git a/mod/questionnaire/db/log.php b/mod/questionnaire/db/log.php
new file mode 100644
index 0000000..6a41de7
--- /dev/null
+++ b/mod/questionnaire/db/log.php
@@ -0,0 +1,32 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Capability definitions for the quiz module.
+ *
+ * @package    mod
+ * @subpackage questionnaire
+ * @copyright  2010 Remote-Learner.net (http://www.remote-learner.net)
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+$logs = array(
+    array('module' => 'questionnaire', 'action' => 'view all', 'mtable' => 'questionnaire', 'field' => 'name'),
+    array('module' => 'questionnaire', 'action' => 'submit', 'mtable' => 'questionnaire_attempts', 'field' => 'rid'),
+    array('module' => 'questionnaire', 'action' => 'view', 'mtable' => 'questionnaire', 'field' => 'name'),
+);
\ No newline at end of file
diff --git a/mod/questionnaire/db/messages.php b/mod/questionnaire/db/messages.php
new file mode 100644
index 0000000..c917e42
--- /dev/null
+++ b/mod/questionnaire/db/messages.php
@@ -0,0 +1,33 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Defines message providers (types of messages being sent)
+ *
+ * @package mod_questionnaire
+ * @copyright  2010 onwards  Aparup Banerjee  http://moodle.com
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+$messageproviders = [
+    // Message to nonrespondents.
+    'message' => [],
+    // Response submissions.
+    'notification' => []
+];
diff --git a/mod/questionnaire/db/tasks.php b/mod/questionnaire/db/tasks.php
new file mode 100644
index 0000000..c36110b
--- /dev/null
+++ b/mod/questionnaire/db/tasks.php
@@ -0,0 +1,39 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Definition of Questionnaire scheduled tasks.
+ * Default is to run once every 12 hours.
+ *
+ * @package mod_questionnaire
+ * @category task
+ * @copyright 2015 The Open University
+ * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+$tasks = array(
+    array(
+        'classname' => 'mod_questionnaire\task\cleanup',
+        'blocking' => 0,
+        'minute' => 'R',
+        'hour' => '*/12',
+        'day' => '*',
+        'month' => '*',
+        'dayofweek' => '*'
+    )
+);
diff --git a/mod/questionnaire/db/upgrade.php b/mod/questionnaire/db/upgrade.php
new file mode 100644
index 0000000..75f158f
--- /dev/null
+++ b/mod/questionnaire/db/upgrade.php
@@ -0,0 +1,675 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+function xmldb_questionnaire_upgrade($oldversion=0) {
+    global $CFG, $DB;
+
+    $dbman = $DB->get_manager(); // Loads ddl manager and xmldb classes.
+
+    $result = true;
+
+    if ($oldversion < 2007120101) {
+        $result &= questionnaire_upgrade_2007120101();
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2007120101, 'questionnaire');
+    }
+
+    if ($oldversion < 2007120102) {
+        // Change enum values to lower case for all tables using them.
+        $table = new xmldb_table('questionnaire_question');
+
+        $field = new xmldb_field('required');
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, false, null, 'n');
+        $dbman->change_field_enum($table, $field);
+        $DB->set_field('questionnaire_question', 'required', 'y', array('required' => 'Y'));
+        $DB->set_field('questionnaire_question', 'required', 'n', array('required' => 'N'));
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, XMLDB_ENUM, array('y', 'n'), 'n');
+        $dbman->change_field_enum($table, $field);
+        $dbman->change_field_default($table, $field);
+        unset($field);
+
+        $field = new xmldb_field('deleted');
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, false, null, 'n');
+        $dbman->change_field_enum($table, $field);
+        $DB->set_field('questionnaire_question', 'deleted', 'y', array('deleted' => 'Y'));
+        $DB->set_field('questionnaire_question', 'deleted', 'n', array('deleted' => 'N'));
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, XMLDB_ENUM, array('y', 'n'), 'n');
+        $dbman->change_field_enum($table, $field);
+        $dbman->change_field_default($table, $field);
+        unset($field);
+
+        $field = new xmldb_field('public');
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, false, null, 'n');
+        $dbman->change_field_enum($table, $field);
+        $DB->set_field('questionnaire_question', 'public', 'y', array('public' => 'Y'));
+        $DB->set_field('questionnaire_question', 'public', 'n', array('public' => 'N'));
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, XMLDB_ENUM, array('y', 'n'), 'y');
+        $dbman->change_field_enum($table, $field);
+        $dbman->change_field_default($table, $field);
+        unset($field);
+
+        unset($table);
+
+        $table = new xmldb_table('questionnaire_question_type');
+
+        $field = new xmldb_field('has_choices');
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, false, null, 'n');
+        $dbman->change_field_enum($table, $field);
+        $DB->set_field('questionnaire_question_type', 'has_choices', 'y', array('has_choices' => 'Y'));
+        $DB->set_field('questionnaire_question_type', 'has_choices', 'n', array('has_choices' => 'N'));
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, XMLDB_ENUM, array('y', 'n'), 'y');
+        $dbman->change_field_enum($table, $field);
+        $dbman->change_field_default($table, $field);
+        unset($field);
+
+        unset($table);
+
+        $table = new xmldb_table('questionnaire_response');
+
+        $field = new xmldb_field('complete');
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, false, null, 'n');
+        $dbman->change_field_enum($table, $field);
+        $DB->set_field('questionnaire_response', 'complete', 'y', array('complete' => 'Y'));
+        $DB->set_field('questionnaire_response', 'complete', 'n', array('complete' => 'N'));
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, XMLDB_ENUM, array('y', 'n'), 'n');
+        $dbman->change_field_enum($table, $field);
+        $dbman->change_field_default($table, $field);
+        unset($field);
+
+        unset($table);
+
+        $table = new xmldb_table('questionnaire_response_bool');
+
+        $field = new xmldb_field('choice_id');
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, false, null, 'n');
+        $dbman->change_field_enum($table, $field);
+        $DB->set_field('questionnaire_response_bool', 'choice_id', 'y', array('choice_id' => 'Y'));
+        $DB->set_field('questionnaire_response_bool', 'choice_id', 'n', array('choice_id' => 'N'));
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, XMLDB_ENUM, array('y', 'n'), 'y');
+        $dbman->change_field_enum($table, $field);
+        $dbman->change_field_default($table, $field);
+        unset($field);
+
+        unset($table);
+
+        $table = new xmldb_table('questionnaire_survey');
+
+        $field = new xmldb_field('public');
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, false, null, 'n');
+        $dbman->change_field_enum($table, $field);
+        $DB->set_field('questionnaire_survey', 'public', 'y', array('public' => 'Y'));
+        $DB->set_field('questionnaire_survey', 'public', 'n', array('public' => 'N'));
+        $field->set_attributes(XMLDB_TYPE_CHAR, '1', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, XMLDB_ENUM, array('y', 'n'), 'y');
+        $dbman->change_field_enum($table, $field);
+        $dbman->change_field_default($table, $field);
+        unset($field);
+
+        // Upgrade question_type table with corrected 'response_table' fields.
+        $DB->set_field('questionnaire_question_type', 'response_table', 'resp_single',
+                        array('response_table' => 'response_single'));
+        $DB->set_field('questionnaire_question_type', 'response_table', 'resp_multiple',
+                        array('response_table' => 'response_multiple'));
+
+        // Questionnaire savepoint reached..
+        upgrade_mod_savepoint(true, 2007120102, 'questionnaire');
+    }
+
+    if ($oldversion < 2008031902) {
+        $table = new xmldb_table('questionnaire');
+        $field = new xmldb_field('grade');
+        $field->set_attributes(XMLDB_TYPE_INTEGER, '10', false, true, false, false, null, 0, 'navigate');
+        $dbman->add_field($table, $field);
+
+        unset($field);
+        unset($table);
+        $table = new xmldb_table('questionnaire_response');
+        $field = new xmldb_field('grade');
+        $field->set_attributes(XMLDB_TYPE_INTEGER, '10', false, true, false, false, null, 0, 'complete');
+        $dbman->add_field($table, $field);
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2008031902, 'questionnaire');
+    }
+
+    if ($oldversion < 2008031904) {
+        $sql = "SELECT q.id, q.resp_eligible, q.resp_view, cm.id as cmid
+                FROM {questionnaire} q, {course_modules} cm, {modules} m
+                WHERE m.name='questionnaire' AND m.id=cm.module AND cm.instance=q.id";
+        if ($rs = $DB->get_recordset_sql($sql)) {
+            $studentroleid = $DB->get_field('role', 'id', array('shortname' => 'student'));
+            $editteacherroleid = $DB->get_field('role', 'id', array('shortname' => 'editingteacher'));
+            $teacherroleid = $DB->get_field('role', 'id', array('shortname' => 'teacher'));
+            $capview = 'mod/questionnaire:view';
+            $capsubmit = 'mod/questionnaire:submit';
+
+            foreach ($rs as $questionnaire) {
+                $context = get_context_instance(CONTEXT_MODULE, $questionnaire->cmid);
+
+                // Convert questionnaires with resp_eligible = 'all' so that students & teachers have view and submit.
+                if ($questionnaire->resp_eligible == 'all') {
+                    assign_capability($capsubmit, CAP_ALLOW, $editteacherroleid, $context->id, true);
+                    assign_capability($capsubmit, CAP_ALLOW, $teacherroleid, $context->id, true);
+                    // Convert questionnaires with resp_eligible = 'students' so that just students have view and submit.
+                } else if ($questionnaire->resp_eligible == 'teachers') {
+                    assign_capability($capsubmit, CAP_ALLOW, $editteacherroleid, $context->id, true);
+                    assign_capability($capsubmit, CAP_ALLOW, $teacherroleid, $context->id, true);
+                    assign_capability($capview, CAP_PREVENT, $studentroleid, $context->id, true);
+                    assign_capability($capsubmit, CAP_PREVENT, $studentroleid, $context->id, true);
+                }
+            }
+            $rs->close();
+        }
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2008031904, 'questionnaire');
+    }
+
+    if ($oldversion < 2008031905) {
+        $table = new xmldb_table('questionnaire_survey');
+        $field = new xmldb_field('changed');
+        $dbman->drop_field($table, $field);
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2008031905, 'questionnaire');
+    }
+
+    if ($oldversion < 2008031906) {
+        $table = new xmldb_table('questionnaire_response_rank');
+        $field = new xmldb_field('rank');
+        $field->set_attributes(XMLDB_TYPE_INTEGER, '11', null, XMLDB_NOTNULL, null, null, null, '0', 'choice_id');
+        $field->setUnsigned(false);
+        $dbman->change_field_unsigned($table, $field);
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2008031906, 'questionnaire');
+    }
+
+    if ($oldversion < 2008060401) {
+        $table = new xmldb_table('questionnaire_question');
+        $field = new xmldb_field('name');
+        $field->set_attributes(XMLDB_TYPE_CHAR, '30', null, XMLDB_NOTNULL, null, null, null, null, 'survey_id');
+        $field->setNotnull(false);
+        $dbman->change_field_notnull($table, $field);
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2008060401, 'questionnaire');
+    }
+
+    if ($oldversion < 2008070702) {
+        $table = new xmldb_table('questionnaire_question_type');
+        $field = new xmldb_field('response_table');
+        $field->set_attributes(XMLDB_TYPE_CHAR, '32', null, XMLDB_NOTNULL, null, null, null, null, 'has_choices');
+        $field->setNotnull(false);
+        $dbman->change_field_notnull($table, $field);
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2008070702, 'questionnaire');
+    }
+
+    if ($oldversion < 2008070703) {
+        $table = new xmldb_table('questionnaire_resp_multiple');
+        $index = new xmldb_index('response_question');
+        $index->set_attributes(XMLDB_INDEX_NOTUNIQUE, array('response_id', 'question_id', 'choice_id'));
+        if (!$dbman->index_exists($table, $index)) {
+            $dbman->add_index($table, $index);
+        }
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2008070703, 'questionnaire');
+    }
+
+    if ($oldversion < 2008070704) {
+        // CONTRIB-1542.
+        $table = new xmldb_table('questionnaire_survey');
+        $field = new xmldb_field('email');
+        $field->set_attributes(XMLDB_TYPE_CHAR, '64', null, XMLDB_NOTNULL, null, null, null, null, 'title');
+        $field->setLength('255');
+        $dbman->change_field_precision($table, $field);
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2008070704, 'questionnaire');
+    }
+
+    if ($oldversion < 2008070705) {
+        // Rename summary field to 'intro' to adhere to new Moodle standard.
+        $table = new xmldb_table('questionnaire');
+        $field = new xmldb_field('summary');
+        $field->set_attributes(XMLDB_TYPE_TEXT, 'small', null, XMLDB_NOTNULL, null, null, null, null, 'name');
+        $dbman->rename_field($table, $field, 'intro');
+
+        // Add 'introformat' to adhere to new Moodle standard.
+        $field = new xmldb_field('introformat', XMLDB_TYPE_INTEGER, '4', XMLDB_UNSIGNED, XMLDB_NOTNULL, null, '0', 'intro');
+        $dbman->add_field($table, $field);
+        // Set all existing records to HTML format.
+        $DB->set_field('questionnaire', 'introformat', 1);
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2008070705, 'questionnaire');
+    }
+
+    if ($oldversion < 2008070706) {
+        // CONTRIB-1153.
+        $table = new xmldb_table('questionnaire_survey');
+        $field = new xmldb_field('public');
+        if ($dbman->field_exists($table, $field)) {
+            $dbman->drop_field($table, $field);
+        }
+
+        $table = new xmldb_table('questionnaire_question');
+        $field = new xmldb_field('public');
+        if ($dbman->field_exists($table, $field)) {
+            $dbman->drop_field($table, $field);
+        }
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2008070706, 'questionnaire');
+    }
+
+    if ($oldversion < 2010110100) {
+        // Drop list of values (enum) from field has_choices on table questionnaire_question_type.
+        $table = new xmldb_table('questionnaire_question_type');
+        $field = new xmldb_field('has_choices', XMLDB_TYPE_CHAR, '1', null, XMLDB_NOTNULL, null, 'y', 'type');
+
+        // Launch drop of list of values from field has_choices.
+        $dbman->drop_enum_from_field($table, $field);
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2010110100, 'questionnaire');
+    }
+
+    if ($oldversion < 2010110101) {
+        // Drop list of values (enum) from field respondenttype on table questionnaire.
+        $table = new xmldb_table('questionnaire');
+        $field = new xmldb_field('respondenttype', XMLDB_TYPE_CHAR, '9', null, XMLDB_NOTNULL, null, 'fullname', 'qtype');
+        // Launch drop of list of values from field respondenttype.
+        $dbman->drop_enum_from_field($table, $field);
+        // Drop list of values (enum) from field resp_eligible on table questionnaire.
+        $field = new xmldb_field('resp_eligible', XMLDB_TYPE_CHAR, '8', null, XMLDB_NOTNULL, null, 'all', 'respondenttype');
+        // Launch drop of list of values from field resp_eligible.
+        $dbman->drop_enum_from_field($table, $field);
+
+        // Drop list of values (enum) from field required on table questionnaire_question.
+        $table = new xmldb_table('questionnaire_question');
+        $field = new xmldb_field('required', XMLDB_TYPE_CHAR, '1', null, XMLDB_NOTNULL, null, 'n', 'content');
+        // Launch drop of list of values from field required.
+        $dbman->drop_enum_from_field($table, $field);
+        // Drop list of values (enum) from field deleted on table questionnaire_question.
+        $field = new xmldb_field('deleted', XMLDB_TYPE_CHAR, '1', null, XMLDB_NOTNULL, null, 'n', 'required');
+        // Launch drop of list of values from field deleted.
+        $dbman->drop_enum_from_field($table, $field);
+
+        // Drop list of values (enum) from field complete on table questionnaire_response.
+        $table = new xmldb_table('questionnaire_response');
+        $field = new xmldb_field('complete', XMLDB_TYPE_CHAR, '1', null, XMLDB_NOTNULL, null, 'n', 'submitted');
+        // Launch drop of list of values from field complete.
+        $dbman->drop_enum_from_field($table, $field);
+
+        // Drop list of values (enum) from field choice_id on table questionnaire_response_bool.
+        $table = new xmldb_table('questionnaire_response_bool');
+        $field = new xmldb_field('choice_id', XMLDB_TYPE_CHAR, '1', null, XMLDB_NOTNULL, null, 'y', 'question_id');
+        // Launch drop of list of values from field choice_id.
+        $dbman->drop_enum_from_field($table, $field);
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2010110101, 'questionnaire');
+    }
+
+    if ($oldversion < 2012100800) {
+        // Changing precision of field name on table questionnaire_survey to (255).
+
+        // First drop the index.
+        $table = new xmldb_table('questionnaire_survey');
+        $index = new xmldb_index('name');
+        $index->set_attributes(XMLDB_INDEX_NOTUNIQUE, array('name'));
+        $dbman->drop_index($table, $index);
+
+        // Launch change of precision for field name.
+        $field = new xmldb_field('name', XMLDB_TYPE_CHAR, '255', null, XMLDB_NOTNULL, null, null, 'id');
+        $dbman->change_field_precision($table, $field);
+
+        // Add back in the index.
+        $table = new xmldb_table('questionnaire_survey');
+        $index = new xmldb_index('name');
+        $index->set_attributes(XMLDB_INDEX_NOTUNIQUE, array('name'));
+        $dbman->add_index($table, $index);
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2012100800, 'questionnaire');
+    }
+
+    if ($oldversion < 2013062302) {
+        // Adding completionsubmit field to table questionnaire.
+
+        $table = new xmldb_table('questionnaire');
+        $field = new xmldb_field('completionsubmit', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '0', 'timemodified');
+
+        // Conditionally launch add field.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2013062302, 'questionnaire');
+    }
+
+    if ($oldversion < 2013062501) {
+        // Skip logic new feature.
+        // Define field dependquestion to be added to questionnaire_question table.
+        $table = new xmldb_table('questionnaire_question');
+        $field = new xmldb_field('dependquestion', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, '0', 'deleted');
+
+        // Conditionally launch add field.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        $table = new xmldb_table('questionnaire_question');
+        $field = new xmldb_field('dependchoice', XMLDB_TYPE_INTEGER, '10', null, XMLDB_NOTNULL, null, '0', 'dependquestion');
+
+        // Conditionally launch add field.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        // Replace the = separator with :: separator in quest_choice content.
+        // This fixes radio button options using old "value"="display" formats.
+        require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+        $choices = $DB->get_recordset('questionnaire_quest_choice', null);
+        $total = $DB->count_records('questionnaire_quest_choice');
+        if ($total > 0) {
+            $pbar = new progress_bar('convertchoicevalues', 500, true);
+            $i = 1;
+            foreach ($choices as $choice) {
+                if (($choice->value == null || $choice->value == 'NULL')
+                                && !preg_match("/^([0-9]{1,3}=.*|!other=.*)$/", $choice->content)) {
+                    $content = questionnaire_choice_values($choice->content);
+                    if (strpos($content->text, '=')) {
+                        $newcontent = str_replace('=', '::', $content->text);
+                        $choice->content = $newcontent;
+                        $DB->update_record('questionnaire_quest_choice', $choice);
+                    }
+                }
+                $pbar->update($i, $total, "Convert questionnaire choice value separator - $i/$total.");
+                $i++;
+            }
+        }
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2013062501, 'questionnaire');
+    }
+
+    if ($oldversion < 2013100500) {
+        // Add autonumbering option for questions and pages.
+        $table = new xmldb_table('questionnaire');
+        $field = new xmldb_field('autonum', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '3', 'completionsubmit');
+
+        // Conditionally launch add field.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2013100500, 'questionnaire');
+    }
+
+    if ($oldversion < 2013122202) {
+        // Personality test feature.
+
+        $table = new xmldb_table('questionnaire_survey');
+        $field = new xmldb_field('feedbacksections', XMLDB_TYPE_INTEGER, '2', null, null, null, null, null);
+        // Conditionally launch add field.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        unset($field);
+        $field = new xmldb_field('feedbacknotes', XMLDB_TYPE_TEXT, null, null, null, null, null);
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        unset($table);
+        unset($field);
+
+        // Define table questionnaire_fb_sections to be created.
+        $table = new xmldb_table('questionnaire_fb_sections');
+        $table->add_field('id', XMLDB_TYPE_INTEGER, '18', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
+        $table->add_field('survey_id', XMLDB_TYPE_INTEGER, '18', null, XMLDB_NOTNULL, null, null);
+        $table->add_field('section', XMLDB_TYPE_INTEGER, '2', null, null, null, null);
+        $table->add_field('scorecalculation', XMLDB_TYPE_TEXT, null, null, null, null, null);
+        $table->add_field('sectionlabel', XMLDB_TYPE_CHAR, '50', null, null, null, null);
+        $table->add_field('sectionheading', XMLDB_TYPE_TEXT, null, null, null, null, null);
+        $table->add_field('sectionheadingformat', XMLDB_TYPE_INTEGER, '2', null, null, null, '1');
+
+        // Adding keys to table questionnaire_fb_sections.
+        $table->add_key('primary', XMLDB_KEY_PRIMARY, array('id'));
+
+        // Conditionally launch create table for assign_user_mapping.
+        if (!$dbman->table_exists($table)) {
+            $dbman->create_table($table);
+        }
+
+        unset($table);
+
+        // Define table questionnaire_feedback to be created.
+        $table = new xmldb_table('questionnaire_feedback');
+        $table->add_field('id', XMLDB_TYPE_INTEGER, '18', null, XMLDB_NOTNULL, XMLDB_SEQUENCE, null);
+        $table->add_field('section_id', XMLDB_TYPE_INTEGER, '18', null, XMLDB_NOTNULL, null, null);
+        $table->add_field('feedbacklabel', XMLDB_TYPE_CHAR, '30', null, null, null, null);
+        $table->add_field('feedbacktext', XMLDB_TYPE_TEXT, null, null, null, null, null);
+        $table->add_field('feedbacktextformat', XMLDB_TYPE_INTEGER, '2', null, null, null, '1');
+        $table->add_field('minscore', XMLDB_TYPE_NUMBER, '10,5', null, null, null, '0.00000');
+        $table->add_field('maxscore', XMLDB_TYPE_NUMBER, '10,5', null, null, null, '101.00000');
+
+        // Adding keys to table questionnaire_fb_sections.
+        $table->add_key('primary', XMLDB_KEY_PRIMARY, array('id'));
+
+        // Conditionally launch create table for assign_user_mapping.
+        if (!$dbman->table_exists($table)) {
+            $dbman->create_table($table);
+        }
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2013122202, 'questionnaire');
+    }
+
+    if ($oldversion < 2014010300) {
+        // Personality test with chart.
+        $table = new xmldb_table('questionnaire_survey');
+        $field = new xmldb_field('chart_type', XMLDB_TYPE_CHAR, '64', null, null, null, null, null);
+
+        // Conditionally launch add field.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        $field = new xmldb_field('feedbackscores', XMLDB_TYPE_INTEGER, '1', null, null, null, '0');
+
+        // Conditionally launch add field.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        // Questionnaire savepoint reached.
+         upgrade_mod_savepoint(true, 2014010300, 'questionnaire');
+    }
+
+    if ($oldversion < 2015051101) {
+        // Move the global config value for 'usergraph' to the plugin config setting instead.
+        if (isset($CFG->questionnaire_usergraph)) {
+            set_config('usergraph', $CFG->questionnaire_usergraph, 'questionnaire');
+            unset_config('questionnaire_usergraph');
+        }
+        upgrade_mod_savepoint(true, 2015051101, 'questionnaire');
+    }
+
+    // Add index to reduce load on the questionnaire_quest_choice table.
+    if ($oldversion < 2015051102) {
+        // Conditionally add an index to the question_id field.
+        $table = new xmldb_table('questionnaire_quest_choice');
+        $index = new xmldb_index('quest_choice_quesidx', XMLDB_INDEX_NOTUNIQUE, array('question_id'));
+        // Only add the index if it does not exist.
+        if (!$dbman->index_exists($table, $index)) {
+            $dbman->add_index($table, $index);
+        }
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2015051102, 'questionnaire');
+    }
+
+    // Ensuring database matches XML state for some known anomalies.
+    if ($oldversion < 2016020204) {
+        // Ensure the feedbackscores field can be null (CONTRIB-6445).
+        $table = new xmldb_table('questionnaire_survey');
+        $field = new xmldb_field('feedbackscores', XMLDB_TYPE_INTEGER, '1', null, null, null, '0');
+        $dbman->change_field_notnull($table, $field);
+
+        // Ensure the feddbacklabel field is 50 characters (CONTRIB-6445).
+        $table = new xmldb_table('questionnaire_feedback');
+        $field = new xmldb_field('feedbacklabel', XMLDB_TYPE_CHAR, '50', null, null, null, null);
+        $dbman->change_field_precision($table, $field);
+
+        // Ensure the response field is text.
+        $table = new xmldb_table('questionnaire_response_date');
+        $field = new xmldb_field('response', XMLDB_TYPE_TEXT, null, null, null, null, null);
+        $dbman->change_field_precision($table, $field);
+
+        // Questionnaire savepoint reached.
+         upgrade_mod_savepoint(true, 2016020204, 'questionnaire');
+    }
+
+    // Ensuring database matches XML state for some known anomalies.
+    if ($oldversion < 2016111105) {
+        $table = new xmldb_table('questionnaire');
+        $field = new xmldb_field('notifications', XMLDB_TYPE_INTEGER, '1', null, XMLDB_NOTNULL, null, '0', 'resp_view');
+
+        // Conditionally launch add field.
+        if (!$dbman->field_exists($table, $field)) {
+            $dbman->add_field($table, $field);
+        }
+
+        // Questionnaire savepoint reached.
+         upgrade_mod_savepoint(true, 2016111105, 'questionnaire');
+    }
+
+    // Redoing the 2017050100 upgrade in 2017050101. If it already completed in 2017050100, skip it.
+    if ($oldversion < 2017050101) {
+        // Changing type of field username from char to int.
+        $table = new xmldb_table('questionnaire_response');
+        $field = new xmldb_field('username', XMLDB_TYPE_INTEGER, '10');
+        // If it already completed in 2017050100, skip it.
+        if ($dbman->field_exists($table, $field)) {
+            // Before we change the field 'username' to an int, ensure there are only numeric values there.
+            $sql = 'SELECT qr.id, qr.username, qa.rid, qa.userid ' .
+                   'FROM {questionnaire_response} qr ' .
+                   'INNER JOIN {questionnaire_attempts} qa ON qr.id = qa.rid ' .
+                   'WHERE qr.username = ?';
+            $rs = $DB->get_recordset_sql($sql, ["Anonymous"]);
+            // Set all "Anonymous" records to the userid in the matching attempt record.
+            foreach ($rs as $record) {
+                $DB->set_field('questionnaire_response', 'username', "{$record->userid}", ['id' => $record->id]);
+            }
+            // If there are any leftover "Anonymous" records, set them all to userid zero (there shouldn't be).
+            $rs = $DB->get_recordset('questionnaire_response', ['username' => 'Anonymous']);
+            foreach ($rs as $record) {
+                $DB->set_field('questionnaire_response', 'username', '0', ['id' => $record->id]);
+            }
+
+            // Launch change of type for field username.
+            $dbman->change_field_type($table, $field);
+
+            // Change the name from username to userid.
+            $dbman->rename_field($table, $field, 'userid');
+        }
+
+        // Changing type of field owner from char to int.
+        $table = new xmldb_table('questionnaire_survey');
+        $field = new xmldb_field('owner', XMLDB_TYPE_INTEGER, '10');
+        // If it already completed in 2017050100, skip it.
+        if ($dbman->field_exists($table, $field)) {
+            // Drop the old 'owner' index before modifying the field.
+            $index = new xmldb_index('owner', XMLDB_INDEX_NOTUNIQUE, ['owner']);
+            $dbman->drop_index($table, $index);
+
+            // Launch change of type for field owner.
+            $dbman->change_field_type($table, $field);
+
+            // Change the name from owner to courseid.
+            $dbman->rename_field($table, $field, 'courseid');
+
+            // Add the index back with the new name.
+            $index = new xmldb_index('courseid', XMLDB_INDEX_NOTUNIQUE, ['courseid']);
+            if (!$dbman->index_exists($table, $index)) {
+                $dbman->add_index($table, $index);
+            }
+        }
+
+        // Questionnaire savepoint reached.
+        upgrade_mod_savepoint(true, 2017050101, 'questionnaire');
+    }
+
+    return $result;
+}
+
+// Supporting functions used once.
+function questionnaire_upgrade_2007120101() {
+    global $DB;
+
+    $dbman = $DB->get_manager(); // Loads ddl manager and xmldb classes.
+    $status = true;
+
+    // Shorten table names to bring them in accordance with the XML DB schema.
+    $qtable = new xmldb_table('questionnaire_question_choice');
+    $dbman->rename_table($qtable, 'questionnaire_quest_choice', false);
+    unset($qtable);
+
+    $qtable = new xmldb_table('questionnaire_response_multiple');
+    $dbman->rename_table($qtable, 'questionnaire_resp_multiple', false);
+    unset($qtable);
+
+    $qtable = new xmldb_table('questionnaire_response_single');
+    $dbman->rename_table($qtable, 'questionnaire_resp_single', false);
+    unset($qtable);
+
+    // Upgrade the questionnaire_question_type table to use typeid.
+    $table = new xmldb_table('questionnaire_question_type');
+    $field = new xmldb_field('typeid');
+    $field->set_attributes(XMLDB_TYPE_CHAR, '20', true, true, false, false, null, '0', 'id');
+    $dbman->add_field($table, $field);
+    if (($numrecs = $dbman->count_records('questionnaire_question_type')) > 0) {
+        $recstart = 0;
+        $recstoget = 100;
+        while ($recstart < $numrecs) {
+            if ($records = $dbman->get_records('questionnaire_question_type', array(), '', '*', $recstart, $recstoget)) {
+                foreach ($records as $record) {
+                    $dbman->set_field('questionnaire_question_type', 'typeid', $record->id, array('id' => $record->id));
+                }
+            }
+            $recstart += $recstoget;
+        }
+    }
+
+    return $status;
+}
diff --git a/mod/questionnaire/drawchart.php b/mod/questionnaire/drawchart.php
new file mode 100644
index 0000000..36e6955
--- /dev/null
+++ b/mod/questionnaire/drawchart.php
@@ -0,0 +1,569 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+function draw_chart($feedbacktype, $charttype=null, $labels,
+                    $score=null, $allscore=null, $globallabel=null, $groupname, $allresponses) {
+    global $PAGE;
+
+    $pageoutput = '';
+
+    if ($allresponses) {
+        $nbvalues = count($allscore);
+    } else {
+        $nbvalues = count($score);
+    }
+    $nblabels = count($labels);
+    $charttitlefont = "Verdana";
+    $charttitlesize = 10;
+    $charttitlesize2 = 10;
+    if ($PAGE->pagetype == 'mod-questionnaire-myreport') {
+        $charttitle = get_string('yourresponse', 'questionnaire');
+    } else {
+        $charttitle = get_string('thisresponse', 'questionnaire');
+    }
+    $charttitle2 = $groupname;
+
+    // Gradient colors if needed.
+    // TODO make gradient colors customizable in the settings.
+    $chartcolorsgradient = "['Gradient(white:blue)', 'Gradient(white:red)', 'Gradient(white:green)', 'Gradient(white:pink)',
+            'Gradient(white:yellow)', 'Gradient(white:cyan)', 'Gradient(white:navy)',
+            'Gradient(white:gray)', 'Gradient(white:black)']";
+    $chartcolorsgradient2 = "['Gradient(pink:red)', 'Gradient(white:blue)', 'Gradient(white:green)', 'Gradient(white:pink)',
+        'Gradient(white:yellow)', 'Gradient(white:cyan)', 'Gradient(white:navy)', 'Gradient(white:gray)', 'Gradient(white:black)']";
+
+    // We do not have labels other than global in this feedback type.
+    if ($feedbacktype == 'global') {
+        $labels = array($globallabel);
+    }
+
+    switch ($charttype) {
+
+        case 'bipolar':
+            // Global feedback with only one score.
+            if ($feedbacktype == 'global') {
+                if ($score) {
+                    if ($allresponses) {
+                        $score = null;
+                    } else {
+                        $score2 = $score;
+                        $score = array($score2[0]);
+                        $oppositescore = array($score2[1]);
+                    }
+                }
+
+                if ($allscore) {
+                    $allscore2 = $allscore;
+                    $allscore = array($allscore2[0]);
+                    $alloppositescore = array($allscore2[1]);
+                }
+                $nblabels = 1.5;     // For a single horizontal bar with 1.5 height.
+                $nbvalues = 1;       // Only one hbar.
+            } else {
+                if ($score) {
+                    $oppositescore = array();
+                    foreach ($score as $sc) {
+                        $oppositescore[] = 100 - $sc;
+                    }
+                }
+                if ($allscore) {
+                    $alloppositescore = array();
+                    foreach ($allscore as $sc) {
+                        $alloppositescore[] = 100 - $sc;
+                    }
+                }
+            }
+            foreach ($labels as $key => $label) {
+                $lb = explode("|", $label);
+                // Just in case there is no pipe separator in label.
+                if (count($lb) > 1) {
+                    $left = $lb[0];
+                    $right = $lb[1];
+                    // Lib core_text and diff needed for non-ascii characters.
+                    $lenleft = core_text::strlen($left);
+                    $diffleft = strlen($left) - $lenleft;
+                    $lenright = core_text::strlen($right);
+                    $diffright = strlen($right) - $lenright;
+                    if ($lenleft < $lenright) {
+                        $padlength = $lenright + $diffleft;
+                        $left = str_pad($left, $padlength, ' ', STR_PAD_LEFT);
+                    }
+                    if ($lenleft > $lenright) {
+                        $padlength = $lenleft + $diffright;
+                        $right = str_pad($right, $padlength, ' ', STR_PAD_RIGHT);
+                    }
+                    $labels[$key] = $left .' '.$right;
+                }
+            }
+            // Find length of longest label.
+            $maxlen = 0;
+            foreach ($labels as $label) {
+                $labellen = core_text::strlen($label);
+                if ($labellen > $maxlen) {
+                    $maxlen = $labellen;
+                }
+            }
+
+            $labels = json_encode($labels, JSON_UNESCAPED_UNICODE);
+            // JSON_UNESCAPED_UNICODE available since php 5.4, used to correctly treat French accents etc.
+
+            // The bar colors :: use green for "positive" (left column) and pink for "negative" (right column).
+            $chartcolors = array();
+            $chartcolors2 = array();
+            if ($score) {
+
+                for ($i = 0; $i < $nbvalues; $i++) {
+                    if ($score[$i] != 0) {
+                        $chartcolors[] = 'lightgreen';
+                    }
+                }
+                for ($i = $nbvalues; $i < $nbvalues * 2; $i++) {
+                    $chartcolors[] = 'pink';
+                }
+            }
+            if ($allscore) {
+
+                for ($i = 0; $i < $nbvalues; $i++) {
+                    if ($allscore[$i] != 0) {
+                        $chartcolors2[] = 'lightgreen';
+                    }
+                }
+                for ($i = $nbvalues; $i < $nbvalues * 2; $i++) {
+                    $chartcolors2[] = 'pink';
+                }
+            }
+
+            // Encode all arrays for javascript compatibility.
+            $chartcolors = json_encode($chartcolors);
+            if ($allscore) {
+                $chartcolors2 = json_encode($chartcolors2);
+            }
+            if ($score) {
+                $score = json_encode($score);
+                $oppositescore = json_encode($oppositescore);
+            }
+
+            if ($allscore) {
+                $allscore = json_encode($allscore);
+                $alloppositescore = json_encode($alloppositescore);
+            }
+            $canvasheight = ($nblabels * 25) + 60;
+            $canvaswidth = max(300, (100 + ($maxlen * 7)));
+            if (!$allresponses) {
+                $pageoutput .= '
+                        <canvas id="cvs" width="'.$canvaswidth.'" height="'.$canvasheight.'">[No canvas support]</canvas>
+                    ';
+            }
+            if ($allscore) {
+                $pageoutput .= '
+                        <canvas id="cvs2" width="'.$canvaswidth.'" height="'.$canvasheight.'">[No canvas support]</canvas>
+                    ';
+            }
+            $pageoutput .= '
+                    <script>
+                        window.onload = function () {';
+            if (!$allresponses) {
+                $pageoutput .= '
+                            var chart = new RGraph.Bipolar("cvs", '.$score.', '.$oppositescore.');
+                            chart.Set("chart.title", "'.$charttitle.'");
+                            chart.Set("chart.title.font", "'.$charttitlefont.'");
+                            chart.Set("chart.title.size", "'.$charttitlesize.'");
+                            chart.Set("chart.labels", '.$labels.');
+                            chart.Set("chart.gutter.center", 0);
+                            chart.Set("chart.gutter.left", 10);
+                            chart.Set("chart.gutter.top", 40);
+                            chart.Set("chart.gutter.bottom", 20);
+                            chart.Set("chart.xmax", 100);
+                            chart.Set("chart.text.size", 10);
+                            chart.Set("chart.text.font", "Courier");
+                            chart.Set("chart.colors", '.$chartcolors.');
+                            chart.Set("chart.colors.sequential", true);
+                            chart.Draw();';
+            }
+            if ($allscore) {
+                $pageoutput .= '
+                            var chart = new RGraph.Bipolar("cvs2", '.$allscore.', '.$alloppositescore.');
+                            chart.Set("chart.title", "'.$charttitle2.'");
+                            chart.Set("chart.title.font", "'.$charttitlefont.'");
+                            chart.Set("chart.title.size", "'.$charttitlesize2.'");
+                            chart.Set("chart.labels", '.$labels.');
+                            chart.Set("chart.gutter.center", 0);
+                            chart.Set("chart.gutter.left", 10);
+                            chart.Set("chart.gutter.right", 15);
+                            chart.Set("chart.gutter.top", 40);
+                            chart.Set("chart.gutter.bottom", 20);
+                            chart.Set("chart.xmax", 100);
+                            chart.Set("chart.text.size", 10);
+                            chart.Set("chart.text.font", "Courier");
+                            chart.Set("chart.colors", '.$chartcolors2.');
+                            chart.Set("chart.colors.sequential", true);
+                            chart.Draw();
+                        ';
+            }
+            $pageoutput .= '
+                    }
+                    </script>
+                ';
+            break;
+
+        case 'hbar':
+            // The bar colors.
+            $chartcolors = array();
+            $chartcolors = json_encode($chartcolors);
+            $sequential = 'true';
+            // Global feedback with only one score.
+            if ($feedbacktype == 'global') {
+                $lb = explode("|", $globallabel);
+                // Just in case there is no pipe separator in label.
+                if (count($lb) > 1) {
+                    $labels = '';
+                    $left = $lb[0];
+                    $right = $lb[1];
+                    $lenleft = core_text::strlen($left);
+                    $lenright = core_text::strlen($right);
+                    if ($lenleft < $lenright) {
+                        $padlength = $lenright;
+                        $left = str_pad($left, $padlength, ' ', STR_PAD_LEFT);
+                    }
+                    if ($lenleft > $lenright) {
+                        $padlength = $lenleft;
+                        $right = str_pad($right, $padlength, ' ', STR_PAD_RIGHT);
+                    }
+                    $labels[0] = $left;
+                    $labels[1] = $right;
+                }
+
+            } else {
+                if ($nblabels > $nbvalues) {
+                    for ($i = 1; $i < $nblabels - 1; $i++) {
+                        unset($labels[$i]);
+                    }
+                }
+                $sequential = 'false';
+            }
+            $nblabels = count($labels) + 1;
+            $score = json_encode($score);
+            if ($allscore) {
+                $allscore = json_encode($allscore);
+            }
+            // Find length of longest label.
+            $maxlen = 0;
+            foreach ($labels as $label) {
+                $labellen = core_text::strlen($label);
+                if ($labellen > $maxlen) {
+                    $maxlen = $labellen;
+                }
+            }
+            foreach ($labels as $value) {
+                $output[] = '"'.$value.'"';
+            }
+            $labels = '[' . implode(',', $output) . ']';
+            $canvasheight = ($nblabels * 20) + 60;
+            $charttextfont = 'Courier';
+            $gutterleft = ($maxlen * 8) + 5;
+            $canvaswidth = 400 + $gutterleft;
+            if (!$allresponses) {
+                $pageoutput .= '
+                    <canvas id="cvs" width="'.$canvaswidth.'" height="'.$canvasheight.'">[No canvas support]</canvas>
+                    ';
+            }
+            if ($allscore) {
+                $pageoutput .= '
+                        <canvas id="cvs2" width="'.$canvaswidth.'" height="'.$canvasheight.'">[No canvas support]</canvas>
+                    ';
+            }
+            $pageoutput .= '
+                    <script>
+                        window.onload = function () {';
+            if (!$allresponses) {
+                $pageoutput .= '
+                            var chart = new RGraph.HBar("cvs", '.$score.');
+                            chart.Set("chart.title", "'.$charttitle.'");
+                            chart.Set("chart.title.font", "'.$charttitlefont.'");
+                            chart.Set("chart.title.size", "'.$charttitlesize.'");
+                            chart.Set("chart.title.x", 400);
+                            chart.Set("gutter.left", "'.$gutterleft.'");
+                            chart.Set("gutter.right", 2);
+                            chart.Set("chart.text.font", "'.$charttextfont.'");
+                            chart.Set("labels", '.$labels.');
+                            chart.Set("chart.colors", '.$chartcolorsgradient.');
+                            chart.Set("chart.colors.sequential", '.$sequential.');
+                            chart.Set("xmax",100);
+                            chart.Draw();
+                            ';
+            }
+            if ($allscore) {
+                $pageoutput .= '
+                            var chart = new RGraph.HBar("cvs2", '.$allscore.');
+                            chart.Set("chart.title", "'.$charttitle2.'");
+                            chart.Set("chart.title.font", "'.$charttitlefont.'");
+                            chart.Set("chart.title.size", "'.$charttitlesize.'");
+                            chart.Set("chart.title.x", 400);
+                            chart.Set("gutter.left", "'.$gutterleft.'");
+                            chart.Set("gutter.right", 2);
+                            chart.Set("chart.text.font", "'.$charttextfont.'");
+                            chart.Set("labels", '.$labels.');
+                            chart.Set("chart.colors", '.$chartcolorsgradient.');
+                            chart.Set("chart.colors.sequential",  '.$sequential.');
+                            chart.Set("xmax",100);
+                            chart.Draw();
+                            ';
+            }
+            $pageoutput .= '
+                    }
+                    </script>
+                ';
+            break;
+
+        case 'radar':
+            $score = json_encode($score);
+            foreach ($labels as $key => $label) {
+                if ($key != 0) {
+                    $labels[$key] = wordwrap($label, 20, "\\r\\n");
+                } else {
+                    $labels[$key] = $label ."\\r\\n";
+                }
+            }
+            foreach ($labels as $value) {
+                $output[] = '"'.$value.'"';
+            }
+            $labels = '[' . implode(',', $output) . ']';
+            if ($allscore) {
+                $allscore = json_encode($allscore);
+            }
+            if (!$allresponses) {
+                $pageoutput .= '
+                        <canvas id="cvs" width="550" height="400">[No canvas support]</canvas>
+                        ';
+            }
+            if ($allscore) {
+                $pageoutput .= '
+                    <canvas id="cvs2" width="550" height="400">[No canvas support]</canvas>
+                    ';
+            }
+            $pageoutput .= '
+                    <script>
+                        window.onload = function () {';
+            if (!$allresponses) {
+                $pageoutput .= '
+                            var chart = new RGraph.Radar("cvs", '.$score.');
+                            chart.Set("chart.title", "'.$charttitle.'");
+                            chart.Set("chart.labels", '.$labels.');
+                            chart.Set("chart.labels.offset", 15);
+                            chart.Set("chart.radius", 150);
+                            chart.Set("chart.ymax", 100);
+                            chart.Set("chart.labels.axes","n");
+                            chart.Draw();
+                            ';
+            }
+            if ($allscore) {
+                $pageoutput .= '
+                            var chart = new RGraph.Radar("cvs2", '.$allscore.');
+                            chart.Set("chart.title", "'.$charttitle2.'");
+                            chart.Set("chart.labels", '.$labels.');
+                            chart.Set("chart.labels.offset", 15);
+                            chart.Set("chart.radius", 150);
+                            chart.Set("chart.ymax", 100);
+                            chart.Set("chart.labels.axes","n");
+                            chart.Draw();
+                            ';
+            }
+            $pageoutput .= '
+                            }
+                            </script>
+                    ';
+            break;
+
+        case 'rose':
+            if ($score != 'null') {
+                $score = json_encode($score);
+            }
+
+            foreach ($labels as $key => $label) {
+                $labels[$key] = wordwrap($label, 8, "\\r\\n");
+            }
+            foreach ($labels as $value) {
+                $output[] = '"'.$value.'"';
+            }
+            $labels = '[' . implode(',', $output) . ']';
+
+            if ($allscore) {
+                $allscore = json_encode($allscore);
+            }
+            $size = 400;
+            if (!$allresponses) {
+                $pageoutput .= '
+                        <canvas id="cvs" width="'.$size.'" height="'.$size.'">[No canvas support]</canvas>
+                    ';
+            }
+            if ($allscore) {
+                $pageoutput .= '&nbsp;&nbsp;&nbsp;
+                        <canvas id="cvs2" width="'.$size.'" height="'.$size.'">[No canvas support]</canvas>
+                    ';
+            }
+            $pageoutput .= '
+                    <script>
+                        window.onload = function () {';
+            if (!$allresponses) {
+                $pageoutput .= '
+                            var chart = new RGraph.Rose("cvs", '.$score.');
+                            chart.Set("chart.title", "'.$charttitle.'");
+                            chart.Set("chart.title.font", "'.$charttitlefont.'");
+                            chart.Set("chart.title.size", "'.$charttitlesize.'");
+                            chart.Set("chart.title.vpos", 0.2);
+                            chart.Set("chart.labels", '.$labels.');
+                            chart.Set("chart.labels.offset", 10);
+                            chart.Set("chart.background.grid.spokes", '.$nblabels.');
+                            chart.Set("chart.labels.axes","n");
+                            chart.Set("chart.radius", 100);
+                            chart.Set("chart.ymax", 100);
+                            chart.Set("chart.background.axes", false);
+                            chart.Set("chart.colors.sequential", true);
+                            chart.Set("chart.colors", ["Gradient(white:red)","Gradient(white:green)","Gradient(white:blue)",
+                            "Gradient(white:gray)","Gradient(white:purple)","Gradient(white:pink)",
+                                            "Gradient(white:orange)","Gradient(white:black)"]);
+                            chart.Draw();
+                            ';
+            }
+            if ($allscore) {
+                $pageoutput .= '
+                            var chart = new RGraph.Rose("cvs2", '.$allscore.');
+                            chart.Set("chart.title", "'.$charttitle2.'");
+                            chart.Set("chart.title.font", "'.$charttitlefont.'");
+                            chart.Set("chart.title.size", "'.$charttitlesize.'");
+                            chart.Set("chart.title.vpos", 0.2);
+                            chart.Set("chart.labels", '.$labels.');
+                            chart.Set("chart.labels.offset", 10);
+                            chart.Set("chart.background.grid.spokes", '.$nblabels.');
+                            chart.Set("chart.labels.axes","n");
+                            chart.Set("chart.radius", 100);
+                            chart.Set("chart.ymax", 100);
+                            chart.Set("chart.background.axes", false);
+                            chart.Set("chart.colors.sequential", true);
+                            chart.Set("chart.colors", ["Gradient(white:red)","Gradient(white:green)","Gradient(white:blue)",
+                            "Gradient(white:gray)","Gradient(white:purple)","Gradient(white:pink)",
+                                            "Gradient(white:orange)","Gradient(white:black)"]);
+                            chart.Draw();
+                            ';
+            }
+            $pageoutput .= '
+                        }
+                    </script>
+                ';
+            break;
+
+        case 'vprogress':
+            if (!$allresponses) {
+                $score = $score[0];
+            } else {
+                $score = null;
+            }
+            $score = json_encode($score);
+            if ($allscore) {
+                $allscore = json_encode($allscore[0]);
+            }
+            // Check presence of pipe separator in label.
+            $lb = explode("|", $globallabel);
+            $maxlen = 0;
+            if (count($lb) > 1) {
+                $labels = array_reverse($lb);
+                // Find length of longest label.
+                $maxlen = 0;
+                foreach ($labels as $label) {
+                    $labellen = core_text::strlen($label);
+                    if ($labellen > $maxlen) {
+                        $maxlen = $labellen;
+                    }
+                }
+                foreach ($labels as $value) {
+                    $output[] = '"'.$value.'"';
+                }
+                $labels = '[' . implode(',', $output) . ']';
+            } else {
+                $labels = '';
+            }
+            $charttextfont = 'Courier';
+            $gutterright = 150 + ($maxlen * 3);
+            $canvaswidth = 250 + ($maxlen * 3);
+
+            if (!$allresponses) {
+                $pageoutput .= '
+                        <canvas id="cvs" width="'.$canvaswidth.'" height="400">[No canvas support]</canvas>
+                    ';
+            }
+            if ($allscore) {
+                $pageoutput .= '
+                        <canvas id="cvs2" width="250" height="400">[No canvas support]</canvas>
+                    ';
+            }
+            $pageoutput .= '
+                    <script>
+                        window.onload = function () {';
+
+            if (!$allresponses) {
+                $pageoutput .= '
+                        var chart = new RGraph.VProgress("cvs", '.$score.',100);
+                        chart.Set("chart.gutter.top", 30);
+                        chart.Set("chart.gutter.left", 50);
+                        chart.Set("chart.gutter.right", "'.$gutterright.'");
+                        chart.Set("scale.decimals", 0);
+                        chart.Set("chart.text.font", "'.$charttextfont.'");
+                        chart.Set("chart.title", "'.$charttitle.'");
+                        chart.Set("chart.title.font", "'.$charttitlefont.'");
+                        chart.Set("chart.title.size", "'.$charttitlesize.'");
+                        ';
+
+                if ($labels) {
+                    $pageoutput .= '
+                                chart.Set("chart.labels.specific", '.$labels.');
+                                ';
+                }
+                $pageoutput .= '
+                                chart.Draw();
+                              ';
+            }
+            if ($allscore) {
+                // Display participants graph.
+                $pageoutput .= '
+                            var chart = new RGraph.VProgress("cvs2", '.$allscore.',100);
+                            chart.Set("chart.gutter.top", 30);
+                            chart.Set("chart.gutter.left", 50);
+                            chart.Set("chart.gutter.right", 150);
+                            chart.Set("chart.title", "'.$charttitle2.'");
+                            chart.Set("chart.text.font", "'.$charttextfont.'");
+                            chart.Set("chart.title.font", "'.$charttitlefont.'");
+                            chart.Set("chart.title.size", "'.$charttitlesize.'");
+                            chart.Set("scale.decimals", 0);
+                            chart.Draw();
+                        ';
+            }
+            $pageoutput .= '
+                        }
+                    </script>
+                ';
+            break;
+    }
+
+    return $pageoutput;
+}
\ No newline at end of file
diff --git a/mod/questionnaire/fbsections.php b/mod/questionnaire/fbsections.php
new file mode 100644
index 0000000..ef4791e
--- /dev/null
+++ b/mod/questionnaire/fbsections.php
@@ -0,0 +1,266 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+$id     = optional_param('id', 0, PARAM_INT);
+$sid    = optional_param('sid', 0, PARAM_INT);
+
+if ($id) {
+    if (! $cm = get_coursemodule_from_id('questionnaire', $id)) {
+        print_error('invalidcoursemodule');
+    }
+    if (! $course = $DB->get_record("course", array("id" => $cm->course))) {
+        print_error('coursemisconf');
+    }
+    if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $cm->instance))) {
+        print_error('invalidcoursemodule');
+    }
+}
+
+// Check login and get context.
+require_login($course->id, false, $cm);
+$context = $cm ? context_module::instance($cm->id) : false;
+
+$url = new moodle_url('/mod/questionnaire/fbsections.php');
+if ($id !== 0) {
+    $url->param('id', $id);
+}
+if ($sid) {
+    $url->param('sid', $sid);
+}
+$questionnaire = new questionnaire(0, $questionnaire, $course, $cm);
+$questions = $questionnaire->questions;
+$sid = $questionnaire->survey->id;
+$viewform = data_submitted($CFG->wwwroot."/mod/questionnaire/fbsections.php");
+$feedbacksections = $questionnaire->survey->feedbacksections;
+$errormsg = '';
+
+// Check if there are any feedbacks stored in database already to use them to check
+// the radio buttons on select questions in sections page.
+if ($fbsections = $DB->get_records('questionnaire_fb_sections',
+        array('survey_id' => $sid)) ) {
+    $scorecalculation = '';
+    $questionsinsections = array();
+    for ($section = 1; $section <= $feedbacksections; $section++) {
+        // Retrieve the scorecalculation formula and the section heading only once.
+        foreach ($fbsections as $fbsection) {
+            if (isset($fbsection->scorecalculation) && $fbsection->section == $section) {
+                $scorecalculation = unserialize($fbsection->scorecalculation);
+                foreach ($scorecalculation as $qid => $key) {
+                    $questionsinsections[$qid] = $section;
+                }
+                break;
+            }
+        }
+    }
+    // If Global Feedback (only 1 section) and no questions have yet been put in section 1 check all questions.
+    if (!empty($questionsinsections)) {
+        $vf = $questionsinsections;
+    }
+}
+if (data_submitted()) {
+    $vf = (array)$viewform;
+    if (isset($vf['savesettings'])) {
+        $action = 'savesettings';
+        unset($vf['savesettings']);
+    }
+    $scorecalculation = array();
+    $submittedvf = array();
+    foreach ($vf as $qs) {
+        $sectionqid = explode("_", $qs);
+        if ($sectionqid[0] != 0) {
+            $scorecalculation[$sectionqid[0]][$sectionqid[1]] = null;
+            $submittedvf[$sectionqid[1]] = $sectionqid[0];
+        }
+    }
+    $c = count($scorecalculation);
+    if ($c < $feedbacksections) {
+        $sectionsnotset = '';
+        for ($section = 1; $section <= $feedbacksections; $section++) {
+            if (!isset($scorecalculation[$section])) {
+                $sectionsnotset .= $section.'&nbsp;';
+            }
+        }
+        $errormsg = get_string('sectionsnotset', 'questionnaire', $sectionsnotset);
+        $vf = $submittedvf;
+    } else {
+        for ($section = 1; $section <= $feedbacksections; $section++) {
+            $fbcalculation[$section] = serialize($scorecalculation[$section]);
+        }
+
+        $sections = $DB->get_records('questionnaire_fb_sections',
+            array('survey_id' => $questionnaire->survey->id), 'section DESC');
+        // Delete former feedbacks if number of feedbacksections has been reduced.
+        foreach ($sections as $section) {
+            if ($section->section > $feedbacksections) {
+                // Delete section record.
+                $DB->delete_records('questionnaire_fb_sections', array('survey_id' => $sid, 'section' => $section->section));
+                // Delete associated feedback records.
+                $DB->delete_records('questionnaire_feedback', array('section_id' => $section->section));
+            }
+        }
+
+        // Check if the number of feedback sections has been increased and insert new ones
+        // must also insert section heading!
+        for ($section = 1; $section <= $feedbacksections; $section++) {
+            if ($existsection = $DB->get_record('questionnaire_fb_sections',
+                        array('survey_id' => $sid, 'section' => $section), '*', IGNORE_MULTIPLE) ) {
+                $DB->set_field('questionnaire_fb_sections', 'scorecalculation', serialize($scorecalculation[$section]),
+                        array('survey_id' => $sid, 'section' => $section));
+            } else {
+                $feedbacksection = new stdClass();
+                $feedbacksection->survey_id = $sid;
+                $feedbacksection->section = $section;
+                $feedbacksection->scorecalculation = serialize($scorecalculation[$section]);
+                $feedbacksection->id = $DB->insert_record('questionnaire_fb_sections', $feedbacksection);
+            }
+        }
+
+        $currentsection = 1;
+        $SESSION->questionnaire->currentfbsection = 1;
+        redirect ($CFG->wwwroot.'/mod/questionnaire/fbsettings.php?id='.
+            $questionnaire->cm->id.'&currentsection='.$currentsection, '', 0);
+    }
+}
+
+$PAGE->set_url($url);
+// Print the page header.
+$PAGE->set_title(get_string('feedbackeditingsections', 'questionnaire'));
+$PAGE->set_heading(format_string($course->fullname));
+$PAGE->navbar->add(get_string('feedbackeditingsections', 'questionnaire'));
+
+// Add renderer and page objects to the questionnaire object for display use.
+$questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+$questionnaire->add_page(new \mod_questionnaire\output\fbsectionspage());
+
+$feedbacksections = $questionnaire->survey->feedbacksections + 1;
+
+if ($errormsg != '') {
+    $questionnaire->page->add_to_page('notifications', $questionnaire->renderer->notification($errormsg));
+}
+$n = 0;
+$bg = 'c0';
+
+$questionnaire->page->add_to_page('formarea', $questionnaire->renderer->box_start());
+
+$questionnaire->page->add_to_page('formarea', $questionnaire->renderer->help_icon('feedbacksectionsselect', 'questionnaire'));
+$questionnaire->page->add_to_page('formarea', '<b>Sections:</b><br /><br />');
+$formdata = new stdClass();
+$descendantsdata = array();
+
+foreach ($questionnaire->questions as $question) {
+    $qtype = $question->type_id;
+    $qname = $question->name;
+    $qprecise = $question->precise;
+    $required = $question->required;
+    $qid = $question->id;
+
+    // Questions to be included in feedback sections must be required, have a name
+    // and must not be child of a parent question.
+    if ($qtype != QUESPAGEBREAK && $qtype != QUESSECTIONTEXT) {
+        $n++;
+    }
+
+    $cannotuse = false;
+    $strcannotuse = '';
+    if ($qtype != QUESSECTIONTEXT && $qtype != QUESPAGEBREAK
+                    && ($qtype != QUESYESNO && $qtype != QUESRADIO && $qtype != QUESRATE
+                    || $required != 'y' || $qname == '' || $question->dependquestion != 0)) {
+        $cannotuse = true;
+        $qn = '<strong>'.$n.'</strong>';
+        if ($qname == '') {
+            $strcannotuse = get_string('missingname', 'questionnaire', $qn);
+        }
+        if ($required != 'y') {
+            if ($qname == '') {
+                $strcannotuse = get_string('missingnameandrequired', 'questionnaire', $qn);
+            } else {
+                $strcannotuse = get_string('missingrequired', 'questionnaire', $qn);
+            }
+        }
+        if ($question->dependquestion != 0) {
+            continue;
+        }
+    }
+
+    $qhasvalues = false;
+    if (!$cannotuse) {
+        if ($qtype == QUESRADIO || $qtype == QUESDROP) {
+            if ($choices = $DB->get_records('questionnaire_quest_choice', array('question_id' => $qid = $question->id))) {
+                foreach ($choices as $choice) {
+                    if ($choice->value != null) {
+                        $qhasvalues = true;
+                        break;
+                    }
+                }
+            }
+        }
+
+        // Valid questions in feedback sections can be of QUESNO type
+        // or of QUESRATE "normal" option type (i.e. not N/A nor nodupes).
+        if ($qtype == QUESYESNO || ($qtype == QUESRATE && ($qprecise == 0 || $qprecise == 3)) ) {
+            $qhasvalues = true;
+        }
+
+        if ($qhasvalues) {
+            $emptyisglobalfeedback = $questionnaire->survey->feedbacksections == 1 && empty($questionsinsections);
+            $questionnaire->page->add_to_page('formarea', '<div style="margin-bottom:5px;">['.$qname.']</div>');
+            for ($i = 0; $i < $feedbacksections; $i++) {
+                $output = '<div style="float:left; padding-right:5px;">';
+                if ($i != 0) {
+                    $output .= '<div class="'.$bg.'"><input type="radio" name="'.$n.'" id="'.$qid.'_'.$i.'" value="'.$i.'_'.
+                        $qid.'"';
+                } else {
+                    $output .= '<div class="'.$bg.'"><input type="radio" name="'.$n.'" id="'.$i.'" value="'.$i.'"';
+                }
+                if ($i == 0) {
+                    $output .= ' checked="checked"';
+                }
+                // Question already present in this section OR this is a Global feedback and questions are not set yet.
+                if ((isset($vf[$qid]) && $vf[$qid] == $i) || $emptyisglobalfeedback) {
+                    $output .= ' checked="checked"';
+                }
+                $output .= ' />';
+                $output .= '<label for="'.$qid.'_'.$i.'">'.'<div style="padding-left: 2px;">'.$i.'</div>'.'</label></div></div>';
+                $questionnaire->page->add_to_page('formarea', $output);
+                if ($bg == 'c0') {
+                    $bg = 'c1';
+                } else {
+                    $bg = 'c0';
+                }
+            }
+        }
+        if ($qhasvalues || $qtype == QUESSECTIONTEXT) {
+            $questionnaire->page->add_to_page('formarea',
+                $questionnaire->renderer->question_output($question, $formdata, '', $n, true));
+        }
+    } else {
+        $questionnaire->page->add_to_page('formarea', '<div class="notifyproblem">');
+        $questionnaire->page->add_to_page('formarea', $strcannotuse);
+        $questionnaire->page->add_to_page('formarea', '</div>');
+        $questionnaire->page->add_to_page('formarea', '<div class="qn-question">'.$question->content.'</div>');
+    }
+}
+// Submit/Cancel buttons.
+$url = $CFG->wwwroot.'/mod/questionnaire/view.php?id='.$cm->id;
+$questionnaire->page->add_to_page('formarea', '<div><input type="submit" name="savesettings" value="'.
+    get_string('feedbackeditmessages', 'questionnaire').'" /><a href="'.$url.'">'.get_string('cancel').'</a></div>');
+$questionnaire->page->add_to_page('formarea', $questionnaire->renderer->box_end());
+echo $questionnaire->renderer->header();
+echo $questionnaire->renderer->render($questionnaire->page);
+echo $questionnaire->renderer->footer($course);
\ No newline at end of file
diff --git a/mod/questionnaire/fbsettings.php b/mod/questionnaire/fbsettings.php
new file mode 100644
index 0000000..879282c
--- /dev/null
+++ b/mod/questionnaire/fbsettings.php
@@ -0,0 +1,153 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+$id = required_param('id', PARAM_INT); // Course module ID.
+$currentsection   = $SESSION->questionnaire->currentfbsection;
+if (! $cm = get_coursemodule_from_id('questionnaire', $id)) {
+    print_error('invalidcoursemodule');
+}
+
+if (! $course = $DB->get_record("course", array("id" => $cm->course))) {
+    print_error('coursemisconf');
+}
+
+if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $cm->instance))) {
+    print_error('invalidcoursemodule');
+}
+
+require_course_login($course, true, $cm);
+$context = context_module::instance($cm->id);
+require_once($CFG->dirroot.'/mod/questionnaire/lib.php');
+
+$url = new moodle_url($CFG->wwwroot.'/mod/questionnaire/fbsettings.php', array('id' => $id));
+$PAGE->set_url($url);
+$PAGE->set_context($context);
+
+$questionnaire = new questionnaire(0, $questionnaire, $course, $cm);
+
+if (!$questionnaire->capabilities->manage) {
+    print_error('nopermissions', 'error', 'mod:questionnaire:manage');
+}
+$sid = $questionnaire->survey->id;
+
+$sdata = clone($questionnaire->survey);
+$sdata->sid = $sid;
+$sdata->id = $cm->id;
+
+$feedbacksections = $questionnaire->survey->feedbacksections;
+
+// Get the current section heading.
+$sectionid = null;
+$scorecalculation = null;
+if ($section = $DB->get_record('questionnaire_fb_sections',
+        array('survey_id' => $sid, 'section' => $currentsection))) {
+    $sectionid = $section->id;
+    $sectionheading = $section->sectionheading;
+    $scorecalculation = $section->scorecalculation;
+    $draftideditor = file_get_submitted_draft_itemid('sectionheading');
+    $currentinfo = file_prepare_draft_area($draftideditor, $context->id, 'mod_questionnaire', 'sectionheading',
+            $sectionid, array('subdirs' => true), $sectionheading);
+    $sdata->sectionlabel = $section->sectionlabel;
+    $sdata->sectionheading = array('text' => $currentinfo, 'format' => FORMAT_HTML, 'itemid' => $draftideditor);
+}
+
+$feedbackform = new mod_questionnaire_feedback_form( null, array('currentsection' => $currentsection, 'sectionid' => $sectionid) );
+$feedbackform->set_data($sdata);
+if ($feedbackform->is_cancelled()) {
+    // Redirect to view questionnaire page.
+    redirect($CFG->wwwroot.'/mod/questionnaire/view.php?id='.$questionnaire->cm->id);
+}
+if ($settings = $feedbackform->get_data()) {
+    $i = 0;
+    while (!empty($settings->feedbackboundaries[$i])) {
+        $boundary = trim($settings->feedbackboundaries[$i]);
+        if (strlen($boundary) > 0 && $boundary[strlen($boundary) - 1] == '%') {
+            $boundary = trim(substr($boundary, 0, -1));
+        }
+        $settings->feedbackboundaries[$i] = $boundary;
+        $i += 1;
+    }
+    $numboundaries = $i;
+    $settings->feedbackboundaries[-1] = 101;
+    $settings->feedbackboundaries[$numboundaries] = 0;
+    $settings->feedbackboundarycount = $numboundaries;
+
+    // Save current section.
+    $section = new stdClass();
+    $section->survey_id = $settings->sid;
+    $section->section = $currentsection;
+    $section->scorecalculation = $scorecalculation;
+    $section->sectionlabel = $settings->sectionlabel;
+    $section->sectionheading = '';
+    $section->sectionheadingformat = $settings->sectionheading['format'];
+
+    // Check if we are updating an existing section record or creating a new one.
+    if ($existsection = $DB->get_record('questionnaire_fb_sections',
+            array('survey_id' => $sid, 'section' => $currentsection) ) ) {
+        $section->id = $existsection->id;
+    } else {
+        $section->id = $DB->insert_record('questionnaire_fb_sections', $section);
+    }
+    $sectionheading = file_save_draft_area_files((int)$settings->sectionheading['itemid'],
+            $context->id, 'mod_questionnaire', 'sectionheading', $section->id,
+            array('subdirs' => false, 'maxfiles' => -1, 'maxbytes' => 0),
+            $settings->sectionheading['text']);
+    $DB->set_field('questionnaire_fb_sections', 'sectionheading', $sectionheading,
+            array('id' => $section->id));
+    $DB->set_field('questionnaire_fb_sections', 'sectionlabel', $settings->sectionlabel,
+            array('id' => $section->id));
+
+    // Save current section's feedbacks
+    // first delete all existing feedbacks for this section - if any
+    // because we never know whether editing feedbacks will have more or less texts, so it's easiest to delete all and stard afresh.
+    $DB->delete_records('questionnaire_feedback', array('section_id' => $section->id));
+    for ($i = 0; $i <= $settings->feedbackboundarycount; $i++) {
+        $feedback = new stdClass();
+        $feedback->section_id = $section->id;
+        if (isset($settings->feedbacklabel[$i])) {
+            $feedback->feedbacklabel = $settings->feedbacklabel[$i];
+        }
+        $feedback->feedbacktext = '';
+        $feedback->feedbacktextformat = $settings->feedbacktext[$i]['format'];
+        $feedback->minscore = $settings->feedbackboundaries[$i];
+        $feedback->maxscore = $settings->feedbackboundaries[$i - 1];
+        $feedback->id = $DB->insert_record('questionnaire_feedback', $feedback);
+
+        $feedbacktext = file_save_draft_area_files((int)$settings->feedbacktext[$i]['itemid'],
+                $context->id, 'mod_questionnaire', 'feedback', $feedback->id,
+                array('subdirs' => false, 'maxfiles' => -1, 'maxbytes' => 0),
+                $settings->feedbacktext[$i]['text']);
+        $DB->set_field('questionnaire_feedback', 'feedbacktext', $feedbacktext,
+                array('id' => $feedback->id));
+    }
+}
+if (isset($settings->savesettings)) {
+    redirect ($CFG->wwwroot.'/mod/questionnaire/view.php?id='.$questionnaire->cm->id, '', 0);
+} else if (isset($settings->submitbutton)) {
+    $SESSION->questionnaire->currentfbsection ++;
+    redirect ($CFG->wwwroot.'/mod/questionnaire/fbsettings.php?id='.$questionnaire->cm->id, '', 0);
+}
+
+// Print the page header.
+    $PAGE->set_title(get_string('feedbackeditingmessages', 'questionnaire'));
+    $PAGE->set_heading(format_string($course->fullname));
+    $PAGE->navbar->add(get_string('feedbackeditingmessages', 'questionnaire'));
+    echo $OUTPUT->header();
+    $feedbackform->display();
+    echo $OUTPUT->footer($course);
diff --git a/mod/questionnaire/grade.php b/mod/questionnaire/grade.php
new file mode 100644
index 0000000..4ea4a2b
--- /dev/null
+++ b/mod/questionnaire/grade.php
@@ -0,0 +1,44 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Redirects the user to either a questionnaire or to the questionnaire report
+ *
+ * @package   mod_questionnaire
+ * @copyright 2013 onwards Joseph Rézeau  email moodle@rezeau.org
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ **/
+
+/**
+ * Require config.php
+ */
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+$id = required_param('id', PARAM_INT);
+$cm = get_coursemodule_from_id('questionnaire', $id, 0, false, MUST_EXIST);
+if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $cm->instance))) {
+    print_error('invalidcoursemodule');
+}
+$course = $DB->get_record('course', array('id' => $cm->course), '*', MUST_EXIST);
+require_login($course, false, $cm);
+$PAGE->set_url('/mod/questionnaire/grade.php', array('id' => $cm->id));
+
+if (has_capability('mod/questionnaire:readallresponseanytime', context_module::instance($cm->id))) {
+    redirect('report.php?instance='.$questionnaire->id);
+} else {
+    redirect('view.php?id='.$cm->id);
+}
diff --git a/mod/questionnaire/images/hbar.gif b/mod/questionnaire/images/hbar.gif
new file mode 100644
index 0000000000000000000000000000000000000000..ee073d8e5fd7048be5902298bc3280bb5aa37965
GIT binary patch
literal 64
zcmZ?wbhEHbWMtrESj51PmiFJ?9*8d4+aLeO$ix5xia%LcL>T@v=zs)3Y8jYWIRwra
IaWYr~0QznX00000

literal 0
HcmV?d00001

diff --git a/mod/questionnaire/images/hbar_l.gif b/mod/questionnaire/images/hbar_l.gif
new file mode 100644
index 0000000000000000000000000000000000000000..605ee6d06ec024fa24d08021ca84be3e7068b4de
GIT binary patch
literal 155
zcmZ?wbhEHbWMSZBIKsg2|Ns9_pZ@IF@qgyb|2;kbTU!1%HGQqBdRtidKP~Nlc=+Go
z;Ge#}-`(Bc+1vkjbbM)Ve~W<>p!k!8RRpL(2c!vPCj+a5f`UM+fe6P-ix*ug*^Ab2
PZ<adync+BdD}yxvilr`c

literal 0
HcmV?d00001

diff --git a/mod/questionnaire/images/hbar_r.gif b/mod/questionnaire/images/hbar_r.gif
new file mode 100644
index 0000000000000000000000000000000000000000..790af3b179c12209e3d0b60038b5cc450afbf727
GIT binary patch
literal 105
zcmZ?wbhEHbWMSZB*v!E2|NsA%mhaWo@5;;frltK45C0bs@YBody}kW^2Zty2_Sfz0
zPukm`wYT46Z@<OfezD?D7FH1k1_m7<W&oMNz#=wb3PYDA)50kwL9-5JcrP~f`^ocy
I!G*yZ0LNS=>i_@%

literal 0
HcmV?d00001

diff --git a/mod/questionnaire/images/print.gif b/mod/questionnaire/images/print.gif
new file mode 100644
index 0000000000000000000000000000000000000000..9180ca1060fa9b2e67633314d7adca81ad0243c4
GIT binary patch
literal 905
zcmZ?wbhEHb6ky<I_|5<V4Pe{=rW$~}hK2(`aOc316CZ#wqhK@yhI9!0|NUXXf+Y<N
z4gZ1O_|NbkOaW;i3kVc{vT!mma5CtC{0Pbu3>;|;!W<$T3l=ywGqW>o_`ZIjb2WpI
z(4TSv2G>qbF{?Wgfs2lIi3kd%?AWN-z|0`vvL-@M^;8oF--$VvpO^Sfv*2H0<N2AP
nWxi2v+MCLR`4<<k8b7k>@K-%J!zIuvbcc!NvDHG%Obpfl;@wCb

literal 0
HcmV?d00001

diff --git a/mod/questionnaire/images/thbar.gif b/mod/questionnaire/images/thbar.gif
new file mode 100644
index 0000000000000000000000000000000000000000..31ce43abe118caeac065de97d8f76587918f6bd7
GIT binary patch
literal 89
zcmZ?wbhEHbWMtrE*v!E2KU4jGiv0fo=2LbI`>Yt|7%<=mia%Kx85md@bU?~LW-zd@
N39vZ6R1jpa1_0*{45I)5

literal 0
HcmV?d00001

diff --git a/mod/questionnaire/images/thbar_l.gif b/mod/questionnaire/images/thbar_l.gif
new file mode 100644
index 0000000000000000000000000000000000000000..30205cdc39edccd67bcea7af9dda7e5826638269
GIT binary patch
literal 840
zcmZ?wbhEHbWMSZB_|Cxaf7k5)8+!jw&-~xy{lCiof3fNREY1I^ivQy!{|7Mt&(Z!L
z#tmX5N`LZVc;U`)#gSnYjE2Cl2?52QEQ}z}=zs`No?zfmWnkn`aBw)#z{JX-=Fw2F
cu#uTtP$6PR!$BujJ~<nP3lA7u8W<R?0a{imwg3PC

literal 0
HcmV?d00001

diff --git a/mod/questionnaire/images/thbar_r.gif b/mod/questionnaire/images/thbar_r.gif
new file mode 100644
index 0000000000000000000000000000000000000000..e12c8deb25d6a15042a8efe1a547b7f87a2d45bd
GIT binary patch
literal 105
zcmZ?wbhEHbWMSZB*v!E2e?#y8mCgU-CI1I7|IgR|AI$zgN%osJ!vj}_3l0p&Y#9z%
zGu(4w*kH!6%$Q-4E`#Dv7Dfgj&;b!3GZ<LJ0z{ae7$z%B2|U#~N!Rz9#goHxd;}O7
FtO1LCA-(_r

literal 0
HcmV?d00001

diff --git a/mod/questionnaire/index.php b/mod/questionnaire/index.php
new file mode 100644
index 0000000..8b7d911
--- /dev/null
+++ b/mod/questionnaire/index.php
@@ -0,0 +1,215 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This script lists all the instances of questionnaire in a particular course
+ *
+ * @package    mod
+ * @subpackage questionnaire
+ * @copyright  1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+$id = required_param('id', PARAM_INT);
+$PAGE->set_url('/mod/questionnaire/index.php', array('id' => $id));
+if (! $course = $DB->get_record('course', array('id' => $id))) {
+    print_error('incorrectcourseid', 'questionnaire');
+}
+$coursecontext = context_course::instance($id);
+require_login($course->id);
+$PAGE->set_pagelayout('incourse');
+
+$event = \mod_questionnaire\event\course_module_instance_list_viewed::create(array(
+                'context' => context_course::instance($course->id)));
+$event->trigger();
+
+// Print the header.
+$strquestionnaires = get_string("modulenameplural", "questionnaire");
+$PAGE->navbar->add($strquestionnaires);
+$PAGE->set_title("$course->shortname: $strquestionnaires");
+$PAGE->set_heading(format_string($course->fullname));
+echo $OUTPUT->header();
+
+// Get all the appropriate data.
+if (!$questionnaires = get_all_instances_in_course("questionnaire", $course)) {
+    notice(get_string('thereareno', 'moodle', $strquestionnaires), "../../course/view.php?id=$course->id");
+    die;
+}
+
+// Check if we need the closing date header.
+$showclosingheader = false;
+foreach ($questionnaires as $questionnaire) {
+    if ($questionnaire->closedate != 0) {
+        $showclosingheader = true;
+    }
+    if ($showclosingheader) {
+        break;
+    }
+}
+
+// Configure table for displaying the list of instances.
+$headings = array(get_string('name'));
+$align = array('left');
+
+if ($showclosingheader) {
+    array_push($headings, get_string('questionnairecloses', 'questionnaire'));
+    array_push($align, 'left');
+}
+
+array_unshift($headings, get_string('sectionname', 'format_'.$course->format));
+array_unshift($align, 'left');
+
+$showing = '';
+
+// Current user role == admin or teacher.
+if (has_capability('mod/questionnaire:viewsingleresponse', $coursecontext)) {
+    array_push($headings, get_string('responses', 'questionnaire'));
+    array_push($align, 'center');
+    $showing = 'stats';
+    array_push($headings, get_string('realm', 'questionnaire'));
+    array_push($align, 'left');
+    // Current user role == student.
+} else if (has_capability('mod/questionnaire:submit', $coursecontext)) {
+    array_push($headings, get_string('status'));
+    array_push($align, 'left');
+    $showing = 'responses';
+}
+
+$table = new html_table();
+$table->head = $headings;
+$table->align = $align;
+
+// Populate the table with the list of instances.
+$currentsection = '';
+foreach ($questionnaires as $questionnaire) {
+    $cmid = $questionnaire->coursemodule;
+    $data = array();
+    $realm = $DB->get_field('questionnaire_survey', 'realm', array('id' => $questionnaire->sid));
+    // Template surveys should NOT be displayed as an activity to students.
+    if (!($realm == 'template' && !has_capability('mod/questionnaire:manage', context_module::instance($cmid)))) {
+        // Section number if necessary.
+        $strsection = '';
+        if ($questionnaire->section != $currentsection) {
+            $strsection = get_section_name($course, $questionnaire->section);
+            $currentsection = $questionnaire->section;
+        }
+        $data[] = $strsection;
+        // Show normal if the mod is visible.
+        $class = '';
+        if (!$questionnaire->visible) {
+            $class = ' class="dimmed"';
+        }
+        $data[] = "<a$class href=\"view.php?id=$cmid\">$questionnaire->name</a>";
+
+        // Close date.
+        if ($questionnaire->closedate) {
+            $data[] = userdate($questionnaire->closedate);
+        } else if ($showclosingheader) {
+            $data[] = '';
+        }
+
+        if ($showing == 'responses') {
+            $status = '';
+            if ($responses = questionnaire_get_user_responses($questionnaire->sid, $USER->id, $complete = false)) {
+                foreach ($responses as $response) {
+                    if ($response->complete == 'y') {
+                        $status .= get_string('submitted', 'questionnaire').' '.userdate($response->submitted).'<br />';
+                    } else {
+                        $status .= get_string('attemptstillinprogress', 'questionnaire').' '.
+                            userdate($response->submitted).'<br />';
+                    }
+                }
+            }
+            $data[] = $status;
+        } else if ($showing == 'stats') {
+            $data[] = $DB->count_records('questionnaire_response', array('survey_id' => $questionnaire->sid, 'complete' => 'y'));
+            if ($survey = $DB->get_record('questionnaire_survey', array('id' => $questionnaire->sid))) {
+                // For a public questionnaire, look for the original public questionnaire that it is based on.
+                if ($survey->realm == 'public') {
+                    $strpreview = get_string('preview_questionnaire', 'questionnaire');
+                    if ($survey->courseid != $course->id) {
+                        $publicoriginal = '';
+                        $originalcourse = $DB->get_record('course', ['id' => $survey->courseid]);
+                        $originalcoursecontext = context_course::instance($survey->courseid);
+                        $originalquestionnaire = $DB->get_record('questionnaire',
+                            ['sid' => $survey->id, 'course' => $survey->courseid]);
+                        $cm = get_coursemodule_from_instance("questionnaire", $originalquestionnaire->id, $survey->courseid);
+                        $context = context_course::instance($survey->courseid, MUST_EXIST);
+                        $canvieworiginal = has_capability('mod/questionnaire:preview', $context, $USER->id, true);
+                        // If current user can view questionnaires in original course,
+                        // provide a link to the original public questionnaire.
+                        if ($canvieworiginal) {
+                            $publicoriginal = '<br />'.get_string('publicoriginal', 'questionnaire').'&nbsp;'.
+                                '<a href="'.$CFG->wwwroot.'/mod/questionnaire/preview.php?id='.
+                                $cm->id.'" title="'.$strpreview.']">'.$originalquestionnaire->name.' ['.
+                                $originalcourse->fullname.']</a>';
+                        } else {
+                            // If current user is not enrolled as teacher in original course,
+                            // only display the original public questionnaire's name and course name.
+                            $publicoriginal = '<br />'.get_string('publicoriginal', 'questionnaire').'&nbsp;'.
+                                $originalquestionnaire->name.' ['.$originalcourse->fullname.']';
+                        }
+                        $data[] = get_string($realm, 'questionnaire').' '.$publicoriginal;
+                    } else {
+                        // Original public questionnaire was created in current course.
+                        // Find which courses it is used in.
+                        $publiccopy = '';
+                        $select = 'course != '.$course->id.' AND sid = '.$questionnaire->sid;
+                        if ($copies = $DB->get_records_select('questionnaire', $select, null,
+                                $sort = 'course ASC', $fields = 'id, course, name')) {
+                            foreach ($copies as $copy) {
+                                $copycourse = $DB->get_record('course', array('id' => $copy->course));
+                                $select = 'course = '.$copycourse->id.' AND sid = '.$questionnaire->sid;
+                                $copyquestionnaire = $DB->get_record('questionnaire',
+                                    array('id' => $copy->id, 'sid' => $survey->id, 'course' => $copycourse->id));
+                                $cm = get_coursemodule_from_instance("questionnaire", $copyquestionnaire->id, $copycourse->id);
+                                $context = context_course::instance($copycourse->id, MUST_EXIST);
+                                $canviewcopy = has_capability('mod/questionnaire:view', $context, $USER->id, true);
+                                if ($canviewcopy) {
+                                    $publiccopy .= '<br />'.get_string('publiccopy', 'questionnaire').'&nbsp;:&nbsp;'.
+                                        '<a href = "'.$CFG->wwwroot.'/mod/questionnaire/preview.php?id='.
+                                        $cm->id.'" title = "'.$strpreview.'">'.
+                                        $copyquestionnaire->name.' ['.$copycourse->fullname.']</a>';
+                                } else {
+                                    // If current user does not have "view" capability in copy course,
+                                    // only display the copied public questionnaire's name and course name.
+                                    $publiccopy .= '<br />'.get_string('publiccopy', 'questionnaire').'&nbsp;:&nbsp;'.
+                                        $copyquestionnaire->name.' ['.$copycourse->fullname.']';
+                                }
+                            }
+                        }
+                        $data[] = get_string($realm, 'questionnaire').' '.$publiccopy;
+                    }
+                } else {
+                    $data[] = get_string($realm, 'questionnaire');
+                }
+            } else {
+                // If a questionnaire is a copy of a public questionnaire which has been deleted.
+                $data[] = get_string('removenotinuse', 'questionnaire');
+            }
+        }
+    }
+    $table->data[] = $data;
+} // End of loop over questionnaire instances.
+
+echo html_writer::table($table);
+
+// Finish the page.
+echo $OUTPUT->footer();
\ No newline at end of file
diff --git a/mod/questionnaire/javascript/RGraph/RGraph.bar.js b/mod/questionnaire/javascript/RGraph/RGraph.bar.js
new file mode 100644
index 0000000..9bf02ff
--- /dev/null
+++ b/mod/questionnaire/javascript/RGraph/RGraph.bar.js
@@ -0,0 +1,2721 @@
+    /**
+    * o-------------------------------------------------------------------------------o
+    * | This file is part of the RGraph package. RGraph is Free software, licensed    |
+    * | under the MIT license - so it's free to use for all purposes. Extended        |
+    * | support is available if required and donations are always welcome! You can    |
+    * | read more here:                                                               |
+    * |                         http://www.rgraph.net/support                         |
+    * o-------------------------------------------------------------------------------o
+    */
+    
+    if (typeof(RGraph) == 'undefined') RGraph = {};
+
+    /**
+    * The bar chart constructor
+    * 
+    * @param object canvas The canvas object
+    * @param array  data   The chart data
+    */
+    RGraph.Bar = function (id, data)
+    {
+        // Get the canvas and context objects
+        this.id                = id;
+        this.canvas            = document.getElementById(typeof id === 'object' ? id.id : id);
+        this.context           = this.canvas.getContext ? this.canvas.getContext("2d") : null;
+        this.canvas.__object__ = this;
+        this.type              = 'bar';
+        this.max               = 0;
+        this.stackedOrGrouped  = false;
+        this.isRGraph          = true;
+        this.uid               = RGraph.CreateUID();
+        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();
+        this.colorsParsed      = false;
+        this.original_colors   = [];
+
+
+        /**
+        * Compatibility with older browsers
+        */
+        RGraph.OldBrowserCompat(this.context);
+
+
+        // Various config type stuff
+        this.properties = {
+            'chart.background.barcolor1':   'rgba(0,0,0,0)',
+            'chart.background.barcolor2':   'rgba(0,0,0,0)',
+            'chart.background.grid':        true,
+            'chart.background.grid.color':  '#ddd',
+            'chart.background.grid.width':  1,
+            'chart.background.grid.hsize':  20,
+            'chart.background.grid.vsize':  20,
+            'chart.background.grid.vlines': true,
+            'chart.background.grid.hlines': true,
+            'chart.background.grid.border': true,
+            'chart.background.grid.autofit':true,
+            'chart.background.grid.autofit.numhlines': 5,
+            'chart.background.grid.autofit.numvlines': 20,
+            'chart.background.grid.dashed': false,
+            'chart.background.grid.dotted': false,
+            'chart.background.image.stretch': true,
+            'chart.background.image.x':     null,
+            'chart.background.image.y':     null,
+            'chart.background.image.w':     null,
+            'chart.background.image.h':     null,
+            'chart.background.image.align': null,
+            'chart.numyticks':              10,
+            'chart.hmargin':                5,
+            'chart.hmargin.grouped':        1,
+            'chart.strokecolor':            'rgba(0,0,0,0)',
+            'chart.axis.color':             'black',
+            'chart.axis.linewidth':         1,
+            'chart.gutter.top':             25,
+            'chart.gutter.bottom':          25,
+            'chart.gutter.left':            25,
+            'chart.gutter.right':           25,
+            'chart.labels':                 null,
+            'chart.labels.ingraph':         null,
+            'chart.labels.above':           false,
+            'chart.labels.above.decimals':  0,
+            'chart.labels.above.size':      null,
+            'chart.labels.above.color':     null,
+            'chart.labels.above.angle':     null,
+            'chart.ylabels':                true,
+            'chart.ylabels.count':          5,
+            'chart.ylabels.inside':         false,
+            'chart.xlabels.offset':         0,
+            'chart.xaxispos':               'bottom',
+            'chart.yaxispos':               'left',
+            'chart.text.angle':             0,
+            'chart.text.color':             'black', // Gradients aren't supported for this color
+            'chart.text.size':              10,
+            'chart.text.font':              'Arial',
+            'chart.ymin':                   0,
+            'chart.ymax':                   null,
+            'chart.title':                  '',
+            'chart.title.font':             null,
+            'chart.title.background':       null, // Gradients aren't supported for this color
+            'chart.title.hpos':             null,
+            'chart.title.vpos':             null,
+            'chart.title.bold':             true,
+            'chart.title.xaxis':            '',
+            'chart.title.xaxis.bold':       true,
+            'chart.title.xaxis.size':       null,
+            'chart.title.xaxis.font':       null,
+            'chart.title.yaxis':            '',
+            'chart.title.yaxis.bold':       true,
+            'chart.title.yaxis.size':       null,
+            'chart.title.yaxis.font':       null,
+            'chart.title.yaxis.color':      null, // Gradients aren't supported for this color
+            'chart.title.xaxis.pos':        null,
+            'chart.title.yaxis.pos':        null,
+            'chart.title.yaxis.x':          null,
+            'chart.title.yaxis.y':          null,
+            'chart.title.xaxis.x':          null,
+            'chart.title.xaxis.y':          null,
+            'chart.title.x':                null,
+            'chart.title.y':                null,
+            'chart.title.halign':           null,
+            'chart.title.valign':           null,            
+            'chart.colors':                 ['#01B4FF', '#0f0', '#00f', '#ff0', '#0ff', '#0f0'],
+            'chart.colors.sequential':      false,
+            'chart.colors.reverse':         false,
+            'chart.grouping':               'grouped',
+            'chart.variant':                'bar',
+            'chart.variant.sketch.verticals': true,
+            'chart.shadow':                 false,
+            'chart.shadow.color':           '#999',  // Gradients aren't supported for this color
+            'chart.shadow.offsetx':         3,
+            'chart.shadow.offsety':         3,
+            'chart.shadow.blur':            3,
+            'chart.tooltips':               null,
+            'chart.tooltips.effect':        'fade',
+            'chart.tooltips.css.class':     'RGraph_tooltip',
+            'chart.tooltips.event':         'onclick',
+            'chart.tooltips.highlight':     true,
+            'chart.highlight.stroke':       'rgba(0,0,0,0)',
+            'chart.highlight.fill':         'rgba(255,255,255,0.7)',
+            'chart.background.hbars':       null,
+            'chart.key':                    null,
+            'chart.key.background':         'white',
+            'chart.key.position':           'graph',
+            'chart.key.shadow':             false,
+            'chart.key.shadow.color':       '#666',
+            'chart.key.shadow.blur':        3,
+            'chart.key.shadow.offsetx':     2,
+            'chart.key.shadow.offsety':     2,
+            'chart.key.position.gutter.boxed':false,
+            'chart.key.position.x':         null,
+            'chart.key.position.y':         null,
+            'chart.key.interactive':        false,
+            'chart.key.interactive.highlight.chart.stroke':'black',
+            'chart.key.interactive.highlight.chart.fill':'rgba(255,255,255,0.7)',
+            'chart.key.interactive.highlight.label':'rgba(255,0,0,0.2)',
+            'chart.key.halign':             'right',
+            'chart.key.color.shape':        'square',
+            'chart.key.rounded':            true,
+            'chart.key.text.size':          10,
+            'chart.key.linewidth':          1,
+            'chart.key.colors':             null,
+            'chart.key.text.color':         'black',
+            'chart.contextmenu':            null,
+            'chart.units.pre':              '',
+            'chart.units.post':             '',
+            'chart.scale.decimals':         0,
+            'chart.scale.point':            '.',
+            'chart.scale.thousand':         ',',
+            'chart.crosshairs':             false,
+            'chart.crosshairs.color':       '#333',
+            'chart.crosshairs.hline':       true,
+            'chart.crosshairs.vline':       true,
+            'chart.linewidth':              1,
+            'chart.annotatable':            false,
+            'chart.annotate.color':         'black',
+            'chart.zoom.factor':            1.5,
+            'chart.zoom.fade.in':           true,
+            'chart.zoom.fade.out':          true,
+            'chart.zoom.hdir':              'right',
+            'chart.zoom.vdir':              'down',
+            'chart.zoom.frames':            25,
+            'chart.zoom.delay':             16.666,
+            'chart.zoom.shadow':            true,
+            'chart.zoom.background':        true,
+            'chart.resizable':              false,
+            'chart.resize.handle.background': null,
+            'chart.adjustable':             false,
+            'chart.noaxes':                 false,
+            'chart.noxaxis':                false,
+            'chart.noyaxis':                false,
+            'chart.events.click':           null,
+            'chart.events.mousemove':       null,
+            'chart.numxticks':              null,
+            'chart.bevel':                  false
+        }
+
+        // Check for support
+        if (!this.canvas) {
+            alert('[BAR] No canvas support');
+            return;
+        }
+
+        /**
+        * Determine whether the chart will contain stacked or grouped bars
+        */
+        for (var i=0; i<data.length; ++i) {
+            if (typeof(data[i]) == 'object' && !RGraph.is_null(data[i])) {
+                this.stackedOrGrouped = true;
+            }
+        }
+
+
+        /**
+        * Create the dollar objects so that functions can be added to them
+        */
+        var linear_data = RGraph.array_linearize(data);
+        for (var i=0; i<linear_data.length; ++i) {
+            this['$' + i] = {};
+        }
+
+
+        // Store the data
+        this.data = data;
+        
+        // Used to store the coords of the bars
+        this.coords     = [];
+        this.coords2    = [];
+        this.coordsText = [];
+
+
+
+        /**
+        * This linearises the data. Doing so can make it easier to pull
+        * out the appropriate data from tooltips
+        */
+        this.data_arr = RGraph.array_linearize(this.data);
+
+
+        /**
+        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen
+        * done already
+        */
+        if (!this.canvas.__rgraph_aa_translated__) {
+            this.context.translate(0.5,0.5);
+
+            this.canvas.__rgraph_aa_translated__ = true;
+        }
+
+
+
+
+        ///////////////////////////////// SHORT PROPERTIES /////////////////////////////////
+
+
+
+
+        var RG   = RGraph;
+        var ca   = this.canvas;
+        var co   = ca.getContext('2d');
+        var prop = this.properties;
+        //var $jq  = jQuery;
+
+
+
+
+        //////////////////////////////////// METHODS ///////////////////////////////////////
+
+
+
+
+        /**
+        * A setter
+        * 
+        * @param name  string The name of the property to set
+        * @param value mixed  The value of the property
+        */
+        this.Set = function (name, value)
+        {
+            name = name.toLowerCase();
+            
+            /**
+            * This should be done first - prepend the propertyy name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            if (name == 'chart.labels.abovebar') {
+                name = 'chart.labels.above';
+            }
+            
+            if (name == 'chart.strokestyle') {
+                name = 'chart.strokecolor';
+            }
+            
+            /**
+            * Check for xaxispos
+            */
+            if (name == 'chart.xaxispos' ) {
+                if (value != 'bottom' && value != 'center' && value != 'top') {
+                    alert('[BAR] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');
+                    value = 'center';
+                }
+                
+                if (value == 'top') {
+                    for (var i=0; i<this.data.length; ++i) {
+                        if (typeof(this.data[i]) == 'number' && this.data[i] > 0) {
+                            alert('[BAR] The data element with index ' + i + ' should be negative');
+                        }
+                    }
+                }
+            }
+            
+            /**
+            * lineWidth doesn't appear to like a zero setting
+            */
+            if (name.toLowerCase() == 'chart.linewidth' && value == 0) {
+                value = 0.0001;
+            }
+    
+            prop[name] = value;
+    
+            return this;
+        }
+
+
+
+
+        /**
+        * A getter
+        * 
+        * @param name  string The name of the property to get
+        */
+        this.Get = function (name)
+        {
+            /**
+            * This should be done first - prepend the property name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            return prop[name];
+        }
+
+
+
+
+        /**
+        * The function you call to draw the bar chart
+        */
+        this.Draw = function ()
+        {    
+            // MUST be the first thing done!
+            if (typeof(prop['chart.background.image']) == 'string') {
+                RG.DrawBackgroundImage(this);
+            }
+    
+            /**
+            * Fire the onbeforedraw event
+            */
+            RG.FireCustomEvent(this, 'onbeforedraw');
+    
+    
+    
+            /**
+            * Parse the colors. This allows for simple gradient syntax
+            */
+            if (!this.colorsParsed) {
+                this.parseColors();
+                
+                // Don't want to do this again
+                this.colorsParsed = true;
+            }
+    
+    
+            
+            /**
+            * This is new in May 2011 and facilitates indiviual gutter settings,
+            * eg chart.gutter.left
+            */
+            this.gutterLeft   = prop['chart.gutter.left'];
+            this.gutterRight  = prop['chart.gutter.right'];
+            this.gutterTop    = prop['chart.gutter.top'];
+            this.gutterBottom = prop['chart.gutter.bottom'];
+    
+            // Cache this in a class variable as it's used rather a lot
+    
+            /**
+            * Check for tooltips and alert the user that they're not supported with pyramid charts
+            */
+            if (   (prop['chart.variant'] == 'pyramid' || prop['chart.variant'] == 'dot')
+                && typeof(prop['chart.tooltips']) == 'object'
+                && prop['chart.tooltips']
+                && prop['chart.tooltips'].length > 0) {
+    
+                alert('[BAR] (' + this.id + ') Sorry, tooltips are not supported with dot or pyramid charts');
+            }
+    
+            /**
+            * Stop the coords arrays from growing uncontrollably
+            */
+            this.coords     = [];
+            this.coords2    = [];
+            this.coordsText = [];
+    
+            /**
+            * Work out a few things. They need to be here because they depend on things you can change before you
+            * call Draw() but after you instantiate the object
+            */
+            this.max            = 0;
+            this.grapharea      = ca.height - this.gutterTop - this.gutterBottom;
+            this.halfgrapharea  = this.grapharea / 2;
+            this.halfTextHeight = prop['chart.text.size'] / 2;
+    
+    
+            // Progressively Draw the chart
+            RG.background.Draw(this);
+    
+    
+    
+    
+            //If it's a sketch chart variant, draw the axes first
+            if (prop['chart.variant'] == 'sketch') {
+                this.DrawAxes();
+                this.Drawbars();
+            } else {
+                this.Drawbars();
+                this.DrawAxes();
+            }
+    
+            this.DrawLabels();
+            
+            
+            /**
+            * Draw the bevel if required
+            */
+            if (prop['chart.bevel'] || prop['chart.bevelled']) {
+                this.DrawBevel();
+            }
+    
+    
+            // Draw the key if necessary
+            if (prop['chart.key'] && prop['chart.key'].length) {
+                RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);
+            }
+            
+            
+            /**
+            * Setup the context menu if required
+            */
+            if (prop['chart.contextmenu']) {
+                RG.ShowContext(this);
+            }
+
+
+    
+    
+            /**
+            * Draw "in graph" labels
+            */
+            if (prop['chart.labels.ingraph']) {
+                RG.DrawInGraphLabels(this);
+            }
+    
+            
+            /**
+            * This function enables resizing
+            */
+            if (prop['chart.resizable']) {
+                RG.AllowResizing(this);
+            }
+    
+    
+            /**
+            * This installs the event listeners
+            */
+            RG.InstallEventListeners(this);
+    
+    
+            /**
+            * Fire the RGraph ondraw event
+            */
+            RG.FireCustomEvent(this, 'ondraw');
+            
+            return this;
+        }
+
+
+
+
+        /**
+        * Draws the charts axes
+        */
+        this.DrawAxes = function ()
+        {    
+            if (prop['chart.noaxes']) {
+                return;
+            }
+    
+            var xaxispos = prop['chart.xaxispos'];
+            var yaxispos = prop['chart.yaxispos'];
+            var isSketch = prop['chart.variant'] == 'sketch';
+    
+            co.beginPath();
+            co.strokeStyle = prop['chart.axis.color'];
+            co.lineWidth   = prop['chart.axis.linewidth'] + 0.001;
+    
+
+            if (ISSAFARI == -1) {
+                co.lineCap = 'square';
+            }
+    
+    
+            // Draw the Y axis
+            if (prop['chart.noyaxis'] == false) {
+                if (yaxispos == 'right') {
+                    co.moveTo(ca.width - this.gutterRight + (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));
+                    co.lineTo(ca.width - this.gutterRight - (isSketch ? 2 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));
+                } else {
+                    co.moveTo(this.gutterLeft - (isSketch ? 2 : 0), this.gutterTop - (isSketch ? 5 : 0));
+                    co.lineTo(this.gutterLeft - (isSketch ? 1 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));
+                }
+            }
+            
+            // Draw the X axis
+            if (prop['chart.noxaxis'] == false) {
+                if (xaxispos == 'center') {
+                    co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), Math.round(((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop + (isSketch ? 2 : 0)));
+                    co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), Math.round(((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop - (isSketch ? 2 : 0)));
+                } else if (xaxispos == 'top') {
+                    co.moveTo(this.gutterLeft - (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));
+                    co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), this.gutterTop + (isSketch ? 2 : 0));
+                } else {
+                    co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), ca.height - this.gutterBottom - (isSketch ? 2 : 0));
+                    co.lineTo(ca.width - this.gutterRight + (isSketch ? 8 : 0), ca.height - this.gutterBottom + (isSketch ? 2 : 0));
+                }
+            }
+    
+            var numYTicks = prop['chart.numyticks'];
+    
+            // Draw the Y tickmarks
+            if (prop['chart.noyaxis'] == false && !isSketch) {
+                var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / numYTicks;
+                var xpos     = yaxispos == 'left' ? this.gutterLeft : ca.width - this.gutterRight;
+    
+                if (this.properties['chart.numyticks'] > 0) {
+                    for (y=this.gutterTop;
+                         xaxispos == 'center' ? y <= (ca.height - this.gutterBottom) : y < (ca.height - this.gutterBottom + (xaxispos == 'top' ? 1 : 0));
+                         y += yTickGap) {
+    
+                        if (xaxispos == 'center' && y == (this.gutterTop + (this.grapharea / 2))) continue;
+                        
+                        // X axis at the top
+                        if (xaxispos == 'top' && y == this.gutterTop) continue;
+    
+                        co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), Math.round(y));
+                        co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(y));
+                    }
+                }
+    
+                /**
+                * If the X axis is not being shown, draw an extra tick
+                */
+                if (prop['chart.noxaxis']) {
+                    if (xaxispos == 'center') {
+                        co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height / 2));
+                        co.lineTo(xpos, Math.round(ca.height / 2));
+                    } else if (xaxispos == 'top') {
+                        co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(this.gutterTop));
+                        co.lineTo(xpos, Math.round(this.gutterTop));
+                    } else {
+                        co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height - this.gutterBottom));
+                        co.lineTo(xpos, Math.round(ca.height - this.gutterBottom));
+                    }
+                }
+            }
+    
+    
+            // Draw the X tickmarks
+            if (prop['chart.noxaxis'] == false && !isSketch) {
+    
+                if (typeof(prop['chart.numxticks']) == 'number') {
+                    var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];
+                } else {
+                    var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length;
+                }
+    
+                if (xaxispos == 'bottom') {
+                    yStart   = ca.height - this.gutterBottom;
+                    yEnd     = (ca.height - this.gutterBottom) + 3;
+                } else if (xaxispos == 'top') {
+                    yStart = this.gutterTop - 3;
+                    yEnd   = this.gutterTop;
+                } else if (xaxispos == 'center') {
+                    yStart = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop + 3;
+                    yEnd   = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop - 3;
+                }
+                
+                yStart = yStart;
+                yEnd = yEnd;
+                
+                //////////////// X TICKS ////////////////
+                var noEndXTick = prop['chart.noendxtick'];
+    
+                for (x=this.gutterLeft + (yaxispos == 'left' ? xTickGap : 0),len=(ca.width - this.gutterRight + (yaxispos == 'left' ? 5 : 0)); x<len; x+=xTickGap) {
+    
+                    if (yaxispos == 'left' && !noEndXTick && x > this.gutterLeft) {
+                        co.moveTo(Math.round(x), yStart);
+                        co.lineTo(Math.round(x), yEnd);
+                    
+                    } else if (yaxispos == 'left' && noEndXTick && x > this.gutterLeft && x < (ca.width - this.gutterRight) ) {
+                        co.moveTo(Math.round(x), yStart);
+                        co.lineTo(Math.round(x), yEnd);
+                    
+                    } else if (yaxispos == 'right' && x < (ca.width - this.gutterRight) && !noEndXTick) {
+                        co.moveTo(Math.round(x), yStart);
+                        co.lineTo(Math.round(x), yEnd);
+                    
+                    } else if (yaxispos == 'right' && x < (ca.width - this.gutterRight) && x > (this.gutterLeft) && noEndXTick) {
+                        co.moveTo(Math.round(x), yStart);
+                        co.lineTo(Math.round(x), yEnd);
+                    }
+                }
+                
+                if (prop['chart.noyaxis'] || prop['chart.numxticks'] == null) {
+                    if (typeof(prop['chart.numxticks']) == 'number' && prop['chart.numxticks'] > 0) {
+                        co.moveTo(Math.round(this.gutterLeft), yStart);
+                        co.lineTo(Math.round(this.gutterLeft), yEnd);
+                    }
+                }
+        
+                //////////////// X TICKS ////////////////
+            }
+    
+            /**
+            * If the Y axis is not being shown, draw an extra tick
+            */
+            if (prop['chart.noyaxis'] && prop['chart.noxaxis'] == false && prop['chart.numxticks'] == null) {
+                if (xaxispos == 'center') {
+                    co.moveTo(Math.round(this.gutterLeft), (ca.height / 2) - 3);
+                    co.lineTo(Math.round(this.gutterLeft), (ca.height / 2) + 3);
+                } else {
+                    co.moveTo(Math.round(this.gutterLeft), ca.height - this.gutterBottom);
+                    co.lineTo(Math.round(this.gutterLeft), ca.height - this.gutterBottom + 3);
+                }
+            }
+    
+            co.stroke();
+        }
+    
+    
+    
+        /**
+        * Draws the bars
+        */
+        this.Drawbars = function ()
+        {
+            // Variable "caching" so the context can be accessed as a local variable
+            var ca   = this.canvas;
+            var co   = this.context;
+            var prop = this.properties;
+    
+            co.lineWidth   = prop['chart.linewidth'];
+            co.strokeStyle = prop['chart.strokecolor'];
+            co.fillStyle   = prop['chart.colors'][0];
+            var prevX      = 0;
+            var prevY      = 0;
+            var decimals   = prop['chart.scale.decimals'];
+    
+            /**
+            * Work out the max value
+            */
+            if (prop['chart.ymax']) {
+    
+                this.scale2 = RGraph.getScale2(this, {
+                                                    'max':prop['chart.ymax'],
+                                                    'strict': true,
+                                                    'min':prop['chart.ymin'],
+                                                    'scale.thousand':prop['chart.scale.thousand'],
+                                                    'scale.point':prop['chart.scale.point'],
+                                                    'scale.decimals':prop['chart.scale.decimals'],
+                                                    'ylabels.count':prop['chart.ylabels.count'],
+                                                    'scale.round':prop['chart.scale.round'],
+                                                    'units.pre': prop['chart.units.pre'],
+                                                    'units.post': prop['chart.units.post']
+                                                   });
+    
+            } else {
+    
+                for (i=0; i<this.data.length; ++i) {
+                    if (typeof(this.data[i]) == 'object') {
+                        var value = prop['chart.grouping'] == 'grouped' ? Number(RGraph.array_max(this.data[i], true)) : Number(RGraph.array_sum(this.data[i])) ;
+    
+                    } else {
+                        var value = Number(this.data[i]);
+                    }
+    
+                    this.max = Math.max(Math.abs(this.max), Math.abs(value));
+                }
+    
+                this.scale2 = RGraph.getScale2(this, {
+                                                    'max':this.max,
+                                                    'min':prop['chart.ymin'],
+                                                    'scale.thousand':prop['chart.scale.thousand'],
+                                                    'scale.point':prop['chart.scale.point'],
+                                                    'scale.decimals':prop['chart.scale.decimals'],
+                                                    'ylabels.count':prop['chart.ylabels.count'],
+                                                    'scale.round':prop['chart.scale.round'],
+                                                    'units.pre': prop['chart.units.pre'],
+                                                    'units.post': prop['chart.units.post']
+                                                   });
+                
+                this.max = this.scale2.max;    
+            }
+            /**
+            * if the chart is adjustable fix the scale so that it doesn't change.
+            */
+            if (prop['chart.adjustable'] && !prop['chart.ymax']) {
+                this.Set('chart.ymax', this.scale2.max);
+            }
+    
+            /**
+            * Draw horizontal bars here
+            */
+            if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {
+                RGraph.DrawBars(this);
+            }
+    
+            var variant = prop['chart.variant'];
+            
+            /**
+            * Draw the 3D axes is necessary
+            */
+            if (variant == '3d') {
+                RG.Draw3DAxes(this);
+            }
+    
+            /**
+            * Get the variant once, and draw the bars, be they regular, stacked or grouped
+            */
+            
+            // Get these variables outside of the loop
+            var xaxispos      = prop['chart.xaxispos'];
+            var width         = (ca.width - this.gutterLeft - this.gutterRight ) / this.data.length;
+            var orig_height   = height;
+            var hmargin       = prop['chart.hmargin'];
+            var shadow        = prop['chart.shadow'];
+            var shadowColor   = prop['chart.shadow.color'];
+            var shadowBlur    = prop['chart.shadow.blur'];
+            var shadowOffsetX = prop['chart.shadow.offsetx'];
+            var shadowOffsetY = prop['chart.shadow.offsety'];
+            var strokeStyle   = prop['chart.strokecolor'];
+            var colors        = prop['chart.colors'];
+            var sequentialColorIndex = 0;
+    
+            for (i=0,len=this.data.length; i<len; i+=1) {
+    
+                // Work out the height
+                //The width is up outside the loop
+                var height = ((RGraph.array_sum(this.data[i]) < 0 ? RGraph.array_sum(this.data[i]) + this.scale2.min : RGraph.array_sum(this.data[i]) - this.scale2.min) / (this.scale2.max - this.scale2.min) ) * (ca.height - this.gutterTop - this.gutterBottom);
+    
+                // Half the height if the Y axis is at the center
+                if (xaxispos == 'center') {
+                    height /= 2;
+                }
+    
+                var x = (i * width) + this.gutterLeft;
+                var y = xaxispos == 'center' ? ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop - height
+                                             : ca.height - height - this.gutterBottom;
+    
+                // xaxispos is top
+                if (xaxispos == 'top') {
+                    y = this.gutterTop + Math.abs(height);
+                }
+    
+    
+                // Account for negative lengths - Some browsers (eg Chrome) don't like a negative value
+                if (height < 0) {
+                    y += height;
+                    height = Math.abs(height);
+                }
+    
+                /**
+                * Turn on the shadow if need be
+                */
+                if (shadow) {
+                    co.shadowColor   = shadowColor;
+                    co.shadowBlur    = shadowBlur;
+                    co.shadowOffsetX = shadowOffsetX;
+                    co.shadowOffsetY = shadowOffsetY;
+                }
+    
+                /**
+                * Draw the bar
+                */
+                co.beginPath();
+                    if (typeof(this.data[i]) == 'number') {
+    
+                        var barWidth = width - (2 * hmargin);
+                        
+                        /**
+                        * Check for a negative bar width
+                        */
+                        if (barWidth < 0) {
+                            alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
+                        }
+    
+                        // Set the fill color
+                        co.strokeStyle = strokeStyle;
+                        co.fillStyle = colors[0];
+                        
+                        /**
+                        * Sequential colors
+                        */
+                        if (prop['chart.colors.sequential']) {
+                            co.fillStyle = colors[i];
+                        }
+    
+                        if (variant == 'sketch') {
+    
+                            co.lineCap = 'round';
+                            
+                            var sketchOffset = 3;
+    
+                            co.beginPath();
+    
+                            co.strokeStyle = colors[0];
+    
+                            /**
+                            * Sequential colors
+                            */
+                            if (prop['chart.colors.sequential']) {
+                                co.strokeStyle = colors[i];
+                            }
+    
+                            // Left side
+                            co.moveTo(x + hmargin + 2, y + height - 2);
+                            co.lineTo(x + hmargin -    1, y - 4);
+    
+                            // The top
+                            co.moveTo(x + hmargin - 3, y + -2 + (this.data[i] < 0 ? height : 0));
+                            co.bezierCurveTo(
+                                             x + ((hmargin + width) * 0.33),
+                                             y + 15 + (this.data[i] < 0 ? height - 10: 0),
+                                             x + ((hmargin + width) * 0.66),
+                                             y + 5 + (this.data[i] < 0 ? height - 10 : 0),x + hmargin + width + -1, y + 0 + (this.data[i] < 0 ? height : 0)
+                                            );
+    
+    
+                            // The right side
+                            co.moveTo(x + hmargin + width - 5, y  - 5);
+                            co.lineTo(x + hmargin + width - 3, y + height - 3);
+    
+                            if (prop['chart.variant.sketch.verticals']) {
+                                for (var r=0.2; r<=0.8; r+=0.2) {
+                                    co.moveTo(x + hmargin + width + (r > 0.4 ? -1 : 3) - (r * width),y - 1);
+                                    co.lineTo(x + hmargin + width - (r > 0.4 ? 1 : -1) - (r * width), y + height + (r == 0.2 ? 1 : -2));
+                                }
+                            }
+    
+                            co.stroke();
+    
+                        // Regular bar
+                        } else if (variant == 'bar' || variant == '3d' || variant == 'glass' || variant == 'bevel') {
+                        
+                            if (RGraph.isOld() && shadow) {
+                                this.DrawIEShadow([x + hmargin, y, barWidth, height]);
+                            }
+                            
+                            if (variant == 'glass') {
+                                RGraph.filledCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);
+                                RGraph.strokedCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);
+                            } else {
+                                // On 9th April 2013 these two were swapped around so that the stroke happens SECOND so that any
+                                // shadow that is cast by the fill does not overwrite the stroke
+
+                                co.beginPath();
+                                co.rect(x + hmargin, y, barWidth, height);
+                                co.fill();
+                                
+                                // Turn the shadow off so that the stroke doesn't cast any "extra" shadow
+                                // that would show inside the bar
+                                RG.NoShadow(this);
+                                
+                                co.beginPath();
+                                co.rect(x + hmargin, y, barWidth, height);
+                                co.stroke();
+                            }
+    
+                            // 3D effect
+                            if (variant == '3d') {
+    
+                                var prevStrokeStyle = co.strokeStyle;
+                                var prevFillStyle   = co.fillStyle;
+    
+                                // Draw the top
+                                co.beginPath();
+                                    co.moveTo(x + hmargin, y);
+                                    co.lineTo(x + hmargin + 10, y - 5);
+                                    co.lineTo(x + hmargin + 10 + barWidth, y - 5);
+                                    co.lineTo(x + hmargin + barWidth, y);
+                                co.closePath();
+    
+                                co.stroke();
+                                co.fill();
+    
+                                // Draw the right hand side
+                                co.beginPath();
+                                    co.moveTo(x + hmargin + barWidth, y);
+                                    co.lineTo(x + hmargin + barWidth + 10, y - 5);
+                                    co.lineTo(x + hmargin + barWidth + 10, y + height - 5);
+                                    co.lineTo(x + hmargin + barWidth, y + height);
+                                co.closePath();
+        
+                                co.stroke();                        
+                                co.fill();
+    
+                                // Draw the darker top section
+                                co.beginPath();                            
+                                    co.fillStyle = 'rgba(255,255,255,0.3)';
+                                    co.moveTo(x + hmargin, y);
+                                    co.lineTo(x + hmargin + 10, y - 5);
+                                    co.lineTo(x + hmargin + 10 + barWidth, y - 5);
+                                    co.lineTo(x + hmargin + barWidth, y);
+                                    co.lineTo(x + hmargin, y);
+                                co.closePath();
+        
+                                co.stroke();
+                                co.fill();
+    
+                                // Draw the darker right side section
+                                co.beginPath();
+                                    co.fillStyle = 'rgba(0,0,0,0.4)';
+                                    co.moveTo(x + hmargin + barWidth, y);
+                                    co.lineTo(x + hmargin + barWidth + 10, y - 5);
+                                    co.lineTo(x + hmargin + barWidth + 10, y - 5 + height);
+                                    co.lineTo(x + hmargin + barWidth, y + height);
+                                    co.lineTo(x + hmargin + barWidth, y);
+                                co.closePath();
+    
+                                co.stroke();
+                                co.fill();
+    
+                                co.strokeStyle = prevStrokeStyle;
+                                co.fillStyle   = prevFillStyle;
+                            
+                            // Glass variant
+                            } else if (variant == 'glass') {
+     
+                                var grad = co.createLinearGradient(x + hmargin,y,x + hmargin + (barWidth / 2),y);
+                                grad.addColorStop(0, 'rgba(255,255,255,0.9)');
+                                grad.addColorStop(1, 'rgba(255,255,255,0.5)');
+    
+                                co.beginPath();
+                                co.fillStyle = grad;
+                                co.fillRect(x + hmargin + 2,y + (this.data[i] > 0 ? 2 : 0),(barWidth / 2) - 2,height - 2);
+                                co.fill();
+                            }
+    
+                            // This bit draws the text labels that appear above the bars if requested
+                            if (prop['chart.labels.above']) {
+    
+                                // Turn off any shadow
+                                if (shadow) {
+                                    RGraph.NoShadow(this);
+                                }
+    
+                                var yPos = y - 3;
+                                var xPos = x + hmargin + (barWidth / 2);
+    
+                                // Account for negative bars
+                                if (this.data[i] < 0) {
+                                    yPos += height + 6 + (prop['chart.text.size']);
+                                }
+    
+                                // Account for chart.xaxispos=top
+                                if (prop['chart.xaxispos'] == 'top') {
+                                    yPos = this.gutterTop + height + 6 + (typeof(prop['chart.labels.above.size']) == 'number' ? prop['chart.labels.above.size'] : prop['chart.text.size'] - 4);
+                                }
+    
+                                // Account for chart.variant=3d
+                                if (prop['chart.variant'] == '3d') {
+                                    yPos -= 3;
+                                    xPos += 5;
+                                }
+                                
+                                // Angled above labels
+                                if (this.properties['chart.labels.above.angle']) {
+                                    var angle = -45;
+                                    var halign = 'left';
+                                    var valign = 'center';
+                                } else {
+                                    var angle = 0;
+                                    var halign = 'center';
+                                    var valign = 'bottom';
+                                }
+
+                                // Above labels color
+                                if (typeof this.properties['chart.labels.above.color'] == 'string') {
+                                    co.fillStyle = prop['chart.labels.above.color'];
+                                } else {
+                                    co.fillStyle = prop['chart.text.color'];
+                                }
+    
+                                RGraph.Text2(this, {'font': prop['chart.text.font'],
+                                                    'size': typeof(prop['chart.labels.above.size']) == 'number' ? prop['chart.labels.above.size'] : prop['chart.text.size'] - 3,
+                                                       'x': xPos,
+                                                       'y': yPos,
+                                                    'text': RGraph.number_format(this, Number(this.data[i]).toFixed(prop['chart.labels.above.decimals']),prop['chart.units.pre'],prop['chart.units.post']),
+                                                  'halign': halign,
+                                                  'marker': false,
+                                                  'valign': valign,
+                                                  'angle': angle,
+                                                  'tag': 'labels.above'
+                                                 });
+                            }
+    
+                        // Dot chart
+                        } else if (variant == 'dot') {
+    
+                            co.beginPath();
+                            co.moveTo(x + (width / 2), y);
+                            co.lineTo(x + (width / 2), y + height);
+                            co.stroke();
+                            
+                            co.beginPath();
+                            co.fillStyle = this.properties['chart.colors'][i];
+                            co.arc(x + (width / 2), y + (this.data[i] > 0 ? 0 : height), 2, 0, 6.28, 0);
+                            
+                            // Set the colour for the dots
+                            co.fillStyle = prop['chart.colors'][0];
+    
+                            /**
+                            * Sequential colors
+                            */
+                            if (prop['chart.colors.sequential']) {
+                                co.fillStyle = colors[i];
+                            }
+    
+                            co.stroke();
+                            co.fill();
+
+    
+    
+                        // Unknown variant type
+                        } else {
+                            alert('[BAR] Warning! Unknown chart.variant: ' + variant);
+                        }
+
+                        this.coords.push([x + hmargin, y, width - (2 * hmargin), height]);
+    
+                            if (typeof this.coords2[i] == 'undefined') {
+                                this.coords2[i] = [];
+                            }
+                            this.coords2[i].push([x + hmargin, y, width - (2 * hmargin), height]);
+    
+    
+                    /**
+                    * Stacked bar
+                    */
+                    } else if (this.data[i] && typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'stacked') {
+                    
+                        if (this.scale2.min) {
+                            alert("[ERROR] Stacked Bar charts with a Y min are not supported");
+                        }
+                        
+                        var barWidth     = width - (2 * hmargin);
+                        var redrawCoords = [];// Necessary to draw if the shadow is enabled
+                        var startY       = 0;
+                        var dataset      = this.data[i];
+                        
+                        /**
+                        * Check for a negative bar width
+                        */
+                        if (barWidth < 0) {
+                            alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
+                        }
+    
+                        for (j=0; j<dataset.length; ++j) {
+    
+                            // Stacked bar chart and X axis pos in the middle - poitless since negative values are not permitted
+                            if (xaxispos == 'center') {
+                                alert("[BAR] It's pointless having the X axis position at the center on a stacked bar chart.");
+                                return;
+                            }
+    
+                            // Negative values not permitted for the stacked chart
+                            if (this.data[i][j] < 0) {
+                                alert('[BAR] Negative values are not permitted with a stacked bar chart. Try a grouped one instead.');
+                                return;
+                            }
+    
+                            /**
+                            * Set the fill and stroke colors
+                            */
+                            co.strokeStyle = strokeStyle
+                            co.fillStyle = colors[j];
+        
+                            if (prop['chart.colors.reverse']) {
+                                co.fillStyle = colors[this.data[i].length - j - 1];
+                            }
+                            
+                            if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {
+                                co.fillStyle = colors[sequentialColorIndex++];
+                            } else if (prop['chart.colors.sequential']) {
+                                co.fillStyle = colors[sequentialColorIndex - 1];
+                            }
+    
+                            var height = (dataset[j] / this.scale2.max) * (ca.height - this.gutterTop - this.gutterBottom );
+
+                            // If the X axis pos is in the center, we need to half the  height
+                            if (xaxispos == 'center') {
+                                height /= 2;
+                            }
+    
+                            var totalHeight = (RGraph.array_sum(dataset) / this.scale2.max) * (ca.height - hmargin - this.gutterTop - this.gutterBottom);
+    
+                            /**
+                            * Store the coords for tooltips
+                            */
+                            this.coords.push([x + hmargin, y, width - (2 * hmargin), height]);
+                            if (typeof this.coords2[i] == 'undefined') {
+                                this.coords2[i] = [];
+                            }
+                            this.coords2[i].push([x + hmargin, y, width - (2 * hmargin), height]);
+    
+                            // MSIE shadow
+                            if (RGraph.isOld() && shadow) {
+                                this.DrawIEShadow([x + hmargin, y, width - (2 * hmargin), height + 1]);
+                            }
+    
+                            if (height > 0) {
+                                co.strokeRect(x + hmargin, y, width - (2 * hmargin), height);
+                                co.fillRect(x + hmargin, y, width - (2 * hmargin), height);
+                            }
+
+                            
+                            if (j == 0) {
+                                var startY = y;
+                                var startX = x;
+                            }
+    
+                            /**
+                            * Store the redraw coords if the shadow is enabled
+                            */
+                            if (shadow) {
+                                redrawCoords.push([x + hmargin, y, width - (2 * hmargin), height, co.fillStyle]);
+                            }
+    
+                            /**
+                            * Stacked 3D effect
+                            */
+                            if (variant == '3d') {
+    
+                                var prevFillStyle = co.fillStyle;
+                                var prevStrokeStyle = co.strokeStyle;
+    
+        
+                                // Draw the top side
+                                if (j == 0) {
+                                    co.beginPath();
+                                        co.moveTo(startX + hmargin, y);
+                                        co.lineTo(startX + 10 + hmargin, y - 5);
+                                        co.lineTo(startX + 10 + barWidth + hmargin, y - 5);
+                                        co.lineTo(startX + barWidth + hmargin, y);
+                                    co.closePath();
+                                    
+                                    co.fill();
+                                    co.stroke();
+                                }
+    
+                                // Draw the side section
+                                co.beginPath();
+                                    co.moveTo(startX + barWidth + hmargin, y);
+                                    co.lineTo(startX + barWidth + hmargin + 10, y - 5);
+                                    co.lineTo(startX + barWidth + hmargin + 10, y - 5 + height);
+                                    co.lineTo(startX + barWidth + hmargin , y + height);
+                                co.closePath();
+                                
+                                co.fill();
+                                co.stroke();
+    
+                                // Draw the darker top side
+                                if (j == 0) {
+                                    co.fillStyle = 'rgba(255,255,255,0.3)';
+                                    co.beginPath();
+                                        co.moveTo(startX + hmargin, y);
+                                        co.lineTo(startX + 10 + hmargin, y - 5);
+                                        co.lineTo(startX + 10 + barWidth + hmargin, y - 5);
+                                        co.lineTo(startX + barWidth + hmargin, y);
+                                    co.closePath();
+                                    
+                                    co.fill();
+                                    co.stroke();
+                                }
+    
+                                // Draw the darker side section
+                                co.fillStyle = 'rgba(0,0,0,0.4)';
+                                co.beginPath();
+                                    co.moveTo(startX + barWidth + hmargin, y);
+                                    co.lineTo(startX + barWidth + hmargin + 10, y - 5);
+                                    co.lineTo(startX + barWidth + hmargin + 10, y - 5 + height);
+                                    co.lineTo(startX + barWidth + hmargin , y + height);
+                                co.closePath();
+                                
+                                co.fill();
+                                co.stroke();
+    
+                                co.strokeStyle = prevStrokeStyle;
+                                co.fillStyle = prevFillStyle;
+                            }
+    
+                            y += height;
+                        }
+    
+                        // This bit draws the text labels that appear above the bars if requested
+                        if (prop['chart.labels.above']) {
+    
+                            // Turn off any shadow
+                            RG.NoShadow(this);
+    
+                            // Above labels color
+                            if (typeof this.properties['chart.labels.above.color'] == 'string') {
+                                co.fillStyle = prop['chart.labels.above.color'];
+                            } else {
+                                co.fillStyle = prop['chart.text.color'];
+                            }
+    
+                            // Angled above labels
+                            if (prop['chart.labels.above.angle']) {
+                                var angle = -45;
+                                var halign = 'left';
+                                var valign = 'center';
+                            } else {
+                                var angle = 0;
+                                var halign = 'center';
+                                var valign = 'bottom';
+                            }
+    
+                            RGraph.Text2(this,{'font': prop['chart.text.font'],
+                                               'size': typeof(prop['chart.labels.above.size']) == 'number' ? prop['chart.labels.above.size'] : prop['chart.text.size'] - 3,
+                                               'x': startX + (barWidth / 2) + prop['chart.hmargin'],
+                                               'y': startY - (prop['chart.shadow'] && prop['chart.shadow.offsety'] < 0 ? 7 : 4) - (prop['chart.variant'] == '3d' ? 5 : 0),
+                                               'text': String(prop['chart.units.pre'] + RGraph.array_sum(this.data[i]).toFixed(prop['chart.labels.above.decimals']) + prop['chart.units.post']),
+                                               'angle': angle,
+                                               'valign': valign,
+                                               'halign': halign,
+                                                'tag': 'labels.above'
+                                              });
+    
+                          
+                            // Turn any shadow back on
+                            if (shadow) {
+                                co.shadowColor   = shadowColor;
+                                co.shadowBlur    = shadowBlur;
+                                co.shadowOffsetX = shadowOffsetX;
+                                co.shadowOffsetY = shadowOffsetY;
+                            }
+                        }
+                        
+    
+                        /**
+                        * Redraw the bars if the shadow is enabled due to hem being drawn from the bottom up, and the
+                        * shadow spilling over to higher up bars
+                        */
+                        if (shadow) {
+    
+                            RGraph.NoShadow(this);
+    
+                            for (k=0; k<redrawCoords.length; ++k) {
+                                co.strokeStyle = strokeStyle;
+                                co.fillStyle = redrawCoords[k][4];
+                                co.strokeRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);
+                                co.fillRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);
+    
+                                co.stroke();
+                                co.fill();
+                            }
+                            
+                            // Reset the redraw coords to be empty
+                            redrawCoords = [];
+                        }
+                    /**
+                    * Grouped bar
+                    */
+                    } else if (this.data[i] && typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'grouped') {
+    
+                        var redrawCoords = [];
+                        co.lineWidth = prop['chart.linewidth'];
+    
+                        for (j=0; j<this.data[i].length; ++j) {
+    
+                            // Set the fill and stroke colors
+                            co.strokeStyle = strokeStyle;
+                            co.fillStyle   = colors[j];
+                            
+                            /**
+                            * Sequential colors
+                            */
+                            if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {
+                                co.fillStyle = colors[sequentialColorIndex++];
+                            } else if (prop['chart.colors.sequential']) {
+                                co.fillStyle = colors[sequentialColorIndex - 1];
+                            }
+    
+                            var individualBarWidth = (width - (2 * hmargin)) / this.data[i].length;
+                            var height = ((this.data[i][j] + (this.data[i][j] < 0 ? this.scale2.min : (-1 * this.scale2.min) )) / (this.scale2.max - this.scale2.min) ) * (ca.height - this.gutterTop - this.gutterBottom );
+                            var groupedMargin = prop['chart.hmargin.grouped'];
+                            var startX = x + hmargin + (j * individualBarWidth);
+    
+                            /**
+                            * Check for a negative bar width
+                            */
+                            if (individualBarWidth < 0) {
+                                alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
+                            }
+    
+                            // If the X axis pos is in the center, we need to half the  height
+                            if (xaxispos == 'center') {
+                                height /= 2;
+                            }
+    
+                            /**
+                            * Determine the start positioning for the bar
+                            */
+                            if (xaxispos == 'top') {
+                                var startY = this.gutterTop;
+                                var height = Math.abs(height);
+    
+                            } else if (xaxispos == 'center') {
+                                var startY = this.gutterTop + (this.grapharea / 2) - height;
+    
+                            } else {
+                                var startY = ca.height - this.gutterBottom - height;
+                                var height = Math.abs(height);
+                            }
+    
+                            /**
+                            * Draw MSIE shadow
+                            */
+                            if (RGraph.isOld() && shadow) {
+                                this.DrawIEShadow([startX, startY, individualBarWidth, height]);
+                            }
+    
+                            co.strokeRect(startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height);
+                            co.fillRect(startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height);
+                            y += height;
+    
+    
+    
+                            /**
+                            * Grouped 3D effect
+                            */
+                            if (variant == '3d') {
+                                var prevFillStyle = co.fillStyle;
+                                var prevStrokeStyle = co.strokeStyle;
+                                
+                                // Draw the top side
+                                co.beginPath();
+                                    co.moveTo(startX, startY);
+                                    co.lineTo(startX + 10, startY - 5);
+                                    co.lineTo(startX + 10 + individualBarWidth, startY - 5);
+                                    co.lineTo(startX + individualBarWidth, startY);
+                                co.closePath();
+                                
+                                co.fill();
+                                co.stroke();
+                                
+                                // Draw the side section
+                                co.beginPath();
+                                    co.moveTo(startX + individualBarWidth, startY);
+                                    co.lineTo(startX + individualBarWidth + 10, startY - 5);
+                                    co.lineTo(startX + individualBarWidth + 10, startY - 5 + height);
+                                    co.lineTo(startX + individualBarWidth , startY + height);
+                                co.closePath();
+                                
+                                co.fill();
+                                co.stroke();
+    
+    
+                                // Draw the darker top side
+                                co.fillStyle = 'rgba(255,255,255,0.3)';
+                                co.beginPath();
+                                    co.moveTo(startX, startY);
+                                    co.lineTo(startX + 10, startY - 5);
+                                    co.lineTo(startX + 10 + individualBarWidth, startY - 5);
+                                    co.lineTo(startX + individualBarWidth, startY);
+                                co.closePath();
+                                
+                                co.fill();
+                                co.stroke();
+                                
+                                // Draw the darker side section
+                                co.fillStyle = 'rgba(0,0,0,0.4)';
+                                co.beginPath();
+                                    co.moveTo(startX + individualBarWidth, startY);
+                                    co.lineTo(startX + individualBarWidth + 10, startY - 5);
+                                    co.lineTo(startX + individualBarWidth + 10, startY - 5 + height);
+                                    co.lineTo(startX + individualBarWidth , startY + height);
+                                co.closePath();
+                                
+                                co.fill();
+                                co.stroke();
+    
+                                co.strokeStyle = prevStrokeStyle;
+                                co.fillStyle   = prevFillStyle;
+                            }
+                            
+                            if (height < 0) {
+                                height = Math.abs(height);
+                                startY = startY - height;
+                            }
+    
+                            this.coords.push([startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height]);
+                            if (typeof this.coords2[i] == 'undefined') {
+                                this.coords2[i] = [];
+                            }
+
+                            this.coords2[i].push([startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height]);
+    
+                            // Facilitate shadows going to the left
+                            if (prop['chart.shadow']) {
+                                redrawCoords.push([startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height, co.fillStyle]);
+                            }
+    
+    
+                            // This bit draws the text labels that appear above the bars if requested
+                            if (prop['chart.labels.above']) {
+    
+                                co.strokeStyle = 'rgba(0,0,0,0)';
+                            
+                                // Turn off any shadow
+                                if (shadow) {
+                                    RGraph.NoShadow(this);
+                                }
+                            
+                                var yPos = y - 3;
+    
+                                // Angled above labels
+                                if (prop['chart.labels.above.angle']) {
+                                    var angle = -45;
+                                    var halign = 'left';
+                                    var valign = 'center';
+                                } else {
+    
+                                    var angle = 0;
+                                    var halign = 'center';
+                                    var valign = 'bottom';
+                            
+                                    // Account for negative bars
+                                    if (this.data[i][j] < 0 || prop['chart.xaxispos'] == 'top') {
+                                        yPos = startY + height + 6;
+                                        var valign = 'top';
+                                    } else {
+                                        yPos = startY;
+                                    }
+                                }
+    
+                                // Above labels color
+                                if (typeof this.properties['chart.labels.above.color'] == 'string') {
+                                    co.fillStyle = prop['chart.labels.above.color'];
+                                } else {
+                                    co.fillStyle = prop['chart.text.color'];
+                                }
+    
+                                RGraph.Text2(this, {'font': prop['chart.text.font'],
+                                                    'size': typeof(prop['chart.labels.above.size']) == 'number' ? prop['chart.labels.above.size'] : prop['chart.text.size'] - 3,
+                                                    'x': startX + (individualBarWidth / 2),
+                                                    'y': yPos - 3,
+                                                    'text': RGraph.number_format(this, this.data[i][j].toFixed(prop['chart.labels.above.decimals'])),
+                                                    'halign': halign,
+                                                    'valign': valign,
+                                                    'angle':angle,
+                                                    'tag': 'labels.above'
+                                                   });
+                              
+                                // Turn any shadow back on
+                                if (shadow) {
+                                    co.shadowColor   = shadowColor;
+                                    co.shadowBlur    = shadowBlur;
+                                    co.shadowOffsetX = shadowOffsetX;
+                                    co.shadowOffsetY = shadowOffsetY;
+                                }
+                            }
+                        }
+
+                        /**
+                        * Redraw the bar if shadows are going to the left
+                        */
+                        if (redrawCoords.length) {
+    
+                            RGraph.NoShadow(this);
+                            
+                            co.lineWidth = prop['chart.linewidth'];
+    
+                            co.beginPath();
+                                for (var j=0; j<redrawCoords.length; ++j) {
+    
+                                    co.fillStyle   = redrawCoords[j][4];
+                                    co.strokeStyle = prop['chart.strokecolor'];
+    
+                                    co.fillRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);
+                                    co.strokeRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);
+                                }
+                            co.fill();
+                            co.stroke();
+    
+                            redrawCoords = [];
+                        }
+                    } else {
+                        this.coords.push([]);
+                    }
+    
+                co.closePath();
+            }
+    
+            /**
+            * Turn off any shadow
+            */
+            RGraph.NoShadow(this);
+        }
+    
+    
+    
+        /**
+        * Draws the labels for the graph
+        */
+        this.DrawLabels = function ()
+        {
+            // Variable "caching" so the context can be accessed as a local variable
+            var ca      = this.canvas;
+            var co      = this.context;
+            var prop    = this.properties;
+            var context = co;
+    
+            var text_angle = prop['chart.text.angle'];
+            var text_size  = prop['chart.text.size'];
+            var labels     = prop['chart.labels'];
+    
+    
+            // Draw the Y axis labels:
+            if (prop['chart.ylabels']) {
+                if (prop['chart.xaxispos'] == 'top')    this.Drawlabels_top();
+                if (prop['chart.xaxispos'] == 'center') this.Drawlabels_center();
+                if (prop['chart.xaxispos'] == 'bottom') this.Drawlabels_bottom();
+            }
+    
+            /**
+            * The X axis labels
+            */
+            if (typeof(labels) == 'object' && labels) {
+    
+                var yOffset = Number(prop['chart.xlabels.offset']);
+    
+                /**
+                * Text angle
+                */
+                if (prop['chart.text.angle'] != 0) {
+                    var valign =  'center';
+                    var halign =  'right';
+                    var angle  = 0 - prop['chart.text.angle'];
+                } else {
+                    var valign =  'top';
+                    var halign =  'center';
+                    var angle  = 0;
+                }
+    
+                // Draw the X axis labels
+                co.fillStyle = prop['chart.text.color'];
+                
+                // How wide is each bar
+                var barWidth = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;
+                
+                // Reset the xTickGap
+                xTickGap = (ca.width - this.gutterRight - this.gutterLeft) / labels.length
+    
+                // Draw the X tickmarks
+                var i=0;
+                var font = prop['chart.text.font'];
+    
+                for (x=this.gutterLeft + (xTickGap / 2); x<=ca.width - this.gutterRight; x+=xTickGap) {
+    
+                    RGraph.Text2(this, {'font': font,
+                                        'size': text_size,
+                                           'x': x,
+                                           'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop - yOffset - 5: (ca.height - this.gutterBottom) + yOffset + 3,
+                                        'text': String(labels[i++]),
+                                      'valign': prop['chart.xaxispos'] == 'top' ? 'bottom' : valign,
+                                      'halign': halign,
+                                        'tag':'label',
+                                        'marker':false,
+                                        'angle':angle,
+                                        'tag': 'labels'
+                                       });
+                }
+            }
+            
+            /**
+            * If chart.labels.above.specific is specified, draw them
+            */
+            if (prop['chart.labels.above.specific']) {
+            
+                var labels = prop['chart.labels.above.specific'];
+                
+                for (var i=0; i<this.coords.length; ++i) {
+    
+                    var xaxispos = prop['chart.xaxispos'];
+                    var coords = this.coords[i];
+                    var value  = this.data_arr[i];
+                    var valign =  (value >=0 && xaxispos != 'top') ? 'bottom' : 'top';
+                    var halign = 'center';
+                    var text   = labels[i];
+    
+    
+                    if (text && text.toString().length > 0) {
+                        RGraph.Text2(this, {'font': prop['chart.text.font'],
+                                            'size': prop['chart.labels.above.size'] ? prop['chart.labels.above.size'] : prop['chart.text.size'],
+                                            'x': coords[0] + (coords[2] / 2),
+                                            'y': (value >=0 && xaxispos != 'top') ? coords[1] - 5 : coords[1] + coords[3] + 3,
+                                            'text': String(labels[i]),
+                                            'valign': valign,
+                                            'halign': halign,
+                                            'tag': 'labels.above'
+                                           });
+                    }
+                }
+            }
+        }
+    
+    
+    
+        /**
+        * Draws the X axis at the top
+        */
+        this.Drawlabels_top = function ()
+        {
+            var ca   = this.canvas;
+            var co   = this.context;
+            var prop = this.properties;
+    
+            co.beginPath();
+            co.fillStyle   = prop['chart.text.color'];
+            co.strokeStyle = 'black';
+    
+            if (prop['chart.xaxispos'] == 'top') {
+    
+                var context    = co;
+                var text_size  = prop['chart.text.size'];
+                var units_pre  = prop['chart.units.pre'];
+                var units_post = prop['chart.units.post'];
+                var align      = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
+                var font       = prop['chart.text.font'];
+                var numYLabels = prop['chart.ylabels.count'];
+                var ymin       = prop['chart.ymin'];
+    
+                if (prop['chart.ylabels.inside'] == true) {
+                    var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
+                    var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
+                    var boxed = true;
+                } else {
+                    var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
+                    var boxed = false;
+                }
+                
+                /**
+                * Draw specific Y labels here so that the local variables can be reused
+                */
+                if (typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {
+                    
+                    var labels = RGraph.array_reverse(prop['chart.ylabels.specific']);
+                    var grapharea = ca.height - this.gutterTop - this.gutterBottom;
+    
+                    for (var i=0; i<labels.length; ++i) {
+                        
+                        var y = this.gutterTop + (grapharea * (i / labels.length)) + (grapharea / labels.length);
+    
+                        RGraph.Text2(this, {'font': font,
+                                            'size': text_size,
+                                            'x': xpos,
+                                            'y': y,
+                                            'text': String(labels[i]),
+                                            'valign': 'center',
+                                            'halign': align,
+                                            'bordered':boxed,
+                                            'tag': 'scale'
+                                           });
+                    }
+    
+                    return;
+                }
+    
+    
+    
+    
+    
+    
+    
+                /**
+                * Draw the scale
+                */
+                var labels = this.scale2.labels;
+                for (var i=0; i<labels.length; ++i) {
+                    RGraph.Text2(this, {'font': font,
+                                        'size':text_size,
+                                        'x':xpos,
+                                        'y':this.gutterTop + ((this.grapharea / labels.length) * (i + 1)),
+                                        'text': '-' + labels[i],
+                                        'valign': 'center',
+                                        'halign': align,
+                                        'bordered': boxed,
+                                        'tag':'scale'});
+                }
+    
+    
+    
+    
+    
+    
+    
+    
+                /**
+                * Show the minimum value if its not zero
+                */
+                if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {
+    
+                    RGraph.Text2(this, {'font': font,
+                                        'size': text_size,
+                                           'x': xpos,
+                                           'y': this.gutterTop,
+                                        'text': (this.scale2.min != 0 ? '-' : '') + RGraph.number_format(this,(this.scale2.min.toFixed((prop['chart.scale.decimals']))), units_pre, units_post),
+                                      'valign': 'center',
+                                      'halign': align,
+                                    'bordered': boxed,
+                                        'tag': 'scale'});
+                }
+    
+            }
+            
+            co.fill();
+        }
+    
+    
+    
+        /**
+        * Draws the X axis in the middle
+        */
+        this.Drawlabels_center = function ()
+        {
+            var ca   = this.canvas;
+            var co   = this.context;
+            var prop = this.properties;
+    
+            var font       = prop['chart.text.font'];
+            var numYLabels = prop['chart.ylabels.count'];
+    
+            co.fillStyle = prop['chart.text.color'];
+    
+            if (prop['chart.xaxispos'] == 'center') {
+    
+                /**
+                * Draw the top labels
+                */
+                var text_size  = prop['chart.text.size'];
+                var units_pre  = prop['chart.units.pre'];
+                var units_post = prop['chart.units.post'];
+                var context = co;
+                var align   = '';
+                var xpos    = 0;
+                var boxed   = false;
+                var ymin    = prop['chart.ymin'];
+    
+                co.fillStyle   = prop['chart.text.color'];
+                co.strokeStyle = 'black';
+    
+                if (prop['chart.ylabels.inside'] == true) {
+                    var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
+                    var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
+                    var boxed = true;
+                } else {
+                    var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
+                    var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
+                    var boxed = false;
+                }
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+                /**
+                * Draw specific Y labels here so that the local variables can be reused
+                */
+                if (typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {
+    
+                    var labels    = prop['chart.ylabels.specific'];
+                    var grapharea = ca.height - this.gutterTop - this.gutterBottom;
+    
+                    // Draw the top halves labels
+                    for (var i=0; i<labels.length; ++i) {
+    
+                        var y = this.gutterTop + ((grapharea / 2) / (labels.length - 1)) * i;
+    
+                        RGraph.Text2(this, {'font':font,
+                                            'size':text_size,
+                                            'x':xpos,
+                                            'y':y,
+                                            'text':String(labels[i]),
+                                            'valign':'center',
+                                            'halign':align,
+                                            'bordered':boxed,
+                                            'tag': 'scale'
+                                           });
+                    }
+    
+                    // Draw the bottom halves labels
+                    for (var i=labels.length-1; i>=1; --i) {
+                        
+                        var y = this.gutterTop  + (grapharea * (i / ((labels.length - 1) * 2) )) + (grapharea / 2);
+    
+                        RG.Text2(this, {'font':font,
+                                            'size':text_size,
+                                            'x':xpos,
+                                            'y':y,
+                                            'text':String(labels[labels.length - i - 1]),
+                                            'valign':'center',
+                                            'halign':align,
+                                            'bordered':boxed,
+                                            'tag': 'scale'
+                                           });
+                    }
+    
+                    return;
+                }
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+                /**
+                * Draw the top halfs labels
+                */
+                for (var i=0; i<this.scale2.labels.length; ++i) {
+                    var y    = this.gutterTop + this.halfgrapharea - ((this.halfgrapharea / numYLabels) * (i + 1));
+                    var text = this.scale2.labels[i];
+                    RG.Text2(this, {'font':font, 'size':text_size, 'x':xpos, 'y':y, 'text': text, 'valign':'center', 'halign': align, 'bordered': boxed, 'tag':'scale'});
+                }
+                
+                /**
+                * Draw the bottom halfs labels
+                */
+                for (var i=(this.scale2.labels.length - 1); i>=0; --i) {
+                    var y = this.gutterTop + ((this.halfgrapharea / numYLabels) * (i + 1)) + this.halfgrapharea;
+                    var text = this.scale2.labels[i];
+                    RG.Text2(this, {'font':font, 'size':text_size,'x':xpos,'y':y,'text': '-' + text,'valign':'center','halign': align,'bordered': boxed,'tag':'scale'});
+                }
+    
+    
+    
+    
+    
+                /**
+                * Show the minimum value if its not zero
+                */
+                if (this.scale2.min != 0 || prop['chart.scale.zerostart']) {
+                    RG.Text2(this, {'font':font,'size':text_size, 'x':xpos, 'y':this.gutterTop + this.halfgrapharea,'text': RGraph.number_format(this,(this.scale2.min.toFixed((prop['chart.scale.decimals']))), units_pre, units_post),'valign':'center', 'valign':'center','halign': align, 'bordered': boxed, 'tag':'scale'});
+                }
+            }
+        }
+    
+    
+    
+    
+        /**
+        * Draws the X axdis at the bottom (the default)
+        */
+        this.Drawlabels_bottom = function ()
+        {
+            var co   = this.context;
+            var ca   = this.canvas;
+            var prop = this.properties;
+    
+            var text_size  = prop['chart.text.size'];
+            var units_pre  = prop['chart.units.pre'];
+            var units_post = prop['chart.units.post'];
+            var context    = this.context;
+            var align      = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
+            var font       = prop['chart.text.font'];
+            var numYLabels = prop['chart.ylabels.count'];
+            var ymin       = prop['chart.ymin'];
+    
+            co.beginPath();
+            co.fillStyle = prop['chart.text.color'];
+            co.strokeStyle = 'black';
+    
+            if (prop['chart.ylabels.inside'] == true) {
+                var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
+                var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
+                var boxed = true;
+            } else {
+                var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
+                var boxed = false;
+            }
+    
+            /**
+            * Draw specific Y labels here so that the local variables can be reused
+            */
+            if (prop['chart.ylabels.specific'] && typeof(prop['chart.ylabels.specific']) == 'object') {
+    
+                var labels = prop['chart.ylabels.specific'];
+                var grapharea = ca.height - this.gutterTop - this.gutterBottom;
+    
+                for (var i=0; i<labels.length; ++i) {
+                    var y = this.gutterTop + (grapharea * (i / (labels.length - 1)));
+    
+                    RGraph.Text2(this, {'font':font,
+                                        'size':text_size,
+                                        'x':xpos,
+                                        'y':y,
+                                        'text': labels[i],
+                                        'valign':'center',
+                                        'halign': align,
+                                        'bordered': boxed,
+                                        'tag':'scale'
+                                       });
+                }
+    
+                return;
+            }
+    
+            var gutterTop      = this.gutterTop;
+            var halfTextHeight = this.halfTextHeight;
+            var scale          = this.scale;
+    
+    
+            for (var i=0; i<numYLabels; ++i) {
+                var text = this.scale2.labels[i];
+                RGraph.Text2(this, {'font':font,
+                                    'size':text_size,
+                                    'x':xpos,
+                                    'y':this.gutterTop + this.grapharea - ((this.grapharea / numYLabels) * (i+1)),
+                                    'text': text,
+                                    'valign':'center',
+                                    'halign': align,
+                                    'bordered': boxed,
+                                    'tag':'scale'});
+            }
+    
+            
+            /**
+            * Show the minimum value if its not zero
+            */
+            if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {
+                RG.Text2(this, {'font':font,
+                                'size':text_size,
+                                'x':xpos,
+                                'y':ca.height - this.gutterBottom,
+                                'text': RG.number_format(this,(this.scale2.min.toFixed((prop['chart.scale.decimals']))), units_pre, units_post),
+                                'valign':'center',
+                                'halign': align,
+                                'bordered': boxed,
+                                'tag':'scale'});
+            }
+            
+            co.fill();
+        }
+    
+    
+        /**
+        * This function is used by MSIE only to manually draw the shadow
+        * 
+        * @param array coords The coords for the bar
+        */
+        this.DrawIEShadow = function (coords)
+        {
+            var co   = this.context;
+            var ca   = this.canvas;
+            var prop = this.properties;
+    
+            var prevFillStyle = co.fillStyle;
+            var offsetx       = prop['chart.shadow.offsetx'];
+            var offsety       = prop['chart.shadow.offsety'];
+            
+            co.lineWidth = prop['chart.linewidth'];
+            co.fillStyle = prop['chart.shadow.color'];
+            co.beginPath();
+            
+            // Draw shadow here
+            co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2], coords[3]);
+    
+            co.fill();
+            
+            // Change the fillstyle back to what it was
+            co.fillStyle = prevFillStyle;
+        }
+    
+    
+        /**
+        * Not used by the class during creating the graph, but is used by event handlers
+        * to get the coordinates (if any) of the selected bar
+        * 
+        * @param object e The event object
+        * @param object   OPTIONAL You can pass in the bar object instead of the
+        *                          function using "this"
+        */
+        this.getShape = 
+        this.getBar = function (e)
+        {
+            // This facilitates you being able to pass in the bar object as a parameter instead of
+            // the function getting it from itself
+            var obj = arguments[1] ? arguments[1] : this;
+    
+            var mouseXY = RGraph.getMouseXY(e);
+            var mouseX  = mouseXY[0];
+            var mouseY  = mouseXY[1];  
+            var canvas  = obj.canvas;
+            var context = obj.context;
+            var coords  = obj.coords
+
+            for (var i=0,len=coords.length; i<len; i+=1) {
+            
+                if (obj.coords[i].length == 0) {
+                    continue;
+                }
+
+                var left   = coords[i][0];
+                var top    = coords[i][1];
+                var width  = coords[i][2];
+                var height = coords[i][3];
+                var prop   = obj.properties;
+    
+                if (mouseX >= left && mouseX <= (left + width) && mouseY >= top && mouseY <= (top + height)) {
+
+
+                    if (prop['chart.tooltips']) {
+                        var tooltip = RGraph.parseTooltipText ? RGraph.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];
+                    }
+    
+                    // Work out the dataset
+                    var dataset = 0;
+                    var idx = i;
+
+                    while (idx >=  (typeof(obj.data[dataset]) == 'object' && obj.data[dataset] ? obj.data[dataset].length : 1)) {
+
+                        if (typeof(obj.data[dataset]) == 'number') {
+                            idx -= 1;
+                        } else if (obj.data[dataset]) { // Accounts for null being an object
+                            idx -= obj.data[dataset].length;
+                        } else {
+                            idx -= 1;
+                        }
+
+                        dataset++;
+                    }
+
+                    if (typeof(obj.data[dataset]) == 'number') {
+                        idx = null;
+                    }
+    
+    
+                    return {
+                            0: obj, 1: left, 2: top, 3: width, 4: height, 5: i,
+                            'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip, 'index_adjusted': idx, 'dataset': dataset
+                           };
+                }
+            }
+            
+            return null;
+        }
+
+
+
+
+        /**
+        * This retrives the bar based on the X coordinate only.
+        * 
+        * @param object e The event object
+        * @param object   OPTIONAL You can pass in the bar object instead of the
+        *                          function using "this"
+        */
+        this.getShapeByX = function (e)
+        {
+            var canvas      = e.target;
+            var mouseCoords = RGraph.getMouseXY(e);
+    
+    
+            // This facilitates you being able to pass in the bar object as a parameter instead of
+            // the function getting it from itself
+            var obj = arguments[1] ? arguments[1] : this;
+    
+    
+            /**
+            * Loop through the bars determining if the mouse is over a bar
+            */
+            for (var i=0,len=obj.coords.length; i<len; i++) {
+
+                if (obj.coords[i].length == 0) {
+                    continue;
+                }
+
+                var mouseX = mouseCoords[0];
+                var mouseY = mouseCoords[1];    
+                var left   = obj.coords[i][0];
+                var top    = obj.coords[i][1];
+                var width  = obj.coords[i][2];
+                var height = obj.coords[i][3];
+                var prop   = obj.properties;
+    
+                if (mouseX >= left && mouseX <= (left + width)) {
+                
+                    if (prop['chart.tooltips']) {
+                        var tooltip = RGraph.parseTooltipText ? RGraph.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];
+                    }
+
+    
+    
+                    return {
+                            0: obj, 1: left, 2: top, 3: width, 4: height, 5: i,
+                            'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip
+                           };
+                }
+            }
+            
+            return null;
+        }
+    
+    
+        /**
+        * When you click on the chart, this method can return the Y value at that point. It works for any point on the
+        * chart (that is inside the gutters) - not just points within the Bars.
+        * 
+        * EITHER:
+        * 
+        * @param object arg The event object
+        * 
+        * OR:
+        * 
+        * @param object arg A two element array containing the X and Y coordinates
+        */
+        this.getValue = function (arg)
+        {
+            var co   = this.context;
+            var ca   = this.canvas;
+            var prop = this.properties;
+    
+            if (arg.length == 2) {
+                var mouseX = arg[0];
+                var mouseY = arg[1];
+            } else {
+                var mouseCoords = RGraph.getMouseXY(arg);
+                var mouseX      = mouseCoords[0];
+                var mouseY      = mouseCoords[1];
+            }
+    
+            if (   mouseY < prop['chart.gutter.top']
+                || mouseY > (ca.height - prop['chart.gutter.bottom'])
+                || mouseX < prop['chart.gutter.left']
+                || mouseX > (ca.width - prop['chart.gutter.right'])
+               ) {
+                return null;
+            }
+            
+            if (prop['chart.xaxispos'] == 'center') {
+                var value = (((this.grapharea / 2) - (mouseY - prop['chart.gutter.top'])) / this.grapharea) * (this.scale2.max - this.scale2.min)
+                value *= 2;
+                
+                if (value >= 0) {
+                    value += this.scale2.min;
+                } else {
+                    value -= this.scale2.min;
+                }
+    
+            } else if (prop['chart.xaxispos'] == 'top') {
+                var value = ((this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea) * (this.scale2.max - this.scale2.min)
+                value = this.scale2.max - value;
+                value = Math.abs(value) * -1;
+            } else {
+                var value = ((this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea) * (this.scale2.max - this.scale2.min)
+                value += this.scale2.min;
+            }
+    
+            return value;
+        }
+    
+    
+        /**
+        * This function can be used when the canvas is clicked on (or similar - depending on the event)
+        * to retrieve the relevant Y coordinate for a particular value.
+        * 
+        * @param int value The value to get the Y coordinate for
+        */
+        this.getYCoord = function (value)
+        {
+            if (value > this.scale2.max) {
+                return null;
+            }
+    
+            var co   = this.context;
+            var ca   = this.canvas;
+            var prop = this.properties;
+    
+            var y;
+            var xaxispos = prop['chart.xaxispos'];
+    
+            if (xaxispos == 'top') {
+            
+                // Account for negative numbers
+                if (value < 0) {
+                    value = Math.abs(value);
+                }
+    
+                y = ((value - this.scale2.min) / (this.scale2.max - this.scale2.min)) * this.grapharea;
+                y = y + this.gutterTop
+    
+            } else if (xaxispos == 'center') {
+    
+                y = ((value - this.scale2.min) / (this.scale2.max - this.scale2.min)) * (this.grapharea / 2);
+                y = (this.grapharea / 2) - y;
+                y += this.gutterTop;
+    
+            } else {
+    
+                if (value < this.scale2.min) {
+                    value = this.scale2.min;
+                }
+    
+                y = ((value - this.scale2.min) / (this.scale2.max - this.scale2.min)) * this.grapharea;
+    
+                y = ca.height - this.gutterBottom - y;
+            }
+            
+            return y;
+        }
+    
+    
+    
+        /**
+        * Each object type has its own Highlight() function which highlights the appropriate shape
+        * 
+        * @param object shape The shape to highlight
+        */
+        this.Highlight = function (shape)
+        {
+            // Add the new highlight
+            RGraph.Highlight.Rect(this, shape);
+        }
+    
+    
+    
+        /**
+        * The getObjectByXY() worker method
+        */
+        this.getObjectByXY = function (e)
+        {
+            var ca   = this.canvas;
+            var prop = this.properties;
+    
+            var mouseXY = RGraph.getMouseXY(e);
+    
+            if (
+                   mouseXY[0] >= prop['chart.gutter.left']
+                && mouseXY[0] <= (ca.width - prop['chart.gutter.right'])
+                && mouseXY[1] >= prop['chart.gutter.top']
+                && mouseXY[1] <= (ca.height - prop['chart.gutter.bottom'])
+                ) {
+    
+                return this;
+            }
+        }
+
+
+
+
+        /**
+        * This method handles the adjusting calculation for when the mouse is moved
+        * 
+        * @param object e The event object
+        */
+        this.Adjusting_mousemove = function (e)
+        {
+            /**
+            * Handle adjusting for the Bar
+            */
+            if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {
+    
+                // Rounding the value to the given number of decimals make the chart step
+                var value   = Number(this.getValue(e));
+                var shape   = this.getShapeByX(e);
+
+                if (shape) {
+
+                    RG.Registry.Set('chart.adjusting.shape', shape);
+
+                    if (this.stackedOrGrouped && prop['chart.grouping'] == 'grouped') {
+
+                        var indexes = RG.sequentialIndexToGrouped(shape['index'], this.data);
+
+                        if (typeof this.data[indexes[0]] == 'number') {
+                            this.data[indexes[0]] = Number(value);
+                        } else if (!RG.is_null(this.data[indexes[0]])) {
+                            this.data[indexes[0]][indexes[1]] = Number(value);
+                        }
+                    } else if (typeof this.data[shape['index']] == 'number') {
+
+                        this.data[shape['index']] = Number(value);
+                    }
+    
+                    RG.RedrawCanvas(e.target);
+                    
+                    RG.FireCustomEvent(this, 'onadjust');
+                }
+            }
+        }
+
+
+
+
+        /**
+        * This function positions a tooltip when it is displayed
+        * 
+        * @param obj object    The chart object
+        * @param int x         The X coordinate specified for the tooltip
+        * @param int y         The Y coordinate specified for the tooltip
+        * @param objec tooltip The tooltips DIV element
+        */
+        this.positionTooltip = function (obj, x, y, tooltip, idx)
+        {
+            var prop       = obj.properties;
+            var coordX     = obj.coords[tooltip.__index__][0];
+            var coordY     = obj.coords[tooltip.__index__][1];
+            var coordW     = obj.coords[tooltip.__index__][2];
+            var coordH     = obj.coords[tooltip.__index__][3];
+            var canvasXY   = RGraph.getCanvasXY(obj.canvas);
+            var gutterLeft = prop['chart.gutter.left'];
+            var gutterTop  = prop['chart.gutter.top'];
+            var width      = tooltip.offsetWidth;
+            var height     = tooltip.offsetHeight;
+            var value      = obj.data_arr[tooltip.__index__];
+    
+    
+            // Set the top position
+            tooltip.style.left = 0;
+            tooltip.style.top  = canvasXY[1] + coordY - height - 7 + 'px';
+            
+            /**
+            * If the tooltip is for a negative value - position it underneath the bar
+            */
+            if (value < 0) {
+                tooltip.style.top =  canvasXY[1] + coordY + coordH + 7 + 'px';
+            }
+            
+            
+            // By default any overflow is hidden
+            tooltip.style.overflow = '';
+            
+            // Inverted arrow
+            // data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAFCAMAAACkeOZkAAAAK3RFWHRDcmVhdGlvbiBUaW1lAFNhdCA2IE9jdCAyMDEyIDEyOjQ5OjMyIC0wMDAw2S1RlgAAAAd0SU1FB9wKBgszM4Ed2k4AAAAJcEhZcwAACxIAAAsSAdLdfvwAAAAEZ0FNQQAAsY8L/GEFAAAACVBMVEX/AAC9vb3//+92Pom0AAAAAXRSTlMAQObYZgAAAB1JREFUeNpjYAABRgY4YGRiRDCZYBwQE8qBMEEcAANCACqByy1sAAAAAElFTkSuQmCC
+    
+            // The arrow
+            var img = new Image();
+                img.style.position = 'absolute';
+                img.id = '__rgraph_tooltip_pointer__';
+                if (value >= 0) {
+                    img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAFCAYAAACjKgd3AAAARUlEQVQYV2NkQAN79+797+RkhC4M5+/bd47B2dmZEVkBCgcmgcsgbAaA9GA1BCSBbhAuA/AagmwQPgMIGgIzCD0M0AMMAEFVIAa6UQgcAAAAAElFTkSuQmCC';
+                    img.style.top = (tooltip.offsetHeight - 2) + 'px';
+                } else {
+                    img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAFCAMAAACkeOZkAAAAK3RFWHRDcmVhdGlvbiBUaW1lAFNhdCA2IE9jdCAyMDEyIDEyOjQ5OjMyIC0wMDAw2S1RlgAAAAd0SU1FB9wKBgszM4Ed2k4AAAAJcEhZcwAACxIAAAsSAdLdfvwAAAAEZ0FNQQAAsY8L/GEFAAAACVBMVEX/AAC9vb3//+92Pom0AAAAAXRSTlMAQObYZgAAAB1JREFUeNpjYAABRgY4YGRiRDCZYBwQE8qBMEEcAANCACqByy1sAAAAAElFTkSuQmCC';
+                    img.style.top = '-5px';
+                }
+                
+            tooltip.appendChild(img);
+            
+            // Reposition the tooltip if at the edges:
+            
+            // LEFT edge
+            if ((canvasXY[0] + coordX + (coordW / 2) - (width / 2)) < 10) {
+                tooltip.style.left = (canvasXY[0] + coordX - (width * 0.1)) + (coordW / 2) + 'px';
+                img.style.left = ((width * 0.1) - 8.5) + 'px';
+    
+            // RIGHT edge
+            } else if ((canvasXY[0] + coordX + (width / 2)) > document.body.offsetWidth) {
+                tooltip.style.left = canvasXY[0] + coordX - (width * 0.9) + (coordW / 2) + 'px';
+                img.style.left = ((width * 0.9) - 8.5) + 'px';
+    
+            // Default positioning - CENTERED
+            } else {
+                tooltip.style.left = (canvasXY[0] + coordX + (coordW / 2) - (width * 0.5)) + 'px';
+                img.style.left = ((width * 0.5) - 8.5) + 'px';
+            }
+        }
+
+
+
+
+        /**
+        * This allows for easy specification of gradients
+        */
+        this.parseColors = function ()
+        {
+            // Save the original colors so that they can be restored when the canvas is reset
+            if (this.original_colors.length === 0) {
+                this.original_colors['chart.colors']                = RGraph.array_clone(prop['chart.colors']);
+                this.original_colors['chart.key.colors']            = RGraph.array_clone(prop['chart.key.colors']);
+                this.original_colors['chart.crosshairs.color']      = prop['chart.crosshairs.color'];
+                this.original_colors['chart.highlight.stroke']      = prop['chart.highlight.stroke'];
+                this.original_colors['chart.highlight.fill']        = prop['chart.highlight.fill'];
+                this.original_colors['chart.text.color']            = prop['chart.text.color'];
+                this.original_colors['chart.background.barcolor1']  = prop['chart.background.barcolor1'];
+                this.original_colors['chart.background.barcolor2']  = prop['chart.background.barcolor2'];
+                this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];
+                this.original_colors['chart.strokecolor']           = prop['chart.strokecolor'];
+                this.original_colors['chart.axis.color']            = prop['chart.axis.color'];
+            }
+            
+            
+            // chart.colors
+            var colors = prop['chart.colors'];
+            if (colors) {
+                for (var i=0; i<colors.length; ++i) {
+                    colors[i] = this.parseSingleColorForGradient(colors[i]);
+                }
+            }
+    
+            // chart.key.colors
+            var colors = prop['chart.key.colors'];
+            if (colors) {
+                for (var i=0; i<colors.length; ++i) {
+                    colors[i] = this.parseSingleColorForGradient(colors[i]);
+                }
+            }
+    
+             prop['chart.crosshairs.color']      = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);
+             prop['chart.highlight.stroke']      = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);
+             prop['chart.highlight.fill']        = this.parseSingleColorForGradient(prop['chart.highlight.fill']);
+             prop['chart.text.color']            = this.parseSingleColorForGradient(prop['chart.text.color']);
+             prop['chart.background.barcolor1']  = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);
+             prop['chart.background.barcolor2']  = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);
+             prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);
+             prop['chart.strokecolor']           = this.parseSingleColorForGradient(prop['chart.strokecolor']);
+             prop['chart.axis.color']            = this.parseSingleColorForGradient(prop['chart.axis.color']);
+        }
+    
+    
+    
+        /**
+        * This parses a single color value
+        */
+        this.parseSingleColorForGradient = function (color)
+        {
+            if (!color || typeof(color) != 'string') {
+                return color;
+            }
+    
+            if (color.match(/^gradient\((.*)\)$/i)) {
+                
+                var parts = RegExp.$1.split(':');
+    
+                // Create the gradient
+                var grad = co.createLinearGradient(0,ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);
+    
+                var diff = 1 / (parts.length - 1);
+    
+                grad.addColorStop(0, RG.trim(parts[0]));
+    
+                for (var j=1,len=parts.length; j<len; ++j) {
+                    grad.addColorStop(j * diff, RGraph.trim(parts[j]));
+                }
+            }
+                
+            return grad ? grad : color;
+        }
+    
+    
+    
+        this.DrawBevel = function ()
+        {
+           var coords  = this.coords;
+           var coords2 = this.coords2;
+           
+           var prop    = this.properties;
+           var co      = this.context;
+           var ca      = this.canvas;
+    
+            if (prop['chart.grouping'] == 'stacked') {
+                for (var i=0; i<coords2.length; ++i) {
+                    if (coords2[i] && coords2[i][0] && coords2[i][0][0]) {
+                        
+                        var x = coords2[i][0][0];
+                        var y = coords2[i][0][1];
+                        var w = coords2[i][0][2];
+    
+                        var arr = [];
+                        for (var j=0; j<coords2[i].length; ++j) {
+                            arr.push(coords2[i][j][3]);
+                        }
+                        var h = RGraph.array_sum(arr);
+    
+        
+                        co.save();
+                        
+                            co.strokeStyle = 'black';
+                        
+                            // Clip to the rect
+                            co.beginPath();
+                            co.rect(x, y, w, h);
+                            co.clip();
+                
+                            // Add the shadow
+                            co.shadowColor = 'black';
+                            co.shadowOffsetX = 0;
+                            co.shadowOffsetY = 0;
+                            co.shadowBlur = 20;
+                
+                            co.beginPath();
+                            co.rect(x - 3, y - 3, w + 6, h + 100);
+                            co.lineWidth = 5;
+                            co.stroke();
+                        co.restore();
+                    }
+                }
+            } else {
+    
+                for (var i=0; i<coords.length; ++i) {
+                    if (coords[i]) {
+    
+                        var x = coords[i][0];
+                        var y = coords[i][1];
+                        var w = coords[i][2];
+                        var h = coords[i][3];
+                        
+                        var xaxispos = prop['chart.xaxispos'];
+                        var xaxis_ycoord = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop;
+                        
+                        
+                        co.save();
+                        
+                            co.strokeStyle = 'black';
+                        
+                            // Clip to the rect
+                            co.beginPath();
+                            co.rect(x, y, w, h);
+                            
+                            co.clip();
+                
+                            // Add the shadow
+                            co.shadowColor = 'black';
+                            co.shadowOffsetX = 0;
+                            co.shadowOffsetY = 0;
+                            co.shadowBlur =  20;
+    
+                            if (xaxispos == 'top' || (xaxispos == 'center' && (y + h) > xaxis_ycoord)) {
+                                y = y - 100;
+                                h = h + 100;
+                            } else {
+                                y = y;
+                                h = h + 100;
+                            }
+    
+                            co.beginPath();
+                                co.rect(x - 3, y - 3, w + 6, h + 6);
+                                co.lineWidth = 5;
+                            co.stroke();
+                        co.restore();
+                    }
+                }
+            }
+        }
+
+
+
+
+        /**
+        * This function handles highlighting an entire data-series for the interactive
+        * key
+        * 
+        * @param int index The index of the data series to be highlighted
+        */
+        this.interactiveKeyHighlight = function (index)
+        {
+            this.coords2.forEach(function (value, idx, arr)
+            {
+                if (typeof value[index] == 'object' && value[index]) {
+
+                    var x = value[index][0]
+                    var y = value[index][1]
+                    var w = value[index][2]
+                    var h = value[index][3]
+                    
+                    co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];
+                    co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];
+                    co.lineWidth   = 2;
+                    co.fillRect(x, y, w, h);
+                    co.strokeRect(x, y, w, h);
+                }
+            });
+        }
+
+
+
+
+        /**
+        * Register the object
+        */
+        RGraph.Register(this);
+    }
+
+
+
+
+
+    /*********************************************************************************************************
+    * This is the combined bar and Line class which makes creating bar/line combo charts a little bit easier *
+    /*********************************************************************************************************/
+
+
+
+
+
+
+
+    RGraph.CombinedChart = function ()
+    {
+        /**
+        * Create a default empty array for the objects
+        */
+        this.objects = [];
+        
+        var objects = arguments;
+
+        if (RGraph.is_array(arguments[0])) {
+            objects = arguments[0];
+        }
+
+        for (var i=0; i<objects.length; ++i) {
+
+            this.objects[i] = objects[i];
+
+            /**
+            * Set the Line chart gutters to match the Bar chart gutters
+            */
+            this.objects[i].Set('chart.gutter.left',  this.objects[0].Get('chart.gutter.left'));
+            this.objects[i].Set('chart.gutter.right',  this.objects[0].Get('chart.gutter.right'));
+            this.objects[i].Set('chart.gutter.top',    this.objects[0].Get('chart.gutter.top'));
+            this.objects[i].Set('chart.gutter.bottom', this.objects[0].Get('chart.gutter.bottom'));
+
+            if (this.objects[i].type == 'line') {
+        
+                /**
+                * Set the line chart hmargin
+                */
+                this.objects[i].Set('chart.hmargin', ((this.objects[0].canvas.width - this.objects[0].Get('chart.gutter.right') - this.objects[0].Get('chart.gutter.left')) / this.objects[0].data.length) / 2 );
+                
+                
+                /**
+                * No labels, axes or grid on the Line chart
+                */
+                this.objects[i].Set('chart.noaxes', true);
+                this.objects[i].Set('chart.background.grid', false);
+                this.objects[i].Set('chart.ylabels', false);
+            }
+
+            /**
+            * Resizing
+            */
+            if (this.objects[i].Get('chart.resizable')) {
+                var resizable_object = this.objects[i];
+            }
+        }
+
+        /**
+        * Resizing
+        */
+        if (resizable_object) {
+            /**
+            * This recalculates the Line chart hmargin when the chart is resized
+            */
+            function myOnresizebeforedraw (obj)
+            {
+                var gutterLeft = obj.Get('chart.gutter.left');
+                var gutterRight = obj.Get('chart.gutter.right');
+            
+                obj.Set('chart.hmargin', (obj.canvas.width - gutterLeft - gutterRight) / (obj.original_data[0].length * 2));
+            }
+
+            RGraph.AddCustomEventListener(resizable_object,
+                                          'onresizebeforedraw',
+                                          myOnresizebeforedraw);
+        }
+    }
+
+
+    /**
+    * The Add method can be used to add methods to the CombinedChart object.
+    */
+    RGraph.CombinedChart.prototype.Add = function (obj)
+    {
+        this.objects.push(obj);
+    }
+
+    
+    /**
+    * The Draw method goes through all of the objects drawing them (sequentially)
+    */
+    RGraph.CombinedChart.prototype.Draw = function ()
+    {
+        for (var i=0; i<this.objects.length; ++i) {
+            if (typeof(arguments[i]) == 'function') {
+                arguments[i](this.objects[i]);
+            } else {
+                this.objects[i].Draw();
+            }
+        }
+    }
\ No newline at end of file
diff --git a/mod/questionnaire/javascript/RGraph/RGraph.bipolar.js b/mod/questionnaire/javascript/RGraph/RGraph.bipolar.js
new file mode 100644
index 0000000..7f7951c
--- /dev/null
+++ b/mod/questionnaire/javascript/RGraph/RGraph.bipolar.js
@@ -0,0 +1,1155 @@
+    /**
+    * o-------------------------------------------------------------------------------o
+    * | This file is part of the RGraph package. RGraph is Free software, licensed    |
+    * | under the MIT license - so it's free to use for all purposes. Extended        |
+    * | support is available if required and donations are always welcome! You can    |
+    * | read more here:                                                               |
+    * |                         http://www.rgraph.net/support                         |
+    * o-------------------------------------------------------------------------------o
+    */
+
+    if (typeof(RGraph) == 'undefined') RGraph = {};
+
+    /**
+    * The bi-polar/age frequency constructor.
+    * 
+    * @param string id The id of the canvas
+    * @param array  left  The left set of data points
+    * @param array  right The right set of data points
+    * 
+    * REMEMBER If ymin is implemented you need to update the .getValue() method
+    */
+    RGraph.Bipolar = function (id, left, right)
+    {
+        // Get the canvas and context objects
+        this.id                = id;
+        this.canvas            = document.getElementById(typeof id === 'object' ? id.id : id);
+        this.context           = this.canvas.getContext('2d');
+        this.canvas.__object__ = this;
+        this.type              = 'bipolar';
+        this.coords            = [];
+        this.coordsLeft        = [];
+        this.coordsRight       = [];
+        this.max               = 0;
+        this.isRGraph          = true;
+        this.uid               = RGraph.CreateUID();
+        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();
+        this.coordsText        = [];
+
+
+        /**
+        * Compatibility with older browsers
+        */
+        RGraph.OldBrowserCompat(this.context);
+
+        
+        // The left and right data respectively
+        this.left       = left;
+        this.right      = right;
+        this.data       = [left, right];
+
+        this.properties = {
+            'chart.margin':                 2,
+            'chart.xtickinterval':          null,
+            'chart.labels':                 [],
+            'chart.labels.above':           false,
+            'chart.text.size':              10,
+            'chart.text.color':             'black', // (Simple) gradients are not supported
+            'chart.text.font':              'Arial',
+            'chart.title.left':             '',
+            'chart.title.right':            '',
+            'chart.gutter.center':          60,
+            'chart.gutter.left':            25,
+            'chart.gutter.right':           25,
+            'chart.gutter.top':             25,
+            'chart.gutter.bottom':          25,
+            'chart.title':                  '',
+            'chart.title.background':       null,
+            'chart.title.hpos':             null,
+            'chart.title.vpos':             null,
+            'chart.title.bold':             true,
+            'chart.title.font':             null,
+            'chart.title.x':                null,
+            'chart.title.y':                null,
+            'chart.title.halign':           null,
+            'chart.title.valign':           null,
+            'chart.colors':                 ['#0f0'],
+            'chart.contextmenu':            null,
+            'chart.tooltips':               null,
+            'chart.tooltips.effect':         'fade',
+            'chart.tooltips.css.class':      'RGraph_tooltip',
+            'chart.tooltips.highlight':     true,
+            'chart.tooltips.event':         'onclick',
+            'chart.highlight.stroke':       'rgba(0,0,0,0)',
+            'chart.highlight.fill':         'rgba(255,255,255,0.7)',
+            'chart.units.pre':              '',
+            'chart.units.post':             '',
+            'chart.shadow':                 false,
+            'chart.shadow.color':           '#666',
+            'chart.shadow.offsetx':         3,
+            'chart.shadow.offsety':         3,
+            'chart.shadow.blur':            3,
+            'chart.annotatable':            false,
+            'chart.annotate.color':         'black',
+            'chart.xmax':                   null,
+            'chart.xmin':                   0,
+            'chart.scale.decimals':         null,
+            'chart.scale.point':            '.',
+            'chart.scale.thousand':         ',',
+            'chart.axis.color':             'black',
+            'chart.zoom.factor':            1.5,
+            'chart.zoom.fade.in':           true,
+            'chart.zoom.fade.out':          true,
+            'chart.zoom.hdir':              'right',
+            'chart.zoom.vdir':              'down',
+            'chart.zoom.frames':            25,
+            'chart.zoom.delay':             16.666,
+            'chart.zoom.shadow':            true,
+            'chart.zoom.background':        true,
+            'chart.zoom.action':            'zoom',
+            'chart.resizable':              false,
+            'chart.resize.handle.background': null,
+            'chart.strokestyle':            'rgba(0,0,0,0)',
+            'chart.events.mousemove':       null,
+            'chart.events.click':           null,
+            'chart.linewidth':              1,
+            'chart.noaxes':                 false,
+            'chart.xlabels':                true,
+            'chart.numyticks':              null,
+            'chart.numxticks':              5,
+            'chart.axis.linewidth':         1,
+            'chart.labels.count':           5
+        }
+
+        // Pad the arrays so they're the same size
+        while (this.left.length < this.right.length) this.left.push(0);
+        while (this.left.length > this.right.length) this.right.push(0);
+        
+        /**
+        * Set the default for the number of Y tickmarks
+        */
+        this.properties['chart.numyticks'] = this.left.length;
+
+        
+
+
+        /**
+        * Create the dollar objects so that functions can be added to them
+        */
+        var linear_data = RGraph.array_linearize(this.left, this.right);
+        for (var i=0; i<linear_data.length; ++i) {
+            this['$' + i] = {};
+        }
+
+
+        /**
+        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen
+        * done already
+        */
+        if (!this.canvas.__rgraph_aa_translated__) {
+            this.context.translate(0.5,0.5);
+            
+            this.canvas.__rgraph_aa_translated__ = true;
+        }
+
+
+
+
+        ///////////////////////////////// SHORT PROPERTIES /////////////////////////////////
+
+
+
+
+        var RG   = RGraph;
+        var ca   = this.canvas;
+        var co   = ca.getContext('2d');
+        var prop = this.properties;
+        //var $jq  = jQuery;
+
+
+
+
+        //////////////////////////////////// METHODS ///////////////////////////////////////
+
+
+
+
+        /**
+        * The setter
+        * 
+        * @param name  string The name of the parameter to set
+        * @param value mixed  The value of the paraneter 
+        */
+        this.Set = function (name, value)
+        {
+            name = name.toLowerCase();
+    
+            /**
+            * This should be done first - prepend the propertyy name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            prop[name] = value;
+    
+            return this;
+        }
+
+
+
+
+        /**
+        * The getter
+        * 
+        * @param name string The name of the parameter to get
+        */
+        this.Get = function (name)
+        {
+            /**
+            * This should be done first - prepend the property name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            return this.properties[name.toLowerCase()];
+        }
+
+
+
+
+        /**
+        * Draws the graph
+        */
+        this.Draw = function ()
+        {
+            /**
+            * Fire the onbeforedraw event
+            */
+            RG.FireCustomEvent(this, 'onbeforedraw');
+    
+    
+            /**
+            * Parse the colors. This allows for simple gradient syntax
+            */
+            if (!this.colorsParsed) {
+                this.parseColors();
+                
+                // Don't want to do this again
+                this.colorsParsed = true;
+            }
+    
+    
+            /**
+            * This is new in May 2011 and facilitates indiviual gutter settings,
+            * eg chart.gutter.left
+            */
+            this.gutterLeft   = prop['chart.gutter.left'];
+            this.gutterRight  = prop['chart.gutter.right'];
+            this.gutterTop    = prop['chart.gutter.top'];
+            this.gutterBottom = prop['chart.gutter.bottom'];
+            
+    
+    
+            // Reset the data to what was initially supplied
+            this.left  = this.data[0];
+            this.right = this.data[1];
+            
+            // Sequential color index
+            this.sequentialColorIndex = 0;
+    
+    
+            /**
+            * Reset the coords array
+            */
+            this.coords = [];
+    
+            this.GetMax();
+            this.DrawAxes();
+            this.DrawTicks();
+            this.DrawLeftBars();
+            this.DrawRightBars();
+            
+            // Redraw the bars so that shadows on not on top
+            this.RedrawBars();
+            
+            this.DrawAxes();
+    
+            this.DrawLabels();
+            this.DrawTitles();
+    
+    
+            /**
+            * Setup the context menu if required
+            */
+            if (prop['chart.contextmenu']) {
+                RG.ShowContext(this);
+            }
+    
+            
+            /**
+            * This function enables resizing
+            */
+            if (prop['chart.resizable']) {
+                RG.AllowResizing(this);
+            }
+    
+    
+            /**
+            * This installs the event listeners
+            */
+            RG.InstallEventListeners(this);
+    
+    
+            /**
+            * Fire the RGraph ondraw event
+            */
+            RG.FireCustomEvent(this, 'ondraw');
+            
+            return this;
+        }
+
+
+
+
+        /**
+        * Draws the axes
+        */
+        this.DrawAxes = function ()
+        {
+            // Set the linewidth
+            co.lineWidth = prop['chart.axis.linewidth'] + 0.001;
+    
+    
+            // Draw the left set of axes
+            co.beginPath();
+            co.strokeStyle = prop['chart.axis.color'];
+    
+            this.axisWidth  = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;
+            this.axisHeight = ca.height - this.gutterTop - this.gutterBottom;
+            
+            
+            // This must be here so that the two above variables are calculated
+            if (prop['chart.noaxes']) {
+                return;
+            }
+    
+            co.moveTo(this.gutterLeft, Math.round( ca.height - this.gutterBottom));
+            co.lineTo(this.gutterLeft + this.axisWidth, Math.round( ca.height - this.gutterBottom));
+            
+            co.moveTo(Math.round( this.gutterLeft + this.axisWidth), ca.height - this.gutterBottom);
+            co.lineTo(Math.round( this.gutterLeft + this.axisWidth), this.gutterTop);
+            
+            co.stroke();
+    
+    
+            // Draw the right set of axes
+            co.beginPath();
+    
+            var x = this.gutterLeft + this.axisWidth + prop['chart.gutter.center'];
+            
+            co.moveTo(Math.round( x), this.gutterTop);
+            co.lineTo(Math.round( x), ca.height - this.gutterBottom);
+            
+            co.moveTo(Math.round( x), Math.round( ca.height - this.gutterBottom));
+            co.lineTo(ca.width - this.gutterRight, Math.round( ca.height - this.gutterBottom));
+    
+            co.stroke();
+        }
+
+
+
+
+        /**
+        * Draws the tick marks on the axes
+        */
+        this.DrawTicks = function ()
+        {
+            // Set the linewidth
+            co.lineWidth = prop['chart.axis.linewidth'] + 0.001;
+    
+            var numDataPoints = this.left.length;
+            var barHeight     = ( (ca.height - this.gutterTop - this.gutterBottom)- (this.left.length * (prop['chart.margin'] * 2) )) / numDataPoints;
+    
+            // Store this for later
+            this.barHeight = barHeight;
+    
+            // If no axes - no tickmarks
+            if (prop['chart.noaxes']) {
+                return;
+            }
+    
+            // Draw the left Y tick marks
+            if (prop['chart.numyticks'] > 0) {
+                co.beginPath();
+                    for (var i=0; i<prop['chart.numyticks']; ++i) {
+                        var y = prop['chart.gutter.top'] + (((ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numyticks']) * i);
+                        co.moveTo(this.gutterLeft + this.axisWidth , y);
+                        co.lineTo(this.gutterLeft + this.axisWidth + 3, y);
+                    }
+                co.stroke();
+    
+                //Draw the right axis Y tick marks
+                co.beginPath();
+                    for (var i=0; i<prop['chart.numyticks']; ++i) {
+                        var y = prop['chart.gutter.top'] + (((ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numyticks']) * i);
+                        co.moveTo(this.gutterLeft + this.axisWidth + prop['chart.gutter.center'], y);
+                        co.lineTo(this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] - 3, y);
+                    }
+                co.stroke();
+            }
+            
+            
+            
+            /**
+            * X tickmarks
+            */
+            if (prop['chart.numxticks'] > 0) {
+                var xInterval = this.axisWidth / prop['chart.numxticks'];
+        
+                // Is chart.xtickinterval specified ? If so, use that.
+                if (typeof(prop['chart.xtickinterval']) == 'number') {
+                    xInterval = prop['chart.xtickinterval'];
+                }
+        
+                
+                // Draw the left sides X tick marks
+                for (i=this.gutterLeft; i<(this.gutterLeft + this.axisWidth); i+=xInterval) {
+                    co.beginPath();
+                    co.moveTo(Math.round( i), ca.height - this.gutterBottom);
+                    co.lineTo(Math.round( i), (ca.height - this.gutterBottom) + 4);
+                    co.closePath();
+                    
+                    co.stroke();
+                }
+        
+                // Draw the right sides X tick marks
+                var stoppingPoint = ca.width - this.gutterRight;
+        
+                for (i=(this.gutterLeft + this.axisWidth + prop['chart.gutter.center'] + xInterval); i<=stoppingPoint; i+=xInterval) {
+                    co.beginPath();
+                        co.moveTo(Math.round(i), ca.height - this.gutterBottom);
+                        co.lineTo(Math.round(i), (ca.height - this.gutterBottom) + 4);
+                    co.closePath();
+                    
+                    co.stroke();
+                }
+            }
+        }
+
+
+
+
+        /**
+        * Figures out the maximum value, or if defined, uses xmax
+        */
+        this.GetMax = function()
+        {
+            var dec  = prop['chart.scale.decimals'];
+            
+            // chart.xmax defined
+            if (prop['chart.xmax']) {
+    
+                var max = prop['chart.xmax'];
+                var min = prop['chart.xmin'];
+    
+                this.scale2 = RG.getScale2(this, {
+                                                      'max':max,
+                                                      'min':min,
+                                                      'strict': true,
+                                                      'scale.thousand':prop['chart.scale.thousand'],
+                                                      'scale.point':prop['chart.scale.point'],
+                                                      'scale.decimals':prop['chart.scale.decimals'],
+                                                      'ylabels.count':prop['chart.labels.count'],
+                                                      'scale.round':prop['chart.scale.round'],
+                                                      'units.pre': prop['chart.units.pre'],
+                                                      'units.post': prop['chart.units.post']
+                                                     });
+                this.max = this.scale2.max;
+                this.min = this.scale2.min;
+    
+    
+            /**
+            * Generate the scale ourselves
+            */
+            } else {
+    
+                var max = Math.max(RG.array_max(this.left), RG.array_max(this.right));
+    
+                this.scale2 = RG.getScale2(this, {
+                                                      'max':max,
+                                                      //'strict': true,
+                                                      'min':prop['chart.xmin'],
+                                                      'scale.thousand':prop['chart.scale.thousand'],
+                                                      'scale.point':prop['chart.scale.point'],
+                                                      'scale.decimals':prop['chart.scale.decimals'],
+                                                      'ylabels.count':prop['chart.labels.count'],
+                                                      'scale.round':prop['chart.scale.round'],
+                                                      'units.pre': prop['chart.units.pre'],
+                                                      'units.post': prop['chart.units.post']
+                                                     });
+    
+    
+                this.max = this.scale2.max;
+                this.min = this.scale2.min;
+            }
+    
+            // Don't need to return it as it is stored in this.max
+        }
+
+
+
+
+        /**
+        * Function to draw the left hand bars
+        */
+        this.DrawLeftBars = function ()
+        {
+            // Set the stroke colour
+            co.strokeStyle = prop['chart.strokestyle'];
+            
+            // Set the linewidth
+            co.lineWidth = prop['chart.linewidth'];
+    
+            for (i=0; i<this.left.length; ++i) {
+
+                /**
+                * Turn on a shadow if requested
+                */
+                if (prop['chart.shadow']) {
+                    co.shadowColor   = prop['chart.shadow.color'];
+                    co.shadowBlur    = prop['chart.shadow.blur'];
+                    co.shadowOffsetX = prop['chart.shadow.offsetx'];
+                    co.shadowOffsetY = prop['chart.shadow.offsety'];
+                }
+    
+                co.beginPath();
+                    
+                    // If chart.colors.sequential is specified - handle that
+                    if (prop['chart.colors.sequential']) {
+                        co.fillStyle = prop['chart.colors'][this.sequentialColorIndex];
+                        this.sequentialColorIndex++;
+
+                    } else {
+                        co.fillStyle = prop['chart.colors'][0];
+                    }
+                    
+                    /**
+                    * Work out the coordinates
+                    */
+    
+                    var width = (( (this.left[i] - this.min) / (this.max - this.min)) *  this.axisWidth);
+    
+                    var coords = [Math.round( this.gutterLeft + this.axisWidth - width),
+                                  Math.round( this.gutterTop + (i * ( this.axisHeight / this.left.length)) + prop['chart.margin']),
+                                  width,
+                                  this.barHeight];
+    
+                    // Draw the IE shadow if necessary
+                    if (ISOLD && prop['chart.shadow']) {
+                        this.DrawIEShadow(coords);
+                    }
+        
+                    
+                    if (this.left[i]) {
+                        co.strokeRect(coords[0], coords[1], coords[2], coords[3]);
+                        co.fillRect(coords[0], coords[1], coords[2], coords[3]);
+                    }
+    
+                co.stroke();
+                co.fill();
+    
+                /**
+                * Add the coordinates to the coords array
+                */
+                this.coords.push([coords[0],coords[1],coords[2],coords[3]]);
+                this.coordsLeft.push([coords[0],coords[1],coords[2],coords[3]]);
+            }
+    
+            /**
+            * Turn off any shadow
+            */
+            RG.NoShadow(this);
+            
+            // Reset the linewidth
+            co.lineWidth = 1;
+        }
+
+
+
+
+        /**
+        * Function to draw the right hand bars
+        */
+        this.DrawRightBars = function ()
+        {
+            // Set the stroke colour
+            co.strokeStyle = prop['chart.strokestyle'];
+            
+            // Set the linewidth
+            co.lineWidth = prop['chart.linewidth'];
+                
+            /**
+            * Turn on a shadow if requested
+            */
+            if (prop['chart.shadow']) {
+                co.shadowColor   = prop['chart.shadow.color'];
+                co.shadowBlur    = prop['chart.shadow.blur'];
+                co.shadowOffsetX = prop['chart.shadow.offsetx'];
+                co.shadowOffsetY = prop['chart.shadow.offsety'];
+            }
+    
+            for (var i=0; i<this.right.length; ++i) {
+    
+                co.beginPath();
+    
+                    // If chart.colors.sequential is specified - handle that
+                    if (prop['chart.colors.sequential']) {
+                        co.fillStyle = prop['chart.colors'][this.sequentialColorIndex++];
+                    } else {
+                        co.fillStyle = prop['chart.colors'][0];
+                    }
+        
+        
+                    var width = (((this.right[i] - this.min) / (this.max - this.min)) * this.axisWidth);
+    
+                    var coords = [
+                                  Math.round( this.gutterLeft + this.axisWidth + prop['chart.gutter.center']),
+                                  Math.round( prop['chart.margin'] + (i * (this.axisHeight / this.right.length)) + this.gutterTop),
+                                  width,
+                                  this.barHeight
+                                ];
+        
+                        // Draw the IE shadow if necessary
+                        if (ISOLD && prop['chart.shadow']) {
+                            this.DrawIEShadow(coords);
+                        }
+                    if (this.right[i]) {
+                        co.strokeRect(Math.round( coords[0]), Math.round( coords[1]), coords[2], coords[3]);
+                        co.fillRect(Math.round( coords[0]), Math.round( coords[1]), coords[2], coords[3]);
+                    }
+    
+                co.closePath();
+            
+                /**
+                * Add the coordinates to the coords array
+                */
+                this.coords.push([coords[0],coords[1],coords[2],coords[3]]);
+                this.coordsRight.push([coords[0],coords[1],coords[2],coords[3]]);
+            }
+            
+            co.stroke();
+    
+            /**
+            * Turn off any shadow
+            */
+            RG.NoShadow(this);
+            
+            // Reset the linewidth
+            co.lineWidth = 1;
+        }
+
+
+
+
+        /**
+        * Draws the titles
+        */
+        this.DrawLabels = function ()
+        {
+            co.fillStyle = prop['chart.text.color'];
+
+            //var labelPoints = new Array();
+            var font   = prop['chart.text.font'];
+            var size   = prop['chart.text.size'];
+            var labels = prop['chart.labels'];
+            var barAreaHeight = ca.height - this.gutterTop - this.gutterBottom;
+            
+            for (var i=0,len=labels.length; i<len; i+=1) {
+                RG.Text2(this, {'font':font,
+                                'size':size,
+                                'x':this.gutterLeft + this.axisWidth + (prop['chart.gutter.center'] / 2),
+                                'y':this.gutterTop + ((barAreaHeight / labels.length) * (i)) + ((barAreaHeight / labels.length) / 2),
+                                'text':String(labels[i] ? String(labels[i]) : ''),
+                                'halign':'center',
+                                'valign':'center',
+                                'marker':false,
+                                'tag': 'labels'
+                               });
+            }
+            
+/*
+* OLD STYLE LABELS
+* 
+            var max = Math.max(this.left.length, this.right.length);
+            
+            for (i=0; i<max; ++i) {
+                var barAreaHeight = ca.height - this.gutterTop - this.gutterBottom;
+                var barHeight     = barAreaHeight / this.left.length;
+                var yPos          = (i * barAreaHeight) + this.gutterTop;
+    
+                labelPoints.push(this.gutterTop + (i * barHeight) + (barHeight / 2) + 5);
+            }
+    
+            for (i=0; i<labelPoints.length; ++i) {
+    
+                RG.Text2(this, {'font':prop['chart.text.font'],
+                                    'size':prop['chart.text.size'],
+                                    'x':this.gutterLeft + this.axisWidth + (prop['chart.gutter.center'] / 2),
+                                    'y':labelPoints[i],
+                                    'text':String(prop['chart.labels'][i] ? prop['chart.labels'][i] : ''),
+                                    'halign':'center',
+                                    'tag': 'labels'
+                                   });
+            }
+*/
+
+
+
+
+            if (prop['chart.xlabels']) {
+            
+                var grapharea = (ca.width - prop['chart.gutter.center'] - this.gutterLeft - this.gutterRight) / 2;
+
+                // Now draw the X labels for the left hand side
+                for (var i=0; i<this.scale2.labels.length; ++i) {
+                    RG.Text2(this, {'font':font,
+                                        'size':size,
+                                        'x':this.gutterLeft + ((grapharea / this.scale2.labels.length) * i),
+                                        'y':ca.height - this.gutterBottom + 3,
+                                        'text':this.scale2.labels[this.scale2.labels.length - i - 1],
+                                        'valign':'top',
+                                        'halign':'center',
+                                        'tag': 'scale'
+                                       });
+                    
+                    // Draw the scale for the right hand side
+                    RG.Text2(this, {'font':font,
+                                        'size':size,
+                                        'x':this.gutterLeft+ grapharea + prop['chart.gutter.center'] + ((grapharea / this.scale2.labels.length) * (i + 1)),
+                                        'y':ca.height - this.gutterBottom + 3,
+                                        'text':this.scale2.labels[i],
+                                        'valign':'top',
+                                        'halign':'center',
+                                        'tag': 'scale'
+                                       });
+                }
+            }
+            
+            /**
+            * Draw above labels
+            */
+            if (prop['chart.labels.above']) {
+                
+                // Draw the left sides above labels
+                for (var i=0; i<this.coordsLeft.length; ++i) {
+    
+                    if (typeof(this.left[i]) != 'number') {
+                        continue;
+                    }
+    
+                    var coords = this.coordsLeft[i];
+                    RG.Text2(this, {'font':font,
+                                        'size':size,
+                                        'x':coords[0] - 5,
+                                        'y':coords[1] + (coords[3] / 2),
+                                        'text':RG.number_format(this, this.left[i], prop['chart.units.pre'], prop['chart.units.post']),
+                                        'valign':'center',
+                                        'halign':'right',
+                                        'tag':'labels.above'
+                                       });
+                }
+                
+                // Draw the right sides above labels
+                for (i=0; i<this.coordsRight.length; ++i) {
+    
+                    if (typeof(this.right[i]) != 'number') {
+                        continue;
+                    }
+    
+                    var coords = this.coordsRight[i];
+                    RG.Text2(this, {'font':font,
+                                        'size':size,
+                                        'x':coords[0] + coords[2] +  5,
+                                        'y':coords[1] + (coords[3] / 2),
+                                        'text':RG.number_format(this, this.right[i], prop['chart.units.pre'], prop['chart.units.post']),
+                                        'valign':'center',
+                                        'halign':'left',
+                                        'tag': 'labels.above'
+                                       });
+                }
+            }
+        }
+
+
+
+
+        /**
+        * Draws the titles
+        */
+        this.DrawTitles = function ()
+        {
+            RG.Text2(this, {'font':prop['chart.text.font'],
+                         'size':prop['chart.text.size'],
+                         'x':this.gutterLeft + 5,
+                         'y':this.gutterTop - 5,
+                         'text':String(prop['chart.title.left']),
+                         'halign':'left',
+                         'valign':'bottom',
+                         'tag': 'title.left'
+                        });
+    
+            RG.Text2(this, {'font':prop['chart.text.font'],
+                         'size':prop['chart.text.size'],
+                         'x': ca.width - this.gutterRight - 5,
+                         'y':this.gutterTop - 5,
+                         'text':String(prop['chart.title.right']),
+                         'halign':'right',
+                         'valign':'bottom',
+                         'tag': 'title.right'
+                        });
+    
+    
+            
+            // Draw the main title for the whole chart
+            RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : null);
+        }
+
+
+
+
+        /**
+        * This function is used by MSIE only to manually draw the shadow
+        * 
+        * @param array coords The coords for the bar
+        */
+        this.DrawIEShadow = function (coords)
+        {
+            var prevFillStyle = co.fillStyle;
+            var offsetx = prop['chart.shadow.offsetx'];
+            var offsety = prop['chart.shadow.offsety'];
+            
+            co.lineWidth = prop['chart.linewidth'];
+            co.fillStyle = prop['chart.shadow.color'];
+            co.beginPath();
+            
+            // Draw shadow here
+            co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2],coords[3]);
+    
+            co.fill();
+            
+            // Change the fillstyle back to what it was
+            co.fillStyle = prevFillStyle;
+        }
+
+
+
+
+        /**
+        * Returns the appropriate focussed bar coordinates
+        * 
+        * @param e object The event object
+        */
+        this.getShape = 
+        this.getBar = function (e)
+        {
+            var canvas      = this.canvas;
+            var context     = this.context;
+            var mouseCoords = RG.getMouseXY(e);
+    
+            /**
+            * Loop through the bars determining if the mouse is over a bar
+            */
+            for (var i=0; i<this.coords.length; i++) {
+    
+                var mouseX = mouseCoords[0];
+                var mouseY = mouseCoords[1];
+                var left   = this.coords[i][0];
+                var top    = this.coords[i][1];
+                var width  = this.coords[i][2];
+                var height = this.coords[i][3];
+    
+                if (mouseX >= left && mouseX <= (left + width) && mouseY >= top && mouseY <= (top + height) ) {
+                
+                    var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);
+    
+                    return {
+                            0: this,1: left,2: top,3: width,4: height,5: i,
+                            'object': this, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip
+                           };
+                }
+            }
+    
+            return null;
+        }
+
+
+
+
+        /**
+        * Each object type has its own Highlight() function which highlights the appropriate shape
+        * 
+        * @param object shape The shape to highlight
+        */
+        this.Highlight = function (shape)
+        {
+            // Add the new highlight
+            RG.Highlight.Rect(this, shape);
+        }
+
+
+
+
+        /**
+        * When you click on the canvas, this will return the relevant value (if any)
+        * 
+        * REMEMBER This function will need updating if the Bipolar ever gets chart.ymin
+        * 
+        * @param object e The event object
+        */
+        this.getValue = function (e)
+        {
+            var obj     = e.target.__object__;
+            var mouseXY = RG.getMouseXY(e);
+            var mouseX  = mouseXY[0];
+            
+            /**
+            * Left hand side
+            */
+            if (mouseX > this.gutterLeft && mouseX < ( (ca.width / 2) - (prop['chart.gutter.center'] / 2) )) {
+                var value = (mouseX - prop['chart.gutter.left']) / this.axisWidth;
+                    value = this.max - (value * this.max);
+            }
+            
+            /**
+            * Right hand side
+            */
+            if (mouseX < (ca.width -  this.gutterRight) && mouseX > ( (ca.width / 2) + (prop['chart.gutter.center'] / 2) )) {
+                var value = (mouseX - prop['chart.gutter.left'] - this.axisWidth - prop['chart.gutter.center']) / this.axisWidth;
+                    value = (value * this.max);
+            }
+            
+            return value;
+        }
+
+
+
+
+        /**
+        * The getObjectByXY() worker method. Don't call this call:
+        * 
+        * RGraph.ObjectRegistry.getObjectByXY(e)
+        * 
+        * @param object e The event object
+        */
+        this.getObjectByXY = function (e)
+        {
+            var mouseXY = RG.getMouseXY(e);
+    
+            if (
+                   mouseXY[0] > prop['chart.gutter.left']
+                && mouseXY[0] < (ca.width - prop['chart.gutter.right'])
+                && mouseXY[1] > prop['chart.gutter.top']
+                && mouseXY[1] < (ca.height - prop['chart.gutter.bottom'])
+                ) {
+    
+                return this;
+            }
+        }
+
+
+
+
+        /**
+        * This function positions a tooltip when it is displayed
+        * 
+        * @param obj object    The chart object
+        * @param int x         The X coordinate specified for the tooltip
+        * @param int y         The Y coordinate specified for the tooltip
+        * @param objec tooltip The tooltips DIV element
+        */
+        this.positionTooltip = function (obj, x, y, tooltip, idx)
+        {
+            var coordX     = obj.coords[tooltip.__index__][0];
+            var coordY     = obj.coords[tooltip.__index__][1];
+            var coordW     = obj.coords[tooltip.__index__][2];
+            var coordH     = obj.coords[tooltip.__index__][3];
+            var canvasXY   = RG.getCanvasXY(obj.canvas);
+            var gutterLeft = obj.Get('chart.gutter.left');
+            var gutterTop  = obj.Get('chart.gutter.top');
+            var width      = tooltip.offsetWidth;
+            var height     = tooltip.offsetHeight;
+    
+            // Set the top position
+            tooltip.style.left = 0;
+            tooltip.style.top  = canvasXY[1] + coordY - height - 7 + 'px';
+            
+            // By default any overflow is hidden
+            tooltip.style.overflow = '';
+    
+            // The arrow
+            var img = new Image();
+                img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAFCAYAAACjKgd3AAAARUlEQVQYV2NkQAN79+797+RkhC4M5+/bd47B2dmZEVkBCgcmgcsgbAaA9GA1BCSBbhAuA/AagmwQPgMIGgIzCD0M0AMMAEFVIAa6UQgcAAAAAElFTkSuQmCC';
+                img.style.position = 'absolute';
+                img.id = '__rgraph_tooltip_pointer__';
+                img.style.top = (tooltip.offsetHeight - 2) + 'px';
+            tooltip.appendChild(img);
+            
+            // Reposition the tooltip if at the edges:
+            
+            // LEFT edge
+            if ((canvasXY[0] + coordX + (coordW / 2)- (width / 2)) < 0) {
+                tooltip.style.left = (canvasXY[0] + coordX - (width * 0.1)) + (coordW / 2) + 'px';
+                img.style.left = ((width * 0.1) - 8.5) + 'px';
+    
+            // RIGHT edge
+            } else if ((canvasXY[0] + coordX + width) > document.body.offsetWidth) {
+                tooltip.style.left = canvasXY[0] + coordX - (width * 0.9) + (coordW / 2) + 'px';
+                img.style.left = ((width * 0.9) - 8.5) + 'px';
+    
+            // Default positioning - CENTERED
+            } else {
+                tooltip.style.left = (canvasXY[0] + coordX + (coordW / 2) - (width * 0.5)) + 'px';
+                img.style.left = ((width * 0.5) - 8.5) + 'px';
+            }
+        }
+
+
+
+
+        /**
+        * Redraw the bar so that the shadow is NOT on top
+        */
+        this.RedrawBars = function ()
+        {
+            var coords = this.coords;
+            var len    = coords.length;
+            
+            // Reset the sequentail color index
+            this.sequentialColorIndex = 0;
+    
+            co.beginPath();
+    
+                // Turn off shadow
+                RG.NoShadow(this);
+    
+                // Set the stroke color
+                co.strokeStyle = prop['chart.strokestyle'];
+                
+                // Set the linewidth
+                co.lineWidth = prop['chart.linewidth'];
+    
+                for (var i=0; i<len; ++i) {
+    
+                    // No redrawing occurs if there is no value
+                    if (coords[i][2] > 0) {
+                        
+                        if (prop['chart.colors.sequential']) {
+                            co.fillStyle = prop['chart.colors'][this.sequentialColorIndex++];
+                        } else {
+                            co.fillStyle = prop['chart.colors'][0];
+                        }
+        
+                        // Draw the bar itself
+                        co.strokeRect(coords[i][0], coords[i][1], coords[i][2], coords[i][3]);
+                        co.fillRect(coords[i][0], coords[i][1], coords[i][2], coords[i][3]);
+
+                    } else {
+
+                        // Even if there's no redrawing - the color index needs incrementing
+                        this.sequentialColorIndex++
+                    }
+                }
+            co.stroke();
+            co.fill();
+        }
+
+
+
+
+        /**
+        * Returns the X coords for a value. Returns two coords because there are... two scales.
+        * 
+        * @param number value The value to get the coord for
+        */
+        this.getXCoord = function (value)
+        {
+            if (value > this.max || value < 0) {
+                return null;
+            }
+    
+            var ret = [];
+            
+            // The offset into the graph area
+            var offset = ((value / this.max) * this.axisWidth);
+            
+            // Get the coords (one fo each side)
+            ret[0] = (this.gutterLeft + this.axisWidth) - offset;
+            ret[1] = (ca.width - this.gutterRight - this.axisWidth) + offset;
+            
+            return ret;
+    
+        }
+
+
+
+
+        /**
+        * This allows for easy specification of gradients
+        */
+        this.parseColors = function ()
+        {
+            var props = this.properties;
+            var colors = props['chart.colors'];
+    
+            for (var i=0; i<colors.length; ++i) {
+                colors[i] = this.parseSingleColorForGradient(colors[i]);
+            }
+            
+            props['chart.highlight.stroke'] = this.parseSingleColorForGradient(props['chart.highlight.stroke']);
+            props['chart.highlight.fill']   = this.parseSingleColorForGradient(props['chart.highlight.fill']);
+            props['chart.axis.color']       = this.parseSingleColorForGradient(props['chart.axis.color']);
+            props['chart.strokestyle']      = this.parseSingleColorForGradient(props['chart.strokestyle']);
+        }
+
+
+
+
+        /**
+        * This parses a single color value
+        */
+        this.parseSingleColorForGradient = function (color)
+        {
+            if (!color || typeof(color) != 'string') {
+                return color;
+            }
+    
+            if (color.match(/^gradient\((.*)\)$/i)) {
+                
+                var parts = RegExp.$1.split(':');
+    
+                // Create the gradient
+                var grad = co.createLinearGradient(prop['chart.gutter.left'],0,ca.width - prop['chart.gutter.right'],0);
+    
+                var diff = 1 / (parts.length - 1);
+    
+                grad.addColorStop(0, RG.trim(parts[0]));
+    
+                for (var j=1; j<parts.length; ++j) {
+                    grad.addColorStop(j * diff, RG.trim(parts[j]));
+                }
+            }
+                
+            return grad ? grad : color;
+        }
+
+
+
+
+        /**
+        * Objects are now always registered so that when RGraph.Redraw()
+        * is called this chart will be redrawn.
+        */
+        RG.Register(this);
+    }
\ No newline at end of file
diff --git a/mod/questionnaire/javascript/RGraph/RGraph.common.core.js b/mod/questionnaire/javascript/RGraph/RGraph.common.core.js
new file mode 100644
index 0000000..365076f
--- /dev/null
+++ b/mod/questionnaire/javascript/RGraph/RGraph.common.core.js
@@ -0,0 +1,4057 @@
+    /**
+    * o-------------------------------------------------------------------------------o
+    * | This file is part of the RGraph package. RGraph is Free software, licensed    |
+    * | under the MIT license - so it's free to use for all purposes. Extended        |
+    * | support is available if required and donations are always welcome! You can    |
+    * | read more here:                                                               |
+    * |                         http://www.rgraph.net/support                         |
+    * o-------------------------------------------------------------------------------o
+    */
+
+    /**
+    * Initialise the various objects
+    */
+    if (typeof(RGraph) == 'undefined') RGraph = {isRGraph:true,type:'common'};
+
+    RGraph.Highlight      = {};
+    RGraph.Registry       = {};
+    RGraph.Registry.store = [];
+    RGraph.Registry.store['chart.event.handlers']       = [];
+    RGraph.Registry.store['__rgraph_event_listeners__'] = []; // Used in the new system for tooltips
+    RGraph.background     = {};
+    RGraph.objects        = [];
+    RGraph.Resizing       = {};
+    RGraph.events         = [];
+    RGraph.cursor         = [];
+    
+    RGraph.HTML = RGraph.HTML || {};
+
+    RGraph.ObjectRegistry                    = {};
+    RGraph.ObjectRegistry.objects            = {};
+    RGraph.ObjectRegistry.objects.byUID      = [];
+    RGraph.ObjectRegistry.objects.byCanvasID = [];
+
+
+    /**
+    * Some "constants"
+    */
+    PI       = Math.PI;
+    HALFPI   = PI / 2;
+    TWOPI    = PI * 2;
+    ISFF     = navigator.userAgent.indexOf('Firefox') != -1;
+    ISOPERA  = navigator.userAgent.indexOf('Opera') != -1;
+    ISCHROME = navigator.userAgent.indexOf('Chrome') != -1;
+    ISSAFARI = navigator.userAgent.indexOf('Safari') != -1 && !ISCHROME;
+    ISWEBKIT = navigator.userAgent.indexOf('WebKit') != -1;
+    //ISIE     is defined below
+    //ISIE6    is defined below
+    //ISIE7    is defined below
+    //ISIE8    is defined below
+    //ISIE9    is defined below
+    //ISIE9    is defined below
+    //ISIE9UP  is defined below
+    //ISIE10   is defined below
+    //ISIE10UP is defined below
+    //ISIE11   is defined below
+    //ISIE11UP is defined below
+    //ISOLD    is defined below
+
+
+    /**
+    * Returns five values which are used as a nice scale
+    * 
+    * @param  max int    The maximum value of the graph
+    * @param  obj object The graph object
+    * @return     array   An appropriate scale
+    */
+    RGraph.getScale = function (max, obj)
+    {
+        /**
+        * Special case for 0
+        */
+        if (max == 0) {
+            return ['0.2', '0.4', '0.6', '0.8', '1.0'];
+        }
+
+        var original_max = max;
+
+        /**
+        * Manually do decimals
+        */
+        if (max <= 1) {
+            if (max > 0.5) {
+                return [0.2,0.4,0.6,0.8, Number(1).toFixed(1)];
+
+            } else if (max >= 0.1) {
+                return obj.Get('chart.scale.round') ? [0.2,0.4,0.6,0.8,1] : [0.1,0.2,0.3,0.4,0.5];
+
+            } else {
+
+                var tmp = max;
+                var exp = 0;
+
+                while (tmp < 1.01) {
+                    exp += 1;
+                    tmp *= 10;
+                }
+
+                var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];
+
+
+                if (max <= ('5e-' + exp)) {
+                    ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];
+                }
+
+                return ret;
+            }
+        }
+
+        // Take off any decimals
+        if (String(max).indexOf('.') > 0) {
+            max = String(max).replace(/\.\d+$/, '');
+        }
+
+        var interval = Math.pow(10, Number(String(Number(max)).length - 1));
+        var topValue = interval;
+
+        while (topValue < max) {
+            topValue += (interval / 2);
+        }
+
+        // Handles cases where the max is (for example) 50.5
+        if (Number(original_max) > Number(topValue)) {
+            topValue += (interval / 2);
+        }
+
+        // Custom if the max is greater than 5 and less than 10
+        if (max < 10) {
+            topValue = (Number(original_max) <= 5 ? 5 : 10);
+        }
+        
+        /**
+        * Added 02/11/2010 to create "nicer" scales
+        */
+        if (obj && typeof(obj.Get('chart.scale.round')) == 'boolean' && obj.Get('chart.scale.round')) {
+            topValue = 10 * interval;
+        }
+
+        return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    /**
+    * Returns an appropriate scale. The return value is actualy anm object consiosting of:
+    *  scale.max
+    *  scale.min
+    *  scale.scale
+    * 
+    * @param  obj object  The graph object
+    * @param  prop object An object consisting of configuration properties
+    * @return     object  An object containg scale information
+    */
+    RGraph.getScale2 = function (obj, opt)
+    {
+        var RG   = RGraph;
+        var ca   = obj.canvas;
+        var co   = obj.context;
+        var prop = obj.properties;
+        
+        var numlabels    = typeof(opt['ylabels.count']) == 'number' ? opt['ylabels.count'] : 5;
+        var units_pre    = typeof(opt['units.pre']) == 'string' ? opt['units.pre'] : '';
+        var units_post   = typeof(opt['units.post']) == 'string' ? opt['units.post'] : '';
+        var max          = Number(opt['max']);
+        var min          = typeof(opt['min']) == 'number' ? opt['min'] : 0;
+        var strict       = opt['strict'];
+        var decimals     = Number(opt['scale.decimals']); // Sometimes the default is null
+        var point        = opt['scale.point']; // Default is a string in all chart libraries so no need to cast it
+        var thousand     = opt['scale.thousand']; // Default is a string in all chart libraries so no need to cast it
+        var original_max = max;
+        var round        = opt['scale.round'];
+        var scale        = {'max':1,'labels':[]};
+
+
+
+        /**
+        * Special case for 0
+        * 
+        * ** Must be first **
+        */
+        if (!max) {
+
+            var max   = 1;
+
+            var scale = {max:1,min:0,labels:[]};
+
+            for (var i=0; i<numlabels; ++i) {
+                var label = ((((max - min) / numlabels) + min) * (i + 1)).toFixed(decimals);
+                scale.labels.push(units_pre + label + units_post);
+            }
+
+        /**
+        * Manually do decimals
+        */
+        } else if (max <= 1 && !strict) {
+
+            if (max > 0.5) {
+
+                max  = 1;
+                min  = min;
+                scale.min = min;
+
+                for (var i=0; i<numlabels; ++i) {
+                    var label = ((((max - min) / numlabels) * (i + 1)) + min).toFixed(decimals);
+
+                    scale.labels.push(units_pre + label + units_post);
+                }
+
+            } else if (max >= 0.1) {
+                
+                max   = 0.5;
+                min   = min;
+                scale = {'max': 0.5, 'min':min,'labels':[]}
+
+                for (var i=0; i<numlabels; ++i) {
+                    var label = ((((max - min) / numlabels) + min) * (i + 1)).toFixed(decimals);
+                    scale.labels.push(units_pre + label + units_post);
+                }
+
+            } else {
+
+                scale = {'min':min,'labels':[]}
+                var max_str = String(max);
+                
+                if (max_str.indexOf('e') > 0) {
+                    var numdecimals = Math.abs(max_str.substring(max_str.indexOf('e') + 1));
+                } else {
+                    var numdecimals = String(max).length - 2;
+                }
+
+                var max = 1  / Math.pow(10,numdecimals - 1);
+
+                for (var i=0; i<numlabels; ++i) {
+                    var label = ((((max - min) / numlabels) + min) * (i + 1));
+                        label = label.toExponential();
+                        label = label.split(/e/);
+                        label[0] = Math.round(label[0]);
+                        label = label.join('e');
+                    scale.labels.push(label);
+                }
+
+                //This makes the top scale value of the format 10e-2 instead of 1e-1
+                tmp = scale.labels[scale.labels.length - 1].split(/e/);
+                tmp[0] += 0;
+                tmp[1] = Number(tmp[1]) - 1;
+                tmp = tmp[0] + 'e' + tmp[1];
+                scale.labels[scale.labels.length - 1] = tmp;
+                
+                // Add the units
+                for (var i=0; i<scale.labels.length ; ++i) {
+                    scale.labels[i] = units_pre + scale.labels[i] + units_post;
+                }
+                
+                scale.max = Number(max);
+            }
+
+
+        } else if (!strict) {
+
+
+            /**
+            * Now comes the scale handling for integer values
+            */
+
+
+            // This accomodates decimals by rounding the max up to the next integer
+            max = Math.ceil(max);
+
+            var interval = Math.pow(10, Math.max(1, Number(String(Number(max) - Number(min)).length - 1)) );
+
+            var topValue = interval;
+
+            while (topValue < max) {
+                topValue += (interval / 2);
+            }
+    
+            // Handles cases where the max is (for example) 50.5
+            if (Number(original_max) > Number(topValue)) {
+                topValue += (interval / 2);
+            }
+
+            // Custom if the max is greater than 5 and less than 10
+            if (max <= 10) {
+                topValue = (Number(original_max) <= 5 ? 5 : 10);
+            }
+    
+    
+            // Added 02/11/2010 to create "nicer" scales
+            if (obj && typeof(round) == 'boolean' && round) {
+                topValue = 10 * interval;
+            }
+
+            scale.max = topValue;
+
+            // Now generate the scale. Temporarily set the objects chart.scale.decimal and chart.scale.point to those
+            //that we've been given as the number_format functuion looks at those instead of using argumrnts.
+            var tmp_point    = prop['chart.scale.point'];
+            var tmp_thousand = prop['chart.scale.thousand'];
+
+            obj.Set('chart.scale.thousand', thousand);
+            obj.Set('chart.scale.point', point);
+
+
+            for (var i=0; i<numlabels; ++i) {
+                scale.labels.push( RG.number_format(obj, ((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals), units_pre, units_post) );
+            }
+
+            obj.Set('chart.scale.thousand', tmp_thousand);
+            obj.Set('chart.scale.point', tmp_point);
+        
+        } else if (typeof(max) == 'number' && strict) {
+
+            /**
+            * ymax is set and also strict
+            */
+            for (var i=0; i<numlabels; ++i) {
+                scale.labels.push( RG.number_format(obj, ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals), units_pre, units_post) );
+            }
+            
+            // ???
+            scale.max = max;
+        }
+
+        
+        scale.units_pre  = units_pre;
+        scale.units_post = units_post;
+        scale.point      = point;
+        scale.decimals   = decimals;
+        scale.thousand   = thousand;
+        scale.numlabels  = numlabels;
+        scale.round      = Boolean(round);
+        scale.min        = min;
+
+
+        return scale;
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+    /**
+    * Returns the maximum numeric value which is in an array
+    * 
+    * @param  array arr The array (can also be a number, in which case it's returned as-is)
+    * @param  int       Whether to ignore signs (ie negative/positive)
+    * @return int       The maximum value in the array
+    */
+    RGraph.array_max = function (arr)
+    {
+        var max       = null;
+        var MathLocal = Math;
+        
+        if (typeof(arr) == 'number') {
+            return arr;
+        }
+        
+        if (RGraph.is_null(arr)) {
+            return 0;
+        }
+
+        for (var i=0,len=arr.length; i<len; ++i) {
+            if (typeof(arr[i]) == 'number') {
+
+                var val = arguments[1] ? MathLocal.abs(arr[i]) : arr[i];
+                
+                if (typeof max == 'number') {
+                    max = MathLocal.max(max, val);
+                } else {
+                    max = val;
+                }
+            }
+        }
+        
+        return max;
+    }
+
+
+
+
+    /**
+    * Returns the maximum value which is in an array
+    * 
+    * @param  array arr The array
+    * @param  int   len The length to pad the array to
+    * @param  mixed     The value to use to pad the array (optional)
+    */
+    RGraph.array_pad = function (arr, len)
+    {
+        if (arr.length < len) {
+            var val = arguments[2] ? arguments[2] : null;
+            
+            for (var i=arr.length; i<len; i+=1) {
+                arr[i] = val;
+            }
+        }
+        
+        return arr;
+    }
+
+
+
+
+    /**
+    * An array sum function
+    * 
+    * @param  array arr The  array to calculate the total of
+    * @return int       The summed total of the arrays elements
+    */
+    RGraph.array_sum = function (arr)
+    {
+        // Allow integers
+        if (typeof(arr) == 'number') {
+            return arr;
+        }
+        
+        // Account for null
+        if (RGraph.is_null(arr)) {
+            return 0;
+        }
+
+        var i, sum;
+        var len = arr.length;
+
+        for(i=0,sum=0;i<len;sum+=arr[i++]);
+        return sum;
+    }
+
+
+
+
+    /**
+    * Takes any number of arguments and adds them to one big linear array
+    * which is then returned
+    * 
+    * @param ... mixed The data to linearise. You can strings, booleans, numbers or arrays
+    */
+    RGraph.array_linearize = function ()
+    {
+        var arr  = [];
+        var args = arguments;
+        var RG   = RGraph;
+
+        for (var i=0,len=args.length; i<len; ++i) {
+
+            if (typeof(args[i]) == 'object' && args[i]) {
+                for (var j=0; j<args[i].length; ++j) {
+                    var sub = RG.array_linearize(args[i][j]);
+                    
+                    for (var k=0; k<sub.length; ++k) {
+                        arr.push(sub[k]);
+                    }
+                }
+            } else {
+                arr.push(args[i]);
+            }
+        }
+
+        return arr;
+    }
+
+
+
+
+    /**
+    * This is a useful function which is basically a shortcut for drawing left, right, top and bottom alligned text.
+    * 
+    * @param object context The context
+    * @param string font    The font
+    * @param int    size    The size of the text
+    * @param int    x       The X coordinate
+    * @param int    y       The Y coordinate
+    * @param string text    The text to draw
+    * @parm  string         The vertical alignment. Can be null. "center" gives center aligned  text, "top" gives top aligned text.
+    *                       Anything else produces bottom aligned text. Default is bottom.
+    * @param  string        The horizontal alignment. Can be null. "center" gives center aligned  text, "right" gives right aligned text.
+    *                       Anything else produces left aligned text. Default is left.
+    * @param  bool          Whether to show a bounding box around the text. Defaults not to
+    * @param int            The angle that the text should be rotate at (IN DEGREES)
+    * @param string         Background color for the text
+    * @param bool           Whether the text is bold or not
+    */
+    RGraph.Text = function (context, font, size, x, y, text)
+    {
+        // "Cache" the args as a local variable
+        var args = arguments;
+
+        // Handle undefined - change it to an empty string
+        if ((typeof(text) != 'string' && typeof(text) != 'number') || text == 'undefined') {
+            return;
+        }
+
+
+
+
+        /**
+        * This accommodates multi-line text
+        */
+        if (typeof(text) == 'string' && text.match(/\r\n/)) {
+
+            var dimensions = RGraph.MeasureText('M', args[11], font, size);
+
+            /**
+            * Measure the text (width and height)
+            */
+
+            var arr = text.split('\r\n');
+
+            /**
+            * Adjust the Y position
+            */
+            
+            // This adjusts the initial y position
+            if (args[6] && args[6] == 'center') y = (y - (dimensions[1] * ((arr.length - 1) / 2)));
+
+            for (var i=1; i<arr.length; ++i) {
+    
+                RGraph.Text(context,
+                            font,
+                            size,
+                            args[9] == -90 ? (x + (size * 1.5)) : x,
+                            y + (dimensions[1] * i),
+                            arr[i],
+                            args[6] ? args[6] : null,
+                            args[7],
+                            args[8],
+                            args[9],
+                            args[10],
+                            args[11],
+                            args[12]);
+            }
+            
+            // Update text to just be the first line
+            text = arr[0];
+        }
+
+
+        // Accommodate MSIE
+        if (document.all && ISOLD) {
+            y += 2;
+        }
+
+
+        context.font = (args[11] ? 'Bold ': '') + size + 'pt ' + font;
+
+        var i;
+        var origX = x;
+        var origY = y;
+        var originalFillStyle = context.fillStyle;
+        var originalLineWidth = context.lineWidth;
+
+        // Need these now the angle can be specified, ie defaults for the former two args
+        if (typeof(args[6])  == 'undefined') args[6]  = 'bottom'; // Vertical alignment. Default to bottom/baseline
+        if (typeof(args[7])  == 'undefined') args[7]  = 'left';   // Horizontal alignment. Default to left
+        if (typeof(args[8])  == 'undefined') args[8]  = null;     // Show a bounding box. Useful for positioning during development. Defaults to false
+        if (typeof(args[9])  == 'undefined') args[9]  = 0;        // Angle (IN DEGREES) that the text should be drawn at. 0 is middle right, and it goes clockwise
+
+        // The alignment is recorded here for purposes of Opera compatibility
+        if (navigator.userAgent.indexOf('Opera') != -1) {
+            context.canvas.__rgraph_valign__ = args[6];
+            context.canvas.__rgraph_halign__ = args[7];
+        }
+
+        // First, translate to x/y coords
+        context.save();
+
+            context.canvas.__rgraph_originalx__ = x;
+            context.canvas.__rgraph_originaly__ = y;
+
+            context.translate(x, y);
+            x = 0;
+            y = 0;
+
+            // Rotate the canvas if need be
+            if (args[9]) {
+                context.rotate(args[9] / (180 / PI));
+            }
+
+
+            // Vertical alignment - defaults to bottom
+            if (args[6]) {
+
+                var vAlign = args[6];
+
+                if (vAlign == 'center') {
+                    context.textBaseline = 'middle';
+                } else if (vAlign == 'top') {
+                    context.textBaseline = 'top';
+                }
+            }
+
+
+            // Hoeizontal alignment - defaults to left
+            if (args[7]) {
+
+                var hAlign = args[7];
+                var width  = context.measureText(text).width;
+    
+                if (hAlign) {
+                    if (hAlign == 'center') {
+                        context.textAlign = 'center';
+                    } else if (hAlign == 'right') {
+                        context.textAlign = 'right';
+                    }
+                }
+            }
+            
+            
+            context.fillStyle = originalFillStyle;
+
+            /**
+            * Draw a bounding box if requested
+            */
+            context.save();
+                 context.fillText(text,0,0);
+                 context.lineWidth = 1;
+
+                var width = context.measureText(text).width;
+                var width_offset = (hAlign == 'center' ? (width / 2) : (hAlign == 'right' ? width : 0));
+                var height = size * 1.5; // !!!
+                var height_offset = (vAlign == 'center' ? (height / 2) : (vAlign == 'top' ? height : 0));
+                var ieOffset = ISOLD ? 2 : 0;
+
+                if (args[8]) {
+
+                    context.strokeRect(-3 - width_offset,
+                                       0 - 3 - height - ieOffset + height_offset,
+                                       width + 6,
+                                       height + 6);
+                    /**
+                    * If requested, draw a background for the text
+                    */
+                    if (args[10]) {
+                        context.fillStyle = args[10];
+                        context.fillRect(-3 - width_offset,
+                                           0 - 3 - height - ieOffset + height_offset,
+                                           width + 6,
+                                           height + 6);
+                    }
+
+                    
+                    context.fillStyle = originalFillStyle;
+
+
+                    /**
+                    * Do the actual drawing of the text
+                    */
+                    context.fillText(text,0,0);
+                }
+            context.restore();
+            
+            // Reset the lineWidth
+            context.lineWidth = originalLineWidth;
+
+        context.restore();
+    }
+
+
+
+
+    /**
+    * Clears the canvas by setting the width. You can specify a colour if you wish.
+    * 
+    * @param object canvas The canvas to clear
+    */
+    RGraph.Clear = function (ca)
+    {
+        var RG    = RGraph;
+        var co    = ca.getContext('2d');
+        var color = arguments[1];
+
+        if (!ca) {
+            return;
+        }
+        
+        RG.FireCustomEvent(ca.__object__, 'onbeforeclear');
+
+        if (ISIE8 && !color) {
+            color = 'white';
+        }
+
+        /**
+        * Can now clear the canvas back to fully transparent
+        */
+        if (!color || (color && color == 'rgba(0,0,0,0)' || color == 'transparent')) {
+
+            co.clearRect(0,0,ca.width, ca.height);
+            
+            // Reset the globalCompositeOperation
+            co.globalCompositeOperation = 'source-over';
+
+        } else {
+
+            co.fillStyle = color;
+            co.beginPath();
+
+            if (ISIE8) {
+                co.fillRect(0,0,ca.width,ca.height);
+            } else {
+                co.fillRect(-10,-10,ca.width + 20,ca.height + 20);
+            }
+
+            co.fill();
+        }
+        
+        //if (RG.ClearAnnotations) {
+            //RG.ClearAnnotations(ca.id);
+        //}
+        
+        /**
+        * This removes any background image that may be present
+        */
+        if (RG.Registry.Get('chart.background.image.' + ca.id)) {
+            var img = RG.Registry.Get('chart.background.image.' + ca.id);
+            img.style.position = 'absolute';
+            img.style.left     = '-10000px';
+            img.style.top      = '-10000px';
+        }
+        
+        /**
+        * This hides the tooltip that is showing IF it has the same canvas ID as
+        * that which is being cleared
+        */
+        if (RG.Registry.Get('chart.tooltip')) {
+            RG.HideTooltip(ca);
+            //RG.Redraw();
+        }
+
+        /**
+        * Set the cursor to default
+        */
+        ca.style.cursor = 'default';
+
+        RG.FireCustomEvent(ca.__object__, 'onclear');
+    }
+
+
+
+
+    /**
+    * Draws the title of the graph
+    * 
+    * @param object  canvas The canvas object
+    * @param string  text   The title to write
+    * @param integer gutter The size of the gutter
+    * @param integer        The center X point (optional - if not given it will be generated from the canvas width)
+    * @param integer        Size of the text. If not given it will be 14
+    */
+    RGraph.DrawTitle = function (obj, text, gutterTop)
+    {
+        var RG           = RGraph;
+        var ca = canvas  = obj.canvas;
+        var co = context = obj.context;
+        var prop         = obj.properties;
+
+        var gutterLeft   = prop['chart.gutter.left'];
+        var gutterRight  = prop['chart.gutter.right'];
+        var gutterTop    = gutterTop;
+        var gutterBottom = prop['chart.gutter.bottom'];
+        var size         = arguments[4] ? arguments[4] : 12;
+        var bold         = prop['chart.title.bold'];
+        var centerx      = (arguments[3] ? arguments[3] : ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft);
+        var keypos       = prop['chart.key.position'];
+        var vpos         = prop['chart.title.vpos'];
+        var hpos         = prop['chart.title.hpos'];
+        var bgcolor      = prop['chart.title.background'];
+        var x            = prop['chart.title.x'];
+        var y            = prop['chart.title.y'];
+        var halign       = 'center';
+        var valign       = 'center';
+
+        // Account for 3D effect by faking the key position
+        if (obj.type == 'bar' && prop['chart.variant'] == '3d') {
+            keypos = 'gutter';
+        }
+
+        co.beginPath();
+        co.fillStyle = prop['chart.text.color'] ? prop['chart.text.color'] : 'black';
+
+
+
+
+
+        /**
+        * Vertically center the text if the key is not present
+        */
+        if (keypos && keypos != 'gutter') {
+            var valign = 'center';
+
+        } else if (!keypos) {
+            var valign = 'center';
+
+        } else {
+            var valign = 'bottom';
+        }
+
+
+
+
+
+        // if chart.title.vpos is a number, use that
+        if (typeof(prop['chart.title.vpos']) == 'number') {
+            vpos = prop['chart.title.vpos'] * gutterTop;
+
+            if (prop['chart.xaxispos'] == 'top') {
+                vpos = prop['chart.title.vpos'] * gutterBottom + gutterTop + (ca.height - gutterTop - gutterBottom);
+            }
+
+        } else {
+            vpos = gutterTop - size - 5;
+
+            if (prop['chart.xaxispos'] == 'top') {
+                vpos = ca.height  - gutterBottom + size + 5;
+            }
+        }
+
+
+
+
+        // if chart.title.hpos is a number, use that. It's multiplied with the (entire) canvas width
+        if (typeof(hpos) == 'number') {
+            centerx = hpos * ca.width;
+        }
+
+        /**
+        * Now the chart.title.x and chart.title.y settings override (is set) the above
+        */
+        if (typeof(x) == 'number') centerx = x;
+        if (typeof(y) == 'number') vpos    = y;
+
+
+
+
+        /**
+        * Horizontal alignment can now (Jan 2013) be specified
+        */
+        if (typeof(prop['chart.title.halign']) == 'string') {
+            halign = prop['chart.title.halign'];
+        }
+        
+        /**
+        * Vertical alignment can now (Jan 2013) be specified
+        */
+        if (typeof(prop['chart.title.valign']) == 'string') {
+            valign = prop['chart.title.valign'];
+        }
+
+
+
+
+        
+        // Set the colour
+        if (typeof(prop['chart.title.color'] != null)) {
+            var oldColor = co.fillStyle
+            var newColor = prop['chart.title.color']
+            co.fillStyle = newColor ? newColor : 'black';
+        }
+
+
+
+
+        /**
+        * Default font is Arial
+        */
+        var font = prop['chart.text.font'];
+
+
+
+
+        /**
+        * Override the default font with chart.title.font
+        */
+        if (typeof(prop['chart.title.font']) == 'string') {
+            font = prop['chart.title.font'];
+        }
+
+
+
+
+        /**
+        * Draw the title
+        */
+        RG.Text2(obj,{'font':font,
+                          'size':size,
+                          'x':centerx,
+                          'y':vpos,
+                          'text':text,
+                          'valign':valign,
+                          'halign':halign,
+                          'bounding':bgcolor != null,
+                          'bounding.fill':bgcolor,
+                          'bold':bold,
+                          'tag':'title'
+                         });
+        
+        // Reset the fill colour
+        co.fillStyle = oldColor;
+    }
+
+
+
+
+
+    /**
+    * This function returns the mouse position in relation to the canvas
+    * 
+    * @param object e The event object.
+    *
+    RGraph.getMouseXY = function (e)
+    {
+        var el = (ISOLD ? event.srcElement : e.target);
+        var x;
+        var y;
+
+        // ???
+        var paddingLeft = el.style.paddingLeft ? parseInt(el.style.paddingLeft) : 0;
+        var paddingTop  = el.style.paddingTop ? parseInt(el.style.paddingTop) : 0;
+        var borderLeft  = el.style.borderLeftWidth ? parseInt(el.style.borderLeftWidth) : 0;
+        var borderTop   = el.style.borderTopWidth  ? parseInt(el.style.borderTopWidth) : 0;
+        
+        if (ISIE8) e = event;
+
+        // Browser with offsetX and offsetY
+        if (typeof(e.offsetX) == 'number' && typeof(e.offsetY) == 'number') {
+            x = e.offsetX;
+            y = e.offsetY;
+
+        // FF and other
+        } else {
+            x = 0;
+            y = 0;
+
+            while (el != document.body && el) {
+                x += el.offsetLeft;
+                y += el.offsetTop;
+
+                el = el.offsetParent;
+            }
+
+            x = e.pageX - x;
+            y = e.pageY - y;
+        }
+
+        return [x, y];
+    }*/
+
+
+    RGraph.getMouseXY = function(e)
+    {
+        var el      = e.target;
+        var ca      = el;
+        var caStyle = ca.style;
+        var offsetX = 0;
+        var offsetY = 0;
+        var x;
+        var y;
+        var ISFIXED     = (ca.style.position == 'fixed');
+        var borderLeft  = parseInt(caStyle.borderLeftWidth) || 0;
+        var borderTop   = parseInt(caStyle.borderTopWidth) || 0;
+        var paddingLeft = parseInt(caStyle.paddingLeft) || 0
+        var paddingTop  = parseInt(caStyle.paddingTop) || 0
+        var additionalX = borderLeft + paddingLeft;
+        var additionalY = borderTop + paddingTop;
+
+
+        if (typeof(e.offsetX) == 'number' && typeof(e.offsetY) == 'number') {
+
+            if (ISFIXED) {
+                if (ISOPERA) {
+                    x = e.offsetX;
+                    y = e.offsetY;
+                
+                } else if (ISWEBKIT) {
+                    x = e.offsetX - paddingLeft - borderLeft;
+                    y = e.offsetY - paddingTop - borderTop;
+                
+                } else if (ISIE) {
+                    x = e.offsetX - paddingLeft;
+                    y = e.offsetY - paddingTop;
+    
+                } else {
+                    x = e.offsetX;
+                    y = e.offsetY;
+                }
+    
+    
+    
+    
+            } else {
+    
+    
+    
+    
+                if (!ISIE && !ISOPERA) {
+                    x = e.offsetX - borderLeft - paddingLeft;
+                    y = e.offsetY - borderTop - paddingTop;
+                
+                } else if (ISIE) {
+                    x = e.offsetX - paddingLeft;
+                    y = e.offsetY - paddingTop;
+                
+                } else {
+                    x = e.offsetX;
+                    y = e.offsetY;
+                }
+            }   
+
+        } else {
+
+            if (typeof(el.offsetParent) != 'undefined') {
+                do {
+                    offsetX += el.offsetLeft;
+                    offsetY += el.offsetTop;
+                } while ((el = el.offsetParent));
+            }
+
+            x = e.pageX - offsetX - additionalX;
+            y = e.pageY - offsetY - additionalY;
+
+            x -= (2 * (parseInt(document.body.style.borderLeftWidth) || 0));
+            y -= (2 * (parseInt(document.body.style.borderTopWidth) || 0));
+
+            //x += (parseInt(caStyle.borderLeftWidth) || 0);
+            //y += (parseInt(caStyle.borderTopWidth) || 0);
+        }
+
+        // We return a javascript array with x and y defined
+        return [x, y];
+    }
+
+
+
+
+    /**
+    * This function returns a two element array of the canvas x/y position in
+    * relation to the page
+    * 
+    * @param object canvas
+    */
+    RGraph.getCanvasXY = function (canvas)
+    {
+        var x  = 0;
+        var y  = 0;
+        var el = canvas; // !!!
+
+        do {
+
+            x += el.offsetLeft;
+            y += el.offsetTop;
+            
+            // ACCOUNT FOR TABLES IN wEBkIT
+            if (el.tagName.toLowerCase() == 'table' && (ISCHROME || ISSAFARI)) {
+                x += parseInt(el.border) || 0;
+                y += parseInt(el.border) || 0;
+            }
+
+            el = el.offsetParent;
+
+        } while (el && el.tagName.toLowerCase() != 'body');
+
+
+        var paddingLeft = canvas.style.paddingLeft ? parseInt(canvas.style.paddingLeft) : 0;
+        var paddingTop  = canvas.style.paddingTop ? parseInt(canvas.style.paddingTop) : 0;
+        var borderLeft  = canvas.style.borderLeftWidth ? parseInt(canvas.style.borderLeftWidth) : 0;
+        var borderTop   = canvas.style.borderTopWidth  ? parseInt(canvas.style.borderTopWidth) : 0;
+
+        if (navigator.userAgent.indexOf('Firefox') > 0) {
+            x += parseInt(document.body.style.borderLeftWidth) || 0;
+            y += parseInt(document.body.style.borderTopWidth) || 0;
+        }
+
+        return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];
+    }
+
+
+
+
+    /**
+    * This function determines whther a canvas is fixed (CSS positioning) or not. If not it returns
+    * false. If it is then the element that is fixed is returned (it may be a parent of the canvas).
+    * 
+    * @return Either false or the fixed positioned element
+    */
+    RGraph.isFixed = function (canvas)
+    {
+        var obj = canvas;
+        var i = 0;
+
+        while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {
+
+            if (obj.style.position == 'fixed') {
+                return obj;
+            }
+            
+            obj = obj.offsetParent;
+        }
+
+        return false;
+    }
+
+
+
+
+    /**
+    * Registers a graph object (used when the canvas is redrawn)
+    * 
+    * @param object obj The object to be registered
+    */
+    RGraph.Register = function (obj)
+    {
+        // Checking this property ensures the object is only registered once
+        if (!obj.Get('chart.noregister')) {
+            // As of 21st/1/2012 the object registry is now used
+            RGraph.ObjectRegistry.Add(obj);
+            obj.Set('chart.noregister', true);
+        }
+    }
+
+
+
+
+    /**
+    * Causes all registered objects to be redrawn
+    * 
+    * @param string An optional color to use to clear the canvas
+    */
+    RGraph.Redraw = function ()
+    {
+        var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;
+
+        // Get all of the canvas tags on the page
+        var tags = document.getElementsByTagName('canvas');
+
+        for (var i=0,len=tags.length; i<len; ++i) {
+            if (tags[i].__object__ && tags[i].__object__.isRGraph) {
+                
+                // Only clear the canvas if it's not Trace'ing - this applies to the Line/Scatter Trace effects
+                if (!tags[i].noclear) {
+                    RGraph.Clear(tags[i], arguments[0] ? arguments[0] : null);
+                }
+            }
+        }
+
+        // Go through the object registry and redraw *all* of the canvas'es that have been registered
+        for (var i=0,len=objectRegistry.length; i<len; ++i) {
+            if (objectRegistry[i]) {
+                var id = objectRegistry[i][0];
+                objectRegistry[i][1].Draw();
+            }
+        }
+    }
+
+
+
+
+    /**
+    * Causes all registered objects ON THE GIVEN CANVAS to be redrawn
+    * 
+    * @param canvas object The canvas object to redraw
+    * @param        bool   Optional boolean which defaults to true and determines whether to clear the canvas
+    */
+    RGraph.RedrawCanvas = function (canvas)
+    {
+        var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);
+
+        /**
+        * First clear the canvas
+        */
+        if (!arguments[1] || (typeof(arguments[1]) == 'boolean' && !arguments[1] == false) ) {
+            
+            // TODO This function should really support passing a color as the second optional argument - which is then used in the below
+            // call
+            RGraph.Clear(canvas);
+        }
+
+        /**
+        * Now redraw all the charts associated with that canvas
+        */
+        for (var i=0,len=objects.length; i<len; ++i) {
+            if (objects[i]) {
+                if (objects[i] && objects[i].isRGraph) { // Is it an RGraph object ??
+                    objects[i].Draw();
+                }
+            }
+        }
+    }
+
+
+
+
+    /**
+    * This function draws the background for the bar chart, line chart and scatter chart.
+    * 
+    * @param  object obj The graph object
+    */
+    RGraph.background.Draw = function (obj)
+    {
+        var RG           = RGraph;
+        var ca = canvas  = obj.canvas;
+        var co = context = obj.context;
+        var prop         = obj.properties;
+
+        var height       = 0;
+        var gutterLeft   = obj.gutterLeft;
+        var gutterRight  = obj.gutterRight;
+        var gutterTop    = obj.gutterTop;
+        var gutterBottom = obj.gutterBottom;
+        var variant      = prop['chart.variant'];
+        
+        co.fillStyle = prop['chart.text.color'];
+        
+        // If it's a bar and 3D variant, translate
+        if (variant == '3d') {
+            co.save();
+            co.translate(10, -5);
+        }
+
+        // X axis title
+        if (typeof(prop['chart.title.xaxis']) == 'string' && prop['chart.title.xaxis'].length) {
+        
+            var size = prop['chart.text.size'] + 2;
+            var font = prop['chart.text.font'];
+            var bold = prop['chart.title.xaxis.bold'];
+
+            if (typeof(prop['chart.title.xaxis.size']) == 'number') {
+                size = prop['chart.title.xaxis.size'];
+            }
+
+            if (typeof(prop['chart.title.xaxis.font']) == 'string') {
+                font = prop['chart.title.xaxis.font'];
+            }
+            
+            var hpos = ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft;
+            var vpos = ca.height - gutterBottom + 25;
+            
+            if (typeof(prop['chart.title.xaxis.pos']) == 'number') {
+                vpos = ca.height - (gutterBottom * prop['chart.title.xaxis.pos']);
+            }
+
+
+
+
+            // Specifically specified X/Y positions
+            if (typeof prop['chart.title.xaxis.x'] == 'number') {
+                hpos = prop['chart.title.xaxis.x'];
+            }
+
+            if (typeof prop['chart.title.xaxis.y'] == 'number') {
+                vpos = prop['chart.title.xaxis.y'];
+            }
+
+
+
+
+            RG.Text2(obj, {'font':font,
+                           'size':size,
+                           'x':hpos,
+                           'y':vpos,
+                           'text':prop['chart.title.xaxis'],
+                           'halign':'center',
+                           'valign':'center',
+                           'bold':bold,
+                           'tag': 'title xaxis'
+                          });
+        }
+
+        // Y axis title
+        if (typeof(prop['chart.title.yaxis']) == 'string' && prop['chart.title.yaxis'].length) {
+
+            var size  = prop['chart.text.size'] + 2;
+            var font  = prop['chart.text.font'];
+            var angle = 270;
+            var bold  = prop['chart.title.yaxis.bold'];
+            var color = prop['chart.title.yaxis.color'];
+
+            if (typeof(prop['chart.title.yaxis.pos']) == 'number') {
+                var yaxis_title_pos = prop['chart.title.yaxis.pos'] * gutterLeft;
+            } else {
+                var yaxis_title_pos = ((gutterLeft - 25) / gutterLeft) * gutterLeft;
+            }
+
+            if (typeof(prop['chart.title.yaxis.size']) == 'number') {
+                size = prop['chart.title.yaxis.size'];
+            }
+
+            if (typeof(prop['chart.title.yaxis.font']) == 'string') {
+                font = prop['chart.title.yaxis.font'];
+            }
+
+            if (prop['chart.title.yaxis.align'] == 'right' || prop['chart.title.yaxis.position'] == 'right') {
+                angle = 90;
+                yaxis_title_pos = prop['chart.title.yaxis.pos'] ? (ca.width - gutterRight) + (prop['chart.title.yaxis.pos'] * gutterRight) :
+                                                                   ca.width - gutterRight + prop['chart.text.size'] + 5;
+            } else {
+                yaxis_title_pos = yaxis_title_pos;
+            }
+            
+            var y = ((ca.height - gutterTop - gutterBottom) / 2) + gutterTop;
+            
+            // Specifically specified X/Y positions
+            if (typeof prop['chart.title.yaxis.x'] == 'number') {
+                yaxis_title_pos = prop['chart.title.yaxis.x'];
+            }
+
+            if (typeof prop['chart.title.yaxis.y'] == 'number') {
+                y = prop['chart.title.yaxis.y'];
+            }
+
+            co.fillStyle = color;
+            RG.Text2(obj, {'font':font,
+                           'size':size,
+                           'x':yaxis_title_pos,
+                           'y':y,
+                           'valign':'center',
+                           'halign':'center',
+                           'angle':angle,
+                           'bold':bold,
+                           'text':prop['chart.title.yaxis'],
+                           'tag':'title yaxis'
+                          });
+        }
+
+        /**
+        * If the background color is spec ified - draw that. It's a rectangle that fills the
+        * entire are within the gutters
+        */
+        var bgcolor = prop['chart.background.color'];
+        if (bgcolor) {
+            co.fillStyle = bgcolor;
+            co.fillRect(gutterLeft, gutterTop, ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);
+        }
+
+        /**
+        * Draw horizontal background bars
+        */
+        co.beginPath(); // Necessary?
+
+        co.fillStyle   = prop['chart.background.barcolor1'];
+        co.strokeStyle = co.fillStyle;
+        height = (ca.height - gutterBottom);
+
+        for (var i=gutterTop; i<height ; i+=80) {
+            co.fillRect(gutterLeft, i, ca.width - gutterLeft - gutterRight, Math.min(40, ca.height - gutterBottom - i) );
+        }
+
+        co.fillStyle   = prop['chart.background.barcolor2'];
+        co.strokeStyle = co.fillStyle;
+        height = (ca.height - gutterBottom);
+
+        for (var i= (40 + gutterTop); i<height; i+=80) {
+            co.fillRect(gutterLeft, i, ca.width - gutterLeft - gutterRight, i + 40 > (ca.height - gutterBottom) ? ca.height - (gutterBottom + i) : 40);
+        }
+        
+        //context.stroke();
+        co.beginPath();
+    
+
+        // Draw the background grid
+        if (prop['chart.background.grid']) {
+
+            // If autofit is specified, use the .numhlines and .numvlines along with the width to work
+            // out the hsize and vsize
+            if (prop['chart.background.grid.autofit']) {
+
+                /**
+                * Align the grid to the tickmarks
+                */
+                if (prop['chart.background.grid.autofit.align']) {
+                    
+                    // Align the horizontal lines
+                    obj.Set('chart.background.grid.autofit.numhlines', prop['chart.ylabels.count']);
+
+                    // Align the vertical lines for the line
+                    if (obj.type == 'line') {
+                        if (prop['chart.labels'] && prop['chart.labels'].length) {
+                            obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length - 1);
+                        } else {
+                            obj.Set('chart.background.grid.autofit.numvlines', obj.data[0].length - 1);
+                        }
+
+                    // Align the vertical lines for the bar
+                    } else if (obj.type == 'bar' && prop['chart.labels'] && prop['chart.labels'].length) {
+                        obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length);
+                    }
+                }
+
+                var vsize = ((ca.width - gutterLeft - gutterRight)) / prop['chart.background.grid.autofit.numvlines'];
+                var hsize = (ca.height - gutterTop - gutterBottom) / prop['chart.background.grid.autofit.numhlines'];
+
+                obj.Set('chart.background.grid.vsize', vsize);
+                obj.Set('chart.background.grid.hsize', hsize);
+            }
+
+            co.beginPath();
+            co.lineWidth   = prop['chart.background.grid.width'] ? prop['chart.background.grid.width'] : 1;
+            co.strokeStyle = prop['chart.background.grid.color'];
+
+            // Dashed background grid
+            if (prop['chart.background.grid.dashed'] && typeof co.setLineDash == 'function') {
+                co.setLineDash([3,2]);
+            }
+            
+            // Dotted background grid
+            if (prop['chart.background.grid.dotted'] && typeof co.setLineDash == 'function') {
+                co.setLineDash([1,2]);
+            }
+
+
+            // Draw the horizontal lines
+            if (prop['chart.background.grid.hlines']) {
+                height = (ca.height - gutterBottom)
+                for (y=gutterTop; y<height; y+=prop['chart.background.grid.hsize']) {
+                    context.moveTo(gutterLeft, Math.round(y));
+                    context.lineTo(ca.width - gutterRight, Math.round(y));
+                }
+            }
+
+            if (prop['chart.background.grid.vlines']) {
+                // Draw the vertical lines
+                var width = (ca.width - gutterRight)
+                for (x=gutterLeft; x<=width; x+=prop['chart.background.grid.vsize']) {
+                    co.moveTo(Math.round(x), gutterTop);
+                    co.lineTo(Math.round(x), ca.height - gutterBottom);
+                }
+            }
+
+            if (prop['chart.background.grid.border']) {
+                // Make sure a rectangle, the same colour as the grid goes around the graph
+                co.strokeStyle = prop['chart.background.grid.color'];
+                co.strokeRect(Math.round(gutterLeft), Math.round(gutterTop), ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);
+            }
+        }
+
+        context.stroke();
+
+        // Reset the line dash
+        if (typeof co.setLineDash == 'function') {
+            co.setLineDash([1,0]);
+        }
+
+        // If it's a bar and 3D variant, translate
+        if (variant == '3d') {
+            co.restore();
+        }
+
+        // Draw the title if one is set
+        if ( typeof(prop['chart.title']) == 'string') {
+
+            if (obj.type == 'gantt') {
+                gutterTop -= 10;
+            }
+
+            RG.DrawTitle(obj,
+                         prop['chart.title'],
+                         gutterTop,
+                         null,
+                         prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);
+        }
+
+        co.stroke();
+    }
+
+
+
+
+    /**
+    * Makes a clone of an object
+    * 
+    * @param obj val The object to clone
+    */
+    RGraph.array_clone = function (obj)
+    {
+        var RG = RGraph;
+
+        if(obj == null || typeof(obj) != 'object') {
+            return obj;
+        }
+
+        var temp = [];
+
+        for (var i=0,len=obj.length;i<len; ++i) {
+
+            if (typeof(obj[i]) == 'number') {
+                temp[i] = (function (arg) {return Number(arg);})(obj[i]);
+            } else if (typeof(obj[i]) == 'string') {
+                temp[i] = (function (arg) {return String(arg);})(obj[i]);
+            } else if (typeof(obj[i]) == 'function') {
+                temp[i] = obj[i];
+            
+            } else {
+                temp[i] = RG.array_clone(obj[i]);
+            }
+        }
+
+        return temp;
+    }
+
+
+
+
+    /**
+    * Formats a number with thousand seperators so it's easier to read
+    * 
+    * @param  integer obj The chart object
+    * @param  integer num The number to format
+    * @param  string      The (optional) string to prepend to the string
+    * @param  string      The (optional) string to append to the string
+    * @return string      The formatted number
+    */
+    RGraph.number_format = function (obj, num)
+    {
+        var RG   = RGraph;
+        var ca   = obj.canvas;
+        var co   = obj.context;
+        var prop = obj.properties;
+
+        var i;
+        var prepend = arguments[2] ? String(arguments[2]) : '';
+        var append  = arguments[3] ? String(arguments[3]) : '';
+        var output  = '';
+        var decimal = '';
+        var decimal_seperator  = typeof(prop['chart.scale.point']) == 'string' ? prop['chart.scale.point'] : '.';
+        var thousand_seperator = typeof(prop['chart.scale.thousand']) == 'string' ? prop['chart.scale.thousand'] : ',';
+        RegExp.$1   = '';
+        var i,j;
+
+        if (typeof(prop['chart.scale.formatter']) == 'function') {
+            return prop['chart.scale.formatter'](obj, num);
+        }
+
+        // Ignore the preformatted version of "1e-2"
+        if (String(num).indexOf('e') > 0) {
+            return String(prepend + String(num) + append);
+        }
+
+        // We need then number as a string
+        num = String(num);
+        
+        // Take off the decimal part - we re-append it later
+        if (num.indexOf('.') > 0) {
+            var tmp = num;
+            num     = num.replace(/\.(.*)/, ''); // The front part of the number
+            decimal = tmp.replace(/(.*)\.(.*)/, '$2'); // The decimal part of the number
+        }
+
+        // Thousand seperator
+        //var seperator = arguments[1] ? String(arguments[1]) : ',';
+        var seperator = thousand_seperator;
+        
+        /**
+        * Work backwards adding the thousand seperators
+        */
+        var foundPoint;
+        for (i=(num.length - 1),j=0; i>=0; j++,i--) {
+            var character = num.charAt(i);
+            
+            if ( j % 3 == 0 && j != 0) {
+                output += seperator;
+            }
+            
+            /**
+            * Build the output
+            */
+            output += character;
+        }
+        
+        /**
+        * Now need to reverse the string
+        */
+        var rev = output;
+        output = '';
+        for (i=(rev.length - 1); i>=0; i--) {
+            output += rev.charAt(i);
+        }
+
+        // Tidy up
+        //output = output.replace(/^-,/, '-');
+        if (output.indexOf('-' + prop['chart.scale.thousand']) == 0) {
+            output = '-' + output.substr(('-' + prop['chart.scale.thousand']).length);
+        }
+
+        // Reappend the decimal
+        if (decimal.length) {
+            output =  output + decimal_seperator + decimal;
+            decimal = '';
+            RegExp.$1 = '';
+        }
+
+        // Minor bugette
+        if (output.charAt(0) == '-') {
+            output = output.replace(/-/, '');
+            prepend = '-' + prepend;
+        }
+
+        return prepend + output + append;
+    }
+
+
+
+
+    /**
+    * Draws horizontal coloured bars on something like the bar, line or scatter
+    */
+    RGraph.DrawBars = function (obj)
+    {
+        var prop  = obj.properties;
+        var co    = obj.context;
+        var ca    = obj.canvas;
+        var RG    = RGraph;
+        var hbars = prop['chart.background.hbars'];
+
+        if (hbars === null) {
+            return;
+        }
+
+        /**
+        * Draws a horizontal bar
+        */
+        co.beginPath();
+
+        for (i=0,len=hbars.length; i<len; ++i) {
+        
+            var start  = hbars[i][0];
+            var length = hbars[i][1];
+            var color  = hbars[i][2];
+            
+
+            // Perform some bounds checking
+            if(RG.is_null(start))start = obj.scale2.max
+            if (start > obj.scale2.max) start = obj.scale2.max;
+            if (RG.is_null(length)) length = obj.scale2.max - start;
+            if (start + length > obj.scale2.max) length = obj.scale2.max - start;
+            if (start + length < (-1 * obj.scale2.max) ) length = (-1 * obj.scale2.max) - start;
+
+            if (prop['chart.xaxispos'] == 'center' && start == obj.scale2.max && length < (obj.scale2.max * -2)) {
+                length = obj.scale2.max * -2;
+            }
+
+
+            /**
+            * Draw the bar
+            */
+            var x = prop['chart.gutter.left'];
+            var y = obj.getYCoord(start);
+            var w = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];
+            var h = obj.getYCoord(start + length) - y;
+
+            // Accommodate Opera :-/
+            if (ISOPERA != -1 && prop['chart.xaxispos'] == 'center' && h < 0) {
+                h *= -1;
+                y = y - h;
+            }
+
+            /**
+            * Account for X axis at the top
+            */
+            if (prop['chart.xaxispos'] == 'top') {
+                y  = ca.height - y;
+                h *= -1;
+            }
+
+            co.fillStyle = color;
+            co.fillRect(x, y, w, h);
+        }
+/*
+
+
+            
+
+
+            // If the X axis is at the bottom, and a negative max is given, warn the user
+            if (obj.Get('chart.xaxispos') == 'bottom' && (hbars[i][0] < 0 || (hbars[i][1] + hbars[i][1] < 0)) ) {
+                alert('[' + obj.type.toUpperCase() + ' (ID: ' + obj.id + ') BACKGROUND HBARS] You have a negative value in one of your background hbars values, whilst the X axis is in the center');
+            }
+
+            var ystart = (obj.grapharea - (((hbars[i][0] - obj.scale2.min) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea));
+            //var height = (Math.min(hbars[i][1], obj.max - hbars[i][0]) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea;
+            var height = obj.getYCoord(hbars[i][0]) - obj.getYCoord(hbars[i][1]);
+
+            // Account for the X axis being in the center
+            if (obj.Get('chart.xaxispos') == 'center') {
+                ystart /= 2;
+                //height /= 2;
+            }
+            
+            ystart += obj.Get('chart.gutter.top')
+
+            var x = obj.Get('chart.gutter.left');
+            var y = ystart - height;
+            var w = obj.canvas.width - obj.Get('chart.gutter.left') - obj.Get('chart.gutter.right');
+            var h = height;
+
+            // Accommodate Opera :-/
+            if (navigator.userAgent.indexOf('Opera') != -1 && obj.Get('chart.xaxispos') == 'center' && h < 0) {
+                h *= -1;
+                y = y - h;
+            }
+            
+            /**
+            * Account for X axis at the top
+            */
+            //if (obj.Get('chart.xaxispos') == 'top') {
+            //    y  = obj.canvas.height - y;
+            //    h *= -1;
+            //}
+
+            //obj.context.fillStyle = hbars[i][2];
+            //obj.context.fillRect(x, y, w, h);
+        //}
+    }
+
+
+
+
+    /**
+    * Draws in-graph labels.
+    * 
+    * @param object obj The graph object
+    */
+    RGraph.DrawInGraphLabels = function (obj)
+    {
+        var RG      = RGraph;
+        var ca      = obj.canvas;
+        var co      = obj.context;
+        var prop    = obj.properties;
+        var labels  = prop['chart.labels.ingraph'];
+        var labels_processed = [];
+
+        // Defaults
+        var fgcolor   = 'black';
+        var bgcolor   = 'white';
+        var direction = 1;
+
+        if (!labels) {
+            return;
+        }
+
+        /**
+        * Preprocess the labels array. Numbers are expanded
+        */
+        for (var i=0,len=labels.length; i<len; i+=1) {
+            if (typeof(labels[i]) == 'number') {
+                for (var j=0; j<labels[i]; ++j) {
+                    labels_processed.push(null);
+                }
+            } else if (typeof(labels[i]) == 'string' || typeof(labels[i]) == 'object') {
+                labels_processed.push(labels[i]);
+            
+            } else {
+                labels_processed.push('');
+            }
+        }
+
+        /**
+        * Turn off any shadow
+        */
+        RG.NoShadow(obj);
+
+        if (labels_processed && labels_processed.length > 0) {
+
+            for (var i=0,len=labels_processed.length; i<len; ++i) {
+                if (labels_processed[i]) {
+                    var coords = obj.coords[i];
+                    
+                    if (coords && coords.length > 0) {
+                        var x      = (obj.type == 'bar' ? coords[0] + (coords[2] / 2) : coords[0]);
+                        var y      = (obj.type == 'bar' ? coords[1] + (coords[3] / 2) : coords[1]);
+                        var length = typeof(labels_processed[i][4]) == 'number' ? labels_processed[i][4] : 25;
+    
+                        co.beginPath();
+                        co.fillStyle   = 'black';
+                        co.strokeStyle = 'black';
+                        
+    
+                        if (obj.type == 'bar') {
+                        
+                            /**
+                            * X axis at the top
+                            */
+                            if (obj.Get('chart.xaxispos') == 'top') {
+                                length *= -1;
+                            }
+    
+                            if (prop['chart.variant'] == 'dot') {
+                                co.moveTo(Math.round(x), obj.coords[i][1] - 5);
+                                co.lineTo(Math.round(x), obj.coords[i][1] - 5 - length);
+                                
+                                var text_x = Math.round(x);
+                                var text_y = obj.coords[i][1] - 5 - length;
+                            
+                            } else if (prop['chart.variant'] == 'arrow') {
+                                co.moveTo(Math.round(x), obj.coords[i][1] - 5);
+                                co.lineTo(Math.round(x), obj.coords[i][1] - 5 - length);
+                                
+                                var text_x = Math.round(x);
+                                var text_y = obj.coords[i][1] - 5 - length;
+                            
+                            } else {
+    
+                                co.arc(Math.round(x), y, 2.5, 0, 6.28, 0);
+                                co.moveTo(Math.round(x), y);
+                                co.lineTo(Math.round(x), y - length);
+
+                                var text_x = Math.round(x);
+                                var text_y = y - length;
+                            }
+
+                            co.stroke();
+                            co.fill();
+                            
+    
+                        } else if (obj.type == 'line') {
+                        
+                            if (
+                                typeof(labels_processed[i]) == 'object' &&
+                                typeof(labels_processed[i][3]) == 'number' &&
+                                labels_processed[i][3] == -1
+                               ) {
+
+                                co.moveTo(Math.round(x), y + 5);
+                                co.lineTo(Math.round(x), y + 5 + length);
+                                
+                                co.stroke();
+                                co.beginPath();                                
+                                
+                                // This draws the arrow
+                                co.moveTo(Math.round(x), y + 5);
+                                co.lineTo(Math.round(x) - 3, y + 10);
+                                co.lineTo(Math.round(x) + 3, y + 10);
+                                co.closePath();
+                                
+                                var text_x = x;
+                                var text_y = y + 5 + length;
+                            
+                            } else {
+                                
+                                var text_x = x;
+                                var text_y = y - 5 - length;
+
+                                co.moveTo(Math.round(x), y - 5);
+                                co.lineTo(Math.round(x), y - 5 - length);
+                                
+                                co.stroke();
+                                co.beginPath();
+                                
+                                // This draws the arrow
+                                co.moveTo(Math.round(x), y - 5);
+                                co.lineTo(Math.round(x) - 3, y - 10);
+                                co.lineTo(Math.round(x) + 3, y - 10);
+                                co.closePath();
+                            }
+                        
+                            co.fill();
+                        }
+
+                        // Taken out on the 10th Nov 2010 - unnecessary
+                        //var width = context.measureText(labels[i]).width;
+                        
+                        co.beginPath();
+                            
+                            // Fore ground color
+                            co.fillStyle = (typeof(labels_processed[i]) == 'object' && typeof(labels_processed[i][1]) == 'string') ? labels_processed[i][1] : 'black';
+
+                            RG.Text2(obj,{'font':prop['chart.text.font'],
+                                          'size':prop['chart.text.size'],
+                                          'x':text_x,
+                                          'y':text_y,
+                                          'text': (typeof(labels_processed[i]) == 'object' && typeof(labels_processed[i][0]) == 'string') ? labels_processed[i][0] : labels_processed[i],
+                                          'valign': 'bottom',
+                                          'halign':'center',
+                                          'bounding':true,
+                                          'bounding.fill': (typeof(labels_processed[i]) == 'object' && typeof(labels_processed[i][2]) == 'string') ? labels_processed[i][2] : 'white',
+                                          'tag':'labels ingraph'
+                                         });
+                        co.fill();
+                    }
+                }
+            }
+        }
+    }
+
+
+
+
+    /**
+    * This function "fills in" key missing properties that various implementations lack
+    * 
+    * @param object e The event object
+    */
+    RGraph.FixEventObject = function (e)
+    {
+        if (ISOLD) {
+            var e = event;
+
+            e.pageX  = (event.clientX + document.body.scrollLeft);
+            e.pageY  = (event.clientY + document.body.scrollTop);
+            e.target = event.srcElement;
+            
+            if (!document.body.scrollTop && document.documentElement.scrollTop) {
+                e.pageX += parseInt(document.documentElement.scrollLeft);
+                e.pageY += parseInt(document.documentElement.scrollTop);
+            }
+        }
+
+        
+        // Any browser that doesn't implement stopPropagation() (MSIE)
+        if (!e.stopPropagation) {
+            e.stopPropagation = function () {window.event.cancelBubble = true;}
+        }
+        
+        return e;
+    }
+
+
+
+
+    /**
+    * Thisz function hides the crosshairs coordinates
+    */
+    RGraph.HideCrosshairCoords = function ()
+    {
+        var RG  = RGraph;
+        var div = RG.Registry.Get('chart.coordinates.coords.div');
+
+        if (   div
+            && div.style.opacity == 1
+            && div.__object__.Get('chart.crosshairs.coords.fadeout')
+           ) {
+            
+            var style = RG.Registry.Get('chart.coordinates.coords.div').style;
+
+            setTimeout(function() {style.opacity = 0.9;}, 25);
+            setTimeout(function() {style.opacity = 0.8;}, 50);
+            setTimeout(function() {style.opacity = 0.7;}, 75);
+            setTimeout(function() {style.opacity = 0.6;}, 100);
+            setTimeout(function() {style.opacity = 0.5;}, 125);
+            setTimeout(function() {style.opacity = 0.4;}, 150);
+            setTimeout(function() {style.opacity = 0.3;}, 175);
+            setTimeout(function() {style.opacity = 0.2;}, 200);
+            setTimeout(function() {style.opacity = 0.1;}, 225);
+            setTimeout(function() {style.opacity = 0;}, 250);
+            setTimeout(function() {style.display = 'none';}, 275);
+        }
+    }
+
+
+
+
+    /**
+    * Draws the3D axes/background
+    */
+    RGraph.Draw3DAxes = function (obj)
+    {
+        var prop = obj.properties;
+        var co   = obj.context;
+        var ca   = obj.canvas;
+
+        var gutterLeft    = prop['chart.gutter.left'];
+        var gutterRight   = prop['chart.gutter.right'];
+        var gutterTop     = prop['chart.gutter.top'];
+        var gutterBottom  = prop['chart.gutter.bottom'];
+
+
+        co.strokeStyle = '#aaa';
+        co.fillStyle = '#ddd';
+
+        // Draw the vertical left side
+        co.beginPath();
+            co.moveTo(gutterLeft, gutterTop);
+            co.lineTo(gutterLeft + 10, gutterTop - 5);
+            co.lineTo(gutterLeft + 10, ca.height - gutterBottom - 5);
+            co.lineTo(gutterLeft, ca.height - gutterBottom);
+        co.closePath();
+        
+        co.stroke();
+        co.fill();
+
+        // Draw the bottom floor
+        co.beginPath();
+            co.moveTo(gutterLeft, ca.height - gutterBottom);
+            co.lineTo(gutterLeft + 10, ca.height - gutterBottom - 5);
+            co.lineTo(ca.width - gutterRight + 10,  ca.height - gutterBottom - 5);
+            co.lineTo(ca.width - gutterRight, ca.height - gutterBottom);
+        co.closePath();
+        
+        co.stroke();
+        co.fill();
+    }
+
+
+
+
+
+    /**
+    * This function attempts to "fill in" missing functions from the canvas
+    * context object. Only two at the moment - measureText() nd fillText().
+    * 
+    * @param object context The canvas 2D context
+    */
+    RGraph.OldBrowserCompat = function (co)
+    {
+        if (!co) {
+            return;
+        }
+
+        if (!co.measureText) {
+        
+            // This emulates the measureText() function
+            co.measureText = function (text)
+            {
+                var textObj = document.createElement('DIV');
+                textObj.innerHTML = text;
+                textObj.style.position = 'absolute';
+                textObj.style.top = '-100px';
+                textObj.style.left = 0;
+                document.body.appendChild(textObj);
+
+                var width = {width: textObj.offsetWidth};
+                
+                textObj.style.display = 'none';
+                
+                return width;
+            }
+        }
+
+        if (!co.fillText) {
+            // This emulates the fillText() method
+            co.fillText    = function (text, targetX, targetY)
+            {
+                return false;
+            }
+        }
+
+        // If IE8, add addEventListener()
+        if (!co.canvas.addEventListener) {
+            window.addEventListener = function (ev, func, bubble)
+            {
+                return this.attachEvent('on' + ev, func);
+            }
+
+            co.canvas.addEventListener = function (ev, func, bubble)
+            {
+                return this.attachEvent('on' + ev, func);
+            }
+        }
+    }
+
+
+
+
+    /**
+    * Draws a rectangle with curvy corners
+    * 
+    * @param co object The context
+    * @param x number The X coordinate (top left of the square)
+    * @param y number The Y coordinate (top left of the square)
+    * @param w number The width of the rectangle
+    * @param h number The height of the rectangle
+    * @param   number The radius of the curved corners
+    * @param   boolean Whether the top left corner is curvy
+    * @param   boolean Whether the top right corner is curvy
+    * @param   boolean Whether the bottom right corner is curvy
+    * @param   boolean Whether the bottom left corner is curvy
+    */
+    RGraph.strokedCurvyRect = function (co, x, y, w, h)
+    {
+        // The corner radius
+        var r = arguments[5] ? arguments[5] : 3;
+
+        // The corners
+        var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;
+        var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;
+        var corner_br = (arguments[8] || arguments[8] == null) ? true : false;
+        var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;
+
+        co.beginPath();
+
+            // Top left side
+            co.moveTo(x + (corner_tl ? r : 0), y);
+            co.lineTo(x + w - (corner_tr ? r : 0), y);
+            
+            // Top right corner
+            if (corner_tr) {
+                co.arc(x + w - r, y + r, r, PI + HALFPI, TWOPI, false);
+            }
+
+            // Top right side
+            co.lineTo(x + w, y + h - (corner_br ? r : 0) );
+
+            // Bottom right corner
+            if (corner_br) {
+                co.arc(x + w - r, y - r + h, r, TWOPI, HALFPI, false);
+            }
+
+            // Bottom right side
+            co.lineTo(x + (corner_bl ? r : 0), y + h);
+
+            // Bottom left corner
+            if (corner_bl) {
+                co.arc(x + r, y - r + h, r, HALFPI, PI, false);
+            }
+
+            // Bottom left side
+            co.lineTo(x, y + (corner_tl ? r : 0) );
+
+            // Top left corner
+            if (corner_tl) {
+                co.arc(x + r, y + r, r, PI, PI + HALFPI, false);
+            }
+
+        co.stroke();
+    }
+
+
+
+
+    /**
+    * Draws a filled rectangle with curvy corners
+    * 
+    * @param context object The context
+    * @param x       number The X coordinate (top left of the square)
+    * @param y       number The Y coordinate (top left of the square)
+    * @param w       number The width of the rectangle
+    * @param h       number The height of the rectangle
+    * @param         number The radius of the curved corners
+    * @param         boolean Whether the top left corner is curvy
+    * @param         boolean Whether the top right corner is curvy
+    * @param         boolean Whether the bottom right corner is curvy
+    * @param         boolean Whether the bottom left corner is curvy
+    */
+    RGraph.filledCurvyRect = function (co, x, y, w, h)
+    {
+        // The corner radius
+        var r = arguments[5] ? arguments[5] : 3;
+
+        // The corners
+        var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;
+        var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;
+        var corner_br = (arguments[8] || arguments[8] == null) ? true : false;
+        var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;
+
+        co.beginPath();
+
+            // First draw the corners
+
+            // Top left corner
+            if (corner_tl) {
+                co.moveTo(x + r, y + r);
+                co.arc(x + r, y + r, r, PI, PI + HALFPI, false);
+            } else {
+                co.fillRect(x, y, r, r);
+            }
+
+            // Top right corner
+            if (corner_tr) {
+                co.moveTo(x + w - r, y + r);
+                co.arc(x + w - r, y + r, r, PI + HALFPI, 0, false);
+            } else {
+                co.moveTo(x + w - r, y);
+                co.fillRect(x + w - r, y, r, r);
+            }
+
+
+            // Bottom right corner
+            if (corner_br) {
+                co.moveTo(x + w - r, y + h - r);
+                co.arc(x + w - r, y - r + h, r, 0, HALFPI, false);
+            } else {
+                co.moveTo(x + w - r, y + h - r);
+                co.fillRect(x + w - r, y + h - r, r, r);
+            }
+
+            // Bottom left corner
+            if (corner_bl) {
+                co.moveTo(x + r, y + h - r);
+                co.arc(x + r, y - r + h, r, HALFPI, PI, false);
+            } else {
+                co.moveTo(x, y + h - r);
+                co.fillRect(x, y + h - r, r, r);
+            }
+
+            // Now fill it in
+            co.fillRect(x + r, y, w - r - r, h);
+            co.fillRect(x, y + r, r + 1, h - r - r);
+            co.fillRect(x + w - r - 1, y + r, r + 1, h - r - r);
+
+        co.fill();
+    }
+
+
+
+
+    /**
+    * Hides the zoomed canvas
+    */
+    RGraph.HideZoomedCanvas = function ()
+    {
+        var interval = 15;
+        var frames   = 10;
+
+        if (typeof(__zoomedimage__) == 'object') {
+            var obj  = __zoomedimage__.obj;
+            var prop = obj.properties;
+        } else {
+            return;
+        }
+
+        if (prop['chart.zoom.fade.out']) {
+            for (var i=frames,j=1; i>=0; --i, ++j) {
+                if (typeof(__zoomedimage__) == 'object') {
+                    setTimeout("__zoomedimage__.style.opacity = " + String(i / 10), j * interval);
+                }
+            }
+
+            if (typeof(__zoomedbackground__) == 'object') {
+                setTimeout("__zoomedbackground__.style.opacity = " + String(i / frames), j * interval);
+            }
+        }
+
+        if (typeof(__zoomedimage__) == 'object') {
+            setTimeout("__zoomedimage__.style.display = 'none'", prop['chart.zoom.fade.out'] ? (frames * interval) + 10 : 0);
+        }
+
+        if (typeof(__zoomedbackground__) == 'object') {
+            setTimeout("__zoomedbackground__.style.display = 'none'", prop['chart.zoom.fade.out'] ? (frames * interval) + 10 : 0);
+        }
+    }
+
+
+
+
+    /**
+    * Adds an event handler
+    * 
+    * @param object obj   The graph object
+    * @param string event The name of the event, eg ontooltip
+    * @param object func  The callback function
+    */
+    RGraph.AddCustomEventListener = function (obj, name, func)
+    {
+        var RG = RGraph;
+
+        if (typeof(RG.events[obj.uid]) == 'undefined') {
+            RG.events[obj.uid] = [];
+        }
+
+        RG.events[obj.uid].push([obj, name, func]);
+        
+        return RG.events[obj.uid].length - 1;
+    }
+
+
+
+
+    /**
+    * Used to fire one of the RGraph custom events
+    * 
+    * @param object obj   The graph object that fires the event
+    * @param string event The name of the event to fire
+    */
+    RGraph.FireCustomEvent = function (obj, name)
+    {
+        var RG = RGraph;
+
+        if (obj && obj.isRGraph) {
+        
+            // New style of adding custom events
+            if (obj[name]) {
+                (obj[name])(obj);
+            }
+            
+            var uid = obj.uid;
+    
+            if (   typeof(uid) == 'string'
+                && typeof(RG.events) == 'object'
+                && typeof(RG.events[uid]) == 'object'
+                && RG.events[uid].length > 0) {
+    
+                for(var j=0; j<RG.events[uid].length; ++j) {
+                    if (RG.events[uid][j] && RG.events[uid][j][1] == name) {
+                        RG.events[uid][j][2](obj);
+                    }
+                }
+            }
+        }
+    }
+
+
+
+
+    /**
+    * If you prefer, you can use the SetConfig() method to set the configuration information
+    * for your chart. You may find that setting the configuration this way eases reuse.
+    * 
+    * @param object obj    The graph object
+    * @param object config The graph configuration information
+    */
+    RGraph.SetConfig = function (obj, config)
+    {
+        for (i in config) {
+            if (typeof(i) == 'string') {
+                obj.Set(i, config[i]);
+            }
+        }
+        
+        return obj;
+    }
+
+
+
+
+    /**
+    * Clears all the custom event listeners that have been registered
+    * 
+    * @param    string Limits the clearing to this object ID
+    */
+    RGraph.RemoveAllCustomEventListeners = function ()
+    {
+        var RG = RGraph;
+        var id = arguments[0];
+
+        if (id && RG.events[id]) {
+            RG.events[id] = [];
+        } else {
+            RG.events = [];
+        }
+    }
+
+
+
+
+    /**
+    * Clears a particular custom event listener
+    * 
+    * @param object obj The graph object
+    * @param number i   This is the index that is return by .AddCustomEventListener()
+    */
+    RGraph.RemoveCustomEventListener = function (obj, i)
+    {
+        var RG = RGraph;
+
+        if (   typeof(RG.events) == 'object'
+            && typeof(RG.events[obj.id]) == 'object'
+            && typeof(RG.events[obj.id][i]) == 'object') {
+            
+            RG.events[obj.id][i] = null;
+        }
+    }
+
+
+
+
+    /**
+    * This draws the background
+    * 
+    * @param object obj The graph object
+    */
+    RGraph.DrawBackgroundImage = function (obj)
+    {
+        var prop = obj.properties;
+        var ca   = obj.canvas;
+        var co   = obj.context;
+        var RG   = RGraph;
+
+        if (typeof(prop['chart.background.image']) == 'string') {
+            if (typeof(ca.__rgraph_background_image__) == 'undefined') {
+                var img = new Image();
+                img.__object__  = obj;
+                img.__canvas__  = ca;
+                img.__context__ = co;
+                img.src         = obj.Get('chart.background.image');
+                
+                ca.__rgraph_background_image__ = img;
+            } else {
+                img = ca.__rgraph_background_image__;
+            }
+
+            // When the image has loaded - redraw the canvas
+            img.onload = function ()
+            {
+                obj.__rgraph_background_image_loaded__ = true;
+                RG.Clear(ca);
+                RG.RedrawCanvas(ca);
+            }
+                
+            var gutterLeft   = obj.gutterLeft;
+            var gutterRight  = obj.gutterRight;
+            var gutterTop    = obj.gutterTop;
+            var gutterBottom = obj.gutterBottom;
+            var stretch      = prop['chart.background.image.stretch'];
+            var align        = prop['chart.background.image.align'];
+    
+            // Handle chart.background.image.align
+            if (typeof(align) == 'string') {
+                if (align.indexOf('right') != -1) {
+                    var x = ca.width - img.width - gutterRight;
+                } else {
+                    var x = gutterLeft;
+                }
+    
+                if (align.indexOf('bottom') != -1) {
+                    var y = ca.height - img.height - gutterBottom;
+                } else {
+                    var y = gutterTop;
+                }
+            } else {
+                var x = gutterLeft || 25;
+                var y = gutterTop || 25;
+            }
+
+            // X/Y coords take precedence over the align
+            var x = typeof(prop['chart.background.image.x']) == 'number' ? prop['chart.background.image.x'] : x;
+            var y = typeof(prop['chart.background.image.y']) == 'number' ? prop['chart.background.image.y'] : y;
+            var w = stretch ? ca.width - gutterLeft - gutterRight : img.width;
+            var h = stretch ? ca.height - gutterTop - gutterBottom : img.height;
+            
+            /**
+            * You can now specify the width and height of the image
+            */
+            if (typeof(prop['chart.background.image.w']) == 'number') w  = prop['chart.background.image.w'];
+            if (typeof(prop['chart.background.image.h']) == 'number') h = prop['chart.background.image.h'];
+
+            co.drawImage(img,x,y,w, h);
+        }
+    }
+
+
+
+
+    /**
+    * This function determines wshether an object has tooltips or not
+    * 
+    * @param object obj The chart object
+    */
+    RGraph.hasTooltips = function (obj)
+    {
+        var prop = obj.properties;
+
+        if (typeof(prop['chart.tooltips']) == 'object' && prop['chart.tooltips']) {
+            for (var i=0,len=prop['chart.tooltips'].length; i<len; ++i) {
+                if (!RGraph.is_null(obj.Get('chart.tooltips')[i])) {
+                    return true;
+                }
+            }
+        } else if (typeof(prop['chart.tooltips']) == 'function') {
+            return true;
+        }
+        
+        return false;
+    }
+
+
+
+
+    /**
+    * This function creates a (G)UID which can be used to identify objects.
+    * 
+    * @return string (g)uid The (G)UID
+    */
+    RGraph.CreateUID = function ()
+    {
+        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c)
+        {
+            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
+            return v.toString(16);
+        });
+    }
+
+
+
+    /**
+    * This is the new object registry, used to facilitate multiple objects per canvas.
+    * 
+    * @param object obj The object to register
+    */
+    RGraph.ObjectRegistry.Add = function (obj)
+    {
+        var uid = obj.uid;
+        var id  = obj.canvas.id;
+        var RG = RGraph;
+
+        /**
+        * Index the objects by UID
+        */
+        RG.ObjectRegistry.objects.byUID.push([uid, obj]);
+        
+        /**
+        * Index the objects by the canvas that they're drawn on
+        */
+        RG.ObjectRegistry.objects.byCanvasID.push([id, obj]);
+    }
+
+
+
+
+    /**
+    * Remove an object from the object registry
+    * 
+    * @param object obj The object to remove.
+    */
+    RGraph.ObjectRegistry.Remove = function (obj)
+    {
+        var id  = obj.id;
+        var uid = obj.uid;
+        var RG  = RGraph;
+
+        for (var i=0; i<RG.ObjectRegistry.objects.byUID.length; ++i) {
+            if (RG.ObjectRegistry.objects.byUID[i] && RG.ObjectRegistry.objects.byUID[i][1].uid == uid) {
+                RG.ObjectRegistry.objects.byUID[i] = null;
+            }
+        }
+
+
+        for (var i=0; i<RG.ObjectRegistry.objects.byCanvasID.length; ++i) {
+            if (   RG.ObjectRegistry.objects.byCanvasID[i]
+                && RG.ObjectRegistry.objects.byCanvasID[i][1]
+                && RG.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {
+                
+                RG.ObjectRegistry.objects.byCanvasID[i] = null;
+            }
+        }
+
+    }
+
+
+
+
+    /**
+    * Removes all objects from the ObjectRegistry. If either the ID of a canvas is supplied,
+    * or the canvas itself, then only objects pertaining to that canvas are cleared.
+    * 
+    * @param mixed   Either a canvas object (as returned by document.getElementById()
+    *                or the ID of a canvas (ie a string)
+    */
+    RGraph.ObjectRegistry.Clear = function ()
+    {
+        var RG = RGraph;
+
+        // If an ID is supplied restrict the learing to that
+        if (arguments[0]) {
+            var id      = (typeof(arguments[0]) == 'object' ? arguments[0].id : arguments[0]);
+            var objects = RG.ObjectRegistry.getObjectsByCanvasID(id);
+
+            for (var i=0; i<objects.length; ++i) {
+                RG.ObjectRegistry.Remove(objects[i]);
+            }
+
+        } else {
+
+            RG.ObjectRegistry.objects            = {};
+            RG.ObjectRegistry.objects.byUID      = [];
+            RG.ObjectRegistry.objects.byCanvasID = [];
+        }
+    }
+
+
+
+
+    /**
+    * Lists all objects in the ObjectRegistry
+    * 
+    * @param boolean ret Whether to return the list or alert() it
+    */
+    RGraph.ObjectRegistry.List = function ()
+    {
+        var list = [];
+        var RG   = RGraph;
+
+        for (var i=0,len=RG.ObjectRegistry.objects.byUID.length; i<len; ++i) {
+            if (RG.ObjectRegistry.objects.byUID[i]) {
+                list.push(RG.ObjectRegistry.objects.byUID[i][1].type);
+            }
+        }
+        
+        if (arguments[0]) {
+            return list;
+        } else {
+            p(list);
+        }
+    }
+
+
+
+
+    /**
+    * Clears the ObjectRegistry of objects that are of a certain given type
+    * 
+    * @param type string The type to clear
+    */
+    RGraph.ObjectRegistry.ClearByType = function (type)
+    {
+        var RG      = RGraph;
+        var objects = RG.ObjectRegistry.objects.byUID;
+
+        for (var i=0; i<objects.length; ++i) {
+            if (objects[i]) {
+                var uid = objects[i][0];
+                var obj = objects[i][1];
+                
+                if (obj && obj.type == type) {
+                    RG.ObjectRegistry.Remove(obj);
+                }
+            }
+        }
+    }
+
+
+
+
+    /**
+    * This function provides an easy way to go through all of the objects that are held in the
+    * Registry
+    * 
+    * @param func function This function is run for every object. Its passed the object as an argument
+    * @param string type Optionally, you can pass a type of object to look for
+    */
+    RGraph.ObjectRegistry.Iterate = function (func)
+    {
+        var objects = RGraph.ObjectRegistry.objects.byUID;
+
+        for (var i=0; i<objects.length; ++i) {
+        
+            if (typeof arguments[1] == 'string') {
+                
+                var types = arguments[1].split(/,/);
+
+                for (var j=0; j<types.length; ++j) {
+                    if (types[j] == objects[i][1].type) {
+                        func(objects[i][1]);
+                    }
+                }
+            } else {
+                func(objects[i][1]);
+            }
+        }
+    }
+
+
+
+
+    /**
+    * Retrieves all objects for a given canvas id
+    * 
+    * @patarm id string The canvas ID to get objects for.
+    */
+    RGraph.ObjectRegistry.getObjectsByCanvasID = function (id)
+    {
+        var store = RGraph.ObjectRegistry.objects.byCanvasID;
+        var ret = [];
+
+        // Loop through all of the objects and return the appropriate ones
+        for (var i=0; i<store.length; ++i) {
+            if (store[i] && store[i][0] == id ) {
+                ret.push(store[i][1]);
+            }
+        }
+
+        return ret;
+    }
+
+
+
+
+    /**
+    * Retrieves the relevant object based on the X/Y position.
+    * 
+    * @param  object e The event object
+    * @return object   The applicable (if any) object
+    */
+    RGraph.ObjectRegistry.getFirstObjectByXY =
+    RGraph.ObjectRegistry.getObjectByXY = function (e)
+    {
+        var canvas  = e.target;
+        var ret     = null;
+        var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);
+
+        for (var i=(objects.length - 1); i>=0; --i) {
+
+            var obj = objects[i].getObjectByXY(e);
+
+            if (obj) {
+                return obj;
+            }
+        }
+    }
+
+
+
+
+    /**
+    * Retrieves the relevant objects based on the X/Y position.
+    * NOTE This function returns an array of objects
+    * 
+    * @param  object e The event object
+    * @return          An array of pertinent objects. Note the there may be only one object
+    */
+    RGraph.ObjectRegistry.getObjectsByXY = function (e)
+    {
+        var canvas  = e.target;
+        var ret     = [];
+        var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);
+
+        // Retrieve objects "front to back"
+        for (var i=(objects.length - 1); i>=0; --i) {
+
+            var obj = objects[i].getObjectByXY(e);
+
+            if (obj) {
+                ret.push(obj);
+            }
+        }
+        
+        return ret;
+    }
+
+
+
+
+    /**
+    * Retrieves the object with the corresponding UID
+    * 
+    * @param string uid The UID to get the relevant object for
+    */
+    RGraph.ObjectRegistry.getObjectByUID = function (uid)
+    {
+        var objects = RGraph.ObjectRegistry.objects.byUID;
+
+        for (var i=0; i<objects.length; ++i) {
+            if (objects[i] && objects[i][1].uid == uid) {
+                return objects[i][1];
+            }
+        }
+    }
+
+
+
+
+    /**
+    * Brings a chart to the front of the ObjectRegistry by
+    * removing it and then readding it at the end and then
+    * redrawing the canvas
+    * 
+    * @param object  obj    The object to bring to the front
+    * @param boolean redraw Whether to redraw the canvas after the 
+    *                       object has been moved
+    */
+    RGraph.ObjectRegistry.bringToFront = function (obj)
+    {
+        var redraw = typeof arguments[1] == 'undefined' ? true : arguments[1];
+
+        RGraph.ObjectRegistry.Remove(obj);
+        RGraph.ObjectRegistry.Add(obj);
+        
+        if (redraw) {
+            RGraph.RedrawCanvas(obj.canvas);
+        }
+    }
+
+
+
+
+    /**
+    * Retrieves the objects that are the given type
+    * 
+    * @param  mixed canvas  The canvas to check. It can either be the canvas object itself or just the ID
+    * @param  string type   The type to look for
+    * @return array         An array of one or more objects
+    */
+    RGraph.ObjectRegistry.getObjectsByType = function (type)
+    {
+        var objects = RGraph.ObjectRegistry.objects.byUID;
+        var ret     = [];
+
+        for (var i=0; i<objects.length; ++i) {
+
+            if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == type) {
+                ret.push(objects[i][1]);
+            }
+        }
+
+        return ret;
+    }
+
+
+
+
+    /**
+    * Retrieves the FIRST object that matches the given type
+    *
+    * @param  string type   The type of object to look for
+    * @return object        The FIRST object that matches the given type
+    */
+    RGraph.ObjectRegistry.getFirstObjectByType = function (type)
+    {
+        var objects = RGraph.ObjectRegistry.objects.byUID;
+    
+        for (var i=0; i<objects.length; ++i) {
+            if (objects[i] && objects[i][1] && objects[i][1].type == type) {
+                return objects[i][1];
+            }
+        }
+        
+        return null;
+    }
+
+
+
+
+    /**
+    * This takes centerx, centery, x and y coordinates and returns the
+    * appropriate angle relative to the canvas angle system. Remember
+    * that the canvas angle system starts at the EAST axis
+    * 
+    * @param  number cx  The centerx coordinate
+    * @param  number cy  The centery coordinate
+    * @param  number x   The X coordinate (eg the mouseX if coming from a click)
+    * @param  number y   The Y coordinate (eg the mouseY if coming from a click)
+    * @return number     The relevant angle (measured in in RADIANS)
+    */
+    RGraph.getAngleByXY = function (cx, cy, x, y)
+    {
+        var angle = Math.atan((y - cy) / (x - cx));
+            angle = Math.abs(angle)
+
+        if (x >= cx && y >= cy) {
+            angle += TWOPI;
+
+        } else if (x >= cx && y < cy) {
+            angle = (HALFPI - angle) + (PI + HALFPI);
+
+        } else if (x < cx && y < cy) {
+            angle += PI;
+
+        } else {
+            angle = PI - angle;
+        }
+
+        /**
+        * Upper and lower limit checking
+        */
+        if (angle > TWOPI) {
+            angle -= TWOPI;
+        }
+
+        return angle;
+    }
+
+
+
+
+    /**
+    * This function returns the distance between two points. In effect the
+    * radius of an imaginary circle that is centered on x1 and y1. The name
+    * of this function is derived from the word "Hypoteneuse", which in
+    * trigonmetry is the longest side of a triangle
+    * 
+    * @param number x1 The original X coordinate
+    * @param number y1 The original Y coordinate
+    * @param number x2 The target X coordinate
+    * @param number y2 The target Y  coordinate
+    */
+    RGraph.getHypLength = function (x1, y1, x2, y2)
+    {
+        var ret = Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));
+
+        return ret;
+    }
+
+
+
+
+    /**
+    * This function gets the end point (X/Y coordinates) of a given radius.
+    * You pass it the center X/Y and the radius and this function will return
+    * the endpoint X/Y coordinates.
+    * 
+    * @param number cx The center X coord
+    * @param number cy The center Y coord
+    * @param number r  The lrngth of the radius
+    */
+    RGraph.getRadiusEndPoint = function (cx, cy, angle, radius)
+    {
+        var x = cx + (Math.cos(angle) * radius);
+        var y = cy + (Math.sin(angle) * radius);
+        
+        return [x, y];
+    }
+
+
+
+
+    /**
+    * This installs all of the event listeners
+    * 
+    * @param object obj The chart object
+    */
+    RGraph.InstallEventListeners = function (obj)
+    {
+        var RG   = RGraph;
+        var prop = obj.properties;
+
+        /**
+        * Don't attempt to install event listeners for older versions of MSIE
+        */
+        if (ISOLD) {
+            return;
+        }
+
+        /**
+        * If this function exists, then the dynamic file has been included.
+        */
+        if (RG.InstallCanvasClickListener) {
+
+            RG.InstallWindowMousedownListener(obj);
+            RG.InstallWindowMouseupListener(obj);
+            RG.InstallCanvasMousemoveListener(obj);
+            RG.InstallCanvasMouseupListener(obj);
+            RG.InstallCanvasMousedownListener(obj);
+            RG.InstallCanvasClickListener(obj);
+        
+        } else if (   RG.hasTooltips(obj)
+                   || prop['chart.adjustable']
+                   || prop['chart.annotatable']
+                   || prop['chart.contextmenu']
+                   || prop['chart.resizable']
+                   || prop['chart.key.interactive']
+                   || prop['chart.events.click']
+                   || prop['chart.events.mousemove']
+                   || typeof obj.onclick == 'function'
+                   || typeof obj.onmousemove == 'function'
+                  ) {
+
+            alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');
+        }
+    }
+
+
+
+
+    /**
+    * Loosly mimicks the PHP function print_r();
+    */
+    RGraph.pr = function (obj)
+    {
+        var indent = (arguments[2] ? arguments[2] : '    ');
+        var str    = '';
+
+        var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;
+        
+        if (counter >= 5) {
+            return '';
+        }
+        
+        switch (typeof obj) {
+            
+            case 'string':    str += obj + ' (' + (typeof obj) + ', ' + obj.length + ')'; break;
+            case 'number':    str += obj + ' (' + (typeof obj) + ')'; break;
+            case 'boolean':   str += obj + ' (' + (typeof obj) + ')'; break;
+            case 'function':  str += 'function () {}'; break;
+            case 'undefined': str += 'undefined'; break;
+            case 'null':      str += 'null'; break;
+            
+            case 'object':
+                // In case of null
+                if (RGraph.is_null(obj)) {
+                    str += indent + 'null\n';
+                } else {
+                    str += indent + 'Object {' + '\n'
+                    for (j in obj) {
+                        str += indent + '    ' + j + ' => ' + RGraph.pr(obj[j], true, indent + '    ', counter + 1) + '\n';
+                    }
+                    str += indent + '}';
+                }
+                break;
+            
+            
+            default:
+                str += 'Unknown type: ' + typeof obj + '';
+                break;
+        }
+
+
+        /**
+        * Finished, now either return if we're in a recursed call, or alert()
+        * if we're not.
+        */
+        if (!arguments[1]) {
+            alert(str);
+        }
+        
+        return str;
+    }
+
+
+
+
+    /**
+    * Produces a dashed line
+    * 
+    * @param object co The 2D context
+    * @param number x1 The start X coordinate
+    * @param number y1 The start Y coordinate
+    * @param number x2 The end X coordinate
+    * @param number y2 The end Y coordinate
+    */
+    RGraph.DashedLine = function(co, x1, y1, x2, y2)
+    {
+        /**
+        * This is the size of the dashes
+        */
+        var size = 5;
+
+        /**
+        * The optional fifth argument can be the size of the dashes
+        */
+        if (typeof(arguments[5]) == 'number') {
+            size = arguments[5];
+        }
+
+        var dx  = x2 - x1;
+        var dy  = y2 - y1;
+        var num = Math.floor(Math.sqrt((dx * dx) + (dy * dy)) / size);
+
+        var xLen = dx / num;
+        var yLen = dy / num;
+
+        var count = 0;
+
+        do {
+            (count % 2 == 0 && count > 0) ? co.lineTo(x1, y1) : co.moveTo(x1, y1);
+
+            x1 += xLen;
+            y1 += yLen;
+        } while(count++ <= num);
+    }
+
+
+
+
+    /**
+    * Makes an AJAX call. It calls the given callback (a function) when ready
+    * 
+    * @param string   url      The URL to retrieve
+    * @param function callback A function that is called when the response is ready, there's an example below
+    *                          called "myCallback".
+    */
+    RGraph.AJAX = function (url, callback)
+    {
+        // Mozilla, Safari, ...
+        if (window.XMLHttpRequest) {
+            var httpRequest = new XMLHttpRequest();
+
+        // MSIE
+        } else if (window.ActiveXObject) {
+            var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
+        }
+
+        httpRequest.onreadystatechange = function ()
+        {
+            if (this.readyState == 4 && this.status == 200) {
+                this.__user_callback__ = callback;
+                this.__user_callback__(this.responseText);
+            }
+        }
+
+        httpRequest.open('GET', url, true);
+        httpRequest.send();
+    }
+
+
+
+
+    /**
+    * Makes an AJAX POST request. It calls the given callback (a function) when ready
+    * 
+    * @param string   url      The URL to retrieve
+    * @param object   data     The POST data
+    * @param function callback A function that is called when the response is ready, there's an example below
+    *                          called "myCallback".
+    */
+    RGraph.AJAX.POST = function (url, data, callback)
+    {
+        // Used when building the POST string
+        var crumbs = [];
+
+        // Mozilla, Safari, ...
+        if (window.XMLHttpRequest) {
+            var httpRequest = new XMLHttpRequest();
+
+        // MSIE
+        } else if (window.ActiveXObject) {
+            var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
+        }
+
+        httpRequest.onreadystatechange = function ()
+        {
+            if (this.readyState == 4 && this.status == 200) {
+                this.__user_callback__ = callback;
+                this.__user_callback__(this.responseText);
+            }
+        }
+
+        httpRequest.open('POST', url, true);
+        httpRequest.setRequestHeader("Content-type","application/x-www-form-urlencoded");
+        
+        for (i in data) {
+            if (typeof i == 'string') {
+                crumbs.push(i + '=' + encodeURIComponent(data[i]));
+            }
+        }
+
+        httpRequest.send(crumbs.join('&'));
+    }
+
+
+
+
+    /**
+    * Uses the above function but calls the call back passing a number as its argument
+    * 
+    * @param url string The URL to fetch
+    * @param callback function Your callback function (which is passed the number as an argument)
+    */
+    RGraph.AJAX.getNumber = function (url, callback)
+    {
+        RGraph.AJAX(url, function ()
+        {
+            var num = parseFloat(this.responseText);
+
+            callback(num);
+        });
+    }
+
+
+
+
+    /**
+    * Uses the above function but calls the call back passing a string as its argument
+    * 
+    * @param url string The URL to fetch
+    * @param callback function Your callback function (which is passed the string as an argument)
+    */
+    RGraph.AJAX.getString = function (url, callback)
+    {
+        RGraph.AJAX(url, function ()
+        {
+            var str = String(this.responseText);
+
+            callback(str);
+        });
+    }
+
+
+
+
+    /**
+    * Uses the above function but calls the call back passing JSON (ie a JavaScript object ) as its argument
+    * 
+    * @param url string The URL to fetch
+    * @param callback function Your callback function (which is passed the JSON object as an argument)
+    */
+    RGraph.AJAX.getJSON = function (url, callback)
+    {
+        RGraph.AJAX(url, function ()
+        {
+
+            var json = eval('(' + this.responseText + ')');
+
+            callback(json);
+        });
+    }
+
+
+
+
+    /**
+    * Uses the above RGraph.AJAX function but calls the call back passing an array as its argument.
+    * Useful if you're retrieving CSV data
+    * 
+    * @param url string The URL to fetch
+    * @param callback function Your callback function (which is passed the CSV/array as an argument)
+    */
+    RGraph.AJAX.getCSV = function (url, callback)
+    {
+        var seperator = arguments[2] ? arguments[2] : ',';
+
+        RGraph.AJAX(url, function ()
+        {
+            var regexp = new RegExp(seperator);
+            var arr = this.responseText.split(regexp);
+            
+            // Convert the strings to numbers
+            for (var i=0,len=arr.length;i<len;++i) {
+                arr[i] = parseFloat(arr[i]);
+            }
+
+            callback(arr);
+        });
+    }
+
+
+
+
+    /**
+    * Rotates the canvas
+    * 
+    * @param object canvas The canvas to rotate
+    * @param  int   x      The X coordinate about which to rotate the canvas
+    * @param  int   y      The Y coordinate about which to rotate the canvas
+    * @param  int   angle  The angle(in RADIANS) to rotate the canvas by
+    */
+    RGraph.RotateCanvas = function (ca, x, y, angle)
+    {
+        var co = ca.getContext('2d');
+
+        co.translate(x, y);
+        co.rotate(angle);
+        co.translate(0 - x, 0 - y);    
+    }
+
+
+
+
+    /**
+    * Measures text by creating a DIV in the document and adding the relevant text to it.
+    * Then checking the .offsetWidth and .offsetHeight.
+    * 
+    * @param  string text   The text to measure
+    * @param  bool   bold   Whether the text is bold or not
+    * @param  string font   The font to use
+    * @param  size   number The size of the text (in pts)
+    * @return array         A two element array of the width and height of the text
+    */
+    RGraph.MeasureText = function (text, bold, font, size)
+    {
+        // Add the sizes to the cache as adding DOM elements is costly and causes slow downs
+        if (typeof(__rgraph_measuretext_cache__) == 'undefined') {
+            __rgraph_measuretext_cache__ = [];
+        }
+
+        var str = text + ':' + bold + ':' + font + ':' + size;
+        if (typeof(__rgraph_measuretext_cache__) == 'object' && __rgraph_measuretext_cache__[str]) {
+            return __rgraph_measuretext_cache__[str];
+        }
+        
+        if (!__rgraph_measuretext_cache__['text-div']) {
+            var div = document.createElement('DIV');
+                div.style.position = 'absolute';
+                div.style.top = '-100px';
+                div.style.left = '-100px';
+            document.body.appendChild(div);
+            
+            // Now store the newly created DIV
+            __rgraph_measuretext_cache__['text-div'] = div;
+
+        } else if (__rgraph_measuretext_cache__['text-div']) {
+            var div = __rgraph_measuretext_cache__['text-div'];
+        }
+
+        div.innerHTML = text.replace(/\r\n/g, '<br />');
+        div.style.fontFamily = font;
+        div.style.fontWeight = bold ? 'bold' : 'normal';
+        div.style.fontSize = (size || 12) + 'pt';
+        
+        var size = [div.offsetWidth, div.offsetHeight];
+
+        //document.body.removeChild(div);
+        __rgraph_measuretext_cache__[str] = size;
+        
+        return size;
+    }
+
+
+
+
+    /* New text function. Accepts two arguments:
+    *  o obj - The chart object
+    *  o opt - An object/hash/map of properties. This can consist of:
+    *          x                The X coordinate (REQUIRED)
+    *          y                The Y coordinate (REQUIRED)
+    *          text             The text to show (REQUIRED)
+    *          font             The font to use
+    *          size             The size of the text (in pt)
+    *          bold             Whether the text shouldd be bold or not
+    *          marker           Whether to show a marker that indicates the X/Y coordinates
+    *          valign           The vertical alignment
+    *          halign           The horizontal alignment
+    *          bounding         Whether to draw a bounding box for the text
+    *          boundingStroke   The strokeStyle of the bounding box
+    *          boundingFill     The fillStyle of the bounding box
+    */
+    RGraph.Text2 = function (obj, opt)
+    {
+        /**
+        * An RGraph object can be given, or a string or the 2D rendering context
+        * The coords are placed on the obj.coordsText variable ONLY if it's an RGraph object. The function
+        * still returns the cooords though in all cases.
+        */
+        if (obj && obj.isRGraph) {
+            var co = obj.context;
+            var ca = obj.canvas;
+        } else if (typeof obj == 'string') {
+            var ca = document.getElementById(obj);
+            var co = ca.getContext('2d');
+        } else if (typeof obj.getContext == 'function') {
+            var ca = obj;
+            var co = ca.getContext('2d');
+        } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1) {
+            var co = obj;
+            var ca = obj.context;
+        }
+
+        var x              = opt.x;
+        var y              = opt.y;
+        var originalX      = x;
+        var originalY      = y;
+        var text           = opt.text;
+        var text_multiline = text.split(/\r?\n/g);
+        var numlines       = text_multiline.length;
+        var font           = opt.font ? opt.font : 'Arial';
+        var size           = opt.size ? opt.size : 10;
+        var size_pixels    = size * 1.5;
+        var bold           = opt.bold;
+        var halign         = opt.halign ? opt.halign : 'left';
+        var valign         = opt.valign ? opt.valign : 'bottom';
+        var tag            = typeof opt.tag == 'string' && opt.tag.length > 0 ? opt.tag : '';
+        var marker         = opt.marker;
+        var angle          = opt.angle || 0;
+        
+        /**
+        * Changed the name of boundingFill/boundingStroke - this allows you to still use those names
+        */
+        if (typeof opt.boundingFill == 'string')   opt['bounding.fill']   = opt.boundingFill;
+        if (typeof opt.boundingStroke == 'string') opt['bounding.stroke'] = opt.boundingStroke;
+
+        var bounding                = opt.bounding;
+        var bounding_stroke         = opt['bounding.stroke'] ? opt['bounding.stroke'] : 'black';
+        var bounding_fill           = opt['bounding.fill'] ? opt['bounding.fill'] : 'rgba(255,255,255,0.7)';
+        var bounding_shadow         = opt['bounding.shadow'];
+        var bounding_shadow_color   = opt['bounding.shadow.color'] || '#ccc';
+        var bounding_shadow_blur    = opt['bounding.shadow.blur'] || 3;
+        var bounding_shadow_offsetx = opt['bounding.shadow.offsetx'] || 3;
+        var bounding_shadow_offsety = opt['bounding.shadow.offsety'] || 3;
+        var bounding_linewidth      = opt['bounding.linewidth'] || 1;
+
+
+
+        /**
+        * Initialize the return value to an empty object
+        */
+        var ret = {};
+
+
+
+        /**
+        * The text arg must be a string or a number
+        */
+        if (typeof text == 'number') {
+            text = String(text);
+        }
+
+        if (typeof text != 'string') {
+            alert('[RGRAPH TEXT] The text given must a string or a number');
+            return;
+        }
+        
+        
+        
+        /**
+        * This facilitates vertical text
+        */
+        if (angle != 0) {
+            co.save();
+            co.translate(x, y);
+            co.rotate((Math.PI / 180) * angle)
+            x = 0;
+            y = 0;
+        }
+
+
+        
+        /**
+        * Set the font
+        */
+        co.font = (opt.bold ? 'bold ' : '') + size + 'pt ' + font;
+
+
+
+        /**
+        * Measure the width/height. This must be done AFTER the font has been set
+        */
+        var width=0;
+        for (var i=0; i<numlines; ++i) {
+            width = Math.max(width, co.measureText(text_multiline[i]).width);
+        }
+        var height = size_pixels * numlines;
+
+
+
+
+        /**
+        * Accommodate old MSIE 7/8
+        */
+        //if (document.all && ISOLD) {
+            //y += 2;
+        //}
+
+
+
+        /**
+        * If marker is specified draw a marker at the X/Y coordinates
+        */
+        if (opt.marker) {
+            var marker_size = 10;
+            var strokestyle = co.strokeStyle;
+            co.beginPath();
+                co.strokeStyle = 'red';
+                co.moveTo(x, y - marker_size);
+                co.lineTo(x, y + marker_size);
+                co.moveTo(x - marker_size, y);
+                co.lineTo(x + marker_size, y);
+            co.stroke();
+            co.strokeStyle = strokestyle;
+        }
+
+
+
+        /**
+        * Set the horizontal alignment
+        */
+        if (halign == 'center') {
+            co.textAlign = 'center';
+            var boundingX = x - 2 - (width / 2);
+        } else if (halign == 'right') {
+            co.textAlign = 'right';
+            var boundingX = x - 2 - width;
+        } else {
+            co.textAlign = 'left';
+            var boundingX = x - 2;
+        }
+
+
+        /**
+        * Set the vertical alignment
+        */
+        if (valign == 'center') {
+            
+            co.textBaseline = 'middle';
+            // Move the text slightly
+            y -= 1;
+            
+            y -= ((numlines - 1) / 2) * size_pixels;
+            var boundingY = y - (size_pixels / 2) - 2;
+        
+        } else if (valign == 'top') {
+            co.textBaseline = 'top';
+
+            var boundingY = y - 2;
+
+        } else {
+
+            co.textBaseline = 'bottom';
+            
+            // Move the Y coord if multiline text
+            if (numlines > 1) {
+                y -= ((numlines - 1) * size_pixels);
+            }
+
+            var boundingY = y - size_pixels - 2;
+        }
+        
+        var boundingW = width + 4;
+        var boundingH = height + 4;
+
+
+
+        /**
+        * Draw a bounding box if required
+        */
+        if (bounding) {
+
+            var pre_bounding_linewidth     = co.lineWidth;
+            var pre_bounding_strokestyle   = co.strokeStyle;
+            var pre_bounding_fillstyle     = co.fillStyle;
+            var pre_bounding_shadowcolor   = co.shadowColor;
+            var pre_bounding_shadowblur    = co.shadowBlur;
+            var pre_bounding_shadowoffsetx = co.shadowOffsetX;
+            var pre_bounding_shadowoffsety = co.shadowOffsetY;
+
+            co.lineWidth   = bounding_linewidth;
+            co.strokeStyle = bounding_stroke;
+            co.fillStyle   = bounding_fill;
+
+            if (bounding_shadow) {
+                co.shadowColor   = bounding_shadow_color;
+                co.shadowBlur    = bounding_shadow_blur;
+                co.shadowOffsetX = bounding_shadow_offsetx;
+                co.shadowOffsetY = bounding_shadow_offsety;
+            }
+
+            //obj.context.strokeRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);
+            //obj.context.fillRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);
+            co.strokeRect(boundingX, boundingY, boundingW, boundingH);
+            co.fillRect(boundingX, boundingY, boundingW, boundingH);
+
+            // Reset the linewidth,colors and shadow to it's original setting
+            co.lineWidth     = pre_bounding_linewidth;
+            co.strokeStyle   = pre_bounding_strokestyle;
+            co.fillStyle     = pre_bounding_fillstyle;
+            co.shadowColor   = pre_bounding_shadowcolor
+            co.shadowBlur    = pre_bounding_shadowblur
+            co.shadowOffsetX = pre_bounding_shadowoffsetx
+            co.shadowOffsetY = pre_bounding_shadowoffsety
+        }
+
+        
+        
+        /**
+        * Draw the text
+        */
+        if (numlines > 1) {
+            for (var i=0; i<numlines; ++i) {
+                co.fillText(text_multiline[i], x, y + (size_pixels * i));
+            }
+        } else {
+            co.fillText(text, x, y);
+        }
+        
+        
+        
+        /**
+        * If the text is at 90 degrees restore() the canvas - getting rid of the rotation
+        * and the translate that we did
+        */
+        if (angle != 0) {
+            if (angle == 90) {
+                if (halign == 'left') {
+                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
+                
+                } else if (halign == 'center') {
+                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'center') {boundingX = originalX - (height / 2) -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'top')    {boundingX = originalX - height -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}
+                
+                } else if (halign == 'right') {
+                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
+                }
+
+            } else if (angle == 180) {
+
+                if (halign == 'left') {
+                    if (valign == 'bottom') {boundingX = originalX - width - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
+                    if (valign == 'center') {boundingX = originalX - width - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
+                    if (valign == 'top')    {boundingX = originalX - width - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}
+                
+                } else if (halign == 'center') {
+                    if (valign == 'bottom') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
+                    if (valign == 'center') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
+                    if (valign == 'top')    {boundingX = originalX - (width / 2) - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}
+                
+                } else if (halign == 'right') {
+                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
+                    if (valign == 'center') {boundingX = originalX - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
+                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}
+                }
+            
+            } else if (angle == 270) {
+
+                if (halign == 'left') {
+                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'center') {boundingX = originalX - (height / 2) - 4; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
+                
+                } else if (halign == 'center') {
+                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'center') {boundingX = originalX - (height/2) - 4; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}
+                
+                } else if (halign == 'right') {
+                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'center') {boundingX = originalX - (height/2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
+                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
+                }
+            }
+
+            co.restore();
+        }
+
+
+
+
+        /**
+        * Reset the text alignment so that text rendered
+        */
+        co.textBaseline = 'alphabetic';
+        co.textAlign    = 'left';
+
+
+
+
+
+        /**
+        * Fill the ret variable with details of the text
+        */
+        ret.x      = boundingX;
+        ret.y      = boundingY;
+        ret.width  = boundingW;
+        ret.height = boundingH
+        ret.object = obj;
+        ret.text   = text;
+        ret.tag    = tag;
+
+
+
+        /**
+        * Save and then return the details of the text (but oly
+        * if it's an RGraph object that was given)
+        */
+        if (obj && obj.isRGraph && obj.coordsText) {
+            obj.coordsText.push(ret);
+        }
+
+        return ret;
+    }
+
+
+
+
+    /**
+    * Takes a sequential index abd returns the group/index variation of it. Eg if you have a
+    * sequential index from a grouped bar chart this function can be used to convert that into
+    * an appropriate group/index combination
+    * 
+    * @param nindex number The sequential index
+    * @param data   array  The original data (which is grouped)
+    * @return              The group/index information
+    */
+    RGraph.sequentialIndexToGrouped = function (index, data)
+    {
+        var group         = 0;
+        var grouped_index = 0;
+
+        while (--index >= 0) {
+
+            if (RGraph.is_null(data[group])) {
+                group++;
+                grouped_index = 0;
+                continue;
+            }
+
+            // Allow for numbers as well as arrays in the dataset
+            if (typeof data[group] == 'number') {
+                group++
+                grouped_index = 0;
+                continue;
+            }
+            
+
+            grouped_index++;
+            
+            if (grouped_index >= data[group].length) {
+                group++;
+                grouped_index = 0;
+            }
+        }
+        
+        return [group, grouped_index];
+    }
+
+
+
+
+    /**
+    * Similar to the jQuery each() function - this lets you iterate easily over an array. The 'this' variable is set]
+    * to the array in the callback function.
+    * 
+    * @param array    arr The array
+    * @param function func The function to call
+    * @param object        Optionally you can specify the object that the "this" variable is set to
+    */
+    RGraph.each = function (arr, func)
+    {
+        for(var i=0, len=arr.length; i<len; i+=1) {
+                
+            if (typeof arguments[2] !== 'undefined') {
+                var ret = func.call(arguments[2], i, arr[i]);
+            } else {
+                var ret = func.call(arr, i, arr[i]);
+            }
+            
+            if (ret === false) {
+                return;
+            }
+        }
+    }
+
+
+
+
+    /**
+    * Checks whether strings or numbers are empty or not. It also
+    * handles null or variables set to undefined. If a variable really
+    * is undefined - ie it hasn't been declared at all - you need to use
+    * "typeof variable" and check the return value - which will be undefined.
+    * 
+    * @param mixed value The variable to check
+    */
+    function empty (value)
+    {
+        if (!value || value.length <= 0) {
+            return true;
+        }
+        
+        return false;
+    }
+
+
+
+
+    /**
+    * This function highlights a rectangle
+    * 
+    * @param object obj    The chart object
+    * @param number shape  The coordinates of the rect to highlight
+    */
+    RGraph.Highlight.Rect = function (obj, shape)
+    {        
+        var ca   = obj.canvas;
+        var co   = obj.context;
+        var prop = obj.properties;
+
+        if (prop['chart.tooltips.highlight']) {
+            
+        
+            // Safari seems to need this
+            co.lineWidth = 1;
+
+            /**
+            * Draw a rectangle on the canvas to highlight the appropriate area
+            */
+            co.beginPath();
+
+                co.strokeStyle = prop['chart.highlight.stroke'];
+                co.fillStyle   = prop['chart.highlight.fill'];
+    
+                co.strokeRect(shape['x'],shape['y'],shape['width'],shape['height']);
+                co.fillRect(shape['x'],shape['y'],shape['width'],shape['height']);
+            co.stroke;
+            co.fill();
+        }
+    }
+
+
+
+
+    /**
+    * This function highlights a point
+    * 
+    * @param object obj    The chart object
+    * @param number shape  The coordinates of the rect to highlight
+    */
+    RGraph.Highlight.Point = function (obj, shape)
+    {
+        var prop = obj.properties;
+        var ca   = obj.canvas;
+        var co   = obj.context;
+
+        if (prop['chart.tooltips.highlight']) {
+    
+            /**
+            * Draw a rectangle on the canvas to highlight the appropriate area
+            */
+            co.beginPath();
+                co.strokeStyle = prop['chart.highlight.stroke'];
+                co.fillStyle   = prop['chart.highlight.fill'];
+                var radius   = prop['chart.highlight.point.radius'] || 2;
+                co.arc(shape['x'],shape['y'],radius, 0, TWOPI, 0);
+            co.stroke();
+            co.fill();
+        }
+    }
+
+
+
+
+    /**
+    * Creates an HTML tag
+    * 
+    * @param string type
+    * @param obj    parent
+    * @param obj
+    * @param obj
+    */
+    RGraph.HTML.create = function (type, parent)
+    {
+        var obj = document.createElement(type);
+
+
+
+
+        // Add the attributes
+        if (arguments[2]) {
+            this.attr(obj, arguments[2]);
+        }
+
+
+
+
+        // Add the styles
+        if (arguments[3]) {
+            this.css(obj, arguments[3]);
+        }
+
+
+
+
+        /**
+        * Add the tag to the object that has been provided (usually the document)
+        */
+        parent.appendChild(obj);
+
+
+        return obj;
+    }
+
+
+
+
+    /**
+    * Sets attributes on a HTML object
+    * 
+    * @param object obj
+    * @param object attr
+    */
+    RGraph.HTML.attr = function (obj, attr)
+    {
+        for (i in attr) {
+            if (typeof i == 'string') {
+                obj[i] = attr[i];
+            }
+        }
+    }
+
+
+
+
+    /**
+    * Sets CSS on a HTML object
+    * 
+    * @param object obj
+    * @param object css
+    */
+    RGraph.HTML.css = function (obj, styles)
+    {
+        var style = obj.style;
+
+        for (i in styles) {
+            if (typeof i == 'string') {
+                style[i] = styles[i];
+            }
+        }
+    }
+
+
+
+
+    /**
+    * This is the same as Date.parse - though a little more flexible.
+    * 
+    * @param string str The date string to parse
+    * @return Returns the same thing as Date.parse
+    */
+    RGraph.parseDate = function (str)
+    {
+        str.trim();
+
+        // Allow for: now (just the word "now")
+        if (str === 'now') {
+            str = (new Date()).toString();
+        }
+
+        // Allow for: 2013-11-22 12:12:12 or  2013/11/22 12:12:12
+        if (str.match(/^(\d\d\d\d)(-|\/)(\d\d)(-|\/)(\d\d)( |T)(\d\d):(\d\d):(\d\d)$/)) {
+            str = RegExp.$1 + '-' + RegExp.$3 + '-' + RegExp.$5 + 'T' + RegExp.$7 + ':' + RegExp.$8 + ':' + RegExp.$9;
+        }
+
+        // Allow for: 2013-11-22
+        if (str.match(/^\d\d\d\d-\d\d-\d\d$/)) {
+            str = str.replace(/-/, '/');
+        }
+
+        // Allow for: 12:09:44 (time only using todays date)
+        if (str.match(/^\d\d:\d\d:\d\d$/)) {
+        
+            var dateObj  = new Date();
+            var date     = dateObj.getDate();
+            var month    = dateObj.getMonth() + 1;
+            var year     = dateObj.getFullYear();
+            
+            str = (year + '-' + month + '-' + date) + ' ' + str;
+        }
+
+        return Date.parse(str);
+    }
+
+
+
+
+    // Reset all of the color values to their original values
+    RGraph.resetColorsToOriginalValues = function (obj)
+    {
+        if (obj.original_colors) {
+            // Reset the colors to their original values
+            for (var j in obj.original_colors) {
+                if (typeof j === 'string') {
+                    obj.properties[j] = RGraph.array_clone(obj.original_colors[j]);
+                }
+            }
+        }
+        
+        // Reset the colorsParsed flag so that they're parsed for gradients again
+        obj.colorsParsed = false;
+    }
+
+
+
+
+    /**
+    * This function is a short-cut for the canvas path syntax (which can be rather verbose)
+    * 
+    * @param mixed  obj  This can either be the 2D context or an RGraph object
+    * @param array  path The path details
+    */
+    RGraph.Path = function (obj, path)
+    {
+        /**
+        * Allow either the RGraph object or the context to be used as the first argument
+        */
+        if (obj.isRGraph && typeof obj.type === 'string') {
+            var co = obj.context;
+        } else if (obj.toString().indexOf('CanvasRenderingContext2D') > 0) {
+            var co = obj;
+        }
+
+        /**
+        * If the Path information has been passed as a  string - split it up
+        */
+        if (typeof path == 'string') {
+            path = path.split(/ +/);
+        }
+
+        /**
+        * Go through the path information
+        */
+        for (var i=0,len=path.length; i<len; i+=1) {
+            
+            var op = path[i];
+            
+            // 100,100,50,0,Math.PI * 1.5, false
+            switch (op) {
+                case 'b':co.beginPath();break;
+                case 'c':co.closePath();break;
+                case 'm':co.moveTo(parseFloat(path[i+1]),parseFloat(path[i+2]));i+=2;break;
+                case 'l':co.lineTo(parseFloat(path[i+1]),parseFloat(path[i+2]));i+=2;break;
+                case 's':co.strokeStyle=path[i+1];co.stroke();i+=1;break;
+                case 'f':co.fillStyle=path[i+1];co.fill();i+=1;break;
+                case 'qc':co.quadraticCurveTo(parseFloat(path[i+1]),parseFloat(path[i+2]),parseFloat(path[i+3]),parseFloat(path[i+4]));i+=4;break;
+                case 'bc':co.bezierCurveTo(parseFloat(path[i+1]),parseFloat(path[i+2]),parseFloat(path[i+3]),parseFloat(path[i+4]),parseFloat(path[i+5]),parseFloat(path[i+6]));i+=6;break;
+                case 'r':co.rect(parseFloat(path[i+1]),parseFloat(path[i+2]),parseFloat(path[i+3]),parseFloat(path[i+4]));i+=4;break;
+                case 'a':co.arc(parseFloat(path[i+1]),parseFloat(path[i+2]),parseFloat(path[i+3]),parseFloat(path[i+4]),parseFloat(path[i+5]),path[i+6]==='true'||path[i+6]===true?true:false);i+=6;break;
+                case 'at':co.arcTo(parseFloat(path[i+1]),parseFloat(path[i+2]),parseFloat(path[i+3]),parseFloat(path[i+4]),parseFloat(path[i+5]));i+=5;break;
+                case 'lw':co.lineWidth=parseFloat(path[i+1]);i+=1;break;
+                case 'lj':co.lineJoin=path[i+1];i+=1;break;
+                case 'lc':co.lineCap=path[i+1];i+=1;break;
+                case 'sc':co.shadowColor=path[i+1];i+=1;break;
+                case 'sb':co.shadowBlur=parseFloat(path[i+1]);i+=1;break;
+                case 'sx':co.shadowOffsetX=parseFloat(path[i+1]);i+=1;break;
+                case 'sy':co.shadowOffsetY=parseFloat(path[i+1]);i+=1;break;
+                case 'fu':(path[i+1])(obj);i+=1;break;
+            }
+        }
+    }
+
+
+
+// Some other functions. Because they're rarely changed - they're hand minified
+RGraph.LinearGradient=function(obj,x1,y1,x2,y2,color1,color2){var gradient=obj.context.createLinearGradient(x1,y1,x2,y2);var numColors=arguments.length-5;for (var i=5;i<arguments.length;++i){var color=arguments[i];var stop=(i-5)/(numColors-1);gradient.addColorStop(stop,color);}return gradient;}
+RGraph.RadialGradient=function(obj,x1,y1,r1,x2,y2,r2,color1,color2){var gradient=obj.context.createRadialGradient(x1,y1,r1,x2,y2,r2);var numColors=arguments.length-7;for(var i=7;i<arguments.length; ++i){var color=arguments[i];var stop=(i-7)/(numColors-1);gradient.addColorStop(stop,color);}return gradient;}
+RGraph.array_shift=function(arr){var ret=[];for(var i=1;i<arr.length;++i){ret.push(arr[i]);}return ret;}
+RGraph.AddEventListener=function(id,e,func){var type=arguments[3]?arguments[3]:'unknown';RGraph.Registry.Get('chart.event.handlers').push([id,e,func,type]);}
+RGraph.ClearEventListeners=function(id){if(id&&id=='window'){window.removeEventListener('mousedown',window.__rgraph_mousedown_event_listener_installed__,false);window.removeEventListener('mouseup',window.__rgraph_mouseup_event_listener_installed__,false);}else{var canvas = document.getElementById(id);canvas.removeEventListener('mouseup',canvas.__rgraph_mouseup_event_listener_installed__,false);canvas.removeEventListener('mousemove',canvas.__rgraph_mousemove_event_listener_installed__,false);canvas.removeEventListener('mousedown',canvas.__rgraph_mousedown_event_listener_installed__,false);canvas.removeEventListener('click',canvas.__rgraph_click_event_listener_installed__,false);}}
+RGraph.HidePalette=function(){var div=RGraph.Registry.Get('palette');if(typeof(div)=='object'&&div){div.style.visibility='hidden';div.style.display='none';RGraph.Registry.Set('palette',null);}}
+RGraph.random=function(min,max){var dp=arguments[2]?arguments[2]:0;var r=Math.random();return Number((((max - min) * r) + min).toFixed(dp));}
+RGraph.random.array=function(num,min,max){var arr = [];for(var i=0;i<num;i++)arr.push(RGraph.random(min,max));return arr;}
+RGraph.NoShadow=function(obj){obj.context.shadowColor='rgba(0,0,0,0)';obj.context.shadowBlur=0;obj.context.shadowOffsetX=0;obj.context.shadowOffsetY=0;}
+RGraph.SetShadow=function(obj,color,offsetx,offsety,blur){obj.context.shadowColor=color;obj.context.shadowOffsetX=offsetx;obj.context.shadowOffsetY=offsety;obj.context.shadowBlur=blur;}
+RGraph.array_reverse=function(arr){var newarr=[];for(var i=arr.length-1;i>=0;i--){newarr.push(arr[i]);}return newarr;}
+RGraph.Registry.Set=function(name,value){RGraph.Registry.store[name]=value;return value;}
+RGraph.Registry.Get=function(name){return RGraph.Registry.store[name];}
+RGraph.degrees2Radians=function(degrees){return degrees*(PI/180);}
+RGraph.log=(function(n,base){var log=Math.log;return function(n,base){return log(n)/(base?log(base):1);};})();
+RGraph.is_array=function(obj){return obj!=null&&obj.constructor.toString().indexOf('Array')!=-1;}
+RGraph.trim=function(str){return RGraph.ltrim(RGraph.rtrim(str));}
+RGraph.ltrim=function(str){return str.replace(/^(\s|\0)+/, '');}
+RGraph.rtrim=function(str){return str.replace(/(\s|\0)+$/, '');}
+RGraph.GetHeight=function(obj){return obj.canvas.height;}
+RGraph.GetWidth=function(obj){return obj.canvas.width;}
+RGraph.is_null=function(arg){if(arg==null||(typeof(arg))=='object'&&!arg){return true;}return false;}
+RGraph.Timer=function(label){if(typeof(RGraph.TIMER_LAST_CHECKPOINT)=='undefined'){RGraph.TIMER_LAST_CHECKPOINT=Date.now();}var now=Date.now();console.log(label+': '+(now-RGraph.TIMER_LAST_CHECKPOINT).toString());RGraph.TIMER_LAST_CHECKPOINT=now;}
+RGraph.Async=function(func){return setTimeout(func,arguments[1]?arguments[1]:1);}
+RGraph.isIE=function(){return navigator.userAgent.indexOf('Trident')>0||navigator.userAgent.indexOf('MSIE')>0;};ISIE=RGraph.isIE();
+RGraph.isIE6=function(){return navigator.userAgent.indexOf('MSIE 6')>0;};ISIE6=RGraph.isIE6();
+RGraph.isIE7=function(){return navigator.userAgent.indexOf('MSIE 7')>0;};ISIE7=RGraph.isIE7();
+RGraph.isIE8=function(){return navigator.userAgent.indexOf('MSIE 8')>0;};ISIE8=RGraph.isIE8();
+RGraph.isIE9=function(){return navigator.userAgent.indexOf('MSIE 9')>0;};ISIE9=RGraph.isIE9();
+RGraph.isIE10=function(){return navigator.userAgent.indexOf('MSIE 10')>0;};ISIE10=RGraph.isIE10();
+RGraph.isIE11=function(){return navigator.userAgent.indexOf('MSIE')==-1&&navigator.userAgent.indexOf('Trident')>0;};ISIE11=RGraph.isIE11();
+RGraph.isIE9up=function(){return ISIE9||ISIE10||ISIE11;};ISIE9UP=RGraph.isIE9up();
+RGraph.isIE10up=function(){return ISIE10||ISIE11};ISIE10UP=RGraph.isIE10up();
+RGraph.isIE11up=function(){return ISIE11};ISIE11UP=RGraph.isIE11up();
+RGraph.isOld=function(){return ISIE6||ISIE7||ISIE8;};ISOLD=RGraph.isOld();
+RGraph.Reset=function(canvas){canvas.width=canvas.width;RGraph.ObjectRegistry.Clear(canvas);canvas.__rgraph_aa_translated__=false;}
+function pd(variable){RGraph.pr(variable);}
+function p(variable){RGraph.pr(arguments[0],arguments[1],arguments[3]);}
+function a(variable){alert(variable);}
+function cl(variable){return console.log(variable);}
\ No newline at end of file
diff --git a/mod/questionnaire/javascript/RGraph/RGraph.hbar.js b/mod/questionnaire/javascript/RGraph/RGraph.hbar.js
new file mode 100644
index 0000000..e0eca3d
--- /dev/null
+++ b/mod/questionnaire/javascript/RGraph/RGraph.hbar.js
@@ -0,0 +1,1374 @@
+    /**
+    * o-------------------------------------------------------------------------------o
+    * | This file is part of the RGraph package. RGraph is Free software, licensed    |
+    * | under the MIT license - so it's free to use for all purposes. Extended        |
+    * | support is available if required and donations are always welcome! You can    |
+    * | read more here:                                                               |
+    * |                         http://www.rgraph.net/support                         |
+    * o-------------------------------------------------------------------------------o
+    */
+    
+    if (typeof(RGraph) == 'undefined') RGraph = {};
+
+    /**
+    * The horizontal bar chart constructor. The horizontal bar is a minor variant
+    * on the bar chart. If you have big labels, this may be useful as there is usually
+    * more space available for them.
+    * 
+    * @param object canvas The canvas object
+    * @param array  data   The chart data
+    */
+    RGraph.HBar = function (id, data)
+    {
+        // Get the canvas and context objects
+        this.id                = id;
+        this.canvas            = document.getElementById(typeof id === 'object' ? id.id : id);
+        this.context           = this.canvas.getContext ? this.canvas.getContext("2d") : null;
+        this.canvas.__object__ = this;
+        this.data              = data;
+        this.type              = 'hbar';
+        this.isRGraph          = true;
+        this.uid               = RGraph.CreateUID();
+        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();
+        this.colorsParsed      = false;
+        this.coords            = [];
+        this.coords2           = [];
+        this.coordsText        = [];
+
+
+        /**
+        * Compatibility with older browsers
+        */
+        RGraph.OldBrowserCompat(this.context);
+
+        
+        this.max = 0;
+        this.stackedOrGrouped  = false;
+
+        // Default properties
+        this.properties = {
+            'chart.gutter.left':            75,
+            'chart.gutter.right':           25,
+            'chart.gutter.top':             25,
+            'chart.gutter.bottom':          25,
+            'chart.background.grid':        true,
+            'chart.background.grid.color':  '#ddd',
+            'chart.background.grid.width':  1,
+            'chart.background.grid.hsize':  25,
+            'chart.background.grid.vsize':  25,
+            'chart.background.barcolor1':   'rgba(0,0,0,0)',
+            'chart.background.barcolor2':   'rgba(0,0,0,0)',
+            'chart.background.grid.hlines': true,
+            'chart.background.grid.vlines': true,
+            'chart.background.grid.border': true,
+            'chart.background.grid.autofit':true,
+            'chart.background.grid.autofit.numhlines': 14,
+            'chart.background.grid.autofit.numvlines': 20,
+            'chart.background.grid.dashed': false,
+            'chart.background.grid.dotted': false,
+            'chart.linewidth':              1,
+            'chart.title':                  '',
+            'chart.title.background':       null,
+            'chart.title.xaxis':            '',
+            'chart.title.xaxis.bold':       true,
+            'chart.title.xaxis.size':       null,
+            'chart.title.xaxis.font':       null,
+            'chart.title.yaxis':            '',
+            'chart.title.yaxis.bold':       true,
+            'chart.title.yaxis.size':       null,
+            'chart.title.yaxis.font':       null,
+            'chart.title.yaxis.color':      null,
+            'chart.title.xaxis.pos':        null,
+            'chart.title.yaxis.pos':        0.8,
+            'chart.title.yaxis.x':          null,
+            'chart.title.yaxis.y':          null,
+            'chart.title.xaxis.x':          null,
+            'chart.title.xaxis.y':          null,
+            'chart.title.hpos':             null,
+            'chart.title.vpos':             null,
+            'chart.title.bold':             true,
+            'chart.title.font':             null,
+            'chart.title.x':                null,
+            'chart.title.y':                null,
+            'chart.title.halign':           null,
+            'chart.title.valign':           null,
+            'chart.text.size':              10,
+            'chart.text.color':             'black',
+            'chart.text.font':              'Arial',
+            'chart.colors':                 ['Gradient(white:red)', 'Gradient(white:blue)', 'Gradient(white:green)', 'Gradient(white:pink)', 'Gradient(white:yellow)', 'Gradient(white:cyan)', 'Gradient(white:navy)', 'Gradient(white:gray)', 'Gradient(white:black)'],
+            'chart.colors.sequential':      false,
+            'chart.xlabels.specific':       null,
+            'chart.labels':                 [],
+            'chart.labels.above':           false,
+            'chart.labels.above.decimals':  0,
+            'chart.labels.above.specific':  null,
+            'chart.xlabels':                true,
+            'chart.xlabels.count':          5,
+            'chart.contextmenu':            null,
+            'chart.key':                    null,
+            'chart.key.background':         'white',
+            'chart.key.position':           'graph',
+            'chart.key.halign':             'right',
+            'chart.key.shadow':             false,
+            'chart.key.shadow.color':       '#666',
+            'chart.key.shadow.blur':        3,
+            'chart.key.shadow.offsetx':     2,
+            'chart.key.shadow.offsety':     2,
+            'chart.key.position.gutter.boxed': false,
+            'chart.key.position.x':         null,
+            'chart.key.position.y':         null,
+            'chart.key.color.shape':        'square',
+            'chart.key.rounded':            true,
+            'chart.key.linewidth':          1,
+            'chart.key.colors':             null,
+            'chart.key.interactive':        false,
+            'chart.key.interactive.highlight.chart.stroke': 'black',
+            'chart.key.interactive.highlight.chart.fill':'rgba(255,255,255,0.7)',
+            'chart.key.interactive.highlight.label':'rgba(255,0,0,0.2)',
+            'chart.key.text.color':         'black',
+            'chart.units.pre':              '',
+            'chart.units.post':             '',
+            'chart.units.ingraph':          false,
+            'chart.strokestyle':            'rgba(0,0,0,0)',
+            'chart.xmin':                   0,
+            'chart.xmax':                   0,
+            'chart.axis.color':             'black',
+            'chart.shadow':                 false,
+            'chart.shadow.color':           '#666',
+            'chart.shadow.blur':            3,
+            'chart.shadow.offsetx':         3,
+            'chart.shadow.offsety':         3,
+            'chart.vmargin':                2,
+            'chart.vmargin.grouped':        2,
+            'chart.grouping':               'grouped',
+            'chart.tooltips':               null,
+            'chart.tooltips.event':         'onclick',
+            'chart.tooltips.effect':        'fade',
+            'chart.tooltips.css.class':     'RGraph_tooltip',
+            'chart.tooltips.highlight':     true,
+            'chart.highlight.fill':         'rgba(255,255,255,0.7)',
+            'chart.highlight.stroke':       'rgba(0,0,0,0)',
+            'chart.annotatable':            false,
+            'chart.annotate.color':         'black',
+            'chart.zoom.factor':            1.5,
+            'chart.zoom.fade.in':           true,
+            'chart.zoom.fade.out':          true,
+            'chart.zoom.hdir':              'right',
+            'chart.zoom.vdir':              'down',
+            'chart.zoom.frames':            25,
+            'chart.zoom.delay':             16.666,
+            'chart.zoom.shadow':            true,
+            'chart.zoom.background':        true,
+            'chart.zoom.action':            'zoom',
+            'chart.resizable':              false,
+            'chart.resize.handle.adjust':   [0,0],
+            'chart.resize.handle.background': null,
+            'chart.scale.point':            '.',
+            'chart.scale.thousand':         ',',
+            'chart.scale.decimals':         null,
+            'chart.noredraw':               false,
+            'chart.events.click':           null,
+            'chart.events.mousemove':       null,
+            'chart.noxaxis':                false,
+            'chart.noyaxis':                false,
+            'chart.noaxes':                 false,
+            'chart.noxtickmarks':           false,
+            'chart.noytickmarks':           false,
+            'chart.numyticks':              data.length,
+            'chart.numxticks':              10
+        }
+
+        // Check for support
+        if (!this.canvas) {
+            alert('[HBAR] No canvas support');
+            return;
+        }
+
+        for (i=0; i<this.data.length; ++i) {
+            if (typeof(this.data[i]) == 'object') {
+                this.stackedOrGrouped = true;
+            }
+        }
+
+
+        /**
+        * Create the dollar objects so that functions can be added to them
+        */
+        var linear_data = RGraph.array_linearize(data);
+        for (var i=0; i<linear_data.length; ++i) {
+            this['$' + i] = {};
+        }
+
+
+
+        /**
+        * Create the linear data array
+        */
+        this.data_arr = RGraph.array_linearize(this.data);
+
+
+        /**
+        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen
+        * done already
+        */
+        if (!this.canvas.__rgraph_aa_translated__) {
+            this.context.translate(0.5,0.5);
+            
+            this.canvas.__rgraph_aa_translated__ = true;
+        }
+
+
+
+
+        ///////////////////////////////// SHORT PROPERTIES /////////////////////////////////
+
+
+
+
+        var RG   = RGraph;
+        var ca   = this.canvas;
+        var co   = ca.getContext('2d');
+        var prop = this.properties;
+        //var $jq  = jQuery;
+
+
+
+
+        //////////////////////////////////// METHODS ///////////////////////////////////////
+
+
+
+
+        /**
+        * A setter
+        * 
+        * @param name  string The name of the property to set
+        * @param value mixed  The value of the property
+        */
+        this.Set = function (name, value)
+        {
+            name = name.toLowerCase();
+    
+            /**
+            * This should be done first - prepend the propertyy name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            if (name == 'chart.labels.abovebar') {
+                name = 'chart.labels.above';
+            }
+    
+            prop[name] = value;
+    
+            return this;
+        }
+
+
+
+
+        /**
+        * A getter
+        * 
+        * @param name  string The name of the property to get
+        */
+        this.Get = function (name)
+        {
+            /**
+            * This should be done first - prepend the property name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            if (name == 'chart.labels.abovebar') {
+                name = 'chart.labels.above';
+            }
+    
+            return prop[name];
+        }
+
+
+
+
+        /**
+        * The function you call to draw the bar chart
+        */
+        this.Draw = function ()
+        {
+            /**
+            * Fire the onbeforedraw event
+            */
+            RG.FireCustomEvent(this, 'onbeforedraw');
+    
+    
+            /**
+            * Parse the colors. This allows for simple gradient syntax
+            */
+            if (!this.colorsParsed) {
+                this.parseColors();
+                
+                // Don't want to do this again
+                this.colorsParsed = true;
+            }
+    
+    
+            /**
+            * This is new in May 2011 and facilitates indiviual gutter settings,
+            * eg chart.gutter.left
+            */
+            this.gutterLeft   = prop['chart.gutter.left'];
+            this.gutterRight  = prop['chart.gutter.right'];
+            this.gutterTop    = prop['chart.gutter.top'];
+            this.gutterBottom = prop['chart.gutter.bottom'];
+    
+            /**
+            * Stop the coords array from growing uncontrollably
+            */
+            this.coords  = [];
+            this.coords2 = [];
+            this.max     = 0;
+    
+            /**
+            * Check for chart.xmin in stacked charts
+            */
+            if (prop['chart.xmin'] > 0 && prop['chart.grouping'] == 'stacked') {
+                alert('[HBAR] Using chart.xmin is not supported with stacked charts, resetting chart.xmin to zero');
+                this.Set('chart.xmin', 0);
+            }
+    
+            /**
+            * Work out a few things. They need to be here because they depend on things you can change before you
+            * call Draw() but after you instantiate the object
+            */
+            this.graphwidth     = ca.width - this.gutterLeft - this.gutterRight;
+            this.graphheight    = ca.height - this.gutterTop - this.gutterBottom;
+            this.halfgrapharea  = this.grapharea / 2;
+            this.halfTextHeight = prop['chart.text.size'] / 2;
+    
+    
+    
+    
+    
+    
+            // Progressively Draw the chart
+            RG.background.Draw(this);
+    
+            this.Drawbars();
+            this.DrawAxes();
+            this.DrawLabels();
+    
+    
+            // Draw the key if necessary
+            if (prop['chart.key'] && prop['chart.key'].length) {
+                RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);
+            }
+    
+    
+    
+            /**
+            * Setup the context menu if required
+            */
+            if (prop['chart.contextmenu']) {
+                RG.ShowContext(this);
+            }
+
+
+    
+            /**
+            * Draw "in graph" labels
+            */
+            RG.DrawInGraphLabels(this);
+    
+            
+            /**
+            * This function enables resizing
+            */
+            if (prop['chart.resizable']) {
+                RG.AllowResizing(this);
+            }
+    
+    
+            /**
+            * This installs the event listeners
+            */
+            RG.InstallEventListeners(this);
+    
+    
+            /**
+            * Fire the RGraph ondraw event
+            */
+            RG.FireCustomEvent(this, 'ondraw');
+
+            return this;
+        }
+
+
+
+
+        /**
+        * This draws the axes
+        */
+        this.DrawAxes = function ()
+        {
+            var halfway = Math.round((this.graphwidth / 2) + this.gutterLeft);
+    
+            co.beginPath();
+                
+                co.lineWidth   = prop['chart.axis.linewidth'] ? prop['chart.axis.linewidth'] + 0.001 : 1.001;
+                co.strokeStyle = prop['chart.axis.color'];
+    
+                // Draw the Y axis
+                if (prop['chart.noyaxis'] == false && prop['chart.noaxes'] == false) {
+                    if (prop['chart.yaxispos'] == 'center') {
+                        co.moveTo(halfway, this.gutterTop);
+                        co.lineTo(halfway, ca.height - this.gutterBottom);
+                    } else {
+                        co.moveTo(this.gutterLeft, this.gutterTop);
+                        co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);
+                    }
+                }
+    
+                // Draw the X axis
+                if (prop['chart.noxaxis'] == false && prop['chart.noaxes'] == false) {
+                    co.moveTo(this.gutterLeft +0.001, ca.height - this.gutterBottom + 0.001);
+                    co.lineTo(ca.width - this.gutterRight + 0.001, ca.height - this.gutterBottom + 0.001);
+                }
+    
+                // Draw the Y tickmarks
+                if (   prop['chart.noytickmarks'] == false
+                    && prop['chart.noyaxis'] == false
+                    && prop['chart.numyticks'] > 0
+                    && prop['chart.noaxes'] == false
+                   ) {
+        
+                    var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / (prop['chart.numyticks'] > 0 ? prop['chart.numyticks'] : this.data.length);
+            
+                    for (y=this.gutterTop; y<(ca.height - this.gutterBottom - 1); y+=yTickGap) {
+                        if (prop['chart.yaxispos'] == 'center') {
+                            co.moveTo(halfway + 3, Math.round(y));
+                            co.lineTo(halfway  - 3, Math.round(y));
+                        } else {
+                            co.moveTo(this.gutterLeft, Math.round(y));
+                            co.lineTo( this.gutterLeft  - 3, Math.round(y));
+                        }
+                    }
+                    
+                    // If the X axis isn't being shown draw the end tick
+                    if (prop['chart.noxaxis'] == true) {
+                        if (prop['chart.yaxispos'] == 'center') {
+                            co.moveTo(halfway + 3, Math.round(y));
+                            co.lineTo(halfway  - 3, Math.round(y));
+                        } else {
+                            co.moveTo(this.gutterLeft, Math.round(y));
+                            co.lineTo( this.gutterLeft  - 3, Math.round(y));
+                        }
+                    }
+                }
+        
+        
+                // Draw the X tickmarks
+                if (   prop['chart.noxtickmarks'] == false
+                    && prop['chart.noxaxis'] == false
+                    && prop['chart.numxticks'] > 0
+                    && prop['chart.noaxes'] == false) {
+    
+                    xTickGap = (ca.width - this.gutterLeft - this.gutterRight ) / prop['chart.numxticks'];
+                    
+                    yStart   = ca.height - this.gutterBottom;
+                    yEnd     = (ca.height - this.gutterBottom) + 3;
+            
+                    for (x=(ca.width - this.gutterRight), i=0; prop['chart.yaxispos'] == 'center' ? x>=this.gutterLeft : x>this.gutterLeft; x-=xTickGap) {
+            
+                        if (prop['chart.yaxispos'] != 'center' || i != 5) {
+                            co.moveTo(Math.round(x), yStart);
+                            co.lineTo(Math.round(x), yEnd);
+                        }
+                        i++;
+                    }
+    
+                    // If the Y axis isn't being shown draw the end tick
+                    if (prop['chart.noyaxis'] == true) {
+                        co.moveTo(this.gutterLeft, Math.round(yStart));
+                        co.lineTo( this.gutterLeft, Math.round(yEnd));
+                    }
+                }
+            co.stroke();
+                
+            /**
+            * Reset the linewidth
+            */
+            co.lineWidth = 1;
+        }
+
+
+
+
+        /**
+        * This draws the labels for the graph
+        */
+        this.DrawLabels = function ()
+        {
+            var units_pre  = prop['chart.units.pre'];
+            var units_post = prop['chart.units.post'];
+            var text_size  = prop['chart.text.size'];
+            var font       = prop['chart.text.font'];
+    
+    
+    
+            /**
+            * Set the units to blank if they're to be used for ingraph labels only
+            */
+            if (prop['chart.units.ingraph']) {
+                units_pre  = '';
+                units_post = '';
+            }
+    
+    
+            /**
+            * Draw the X axis labels
+            */
+            if (prop['chart.xlabels']) {
+            
+                /**
+                * Specific X labels
+                */
+                if (RGraph.is_array(prop['chart.xlabels.specific'])) {
+                    
+                    if (prop['chart.yaxispos'] == 'center') {
+
+                        var halfGraphWidth = this.graphwidth / 2;
+                        var labels         = prop['chart.xlabels.specific'];
+                        var interval       = (this.graphwidth / 2) / (labels.length - 1);
+
+                        co.fillStyle = prop['chart.text.color'];
+                        
+                        for (var i=0; i<labels.length; i+=1) {
+                                RG.Text2(this, {'font':font,
+                                                'size':text_size,
+                                                'x':this.gutterLeft + halfGraphWidth + (interval * i),
+                                                'y':ca.height - this.gutterBottom,
+                                                'text':labels[i],
+                                                'valign':'top',
+                                                'halign':'center',
+                                                'tag': 'scale'});
+                        }
+                        
+                        for (var i=(labels.length - 1); i>0; i-=1) {
+                                RG.Text2(this, {'font':font,
+                                                'size':text_size,
+                                                'x':this.gutterLeft + (interval * (labels.length - i - 1)),
+                                                'y':ca.height - this.gutterBottom,
+                                                'text':labels[i],
+                                                'valign':'top',
+                                                'halign':'center',
+                                                'tag': 'scale'});
+                        }
+
+                    } else {
+
+                        var labels   = prop['chart.xlabels.specific'];
+                        var interval = this.graphwidth / (labels.length - 1);
+                        
+                        co.fillStyle = prop['chart.text.color'];
+                        
+                        for (var i=0; i<labels.length; i+=1) {
+                                RG.Text2(this, {'font':font,
+                                                'size':text_size,
+                                                'x':this.gutterLeft + (interval * i),
+                                                'y':ca.height - this.gutterBottom,
+                                                'text':labels[i],
+                                                'valign':'top',
+                                                'halign':'center',
+                                                'tag': 'scale'});
+                        }
+                    }
+
+                /**
+                * Draw an X scale
+                */
+                } else {
+    
+                    var gap = 7;
+        
+                    co.beginPath();
+                    co.fillStyle = prop['chart.text.color'];
+        
+        
+                    if (prop['chart.yaxispos'] == 'center') {
+        
+                        for (var i=0; i<this.scale2.labels.length; ++i) {
+                            RG.Text2(this, {'font':font,
+                                                'size':text_size,
+                                                'x':this.gutterLeft + (this.graphwidth / 2) - ((this.graphwidth / 2) * ((i+1)/this.scale2.labels.length)),
+                                                'y':this.gutterTop + this.halfTextHeight + this.graphheight + gap,
+                                                'text':this.scale2.labels[i],
+                                                'valign':'center',
+                                                'halign':'center',
+                                        'tag': 'scale'});
+                        }
+        
+                        for (var i=0; i<this.scale2.labels.length; ++i) {
+                            RG.Text2(this, {'font':font,
+                                                'size':text_size,
+                                                'x':this.gutterLeft + ((this.graphwidth / 2) * ((i+1)/this.scale2.labels.length)) + (this.graphwidth / 2),
+                                                'y':this.gutterTop + this.halfTextHeight + this.graphheight + gap,
+                                                'text':this.scale2.labels[i],
+                                                'valign':'center',
+                                                'halign':'center',
+                                        'tag': 'scale'});
+                        }
+            
+                    } else {
+                    
+                        for (var i=0; i<this.scale2.labels.length; ++i) {
+                            RG.Text2(this, {'font':font,
+                                                'size':text_size,
+                                                'x':this.gutterLeft + (this.graphwidth * ((i+1)/this.scale2.labels.length)),
+                                                'y':this.gutterTop + this.halfTextHeight + this.graphheight + gap,
+                                                'text':this.scale2.labels[i],
+                                                'valign':'center',
+                                                'halign':'center',
+                                                'tag': 'scale'
+                                               });
+                        }
+                    }
+        
+                    /**
+                    * If xmin is not zero - draw that
+                    */
+                    if (prop['chart.xmin'] > 0 || prop['chart.noyaxis'] == true) {
+        
+                        var x = prop['chart.yaxispos'] == 'center' ?  this.gutterLeft + (this.graphwidth / 2): this.gutterLeft;
+        
+                        RG.Text2(this, {'font':font,
+                                            'size':text_size,
+                                            'x':x,
+                                            'y':this.gutterTop + this.halfTextHeight + this.graphheight + gap,
+                                            'text':RG.number_format(this, prop['chart.xmin'].toFixed(prop['chart.scale.decimals']), units_pre, units_post),
+                                            'valign':'center',
+                                            'halign':'center',
+                                            'tag': 'scale'
+                                           });
+                    }
+        
+                    co.fill();
+                    co.stroke();
+                }
+            }
+    
+            /**
+            * The Y axis labels
+            */
+            if (typeof(prop['chart.labels']) == 'object') {
+            
+                var xOffset = 5;
+                var font    = prop['chart.text.font'];
+    
+                // Draw the X axis labels
+                co.fillStyle = prop['chart.text.color'];
+                
+                // How wide is each bar
+                var barHeight = (ca.height - this.gutterTop - this.gutterBottom ) / prop['chart.labels'].length;
+                
+                // Reset the xTickGap
+                yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.labels'].length
+    
+                // Draw the X tickmarks
+                var i=0;
+                for (y=this.gutterTop + (yTickGap / 2); y<=ca.height - this.gutterBottom; y+=yTickGap) {
+                
+                    RG.Text2(this, {'font':font,
+                                       'size':prop['chart.text.size'],
+                                       'x':this.gutterLeft - xOffset,
+                                       'y':y,
+                                       'text':String(prop['chart.labels'][i++]),
+                                       'halign':'right',
+                                       'valign':'center',
+                                       'tag': 'labels'
+                                      });
+                }
+            }
+        }
+
+
+
+
+        /**
+        * This function draws the bars
+        */
+        this.Drawbars = function ()
+        {
+            co.lineWidth   = prop['chart.linewidth'];
+            co.strokeStyle = prop['chart.strokestyle'];
+            co.fillStyle   = prop['chart.colors'][0];
+            var prevX      = 0;
+            var prevY      = 0;
+    
+            /**
+            * Work out the max value
+            */
+            if (prop['chart.xmax']) {
+                this.scale2 = RG.getScale2(this, {'max':prop['chart.xmax'],
+                                                      'min':prop['chart.xmin'],
+                                                      'scale.decimals':Number(prop['chart.scale.decimals']),
+                                                      'scale.point':prop['chart.scale.point'],
+                                                      'scale.thousand':prop['chart.scale.thousand'],
+                                                      'scale.round':prop['chart.scale.round'],
+                                                      'units.pre':prop['chart.units.pre'],
+                                                      'units.post':prop['chart.units.post'],
+                                                      'ylabels.count':prop['chart.xlabels.count'],
+                                                      'strict':true
+                                                     });
+                this.max = this.scale2.max;
+    
+            } else {
+            
+                var grouping = prop['chart.grouping'];
+    
+                for (i=0; i<this.data.length; ++i) {
+                    if (typeof(this.data[i]) == 'object') {
+                        var value = grouping == 'grouped' ? Number(RG.array_max(this.data[i], true)) : Number(RG.array_sum(this.data[i])) ;
+                    } else {
+                        var value = Number(Math.abs(this.data[i]));
+                    }
+    
+                    this.max = Math.max(Math.abs(this.max), Math.abs(value));
+                }
+    
+                this.scale2 = RG.getScale2(this, {'max':this.max,
+                                                      'min':prop['chart.xmin'],
+                                                      'scale.decimals':Number(prop['chart.scale.decimals']),
+                                                      'scale.point':prop['chart.scale.point'],
+                                                      'scale.thousand':prop['chart.scale.thousand'],
+                                                      'scale.round':prop['chart.scale.round'],
+                                                      'units.pre':prop['chart.units.pre'],
+                                                      'units.post':prop['chart.units.post'],
+                                                      'ylabels.count':prop['chart.xlabels.count']
+                                                     });
+    
+    
+                this.max = this.scale2.max;
+                this.min = this.scale2.min;
+            }
+    
+            if (prop['chart.scale.decimals'] == null && Number(this.max) == 1) {
+                this.Set('chart.scale.decimals', 1);
+            }
+            
+            /**
+            * This is here to facilitate sequential colors
+            */
+            var colorIdx = 0;
+    
+            /**
+            * The bars are drawn HERE
+            */
+            var graphwidth = (ca.width - this.gutterLeft - this.gutterRight);
+            var halfwidth  = graphwidth / 2;
+    
+            for (i=0; i<this.data.length; ++i) {
+    
+                // Work out the width and height
+                var width  = (this.data[i] / this.max) *  graphwidth;
+                var height = this.graphheight / this.data.length;
+    
+                var orig_height = height;
+    
+                var x       = this.gutterLeft;
+                var y       = this.gutterTop + (i * height);
+                var vmargin = prop['chart.vmargin'];
+    
+                // Account for negative lengths - Some browsers (eg Chrome) don't like a negative value
+                if (width < 0) {
+                    x -= width;
+                    width = Math.abs(width);
+                }
+    
+                /**
+                * Turn on the shadow if need be
+                */
+                if (prop['chart.shadow']) {
+                    co.shadowColor   = prop['chart.shadow.color'];
+                    co.shadowBlur    = prop['chart.shadow.blur'];
+                    co.shadowOffsetX = prop['chart.shadow.offsetx'];
+                    co.shadowOffsetY = prop['chart.shadow.offsety'];
+                }
+    
+                /**
+                * Draw the bar
+                */
+                co.beginPath();
+                    if (typeof(this.data[i]) == 'number') {
+    
+                        var barHeight = height - (2 * vmargin);
+                        var barWidth  = ((this.data[i] - prop['chart.xmin']) / (this.max - prop['chart.xmin'])) * this.graphwidth;
+                        var barX      = this.gutterLeft;
+    
+                        // Account for Y axis pos
+                        if (prop['chart.yaxispos'] == 'center') {
+                            barWidth /= 2;
+                            barX += halfwidth;
+                            
+                            if (this.data[i] < 0) {
+                                barWidth = (Math.abs(this.data[i]) - prop['chart.xmin']) / (this.max - prop['chart.xmin']);
+                                barWidth = barWidth * (this.graphwidth / 2);
+                                barX = ((this.graphwidth / 2) + this.gutterLeft) - barWidth;
+                            }
+                        }
+    
+                        // Set the fill color
+                        co.strokeStyle = prop['chart.strokestyle'];
+                        co.fillStyle = prop['chart.colors'][0];
+                        
+                        // Sequential colors
+                        if (prop['chart.colors.sequential']) {
+                            co.fillStyle = prop['chart.colors'][colorIdx++];
+                        }
+    
+                        co.strokeRect(barX, this.gutterTop + (i * height) + prop['chart.vmargin'], barWidth, barHeight);
+                        co.fillRect(barX, this.gutterTop + (i * height) + prop['chart.vmargin'], barWidth, barHeight);
+    
+                        this.coords.push([barX,
+                                          y + vmargin,
+                                          barWidth,
+                                          height - (2 * vmargin),
+                                          co.fillStyle,
+                                          this.data[i],
+                                          true]);
+    
+                    /**
+                    * Stacked bar chart
+                    */
+                    } else if (typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'stacked') {
+    
+                        if (prop['chart.yaxispos'] == 'center') {
+                            alert('[HBAR] You can\'t have a stacked chart with the Y axis in the center, change it to grouped');
+                        }
+    
+                        var barHeight = height - (2 * vmargin);
+
+                        if (typeof this.coords2[i] == 'undefined') {
+                            this.coords2[i] = [];
+                        }
+    
+                        for (j=0; j<this.data[i].length; ++j) {
+                        
+    
+                            // Set the fill/stroke colors
+                            co.strokeStyle = prop['chart.strokestyle'];
+                            co.fillStyle = prop['chart.colors'][j];
+                            
+    
+                            // Sequential colors
+                            if (prop['chart.colors.sequential']) {
+                                co.fillStyle = prop['chart.colors'][colorIdx++];
+                            }
+                            
+    
+                            var width = (((this.data[i][j]) / (this.max))) * this.graphwidth;
+                            var totalWidth = (RG.array_sum(this.data[i]) / this.max) * this.graphwidth;
+    
+                            co.strokeRect(x, this.gutterTop + prop['chart.vmargin'] + (this.graphheight / this.data.length) * i, width, height - (2 * vmargin) );
+                            co.fillRect(x, this.gutterTop + prop['chart.vmargin'] + (this.graphheight / this.data.length) * i, width, height - (2 * vmargin) );
+    
+                            /**
+                            * Store the coords for tooltips
+                            */
+    
+                            // The last property of this array is a boolean which tells you whether the value is the last or not
+                            this.coords.push([x,
+                                              y + vmargin,
+                                              width,
+                                              height - (2 * vmargin),
+                                              co.fillStyle,
+                                              RG.array_sum(this.data[i]),
+                                              j == (this.data[i].length - 1)
+                                             ]);
+                            this.coords2[i].push([x,
+                                                  y + vmargin,
+                                                  width,
+                                                  height - (2 * vmargin),
+                                                  co.fillStyle,
+                                                  RG.array_sum(this.data[i]),
+                                                  j == (this.data[i].length - 1)
+                                                 ]);
+    
+                            x += width;
+                        }
+    
+                    /**
+                    * A grouped bar chart
+                    */
+                    } else if (typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'grouped') {
+    
+                        var vmarginGrouped      = prop['chart.vmargin.grouped'];
+                        var individualBarHeight = ((height - (2 * vmargin) - ((this.data[i].length - 1) * vmarginGrouped)) / this.data[i].length)
+                        
+                        if (typeof this.coords2[i] == 'undefined') {
+                            this.coords2[i] = [];
+                        }
+                        
+                        for (j=0; j<this.data[i].length; ++j) {
+    
+    
+                            /**
+                            * Turn on the shadow if need be
+                            */
+                            if (prop['chart.shadow']) {
+                                RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);
+                            }
+    
+                            // Set the fill/stroke colors
+                            co.strokeStyle = prop['chart.strokestyle'];
+                            co.fillStyle   = prop['chart.colors'][j];
+    
+                            // Sequential colors
+                            if (prop['chart.colors.sequential']) {
+                                co.fillStyle = prop['chart.colors'][colorIdx++];
+                            }
+    
+    
+    
+                            var startY = this.gutterTop + (height * i) + (individualBarHeight * j) + vmargin + (vmarginGrouped * j);
+                            var width = ((this.data[i][j] - prop['chart.xmin']) / (this.max - prop['chart.xmin'])) * (ca.width - this.gutterLeft - this.gutterRight );
+                            var startX = this.gutterLeft;
+    
+    
+    
+    
+                            // Account for the Y axis being in the middle
+                            if (prop['chart.yaxispos'] == 'center') {
+                                width  /= 2;
+                                startX += halfwidth;
+                            }
+                            
+                            if (width < 0) {
+                                startX += width;
+                                width *= -1;
+                            }
+    
+                            co.strokeRect(startX, startY, width, individualBarHeight);
+                            co.fillRect(startX, startY, width, individualBarHeight);
+    
+                            this.coords.push([startX,
+                                              startY,
+                                              width,
+                                              individualBarHeight,
+                                              co.fillStyle,
+                                              this.data[i][j],
+                                              true]);
+    
+                            this.coords2[i].push([startX,
+                                                  startY,
+                                                  width,
+                                                  individualBarHeight,
+                                                  co.fillStyle,
+                                                  this.data[i][j],
+                                                  true]);
+                        }
+                        
+                        startY += vmargin;
+                    }
+    
+                co.closePath();
+            }
+    
+            co.stroke();
+            co.fill();
+    
+    
+    
+            /**
+            * Now the bars are stroke()ed, turn off the shadow
+            */
+            RG.NoShadow(this);
+            
+            this.RedrawBars();
+        }
+
+
+
+
+        /**
+        * This function goes over the bars after they been drawn, so that upwards shadows are underneath the bars
+        */
+        this.RedrawBars = function ()
+        {
+            if (prop['chart.noredraw']) {
+                return;
+            }
+    
+            var coords = this.coords;
+    
+            var font   = prop['chart.text.font'];
+            var size   = prop['chart.text.size'];
+            var color  = prop['chart.text.color'];
+    
+            RG.NoShadow(this);
+            co.strokeStyle = prop['chart.strokestyle'];
+    
+            for (var i=0; i<coords.length; ++i) {
+    
+                if (prop['chart.shadow']) {
+                    co.beginPath();
+                        co.strokeStyle = prop['chart.strokestyle'];
+                        co.fillStyle = coords[i][4];
+                        co.lineWidth = prop['chart.linewidth'];
+                        co.strokeRect(coords[i][0], coords[i][1], coords[i][2], coords[i][3]);
+                        co.fillRect(coords[i][0], coords[i][1], coords[i][2], coords[i][3]);
+                    co.fill();
+                    co.stroke();
+                }
+    
+                /**
+                * Draw labels "above" the bar
+                */
+                if (prop['chart.labels.above'] && coords[i][6]) {
+    
+                    co.fillStyle   = prop['chart.text.color'];
+                    co.strokeStyle = 'black';
+                    RG.NoShadow(this);
+    
+                    var border = (coords[i][0] + coords[i][2] + 7 + co.measureText(prop['chart.units.pre'] + this.coords[i][5] + prop['chart.units.post']).width) > ca.width ? true : false;
+                    
+                    /**
+                    * Default to the value - then check for specific labels
+                    */
+                    var text = RG.number_format(this, (this.coords[i][5]).toFixed(prop['chart.labels.above.decimals']), prop['chart.units.pre'], prop['chart.units.post']);
+                    if (typeof prop['chart.labels.above.specific'] == 'object' && prop['chart.labels.above.specific'] && prop['chart.labels.above.specific'][i]) {
+                        text = prop['chart.labels.above.specific'][i];
+                    }
+
+                    RG.Text2(this, {'font':font,
+                                        'size':size,
+                                        'x':coords[i][0] + coords[i][2] + 5,
+                                        'y':coords[i][1] + (coords[i][3] / 2),
+                                        'text': text,
+                                        'valign':'center',
+                                        'halign':'left',
+                                        'tag': 'labels.above'
+                                       });
+                }
+            }
+        }
+
+
+
+
+        /**
+        * This function can be used to get the appropriate bar information (if any)
+        * 
+        * @param  e Event object
+        * @return   Appriate bar information (if any)
+        */
+        this.getShape =
+        this.getBar = function (e)
+        {
+            var mouseCoords = RG.getMouseXY(e);
+    
+            /**
+            * Loop through the bars determining if the mouse is over a bar
+            */
+            for (var i=0,len=this.coords.length; i<len; i++) {
+    
+                var mouseX = mouseCoords[0];  // In relation to the canvas
+                var mouseY = mouseCoords[1];  // In relation to the canvas
+                var left   = this.coords[i][0];
+                var top    = this.coords[i][1];
+                var width  = this.coords[i][2];
+                var height = this.coords[i][3];
+                var idx    = i;
+    
+                if (mouseX >= left && mouseX <= (left + width) && mouseY >= top && mouseY <= (top + height) ) {
+    
+                    var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);
+    
+                    return {
+                            0: this,   'object': this,
+                            1: left,   'x': left,
+                            2: top,    'y': top,
+                            3: width,  'width': width,
+                            4: height, 'height': height,
+                            5: idx,    'index': idx,
+                                       'tooltip': tooltip
+                           };
+                }
+            }
+        }
+
+
+
+
+        /**
+        * When you click on the chart, this method can return the X value at that point. It works for any point on the
+        * chart (that is inside the gutters) - not just points within the Bars.
+        * 
+        * @param object e The event object
+        */
+        this.getValue = function (arg)
+        {
+            if (arg.length == 2) {
+                var mouseX = arg[0];
+                var mouseY = arg[1];
+            } else {
+                var mouseCoords = RG.getMouseXY(arg);
+                var mouseX      = mouseCoords[0];
+                var mouseY      = mouseCoords[1];
+            }
+            
+            if (   mouseY < this.gutterTop
+                || mouseY > (ca.height - this.gutterBottom)
+                || mouseX < this.gutterLeft
+                || mouseX > (ca.width - this.gutterRight)
+               ) {
+                return null;
+            }
+            
+            if (prop['chart.yaxispos'] == 'center') {
+                var value = ((mouseX - this.gutterLeft) / (this.graphwidth / 2)) * (this.max - prop['chart.xmin']);
+                    value = value - this.max
+                    
+                    // Special case if xmin is defined
+                    if (prop['chart.xmin'] > 0) {
+                        value = ((mouseX - this.gutterLeft - (this.graphwidth / 2)) / (this.graphwidth / 2)) * (this.max - prop['chart.xmin']);
+                        value += prop['chart.xmin'];
+                        
+                        if (mouseX < (this.gutterLeft + (this.graphwidth / 2))) {
+                            value -= (2 * prop['chart.xmin']);
+                        }
+                    }
+            } else {
+                var value = ((mouseX - this.gutterLeft) / this.graphwidth) * (this.max - prop['chart.xmin']);
+                    value += prop['chart.xmin'];
+            }
+    
+            return value;
+        }
+
+
+
+
+        /**
+        * Each object type has its own Highlight() function which highlights the appropriate shape
+        * 
+        * @param object shape The shape to highlight
+        */
+        this.Highlight = function (shape)
+        {
+            // Add the new highlight
+            RG.Highlight.Rect(this, shape);
+        }
+
+
+
+
+        /**
+        * The getObjectByXY() worker method. Don't call this call:
+        * 
+        * RG.ObjectRegistry.getObjectByXY(e)
+        * 
+        * @param object e The event object
+        */
+        this.getObjectByXY = function (e)
+        {
+            var mouseXY = RG.getMouseXY(e);
+    
+            if (
+                   mouseXY[0] > this.gutterLeft
+                && mouseXY[0] < (ca.width - this.gutterRight)
+                && mouseXY[1] > this.gutterTop
+                && mouseXY[1] < (ca.height - this.gutterBottom)
+                ) {
+    
+                return this;
+            }
+        }
+
+
+
+
+        /**
+        * This function positions a tooltip when it is displayed
+        * 
+        * @param obj object    The chart object
+        * @param int x         The X coordinate specified for the tooltip
+        * @param int y         The Y coordinate specified for the tooltip
+        * @param objec tooltip The tooltips DIV element
+        */
+        this.positionTooltip = function (obj, x, y, tooltip, idx)
+        {
+            var coordX     = obj.coords[tooltip.__index__][0];
+            var coordY     = obj.coords[tooltip.__index__][1];
+            var coordW     = obj.coords[tooltip.__index__][2];
+            var coordH     = obj.coords[tooltip.__index__][3];
+            var canvasXY   = RG.getCanvasXY(obj.canvas);
+            var gutterLeft = obj.gutterLeft;
+            var gutterTop  = obj.gutterTop;
+            var width      = tooltip.offsetWidth;
+            var height     = tooltip.offsetHeight;
+    
+            // Set the top position
+            tooltip.style.left = 0;
+            tooltip.style.top  = canvasXY[1] + coordY + (coordH / 2) - height + 'px';
+            
+            // By default any overflow is hidden
+            tooltip.style.overflow = '';
+    
+            // The arrow
+            var img = new Image();
+                img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAFCAYAAACjKgd3AAAARUlEQVQYV2NkQAN79+797+RkhC4M5+/bd47B2dmZEVkBCgcmgcsgbAaA9GA1BCSBbhAuA/AagmwQPgMIGgIzCD0M0AMMAEFVIAa6UQgcAAAAAElFTkSuQmCC';
+                img.style.position = 'absolute';
+                img.id = '__rgraph_tooltip_pointer__';
+                img.style.top = (tooltip.offsetHeight - 2) + 'px';
+            tooltip.appendChild(img);
+            
+            // Reposition the tooltip if at the edges:
+            
+            // LEFT edge
+            if ((canvasXY[0] + coordX  + (coordW / 2) - (width / 2)) < 10) {
+                tooltip.style.left = (canvasXY[0] + coordX - (width * 0.1)) + (coordW / 2) + 'px';
+                img.style.left = ((width * 0.1) - 8.5) + 'px';
+    
+            // RIGHT edge
+            } else if ((canvasXY[0] + (coordW / 2) + coordX + (width / 2)) > document.body.offsetWidth) {
+                tooltip.style.left = canvasXY[0] + coordX - (width * 0.9) + (coordW / 2) + 'px';
+                img.style.left = ((width * 0.9) - 8.5) + 'px';
+    
+            // Default positioning - CENTERED
+            } else {
+                tooltip.style.left = (canvasXY[0] + coordX + (coordW / 2) - (width * 0.5)) + 'px';
+                img.style.left = ((width * 0.5) - 8.5) + 'px';
+            }
+        }
+
+
+
+
+        /**
+        * Returns the appropriate Y coord for the given value
+        * 
+        * @param number value The value to get the coord for
+        */
+        this.getXCoord = function (value)
+        {
+    
+            if (prop['chart.yaxispos'] == 'center') {
+        
+                // Range checking
+                if (value > this.max || value < (-1 * this.max)) {
+                    return null;
+                }
+    
+                var width = (ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right']) / 2;
+                var coord = (((value - prop['chart.xmin']) / (this.max - prop['chart.xmin'])) * width) + width;
+    
+                    coord = prop['chart.gutter.left'] + coord;
+            } else {
+            
+                // Range checking
+                if (value > this.max || value < 0) {
+                    return null;
+                }
+    
+                var width = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];
+                var coord = ((value - prop['chart.xmin']) / (this.max - prop['chart.xmin'])) * width;
+    
+                    coord = prop['chart.gutter.left'] + coord;
+            }
+    
+            return coord;
+        }
+
+
+
+
+        /**
+        * 
+        */
+        this.parseColors = function ()
+        {
+            var colors = prop['chart.colors'];
+    
+            for (var i=0; i<colors.length; ++i) {
+                colors[i] = this.parseSingleColorForGradient(colors[i]);
+            }
+            
+            prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);
+            prop['chart.background.barcolor1']  = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);
+            prop['chart.background.barcolor2']  = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);
+            prop['chart.text.color']            = this.parseSingleColorForGradient(prop['chart.text.color']);
+            prop['chart.labels.colors']         = this.parseSingleColorForGradient(prop['chart.labels.colors']);
+            prop['chart.strokestyle']           = this.parseSingleColorForGradient(prop['chart.strokestyle']);
+            prop['chart.axis.color']            = this.parseSingleColorForGradient(prop['chart.axis.color']);
+            prop['chart.highlight.fill']        = this.parseSingleColorForGradient(prop['chart.highlight.fill']);
+            prop['chart.highlight.stroke']      = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);
+        }
+
+
+
+        /**
+        * This parses a single color value
+        */
+        this.parseSingleColorForGradient = function (color)
+        {
+            if (!color || typeof(color) != 'string') {
+                return color;
+            }
+    
+            if (color.match(/^gradient\((.*)\)$/i)) {
+                
+                var parts = RegExp.$1.split(':');
+    
+                // Create the gradient
+                var grad = co.createLinearGradient(prop['chart.gutter.left'],0,ca.width - prop['chart.gutter.right'],0);
+    
+                var diff = 1 / (parts.length - 1);
+    
+                grad.addColorStop(0, RG.trim(parts[0]));
+    
+                for (var j=1; j<parts.length; ++j) {
+                    grad.addColorStop(j * diff, RG.trim(parts[j]));
+                }
+            }
+                
+            return grad ? grad : color;
+        }
+
+
+
+
+        /**
+        * This function handles highlighting an entire data-series for the interactive
+        * key
+        * 
+        * @param int index The index of the data series to be highlighted
+        */
+        this.interactiveKeyHighlight = function (index)
+        {
+            var obj = this;
+
+            this.coords2.forEach(function (value, idx, arr)
+            {
+                var shape = obj.coords2[idx][index]
+                var pre_linewidth = co.lineWidth;
+                co.lineWidth = 2;
+                co.fillStyle   = prop['chart.key.interactive.highlight.chart.fill'];
+                co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];
+                co.fillRect(shape[0], shape[1], shape[2], shape[3]);
+                co.strokeRect(shape[0], shape[1], shape[2], shape[3]);
+                
+                // Reset the lineWidth
+                co.lineWidth = pre_linewidth;
+            });
+        }
+
+
+
+
+        /**
+        * Charts are now always registered
+        */
+        RG.Register(this);
+    }
\ No newline at end of file
diff --git a/mod/questionnaire/javascript/RGraph/RGraph.radar.js b/mod/questionnaire/javascript/RGraph/RGraph.radar.js
new file mode 100644
index 0000000..6eae911
--- /dev/null
+++ b/mod/questionnaire/javascript/RGraph/RGraph.radar.js
@@ -0,0 +1,1534 @@
+    /**
+    * o-------------------------------------------------------------------------------o
+    * | This file is part of the RGraph package. RGraph is Free software, licensed    |
+    * | under the MIT license - so it's free to use for all purposes. Extended        |
+    * | support is available if required and donations are always welcome! You can    |
+    * | read more here:                                                               |
+    * |                         http://www.rgraph.net/support                         |
+    * o-------------------------------------------------------------------------------o
+    */
+    
+    if (typeof(RGraph) == 'undefined') RGraph = {};
+
+    /**
+    * The traditional radar chart constructor
+    * 
+    * @param string id   The ID of the canvas
+    * @param array  data An array of data to represent
+    */
+    RGraph.Radar = function (id, data)
+    {
+        this.id                = id;
+        this.canvas            = document.getElementById(typeof id === 'object' ? id.id : id);
+        this.context           = this.canvas.getContext('2d');
+        this.canvas.__object__ = this;
+        this.type              = 'radar';
+        this.coords            = [];
+        this.isRGraph          = true;
+        this.data              = [];
+        this.max               = 0;
+        this.original_data     = [];
+        this.uid               = RGraph.CreateUID();
+        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();
+        this.colorsParsed      = false;
+        this.coordsText        = [];
+
+        /**
+        * This allows for passing all of the arguments as one big array instead of as individual daatasets
+        */
+        if (typeof arguments[1] == 'object' && typeof arguments[1][0] == 'object') {
+            for (var i=0,len=arguments[1].length; i<len; ++i) {
+                this.original_data.push(RGraph.array_clone(arguments[1][i]));
+                this.data.push(RGraph.array_clone(arguments[1][i]));
+                this.max = Math.max(this.max, RGraph.array_max(arguments[1][i]));
+            }
+        
+        } else {
+        
+            for (var i=1,len=arguments.length; i<len; ++i) {
+                this.original_data.push(RGraph.array_clone(arguments[i]));
+                this.data.push(RGraph.array_clone(arguments[i]));
+                this.max = Math.max(this.max, RGraph.array_max(arguments[i]));
+            }
+        }
+
+        /**
+        * Compatibility with older browsers
+        */
+        RGraph.OldBrowserCompat(this.context);
+
+        
+        this.properties = {
+            'chart.strokestyle':           '#aaa',
+            'chart.gutter.left':           25,
+            'chart.gutter.right':          25,
+            'chart.gutter.top':            25,
+            'chart.gutter.bottom':         25,
+            'chart.linewidth':             1,
+            'chart.colors':                ['rgba(255,255,0,0.25)','rgba(0,255,255,0.25)','rgba(255,0,0,0.5)', 'red', 'green', 'blue', 'pink', 'aqua','brown','orange','grey'],
+            'chart.colors.alpha':          null,
+            'chart.circle':                0,
+            'chart.circle.fill':           'red',
+            'chart.circle.stroke':         'black',
+            'chart.labels':                [],
+            'chart.labels.offset':         10,
+            'chart.background.circles':    true,
+            'chart.background.circles.count': null,
+            'chart.background.circles.color': '#ddd',
+            'chart.background.circles.poly':  true,
+            'chart.text.size':             10,
+            'chart.text.size.scale':       null,
+            'chart.text.font':             'Arial',
+            'chart.text.color':            'black',
+            'chart.title':                 '',
+            'chart.title.background':      null,
+            'chart.title.hpos':            null,
+            'chart.title.vpos':            null,
+            'chart.title.color':           'black',
+            'chart.title.bold':             true,
+            'chart.title.font':             null,
+            'chart.title.x':                null,
+            'chart.title.y':                null,
+            'chart.title.halign':           null,
+            'chart.title.valign':           null,
+            'chart.linewidth':             1,
+            'chart.key':                   null,
+            'chart.key.background':        'white',
+            'chart.key.shadow':            false,
+            'chart.key.shadow.color':       '#666',
+            'chart.key.shadow.blur':        3,
+            'chart.key.shadow.offsetx':     2,
+            'chart.key.shadow.offsety':     2,
+            'chart.key.position':          'graph',
+            'chart.key.halign':             'right',
+            'chart.key.position.gutter.boxed': false,
+            'chart.key.position.x':         null,
+            'chart.key.position.y':         null,
+            'chart.key.color.shape':        'square',
+            'chart.key.rounded':            true,
+            'chart.key.linewidth':          1,
+            'chart.key.colors':             null,
+            'chart.key.interactive':        false,
+            'chart.key.interactive.highlight.chart.stroke': 'rgba(255,0,0,0.3)',
+            'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)',
+            'chart.key.text.color':        'black',
+            'chart.contextmenu':           null,
+            'chart.annotatable':           false,
+            'chart.annotate.color':        'black',
+            'chart.zoom.factor':           1.5,
+            'chart.zoom.fade.in':          true,
+            'chart.zoom.fade.out':         true,
+            'chart.zoom.hdir':             'right',
+            'chart.zoom.vdir':             'down',
+            'chart.zoom.frames':            25,
+            'chart.zoom.delay':             16.666,
+            'chart.zoom.shadow':           true,
+            'chart.zoom.background':        true,
+            'chart.zoom.action':            'zoom',
+            'chart.tooltips.effect':        'fade',
+            'chart.tooltips.event':         'onmousemove',
+            'chart.tooltips.css.class':     'RGraph_tooltip',
+            'chart.tooltips.highlight':     true,
+            'chart.highlight.stroke':       'gray',
+            'chart.highlight.fill':         'rgba(255,255,255,0.7)',
+            'chart.highlight.point.radius': 2,
+            'chart.resizable':              false,
+            'chart.resize.handle.adjust':   [0,0],
+            'chart.resize.handle.background': null,
+            'chart.labels.axes':            '',
+            'chart.labels.background.fill': 'white',
+            'chart.labels.boxed':           false,
+            'chart.labels.axes.bold':       [],
+            'chart.labels.axes.boxed':      null, // This defaults to true - but that's set in the Draw() method
+            'chart.labels.axes.boxed.zero': true,
+            'chart.labels.specific':        [],
+            'chart.labels.count':           5,
+            'chart.ymax':                   null,
+            'chart.accumulative':           false,
+            'chart.radius':                 null,
+            'chart.events.click':           null,
+            'chart.events.mousemove':       null,
+            'chart.scale.decimals':         0,
+            'chart.scale.point':            '.',
+            'chart.scale.thousand':         ',',
+            'chart.units.pre':              '',
+            'chart.units.post':             '',
+            'chart.tooltips':             null,
+            'chart.tooltips.event':       'onmousemove',
+            'chart.centerx':              null,
+            'chart.centery':              null,
+            'chart.radius':               null,
+            'chart.numxticks':            5,
+            'chart.numyticks':            5,
+            'chart.axes.color':           'rgba(0,0,0,0)',
+            'chart.highlights':           false,
+            'chart.highlights.stroke':    '#ddd',
+            'chart.highlights.fill':      null,
+            'chart.highlights.radius':    3,
+            'chart.fill.click':           null,
+            'chart.fill.mousemove':       null,
+            'chart.fill.tooltips':        null,
+            'chart.fill.highlight.fill':   'rgba(255,255,255,0.7)',
+            'chart.fill.highlight.stroke': 'rgba(0,0,0,0)',
+            'chart.fill.mousemove.redraw': false,
+            'chart.animation.trace.clip': 1
+        }
+
+
+
+        // Must have at least 3 points
+        for (var dataset=0; dataset<this.data.length; ++dataset) {
+            if (this.data[dataset].length < 3) {
+                alert('[RADAR] You must specify at least 3 data points');
+                return;
+            }
+        }
+        
+        
+        /**
+        * Linearize the data and then create the $ objects
+        */
+        var idx = 0;
+        for (var dataset=0; dataset<this.data.length; ++dataset) {
+            for (var i=0,len=this.data[dataset].length; i<len; ++i) {
+                this['$' + (idx++)] = {};
+            }
+        }
+
+
+
+        /**
+        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen
+        * done already
+        */
+        if (!this.canvas.__rgraph_aa_translated__) {
+            this.context.translate(0.5,0.5);
+            
+            this.canvas.__rgraph_aa_translated__ = true;
+        }
+
+
+
+
+        ///////////////////////////////// SHORT PROPERTIES /////////////////////////////////
+
+
+
+
+        var RG   = RGraph;
+        var ca   = this.canvas;
+        var co   = ca.getContext('2d');
+        var prop = this.properties;
+        //var $jq  = jQuery;
+
+
+
+
+        //////////////////////////////////// METHODS ///////////////////////////////////////
+
+
+
+
+        /**
+        * A simple setter
+        * 
+        * @param string name  The name of the property to set
+        * @param string value The value of the property
+        */
+        this.Set = function (name, value)
+        {
+            name = name.toLowerCase();
+    
+            /**
+            * This should be done first - prepend the propertyy name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            if (name == 'chart.text.diameter') {
+                name = 'chart.text.size';
+            }
+    
+            /**
+            * If the name is chart.color, set chart.colors too
+            */
+            if (name == 'chart.color') {
+                this.properties['chart.colors'] = [value];
+            }
+    
+            prop[name] = value;
+    
+            return this;
+        }
+
+
+
+
+
+        /**
+        * A simple hetter
+        * 
+        * @param string name  The name of the property to get
+        */
+        this.Get = function (name)
+        {
+            /**
+            * This should be done first - prepend the property name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            if (name == 'chart.text.diameter') {
+                name = 'chart.text.size';
+            }
+    
+            return prop[name];
+        }
+
+
+
+
+        /**
+        * The draw method which does all the brunt of the work
+        */
+        this.Draw = function ()
+        {
+            /**
+            * Fire the onbeforedraw event
+            */
+            RG.FireCustomEvent(this, 'onbeforedraw');
+            
+            // NB: Colors are parsed further down
+    
+            // Reset the coords array to stop it growing
+            this.coords  = [];
+            this.coords2 = [];
+    
+            /**
+            * Reset the data to the original_data
+            */
+            this.data = RG.array_clone(this.original_data);
+
+            // Loop thru the data array if chart.accumulative is enable checking to see if all the
+            // datasets have the same number of elements.
+            if (prop['chart.accumulative']) {
+                for (var i=0; i<this.data.length; ++i) {
+                    if (this.data[i].length != this.data[0].length) {
+                        alert('[RADAR] Error! When the radar has chart.accumulative set to true all the datasets must have the same number of elements');
+                    }
+                }
+            }
+    
+    
+            /**
+            * This defaults to true, but needs to be an array with a size matching the number of
+            * labels.
+            */
+            if (RG.is_null(prop['chart.labels.axes.boxed'])) {
+                prop['chart.labels.axes.boxed'] = [];
+                for (var i=0; i<(prop['chart.labels.specific'].length || prop['chart.labels.count'] || 5); ++i) {
+                    prop['chart.labels.axes.boxed'][i] = true;
+                }
+            }
+
+
+
+
+            /**
+            * This is new in May 2011 and facilitates indiviual gutter settings,
+            * eg chart.gutter.left
+            */
+            this.gutterLeft   = prop['chart.gutter.left'];
+            this.gutterRight  = prop['chart.gutter.right'];
+            this.gutterTop    = prop['chart.gutter.top'];
+            this.gutterBottom = prop['chart.gutter.bottom'];
+    
+            this.centerx  = ((ca.width - this.gutterLeft - this.gutterRight) / 2) + this.gutterLeft;
+            this.centery  = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop;
+            this.radius   = Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2;
+    
+    
+    
+            /**
+            * Allow these to be set by hand
+            */
+            if (typeof(prop['chart.centerx']) == 'number') this.centerx = 2 * prop['chart.centerx'];
+            if (typeof(prop['chart.centery']) == 'number') this.centery = 2 * prop['chart.centery'];
+            if (typeof(prop['chart.radius']) == 'number') this.radius   = prop['chart.radius'];
+    
+    
+            /**
+            * Parse the colors for gradients. Its down here so that the center X/Y can be used
+            */
+            if (!this.colorsParsed) {
+    
+                this.parseColors();
+    
+                // Don't want to do this again
+                this.colorsParsed = true;
+            }
+    
+    
+    
+            // Work out the maximum value and the sum
+            if (!prop['chart.ymax']) {
+    
+                // this.max is calculated in the constructor
+    
+                // Work out this.max again if the chart is (now) set to be accumulative
+                if (prop['chart.accumulative']) {
+                    
+                    var accumulation = [];
+                    var len = this.original_data[0].length
+    
+                    for (var i=1; i<this.original_data.length; ++i) {
+                        if (this.original_data[i].length != len) {
+                            alert('[RADAR] Error! Stacked Radar chart datasets must all be the same size!');
+                        }
+                        
+                        for (var j=0; j<this.original_data[i].length; ++j) {
+                            this.data[i][j] += this.data[i - 1][j];
+                            this.max = Math.max(this.max, this.data[i][j]);
+                        }
+                    }
+                }
+    
+    
+                this.scale2 = RG.getScale2(this, {'max':typeof(prop['chart.ymax']) == 'number' ? prop['chart.ymax'] : this.max,
+                                                  'min':0,
+                                                  'scale.decimals':Number(prop['chart.scale.decimals']),
+                                                  'scale.point':prop['chart.scale.point'],
+                                                  'scale.thousand':prop['chart.scale.thousand'],
+                                                  'scale.round':prop['chart.scale.round'],
+                                                  'units.pre':prop['chart.units.pre'],
+                                                  'units.post':prop['chart.units.post'],
+                                                  'ylabels.count':prop['chart.labels.count']
+                                                 });
+                this.max = this.scale2.max;
+    
+            } else {
+                var ymax = prop['chart.ymax'];
+    
+                this.scale2 = RG.getScale2(this, {'max':ymax,
+                                                  'min':0,
+                                                  'strict':true,
+                                                  'scale.decimals':Number(prop['chart.scale.decimals']),
+                                                  'scale.point':prop['chart.scale.point'],
+                                                  'scale.thousand':prop['chart.scale.thousand'],
+                                                  'scale.round':prop['chart.scale.round'],
+                                                  'units.pre':prop['chart.units.pre'],
+                                                  'units.post':prop['chart.units.post'],
+                                                  'ylabels.count':prop['chart.labels.count']
+                                                 });
+                this.max = this.scale2.max;
+            }
+    
+            this.DrawBackground();
+            this.DrawAxes();
+            this.DrawCircle();
+            this.DrawLabels();
+            this.DrawAxisLabels();
+            
+            /**
+            * Allow clipping
+            */
+            co.save();
+                co.beginPath();
+                    co.arc(this.centerx, this.centery, this.radius * 2, -HALFPI, (TWOPI * prop['chart.animation.trace.clip']) - HALFPI, false);
+                    co.lineTo(this.centerx, this.centery);
+                co.closePath();
+                co.clip();
+    
+                this.DrawChart();
+                this.DrawHighlights();
+    
+            co.restore();
+            
+            // Draw the title
+            if (prop['chart.title']) {
+                RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.diameter'] ? prop['chart.title.diameter'] : null)
+            }
+    
+            // Draw the key if necessary
+            // obj, key, colors
+            if (prop['chart.key']) {
+                RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);
+            }
+    
+            /**
+            * Show the context menu
+            */
+            if (prop['chart.contextmenu']) {
+                RG.ShowContext(this);
+            }
+    
+            
+            /**
+            * This function enables resizing
+            */
+            if (prop['chart.resizable']) {
+                RG.AllowResizing(this);
+            }
+    
+    
+            /**
+            * This installs the event listeners
+            */
+            RG.InstallEventListeners(this);
+
+            /**
+            * This installs the Radar chart specific area listener
+            */
+            if ( (prop['chart.fill.click'] || prop['chart.fill.mousemove'] || !RG.is_null(prop['chart.fill.tooltips'])) && !this.__fill_click_listeners_installed__) {
+                this.AddFillListeners();
+                this.__fill_click_listeners_installed__ = true;
+            }
+
+            /**
+            * Fire the RGraph ondraw event
+            */
+            RGraph.FireCustomEvent(this, 'ondraw');
+            
+            return this;
+        }
+
+
+
+
+        /**
+        * Draws the background circles
+        */
+        this.DrawBackground = function ()
+        {
+            var color   = prop['chart.background.circles.color'];
+            var poly    = prop['chart.background.circles.poly'];
+            var spacing = prop['chart.background.circles.spacing'];
+    
+    
+    
+    
+    
+            // Set the linewidth for the grid (so that repeated redrawing works OK)
+            co.lineWidth = 1;
+    
+    
+    
+    
+            /**
+            * Draws the background circles
+            */
+            if (prop['chart.background.circles'] && poly == false) {
+    
+    
+    
+    
+    
+                // Draw the concentric circles
+                co.strokeStyle = color;
+               co.beginPath();
+                    
+                    var numrings = typeof(prop['chart.background.circles.count']) == 'number' ? prop['chart.background.circles.count'] : prop['chart.labels.count'];
+
+                    // TODO Currently set to 5 - needs changing
+                   for (var r=0; r<=this.radius; r+=(this.radius / numrings)) {
+                        co.moveTo(this.centerx, this.centery);
+                        co.arc(this.centerx, this.centery,r, 0, TWOPI, false);
+                    }
+                co.stroke();
+    
+    
+    
+    
+        
+                /**
+                * Draw the diagonals/spokes
+                */
+                co.strokeStyle = color;
+    
+                for (var i=0; i<360; i+=15) {
+                    co.beginPath();
+                        co.arc(this.centerx,
+                               this.centery,
+                               this.radius,
+                               (i / 360) * TWOPI,
+                               ((i+0.001) / 360) * TWOPI,
+                               false); // The 0.01 avoids a bug in Chrome 6
+                        co.lineTo(this.centerx, this.centery);
+                    co.stroke();
+                }
+    
+    
+    
+    
+    
+    
+            /**
+            * The background"circles" are actually drawn as a poly based on how many points there are
+            * (ie hexagons if there are 6 points, squares if the are four etc)
+            */
+            } else if (prop['chart.background.circles'] && poly == true) {
+    
+                /**
+                * Draw the diagonals/spokes
+                */
+                co.strokeStyle = color;
+                var increment = 360 / this.data[0].length
+    
+                for (var i=0; i<360; i+=increment) {
+                    co.beginPath();
+                        co.arc(this.centerx,
+                               this.centery,
+                               this.radius,
+                               ((i / 360) * TWOPI) - HALFPI,
+                               (((i + 0.001) / 360) * TWOPI) - HALFPI,
+                               false); // The 0.001 avoids a bug in Chrome 6
+                        co.lineTo(this.centerx, this.centery);
+                    co.stroke();
+                }
+    
+    
+                /**
+                * Draw the lines that go around the Radar chart
+                */
+                co.strokeStyle = color;
+                
+                    var numrings = typeof(prop['chart.background.circles.count']) == 'number' ? prop['chart.background.circles.count'] : prop['chart.labels.count'];
+
+                    for (var r=0; r<=this.radius; r+=(this.radius / numrings)) {
+                        co.beginPath();
+                            for (var a=0; a<=360; a+=(360 / this.data[0].length)) {
+                                co.arc(this.centerx,
+                                       this.centery,
+                                       r,
+                                       RG.degrees2Radians(a) - HALFPI,
+                                       RG.degrees2Radians(a) + 0.001 - HALFPI,
+                                       false);
+                            }
+                        co.closePath();
+                        co.stroke();
+                    }
+            }
+        }
+
+
+
+
+        /**
+        * Draws the axes
+        */
+        this.DrawAxes = function ()
+        {
+            co.strokeStyle = prop['chart.axes.color'];
+    
+            var halfsize = this.radius;
+    
+            co.beginPath();
+                /**
+                * The Y axis
+                */
+                co.moveTo(Math.round(this.centerx), this.centery + this.radius);
+                co.lineTo(Math.round(this.centerx), this.centery - this.radius);
+                
+        
+                // Draw the bits at either end of the Y axis
+                co.moveTo(this.centerx - 5, Math.round(this.centery + this.radius));
+                co.lineTo(this.centerx + 5, Math.round(this.centery + this.radius));
+                co.moveTo(this.centerx - 5, Math.round(this.centery - this.radius));
+                co.lineTo(this.centerx + 5, Math.round(this.centery - this.radius));
+    
+                // Draw Y axis tick marks
+                for (var y=(this.centery - this.radius); y<(this.centery + this.radius); y+=(this.radius/prop['chart.numyticks'])) {
+                    co.moveTo(this.centerx - 3, Math.round(y));
+                    co.lineTo(this.centerx + 3, Math.round(y));
+                }
+        
+                /**
+                * The X axis
+                */
+                co.moveTo(this.centerx - this.radius, Math.round(this.centery));
+                co.lineTo(this.centerx + this.radius, Math.round(this.centery));
+        
+                // Draw the bits at the end of the X axis
+                co.moveTo(Math.round(this.centerx - this.radius), this.centery - 5);
+                co.lineTo(Math.round(this.centerx - this.radius), this.centery + 5);
+                co.moveTo(Math.round(this.centerx + this.radius), this.centery - 5);
+                co.lineTo(Math.round(this.centerx + this.radius), this.centery + 5);
+        
+                // Draw X axis tick marks
+                for (var x=(this.centerx - this.radius); x<(this.centerx + this.radius); x+=(this.radius/prop['chart.numxticks'])) {
+                    co.moveTo(Math.round(x), this.centery - 3);
+                    co.lineTo(Math.round(x), this.centery + 3);
+                }
+    
+            // Stroke it
+            co.stroke();
+        }
+
+
+
+
+        /**
+        * The function which actually draws the radar chart
+        */
+        this.DrawChart = function ()
+        {
+            var alpha = prop['chart.colors.alpha'];
+    
+            if (typeof(alpha) == 'number') {
+                var oldAlpha = co.globalAlpha;
+                co.globalAlpha = alpha;
+            }
+            
+            var numDatasets = this.data.length;
+    
+            for (var dataset=0; dataset<this.data.length; ++dataset) {
+    
+                co.beginPath();
+    
+                    var coords_dataset = [];
+        
+                    for (var i=0; i<this.data[dataset].length; ++i) {
+                        
+                        var coords = this.GetCoordinates(dataset, i);
+    
+                        if (coords_dataset == null) {
+                            coords_dataset = [];
+                        }
+    
+                        coords_dataset.push(coords);
+                        this.coords.push(coords);
+                    }
+                    
+                    this.coords2[dataset] = coords_dataset;
+                    
+    
+                    /**
+                    * Now go through the coords and draw the chart itself
+                    *
+                    * 18/5/2012 - chart.strokestyle can now be an array of colors as well as a single color
+                    */
+    
+                    co.strokeStyle = (typeof(prop['chart.strokestyle']) == 'object' && prop['chart.strokestyle'][dataset]) ? prop['chart.strokestyle'][dataset] : prop['chart.strokestyle'];
+                    co.fillStyle   = prop['chart.colors'][dataset];
+                    co.lineWidth   = prop['chart.linewidth'];
+    
+                    for (i=0; i<coords_dataset.length; ++i) {
+                        if (i == 0) {
+                            co.moveTo(coords_dataset[i][0], coords_dataset[i][1]);
+                        } else {
+                            co.lineTo(coords_dataset[i][0], coords_dataset[i][1]);
+                        }
+                    }
+                    
+    
+                    // If on the second or greater dataset, backtrack
+                    if (prop['chart.accumulative'] && dataset > 0) {
+    
+                        // This goes back to the start coords of this particular dataset
+                        co.lineTo(coords_dataset[0][0], coords_dataset[0][1]);
+                        
+                        //Now move down to the end point of the previous dataset
+                        co.moveTo(last_coords[0][0], last_coords[0][1]);
+    
+                        for (var i=coords_dataset.length - 1; i>=0; --i) {
+                            co.lineTo(last_coords[i][0], last_coords[i][1]);
+                        }
+                    }
+                
+                // This is used by the next iteration of the loop
+                var last_coords = coords_dataset;
+    
+                co.closePath();
+        
+                co.stroke();
+                co.fill();
+            }
+            
+            // Reset the globalAlpha
+            if (typeof(alpha) == 'number') {
+                co.globalAlpha = oldAlpha;
+            }
+        }
+
+
+
+
+        /**
+        * Gets the coordinates for a particular mark
+        * 
+        * @param  number i The index of the data (ie which one it is)
+        * @return array    A two element array of the coordinates
+        */
+        this.GetCoordinates = function (dataset, index)
+        {
+            // The number  of data points
+            var len = this.data[dataset].length;
+    
+            // The magnitude of the data (NOT the x/y coords)
+            var mag = (this.data[dataset][index] / this.max) * this.radius;
+    
+            /**
+            * Get the angle
+            */
+            var angle = (TWOPI / len) * index; // In radians
+angle -= HALFPI;
+    
+    
+            /**
+            * Work out the X/Y coordinates
+            */
+            var x = Math.cos(angle) * mag;
+            var y = Math.sin(angle) * mag;
+    
+            /**
+            * Put the coordinate in the right quadrant
+            */
+            x = this.centerx + x;
+            y = this.centery + y;
+            
+            return [x,y];
+        }
+
+
+
+
+        /**
+        * This function adds the labels to the chart
+        */
+        this.DrawLabels = function ()
+        {
+            var labels = prop['chart.labels'];
+    
+            if (labels && labels.length > 0) {
+    
+                co.lineWidth = 1;
+                co.strokeStyle = 'gray';
+                co.fillStyle = prop['chart.text.color'];
+                
+                var bgFill  = prop['chart.labels.background.fill'];
+                var bold    = prop['chart.labels.bold'];
+                var bgBoxed = prop['chart.labels.boxed'];
+                var offset  = prop['chart.labels.offset'];
+                var font    = prop['chart.text.font'];
+                var size    = prop['chart.text.size'];
+                var radius  = this.radius;
+    
+                for (var i=0; i<labels.length; ++i) {
+                    
+                    var angle  = (TWOPI / prop['chart.labels'].length) * i;
+                        angle -= HALFPI;
+    
+                    var x = this.centerx + (Math.cos(angle) * (radius + offset));
+                    var y = this.centery + (Math.sin(angle) * (radius + offset));
+                    
+                    /**
+                    * Horizontal alignment
+                    */
+                    var halign = x < this.centerx ? 'right' : 'left' ;
+                    if (i == 0 || (i / labels.length) == 0.5) halign = 'center';
+    
+                    if (labels[i] && labels[i].length) {
+                        RG.Text2(this, {'font':font,
+                                        'size':size,
+                                        'x':x,
+                                        'y':y,
+                                        'text':labels[i],
+                                        'valign':'center',
+                                        'halign':halign,
+                                        'bounding':bgBoxed,
+                                        'boundingFill':bgFill,
+                                        'bold':bold,
+                                        'tag': 'labels'
+                                       });
+                    }
+                }
+            }
+        }
+
+
+
+
+        /**
+        * Draws the circle. No arguments as it gets the information from the object properties.
+        */
+        this.DrawCircle = function ()
+        {
+            var circle     = {};
+            circle.limit   = prop['chart.circle'];
+            circle.fill    = prop['chart.circle.fill'];
+            circle.stroke  = prop['chart.circle.stroke'];
+    
+            if (circle.limit) {
+    
+                var r = (circle.limit / this.max) * this.radius;
+                
+                co.fillStyle = circle.fill;
+                co.strokeStyle = circle.stroke;
+    
+                co.beginPath();
+                co.arc(this.centerx, this.centery, r, 0, TWOPI, 0);
+                co.fill();
+                co.stroke();
+            }
+        }
+
+
+
+
+        /**
+        * Unsuprisingly, draws the labels
+        */
+        this.DrawAxisLabels = function ()
+        {
+            /**
+            * Draw specific axis labels
+            */
+            if (RG.is_array(prop['chart.labels.specific']) && prop['chart.labels.specific'].length) {
+                this.DrawSpecificAxisLabels();
+                return;
+            }
+    
+            co.lineWidth = 1;
+            
+            // Set the color to black
+            co.fillStyle = 'black';
+            co.strokeStyle = 'black';
+    
+            var r          = this.radius;
+            var font       = prop['chart.text.font'];
+            var size       = typeof(prop['chart.text.size.scale']) == 'number' ? prop['chart.text.size.scale'] : prop['chart.text.size'];
+            var axes       = prop['chart.labels.axes'].toLowerCase();
+            var color      = 'white';
+            var drawzero   = false;
+            var units_pre  = prop['chart.units.pre'];
+            var units_post = prop['chart.units.post'];
+            var decimals   = prop['chart.scale.decimals'];
+            var bold       = prop['chart.labels.axes.bold'];
+            var boxed      = prop['chart.labels.axes.boxed'];
+            var centerx    = this.centerx;
+            var centery    = this.centery;
+            var scale      = this.scale;
+    
+            co.fillStyle = prop['chart.text.color'];
+    
+            // The "North" axis labels
+            if (axes.indexOf('n') > -1) {
+                for (var i=0; i<this.scale2.labels.length; ++i) {
+                    RG.Text2(this, {'bold':bold[i],
+                                    'font':font,
+                                    'size':size,
+                                    'x':centerx,
+                                    'y':centery - (r * ((i+1)/this.scale2.labels.length)),
+                                    'text':this.scale2.labels[i],
+                                    'valign':'center',
+                                    'halign':'center',
+                                    'bounding':boxed[i],
+                                    'boundingFill':color,
+                                    'tag': 'scale'
+                                   });
+                }
+                
+                drawzero = true;
+            }
+    
+            // The "South" axis labels
+            if (axes.indexOf('s') > -1) {
+                for (var i=0; i<this.scale2.labels.length; ++i) {
+                    RG.Text2(this, {'bold':bold[i],
+                                    'font':font,
+                                    'size':size,
+                                    'x':centerx,
+                                    'y':centery + (r * ((i+1)/this.scale2.labels.length)),
+                                    'text':this.scale2.labels[i],
+                                    'valign':'center',
+                                    'halign':'center',
+                                    'bounding':boxed[i],
+                                    'boundingFill':color,
+                                    'tag': 'scale'
+                                   });
+                }
+                
+                drawzero = true;
+            }
+            
+            // The "East" axis labels
+            if (axes.indexOf('e') > -1) {
+                
+                for (var i=0; i<this.scale2.labels.length; ++i) {
+                    RG.Text2(this, {'bold':bold[i],
+                                    'font':font,
+                                    'size':size,
+                                    'x':centerx + (r * ((i+1)/this.scale2.labels.length)),
+                                    'y':centery,
+                                    'text':this.scale2.labels[i],
+                                    'valign':'center',
+                                    'halign':'center',
+                                    'bounding':boxed[i],
+                                    'boundingFill':color,
+                                    'tag': 'scale'
+                                   });
+                }
+    
+                drawzero = true;
+            }
+    
+            // The "West" axis labels
+            if (axes.indexOf('w') > -1) {
+    
+                for (var i=0; i<this.scale2.labels.length; ++i) {
+                    RG.Text2(this, {'bold':bold[i],
+                                    'font':font,
+                                    'size':size,
+                                    'x':centerx - (r * ((i+1)/this.scale2.labels.length)),
+                                    'y':centery,
+                                    'text':this.scale2.labels[i],
+                                    'valign':'center',
+                                    'halign':'center',
+                                    'bounding':boxed[i],
+                                    'boundingFill':color,
+                                    'tag': 'scale'
+                                   });
+                }
+    
+                drawzero = true;
+            }
+    
+            if (drawzero) {
+                RG.Text2(this, {'font':font,
+                                'size':size,
+                                'x':centerx,
+                                'y':centery,
+                                'text':RG.number_format(this, Number(0).toFixed(decimals), units_pre, units_post),
+                                'valign':'center',
+                                'halign':'center',
+                                'bounding':prop['chart.labels.axes.boxed.zero'],
+                                'boundingFill':color,
+                                'bold':prop['chart.labels.axes.bold.zero'],
+                                'tag': 'scale'
+                               });
+            }
+        }
+
+
+
+
+        /**
+        * Draws specific axis labels
+        */
+        this.DrawSpecificAxisLabels = function ()
+        {
+            /**
+            * Specific axis labels
+            */
+            var labels          = prop['chart.labels.specific'];
+            var bold            = RG.array_pad(prop['chart.labels.axes.bold'],labels.length);
+            var boxed           = RG.array_pad(prop['chart.labels.axes.boxed'],labels.length);
+            var reversed_labels = RG.array_reverse(labels);
+            var reversed_bold   = RG.array_reverse(bold);
+            var reversed_boxed  = RG.array_reverse(boxed);
+            var font            = prop['chart.text.font'];
+            var size            = typeof(prop['chart.text.size.scale']) == 'number' ? prop['chart.text.size.scale'] : prop['chart.text.size'];
+            var axes            = prop['chart.labels.axes'].toLowerCase();
+            
+            co.fillStyle = prop['chart.text.color'];
+
+            for (var i=0; i<labels.length; ++i) {
+    
+                if (axes.indexOf('n') > -1) RG.Text2(this, {'tag': 'labels.specific', 'bold':reversed_bold[i],'font':font,'size':size,'x':this.centerx,'y':this.centery - this.radius + ((this.radius / labels.length) * i),'text':reversed_labels[i],'valign':'center','halign':'center','bounding':reversed_boxed[i],'boundingFill':'white'});
+                if (axes.indexOf('s') > -1) RG.Text2(this, {'tag': 'labels.specific', 'bold':bold[i],'font':font,'size':size,'x':this.centerx,'y':this.centery + ((this.radius / labels.length) * (i+1)),'text':labels[i],'valign':'center','halign':'center','bounding':boxed[i],'boundingFill':'white'});
+                
+                if (axes.indexOf('w') > -1) RG.Text2(this, {'tag': 'labels.specific', 'bold':reversed_bold[i],'font':font,'size':size,'x':this.centerx - this.radius + ((this.radius / labels.length) * i),'y':this.centery,'text':reversed_labels[i],'valign':'center','halign':'center','bounding':reversed_boxed[i],'boundingFill':'white'});
+                if (axes.indexOf('e') > -1) RG.Text2(this, {'tag': 'labels.specific', 'bold':bold[i],'font':font,'size':size,'x':this.centerx + ((this.radius / labels.length) * (i+1)),'y':this.centery,'text':labels[i],'valign':'center','halign':'center','bounding':boxed[i],'boundingFill':'white'});
+            }
+        }
+
+
+
+
+        /**
+        * This method eases getting the focussed point (if any)
+        * 
+        * @param event e The event object
+        */
+        this.getShape =
+        this.getPoint = function (e)
+        {
+            for (var i=0; i<this.coords.length; ++i) {
+    
+                var x        = this.coords[i][0];
+                var y        = this.coords[i][1];
+                var tooltips = prop['chart.tooltips'];
+                var index    = Number(i);
+                var mouseXY  = RG.getMouseXY(e);
+                var mouseX   = mouseXY[0];
+                var mouseY   = mouseXY[1];
+    
+                if (   mouseX < (x + 5)
+                    && mouseX > (x - 5)
+                    && mouseY > (y - 5)
+                    && mouseY < (y + 5)
+                   ) {
+                    
+                    var tooltip = RG.parseTooltipText(prop['chart.tooltips'], index);
+    
+                    return {0: this,    'object':  this,
+                            1: x,       'x':       x,
+                            2: y,       'y':       y,
+                            3: null, 'dataset': null,
+                            4: index,       'index':   i,
+                                        'tooltip': tooltip
+                           }
+                }
+            }
+        }
+
+
+
+
+        /**
+        * Each object type has its own Highlight() function which highlights the appropriate shape
+        * 
+        * @param object shape The shape to highlight
+        */
+        this.Highlight = function (shape)
+        {
+            // Add the new highlight
+            RG.Highlight.Point(this, shape);
+        }
+
+
+
+
+        /**
+        * The getObjectByXY() worker method. Don't call this call:
+        * 
+        * RGraph.ObjectRegistry.getObjectByXY(e)
+        * 
+        * @param object e The event object
+        */
+        this.getObjectByXY = function (e)
+        {
+            var mouseXY = RG.getMouseXY(e);
+    
+            if (
+                   mouseXY[0] > (this.centerx - this.radius)
+                && mouseXY[0] < (this.centerx + this.radius)
+                && mouseXY[1] > (this.centery - this.radius)
+                && mouseXY[1] < (this.centery + this.radius)
+                ) {
+    
+                return this;
+            }
+        }
+
+
+
+
+        /**
+        * This function positions a tooltip when it is displayed
+        * 
+        * @param obj object    The chart object
+        * @param int x         The X coordinate specified for the tooltip
+        * @param int y         The Y coordinate specified for the tooltip
+        * @param objec tooltip The tooltips DIV element
+        */
+        this.positionTooltip = function (obj, x, y, tooltip, idx)
+        {
+            var dataset    = tooltip.__dataset__;
+            var index      = tooltip.__index__;
+            var coordX     = this.coords[index][0];
+            var coordY     = this.coords[index][1];
+            var canvasXY   = RG.getCanvasXY(obj.canvas);
+            var gutterLeft = this.gutterLeft;
+            var gutterTop  = this.gutterTop;
+            var width      = tooltip.offsetWidth;
+    
+            // Set the top position
+            tooltip.style.left = 0;
+            tooltip.style.top  = parseInt(tooltip.style.top) - 9 + 'px';
+            
+            // By default any overflow is hidden
+            tooltip.style.overflow = '';
+    
+            // The arrow
+            var img = new Image();
+                img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAFCAYAAACjKgd3AAAARUlEQVQYV2NkQAN79+797+RkhC4M5+/bd47B2dmZEVkBCgcmgcsgbAaA9GA1BCSBbhAuA/AagmwQPgMIGgIzCD0M0AMMAEFVIAa6UQgcAAAAAElFTkSuQmCC';
+                img.style.position = 'absolute';
+                img.id = '__rgraph_tooltip_pointer__';
+                img.style.top = (tooltip.offsetHeight - 2) + 'px';
+            tooltip.appendChild(img);
+            
+            // Reposition the tooltip if at the edges:
+            
+            // LEFT edge
+            if ((canvasXY[0] + coordX - (width / 2)) < 10) {
+                tooltip.style.left = (canvasXY[0] + coordX - (width * 0.1)) + 'px';
+                img.style.left = ((width * 0.1) - 8.5) + 'px';
+    
+            // RIGHT edge
+            } else if ((canvasXY[0] + coordX + (width / 2)) > document.body.offsetWidth) {
+                tooltip.style.left = canvasXY[0] + coordX - (width * 0.9) + 'px';
+                img.style.left = ((width * 0.9) - 8.5) + 'px';
+    
+            // Default positioning - CENTERED
+            } else {
+                tooltip.style.left = (canvasXY[0] + coordX - (width * 0.5)) + 'px';
+                img.style.left = ((width * 0.5) - 8.5) + 'px';
+            }
+        }
+
+
+
+
+        /**
+        * This draws highlights on the points
+        */
+        this.DrawHighlights = function ()
+        {
+            if (prop['chart.highlights']) {
+                
+                var sequentialIdx = 0;
+                var dataset       = 0;
+                var index         = 0;
+                var radius        = prop['chart.highlights.radius'];
+                
+    
+                
+                for (var dataset=0; dataset <this.data.length; ++dataset) {
+                    for (var index=0; index<this.data[dataset].length; ++index) {
+                        co.beginPath();
+                            co.strokeStyle = prop['chart.highlights.stroke'];
+                            co.fillStyle = prop['chart.highlights.fill'] ? prop['chart.highlights.fill'] : ((typeof(prop['chart.strokestyle']) == 'object' && prop['chart.strokestyle'][dataset]) ? prop['chart.strokestyle'][dataset] : prop['chart.strokestyle']);
+                            co.arc(this.coords[sequentialIdx][0], this.coords[sequentialIdx][1], radius, 0, TWOPI, false);
+                        co.stroke();
+                        co.fill();
+                        ++sequentialIdx;
+                    }
+                }
+                
+            }
+        }
+
+
+
+
+        /**
+        * This function returns the radius (ie the distance from the center) for a particular
+        * value. Note that if you want the angle for a point you can use getAngle(index)
+        * 
+        * @param number value The value you want the radius for
+        */
+        this.getRadius = function (value)
+        {
+            if (value < 0 || value > this.max) {
+                return null;
+            }
+    
+            // Radar doesn't support minimum value
+            var radius = (value / this.max) * this.radius;
+            
+            return radius;
+        }
+
+
+
+
+        /**
+        * This function returns the angle (in radians) for a particular index.
+        * 
+        * @param number numitems The total number of items
+        * @param number index    The zero index number of the item to get the angle for
+        */
+        this.getAngle = function (numitems, index)
+        {
+            var angle = (TWOPI / numitems) * index;
+                angle -= HALFPI;
+            
+            return angle;
+        }
+
+
+
+
+        /**
+        * This allows for easy specification of gradients
+        */
+        this.parseColors = function ()
+        {
+            for (var i=0; i<prop['chart.colors'].length; ++i) {
+                prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);
+            }
+            
+            var keyColors = prop['chart.key.colors'];
+    
+            if (typeof(keyColors) != 'null' && keyColors && keyColors.length) {
+                for (var i=0; i<prop['chart.key.colors'].length; ++i) {
+                    prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);
+                }
+            }
+    
+            prop['chart.title.color']      = this.parseSingleColorForGradient(prop['chart.title.color']);
+            prop['chart.text.color']       = this.parseSingleColorForGradient(prop['chart.text.color']);
+            prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);
+            prop['chart.highlight.fill']   = this.parseSingleColorForGradient(prop['chart.highlight.fill']);
+            prop['chart.circle.fill']      = this.parseSingleColorForGradient(prop['chart.circle.fill']);
+            prop['chart.circle.stroke']    = this.parseSingleColorForGradient(prop['chart.circle.stroke']);
+        }
+
+
+
+
+        /**
+        * This parses a single color value
+        */
+        this.parseSingleColorForGradient = function (color)
+        {
+            if (!color || typeof(color) != 'string') {
+                return color;
+            }
+    
+            if (color.match(/^gradient\((.*)\)$/i)) {
+    
+                var parts = RegExp.$1.split(':');
+    
+                // Create the gradient
+                var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);
+    
+                var diff = 1 / (parts.length - 1);
+    
+                grad.addColorStop(0, RG.trim(parts[0]));
+    
+                for (var j=1; j<parts.length; ++j) {
+                    grad.addColorStop(j * diff, RG.trim(parts[j]));
+                }
+            }
+    
+            return grad ? grad : color;
+        }
+
+
+
+
+        this.AddFillListeners = function (e)
+        {
+            var obj = this;
+
+            var func = function (e)
+            {
+                //var canvas  = e.target;
+                //var context = canvas.getContext('2d');
+                var coords  = this.coords;
+                var coords2 = this.coords2;
+                var mouseXY = RG.getMouseXY(e);
+                var dataset = 0;
+                
+                if (e.type == 'mousemove' && prop['chart.fill.mousemove.redraw']) {
+                    RG.RedrawCanvas(ca);
+                }
+
+                for (var dataset=(obj.coords2.length-1); dataset>=0; --dataset) {
+                    
+                    // Draw the path again so that it can be checked
+                    co.beginPath();
+                        co.moveTo(obj.coords2[dataset][0][0], obj.coords2[dataset][0][1]);
+                        for (var j=0; j<obj.coords2[dataset].length; ++j) {
+                            co.lineTo(obj.coords2[dataset][j][0], obj.coords2[dataset][j][1]);
+                        }
+                        
+                    // Draw a line back to the starting point
+                    co.lineTo(obj.coords2[dataset][0][0], obj.coords2[dataset][0][1]);
+        
+                    // Go thru the previous datasets coords in reverse order
+                    if (prop['chart.accumulative'] && dataset > 0) {
+                        co.lineTo(obj.coords2[dataset - 1][0][0], obj.coords2[dataset - 1][0][1]);
+                        for (var j=(obj.coords2[dataset - 1].length - 1); j>=0; --j) {
+                            co.lineTo(obj.coords2[dataset - 1][j][0], obj.coords2[dataset - 1][j][1]);
+                        }
+                    }
+    
+                    co.closePath();
+                    
+                    if (co.isPointInPath(mouseXY[0], mouseXY[1])) {
+                        var inPath = true;
+                        break;
+                    }
+                }
+                
+                // Call the events
+                if (inPath) {
+    
+                    var fillTooltips = prop['chart.fill.tooltips'];
+    
+                    /**
+                    * Click event
+                    */
+                    if (e.type == 'click') {
+                        if (prop['chart.fill.click']) {
+                            prop['chart.fill.click'](e, dataset);
+                        }
+                    
+                        if (prop['chart.fill.tooltips'] && prop['chart.fill.tooltips'][dataset]) {
+                            obj.DatasetTooltip(e, dataset);
+                        }
+                    }
+
+    
+    
+                    /**
+                    * Mousemove event
+                    */
+                    if (e.type == 'mousemove') {
+    
+                        if (prop['chart.fill.mousemove']) {
+                            prop['chart.fill.mousemove'](e, dataset);
+                        }
+                        
+                        if (!RG.is_null(fillTooltips)) {
+                            e.target.style.cursor = 'pointer';
+                        }
+                    
+                        if (prop['chart.fill.tooltips'] && prop['chart.fill.tooltips'][dataset]) {
+                            e.target.style.cursor = 'pointer';
+                        }
+                    }
+    
+                    e.stopPropagation();
+                
+                } else if (e.type == 'mousemove') {
+                    ca.style.cursor = 'default';
+                }
+            }
+            
+            /**
+            * Add the click listener
+            */
+            if (prop['chart.fill.click'] || !RG.is_null(prop['chart.fill.tooltips'])) {
+                ca.addEventListener('click', func, false);
+            }
+    
+            /**
+            * Add the mousemove listener
+            */
+            if (prop['chart.fill.mousemove'] || !RG.is_null(prop['chart.fill.tooltips'])) {
+                ca.addEventListener('mousemove', func, false);
+            }
+        }
+
+
+
+
+        /**
+        * This highlights a specific dataset on the chart
+        * 
+        * @param number dataset The index of the dataset (which starts at zero)
+        */
+        this.HighlightDataset = function (dataset)
+        {
+            co.beginPath();
+            for (var j=0; j<this.coords2[dataset].length; ++j) {
+                if (j == 0) {
+                    co.moveTo(this.coords2[dataset][0][0], this.coords2[dataset][0][1]);
+                } else {
+                    co.lineTo(this.coords2[dataset][j][0], this.coords2[dataset][j][1]);
+                }
+            }
+    
+            co.lineTo(this.coords2[dataset][0][0], this.coords2[dataset][0][1]);
+            
+            if (prop['chart.accumulative'] && dataset > 0) {
+                co.lineTo(this.coords2[dataset - 1][0][0], this.coords2[dataset - 1][0][1]);
+                for (var j=(this.coords2[dataset - 1].length - 1); j>=0; --j) {
+                    co.lineTo(this.coords2[dataset - 1][j][0], this.coords2[dataset - 1][j][1]);
+                }
+            }
+    
+            co.strokeStyle = prop['chart.fill.highlight.stroke'];
+            co.fillStyle   = prop['chart.fill.highlight.fill'];
+    
+            co.stroke();
+            co.fill();
+        }
+
+
+
+
+        /**
+        * Shows a tooltip for a dataset (a "fill" tooltip), You can pecify these
+        * with chart.fill.tooltips
+        */
+        this.DatasetTooltip = function (e, dataset)
+        {
+            // Highlight the dataset
+            this.HighlightDataset(dataset);
+            
+            // Use the First datapoints coords for the Y position of the tooltip NOTE The X position is changed in the
+            // obj.positionTooltip() method so set the index to be the first one
+            var text = prop['chart.fill.tooltips'][dataset];
+            var x    = 0;
+            var y    = this.coords2[dataset][0][1] + RG.getCanvasXY(ca)[1];
+    
+    
+            // Show a tooltip
+            RG.Tooltip(this, text, x, y, 0, e);
+        }
+
+
+
+
+        /**
+        * This function handles highlighting an entire data-series for the interactive
+        * key
+        * 
+        * @param int index The index of the data series to be highlighted
+        */
+        this.interactiveKeyHighlight = function (index)
+        {
+            var coords = this.coords2[index];
+
+            if (coords) {
+                
+                var pre_linewidth = co.lineWidth;
+                var pre_linecap   = co.lineCap;
+                
+                
+                
+                
+                // ------------------------------------------ //
+
+                co.lineWidth   = prop['chart.linewidth'] + 10;
+                co.lineCap     = 'round';
+                co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];
+
+                
+                co.beginPath();
+                for (var i=0,len=coords.length; i<len; i+=1) {
+                    if (i == 0) {
+                        co.moveTo(coords[i][0], coords[i][1]);
+                    } else {
+                        co.lineTo(coords[i][0], coords[i][1]);
+                    }
+                }
+                co.closePath();
+                co.stroke();
+                
+                // ------------------------------------------ //
+                
+                
+                
+                
+                // Reset the lineCap and lineWidth
+                co.lineWidth = pre_linewidth;
+                co.lineCap = pre_linecap;
+            }
+        }
+
+
+
+
+        /**
+        * Always register the object
+        */
+        RG.Register(this);
+    }
\ No newline at end of file
diff --git a/mod/questionnaire/javascript/RGraph/RGraph.rose.js b/mod/questionnaire/javascript/RGraph/RGraph.rose.js
new file mode 100644
index 0000000..9c413df
--- /dev/null
+++ b/mod/questionnaire/javascript/RGraph/RGraph.rose.js
@@ -0,0 +1,1366 @@
+    /**
+    * o-------------------------------------------------------------------------------o
+    * | This file is part of the RGraph package. RGraph is Free software, licensed    |
+    * | under the MIT license - so it's free to use for all purposes. Extended        |
+    * | support is available if required and donations are always welcome! You can    |
+    * | read more here:                                                               |
+    * |                         http://www.rgraph.net/support                         |
+    * o-------------------------------------------------------------------------------o
+    */
+    
+    if (typeof(RGraph) == 'undefined') RGraph = {};
+    
+    /**
+    * The rose chart constuctor
+    * 
+    * @param object canvas
+    * @param array data
+    */
+    RGraph.Rose = function (id, data)
+    {
+        this.id                = id;
+        this.canvas            = document.getElementById(typeof id === 'object' ? id.id : id);
+        this.context           = this.canvas.getContext('2d');
+        this.data              = data;
+        this.canvas.__object__ = this;
+        this.type              = 'rose';
+        this.isRGraph          = true;
+        this.uid               = RGraph.CreateUID();
+        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();
+        this.colorsParsed      = false;
+        this.coordsText        = [];
+        this.original_colors   = [];
+
+
+        /**
+        * Compatibility with older browsers
+        */
+        RGraph.OldBrowserCompat(this.context);
+
+
+        this.centerx = 0;
+        this.centery = 0;
+        this.radius  = 0;
+        this.max     = 0;
+        this.angles  = [];
+        this.angles2 = [];
+        
+        this.properties = {
+            'chart.background.axes':        true,
+            'chart.background.axes.color':  'black',
+            'chart.background.grid':        true,
+            'chart.background.grid.color':  '#ccc',
+            'chart.background.grid.size':   null,
+            'chart.background.grid.spokes': null,
+            'chart.background.grid.count':  5,
+            'chart.centerx':                null,
+            'chart.centery':                null,
+            'chart.radius':                 null,
+            'chart.angles.start':           0,
+            'chart.colors':                 ['rgba(255,0,0,0.5)', 'rgba(255,255,0,0.5)', 'rgba(0,255,255,0.5)', 'rgb(0,255,0)', 'gray', 'blue', 'rgb(255,128,255)','green', 'pink', 'gray', 'aqua'],
+            'chart.colors.sequential':      false,
+            'chart.colors.alpha':           null,
+            'chart.margin':                 0,
+            'chart.strokestyle':            '#aaa',
+            'chart.gutter.left':            25,
+            'chart.gutter.right':           25,
+            'chart.gutter.top':             25,
+            'chart.gutter.bottom':          25,
+            'chart.title':                  '',
+            'chart.title.background':       null,
+            'chart.title.hpos':             null,
+            'chart.title.vpos':             null,
+            'chart.title.bold':             true,
+            'chart.title.font':             null,
+            'chart.title.x':                null,
+            'chart.title.y':                null,
+            'chart.title.halign':           null,
+            'chart.title.valign':           null,
+            'chart.labels':                 null,
+            'chart.labels.position':       'center',
+            'chart.labels.axes':            'nsew',
+            'chart.labels.offset':          0,
+            'chart.text.color':             'black',
+            'chart.text.font':              'Arial',
+            'chart.text.size':              10,
+            'chart.key':                    null,
+            'chart.key.background':         'white',
+            'chart.key.position':           'graph',
+            'chart.key.halign':             'right',
+            'chart.key.shadow':             false,
+            'chart.key.shadow.color':       '#666',
+            'chart.key.shadow.blur':        3,
+            'chart.key.shadow.offsetx':     2,
+            'chart.key.shadow.offsety':     2,
+            'chart.key.position.gutter.boxed': false,
+            'chart.key.position.x':         null,
+            'chart.key.position.y':         null,
+            'chart.key.color.shape':        'square',
+            'chart.key.rounded':            true,
+            'chart.key.linewidth':          1,
+            'chart.key.colors':             null,
+            'chart.key.interactive':        false,
+            'chart.key.interactive.highlight.chart.stroke': 'black',
+            'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)',
+            'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)',
+            'chart.key.text.color':         'black',
+            'chart.contextmenu':            null,
+            'chart.tooltips':               null,
+            'chart.tooltips.event':         'onclick',
+            'chart.tooltips.effect':        'fade',
+            'chart.tooltips.css.class':     'RGraph_tooltip',
+            'chart.tooltips.highlight':     true,
+            'chart.highlight.stroke':       'rgba(0,0,0,0)',
+            'chart.highlight.fill':         'rgba(255,255,255,0.7)',
+            'chart.annotatable':            false,
+            'chart.annotate.color':         'black',
+            'chart.zoom.factor':            1.5,
+            'chart.zoom.fade.in':           true,
+            'chart.zoom.fade.out':          true,
+            'chart.zoom.hdir':              'right',
+            'chart.zoom.vdir':              'down',
+            'chart.zoom.frames':            25,
+            'chart.zoom.delay':             16.666,
+            'chart.zoom.shadow':            true,
+            'chart.zoom.background':        true,
+            'chart.zoom.action':            'zoom',
+            'chart.resizable':              false,
+            'chart.resize.handle.adjust':   [0,0],
+            'chart.resize.handle.background': null,
+            'chart.adjustable':             false,
+            'chart.ymax':                   null,
+            'chart.ymin':                   0,
+            'chart.scale.decimals':         null,
+            'chart.scale.point':            '.',
+            'chart.scale.thousand':         ',',
+            'chart.variant':                'stacked',
+            'chart.exploded':               0,
+            'chart.events.mousemove':       null,
+            'chart.events.click':           null,
+            'chart.animation.roundrobin.factor':  1,
+            'chart.animation.roundrobin.radius': true,
+            'chart.animation.grow.multiplier': 1,
+            'chart.labels.count':              5
+        }
+
+
+
+        /**
+        * Create the $ objects. In the case of non-equi-angular rose charts it actually creates too many $ objects,
+        * but it doesn't matter.
+        */
+        var linear_data = RGraph.array_linearize(this.data);
+        for (var i=0; i<linear_data.length; ++i) {
+            this["$" + i] = {}
+        }
+
+
+        /**
+        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen
+        * done already
+        */
+        if (!this.canvas.__rgraph_aa_translated__) {
+            this.context.translate(0.5,0.5);
+            
+            this.canvas.__rgraph_aa_translated__ = true;
+        }
+
+
+
+
+        ///////////////////////////////// SHORT PROPERTIES /////////////////////////////////
+
+
+
+
+        var RG   = RGraph;
+        var ca   = this.canvas;
+        var co   = ca.getContext('2d');
+        var prop = this.properties;
+        //var $jq  = jQuery;
+
+
+
+
+        //////////////////////////////////// METHODS ///////////////////////////////////////
+
+
+
+
+        /**
+        * A simple setter
+        * 
+        * @param string name  The name of the property to set
+        * @param string value The value of the property
+        */
+        this.Set = function (name, value)
+        {
+            /**
+            * This should be done first - prepend the propertyy name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            prop[name.toLowerCase()] = value;
+    
+            return this;
+        }
+
+
+
+
+        /**
+        * A simple getter
+        * 
+        * @param string name The name of the property to get
+        */
+        this.Get = function (name)
+        {
+            /**
+            * This should be done first - prepend the property name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            return prop[name.toLowerCase()];
+        }
+
+
+
+
+        /**
+        * This method draws the rose chart
+        */
+        this.Draw = function ()
+        {
+            /**
+            * Fire the onbeforedraw event
+            */
+            RG.FireCustomEvent(this, 'onbeforedraw');
+    
+    
+    
+            /**
+            * This doesn't affect the chart, but is used for compatibility
+            */
+            this.gutterLeft   = prop['chart.gutter.left'];
+            this.gutterRight  = prop['chart.gutter.right'];
+            this.gutterTop    = prop['chart.gutter.top'];
+            this.gutterBottom = prop['chart.gutter.bottom'];
+    
+            // Calculate the radius
+            this.radius       = (Math.min(ca.width - this.gutterLeft - this.gutterRight, ca.height - this.gutterTop - this.gutterBottom) / 2);
+            this.centerx      = ((ca.width - this.gutterLeft - this.gutterRight) / 2) + this.gutterLeft;
+            this.centery      = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop;
+            this.angles       = [];
+            this.angles2      = [];
+            this.total        = 0;
+            this.startRadians = prop['chart.angles.start'];
+            
+            /**
+            * Change the centerx marginally if the key is defined
+            */
+            if (prop['chart.key'] && prop['chart.key'].length > 0 && prop['chart.key'].length >= 3) {
+                this.centerx = this.centerx - this.gutterRight + 5;
+            }
+    
+    
+    
+            // User specified radius, centerx and centery
+            if (typeof(prop['chart.centerx']) == 'number') this.centerx = prop['chart.centerx'];
+            if (typeof(prop['chart.centery']) == 'number') this.centery = prop['chart.centery'];
+            if (typeof(prop['chart.radius']) == 'number')  this.radius  = prop['chart.radius'];
+    
+            /**
+            * Parse the colors for gradients. Its down here so that the center X/Y can be used
+            */
+            if (!this.colorsParsed) {
+    
+                this.parseColors();
+    
+                // Don't want to do this again
+                this.colorsParsed = true;
+            }
+    
+            this.DrawBackground();
+            this.DrawRose();
+            this.DrawLabels();
+    
+            /**
+            * Setup the context menu if required
+            */
+            if (prop['chart.contextmenu']) {
+                RG.ShowContext(this);
+            }
+    
+            
+            /**
+            * This function enables resizing
+            */
+            if (prop['chart.resizable']) {
+                RG.AllowResizing(this);
+            }
+    
+            
+            /**
+            * This function enables adjusting
+            */
+            if (prop['chart.adjustable']) {
+                RG.AllowAdjusting(this);
+            }
+    
+    
+            /**
+            * This installs the event listeners
+            */
+            RG.InstallEventListeners(this);
+    
+    
+            /**
+            * Fire the RGraph ondraw event
+            */
+            RG.FireCustomEvent(this, 'ondraw');
+            
+            return this;
+        }
+
+
+
+
+        /**
+        * This method draws the rose charts background
+        */
+        this.DrawBackground = function ()
+        {
+            co.lineWidth = 1;
+    
+    
+            // Draw the background grey circles/spokes
+            if (prop['chart.background.grid']) {
+                if (typeof(prop['chart.background.grid.count']) == 'number') {
+                    prop['chart.background.grid.size'] = this.radius / prop['chart.background.grid.count'];
+                }
+        
+                co.beginPath();
+                    co.strokeStyle = prop['chart.background.grid.color'];
+                    
+                    // Radius must be greater than 0 for Opera to work
+                    for (var i=prop['chart.background.grid.size']; i<=this.radius; i+=prop['chart.background.grid.size']) {
+                        
+                        // Hmmm... This is questionable
+                        co.moveTo(this.centerx + i, this.centery);
+            
+                        // Radius must be greater than 0 for Opera to work
+                        co.arc(this.centerx,
+                               this.centery,
+                               i,
+                               0,
+                               TWOPI,
+                               false);
+                    }
+                co.stroke();
+    
+    
+    
+    
+    
+    
+                // Draw the background lines that go from the center outwards
+                co.beginPath();
+                    if (typeof(prop['chart.background.grid.spokes']) == 'number') {
+                        
+                        var num = (360 / prop['chart.background.grid.spokes']);
+        
+                        for (var i=num; i<=360; i+=num) {
+                        
+                            // Radius must be greater than 0 for Opera to work
+                            co.arc(this.centerx,
+                                   this.centery,
+                                   this.radius,
+                                   ((i / (180 / PI)) - HALFPI) + this.startRadians,
+                                   (((i + 0.0001) / (180 / PI)) - HALFPI) + this.startRadians,
+                                   false);
+    
+                            co.lineTo(this.centerx, this.centery);
+                        }
+                    } else {
+                        for (var i=15; i<=360; i+=15) {
+                        
+                            // Radius must be greater than 0 for Opera to work
+                            co.arc(this.centerx,
+                                   this.centery,
+                                   this.radius,
+                                   (i / (180/ PI)) - HALFPI,
+                                   ((i + 0.0001) / (180/ PI)) - HALFPI,
+                                   false);
+                        
+                            co.lineTo(this.centerx, this.centery);
+                        }
+                    }
+                co.stroke();
+            }
+    
+    
+    
+            if (prop['chart.background.axes']) {
+                co.beginPath();
+                co.strokeStyle = prop['chart.background.axes.color'];
+            
+                // Draw the X axis
+                co.moveTo(this.centerx - this.radius, Math.round(this.centery) );
+                co.lineTo(this.centerx + this.radius, Math.round(this.centery) );
+            
+                // Draw the X ends
+                co.moveTo(Math.round(this.centerx - this.radius), this.centery - 5);
+                co.lineTo(Math.round(this.centerx - this.radius), this.centery + 5);
+                co.moveTo(Math.round(this.centerx + this.radius), this.centery - 5);
+                co.lineTo(Math.round(this.centerx + this.radius), this.centery + 5);
+                
+                // Draw the X check marks
+                for (var i=(this.centerx - this.radius); i<(this.centerx + this.radius); i+=(this.radius / 5)) {
+                    co.moveTo(Math.round(i),  this.centery - 3);
+                    co.lineTo(Math.round(i),  this.centery + 3.5);
+                }
+                
+                // Draw the Y check marks
+                for (var i=(this.centery - this.radius); i<(this.centery + this.radius); i+=(this.radius / 5)) {
+                    co.moveTo(this.centerx - 3, Math.round(i));
+                    co.lineTo(this.centerx + 3, Math.round(i));
+                }
+            
+                // Draw the Y axis
+                co.moveTo(Math.round(this.centerx), this.centery - this.radius);
+                co.lineTo(Math.round(this.centerx), this.centery + this.radius);
+            
+                // Draw the Y ends
+                co.moveTo(this.centerx - 5, Math.round(this.centery - this.radius));
+                co.lineTo(this.centerx + 5, Math.round(this.centery - this.radius));
+            
+                co.moveTo(this.centerx - 5, Math.round(this.centery + this.radius));
+                co.lineTo(this.centerx + 5, Math.round(this.centery + this.radius));
+                
+                // Stroke it
+                co.closePath();
+                co.stroke();
+            }
+        }
+
+
+
+
+        /**
+        * This method draws the data on the graph
+        */
+        this.DrawRose = function ()
+        {
+            var max    = 0;
+            var data   = this.data;
+            var margin = RGraph.degrees2Radians(prop['chart.margin']);
+    
+            // Must be at least two data points
+            //if (data.length < 2) {
+            //    alert('[ROSE] Must be at least two data points! [' + data + ']');
+            //    return;
+            //}
+    
+            // Work out the maximum value and the sum
+            if (RG.is_null(prop['chart.ymax'])) {
+    
+                // Work out the max
+                for (var i=0; i<data.length; ++i) {
+                    if (typeof(data[i]) == 'number') {
+                        max = Math.max(max, data[i]);
+                    } else if (typeof(data[i]) == 'object' && prop['chart.variant'] == 'non-equi-angular') {
+                        max = Math.max(max, data[i][0]);
+                    
+                    // Fallback is stacked
+                    } else {
+                        max = Math.max(max, RG.array_sum(data[i]));
+                    }
+                }
+    
+                this.scale2 = RG.getScale2(this, {
+                                                  'max':max,
+                                                  'min':0,
+                                                  'scale.thousand':prop['chart.scale.thousand'],
+                                                  'scale.point':prop['chart.scale.point'],
+                                                  'scale.decimals':prop['chart.scale.decimals'],
+                                                  'ylabels.count':prop['chart.labels.count'],
+                                                  'scale.round':prop['chart.scale.round'],
+                                                  'units.pre': prop['chart.units.pre'],
+                                                  'units.post': prop['chart.units.post']
+                                                 });
+                this.max = this.scale2.max;
+    
+            } else {
+    
+                var ymax = prop['chart.ymax'];
+    
+    
+    
+                this.scale2 = RG.getScale2(this, {
+                                                  'max':ymax,
+                                                  'strict':true,
+                                                  'scale.thousand':prop['chart.scale.thousand'],
+                                                  'scale.point':prop['chart.scale.point'],
+                                                  'scale.decimals':prop['chart.scale.decimals'],
+                                                  'ylabels.count':prop['chart.labels.count'],
+                                                  'scale.round':prop['chart.scale.round'],
+                                                  'units.pre': prop['chart.units.pre'],
+                                                  'units.post': prop['chart.units.post']
+                                                 });
+                this.max = this.scale2.max
+            }
+            
+            this.sum = RG.array_sum(data);
+            
+            // Move to the centre
+            co.moveTo(this.centerx, this.centery);
+        
+            co.stroke(); // Stroke the background so it stays grey
+        
+            // Transparency
+            if (prop['chart.colors.alpha']) {
+                co.globalAlpha = prop['chart.colors.alpha'];
+            }
+    
+            /*******************************************************
+            * A non-equi-angular Rose chart
+            *******************************************************/
+            if (typeof(prop['chart.variant']) == 'string' && prop['chart.variant'] == 'non-equi-angular') {
+                /*******************************************************
+                * NON-EQUI-ANGULAR GOES HERE
+                *******************************************************/
+                var total=0;
+                for (var i=0; i<data.length; ++i) {
+                    total += data[i][1];
+                }
+                
+                
+                for (var i=0; i<this.data.length; ++i) {
+                
+                    var segmentRadians = ((this.data[i][1] / total) * TWOPI);
+                    var radius         = ((this.data[i][0] - prop['chart.ymin']) / (this.max - prop['chart.ymin'])) * this.radius;
+                        radius = radius * prop['chart.animation.grow.multiplier'];
+    
+                    co.strokeStyle = prop['chart.strokestyle'];
+                    co.fillStyle   = prop['chart.colors'][0];
+    
+                    if (prop['chart.colors.sequential']) {
+                        co.fillStyle = prop['chart.colors'][i];
+                    }
+    
+                    co.beginPath(); // Begin the segment
+    
+                        var startAngle = (this.startRadians * prop['chart.animation.roundrobin.factor']) - HALFPI + margin;
+                        var endAngle   = ((this.startRadians + segmentRadians) * prop['chart.animation.roundrobin.factor']) - HALFPI - margin;
+    
+                        var exploded  = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);
+                        var explodedX = exploded[0];
+                        var explodedY = exploded[1];
+    
+    
+                        co.arc(this.centerx + explodedX,
+                               this.centery + explodedY,
+                               prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius,
+                               startAngle,
+                               endAngle,
+                               0);
+                        co.lineTo(this.centerx + explodedX, this.centery + explodedY);
+                    co.closePath(); // End the segment
+                    
+                    co.stroke();
+                    co.fill();
+                    
+                    // Store the start and end angles
+    
+                    this.angles.push(gg = [
+                                      startAngle,
+                                      endAngle,
+                                      0,
+                                      radius,
+                                      this.centerx + explodedX,
+                                      this.centery + explodedY
+                                     ]);
+    
+                    this.startRadians += segmentRadians;
+                }
+            } else {
+            
+                var sequentialColorIndex = 0;
+            
+                /*******************************************************
+                * Draw regular segments here
+                *******************************************************/
+                for (var i=0; i<this.data.length; ++i) {
+    
+                    co.strokeStyle = prop['chart.strokestyle'];
+                    co.fillStyle = prop['chart.colors'][0];
+    
+                    /*******************************************************
+                    * This allows sequential colors
+                    *******************************************************/
+                    if (prop['chart.colors.sequential']) {
+                        co.fillStyle = prop['chart.colors'][i];
+                    }
+    
+                    var segmentRadians = (1 / this.data.length) * TWOPI;
+        
+                    if (typeof(this.data[i]) == 'number') {
+                        co.beginPath(); // Begin the segment
+    
+                            var radius = ((this.data[i] - prop['chart.ymin']) / (this.max - prop['chart.ymin'])) * this.radius;
+                                radius = radius * prop['chart.animation.grow.multiplier'];
+    
+                            var startAngle = (this.startRadians * prop['chart.animation.roundrobin.factor']) - HALFPI + margin;
+                            var endAngle   = (this.startRadians * prop['chart.animation.roundrobin.factor']) + (segmentRadians * prop['chart.animation.roundrobin.factor']) - HALFPI - margin;
+    
+                            var exploded  = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);
+                            var explodedX = exploded[0];
+                            var explodedY = exploded[1];
+    
+                            co.arc(this.centerx + explodedX,
+                                   this.centery + explodedY,
+                                   prop['chart.animation.roundrobin.radius'] ? radius * prop['chart.animation.roundrobin.factor'] : radius,
+                                   startAngle,
+                                   endAngle,
+                                   0);
+                            co.lineTo(this.centerx + explodedX, this.centery + explodedY);
+                        co.closePath(); // End the segment
+                        co.stroke();
+                        co.fill();
+    
+                        if (endAngle == 0) {
+                            //endAngle = TWOPI;
+                        }
+    
+                        // Store the start and end angles
+                        this.angles.push([
+                                          startAngle,
+                                          endAngle,
+                                          0,
+                                          radius * prop['chart.animation.roundrobin.factor'],
+                                          this.centerx + explodedX,
+                                          this.centery + explodedY
+                                         ]);
+    
+                    /*******************************************************
+                    * Draw a stacked segment
+                    *******************************************************/
+                    } else if (typeof(this.data[i]) == 'object') {
+                        
+                        var margin = prop['chart.margin'] / (180 / PI);
+                        
+                        // Initialise the angles2 array so there's no undefined error
+                        if (!this.angles2[i]) {
+                            this.angles2[i] = [];
+                        }
+                        
+    
+                        for (var j=0; j<this.data[i].length; ++j) {
+                        
+                            var startAngle = (this.startRadians * prop['chart.animation.roundrobin.factor']) - HALFPI + margin;
+                            var endAngle  = (this.startRadians * prop['chart.animation.roundrobin.factor'])+ (segmentRadians * prop['chart.animation.roundrobin.factor']) - HALFPI - margin;
+                        
+                            var exploded  = this.getexploded(i, startAngle, endAngle, prop['chart.exploded']);
+                            var explodedX = exploded[0];
+                            var explodedY = exploded[1];
+        
+                            co.fillStyle = prop['chart.colors'][j];
+    
+                            // This facilitates sequential color support
+                            if (prop['chart.colors.sequential']) {
+                                co.fillStyle = prop['chart.colors'][sequentialColorIndex++];
+                            }
+    
+                            if (j == 0) {
+                                co.beginPath(); // Begin the segment
+                                    var startRadius = 0;
+                                    var endRadius = ((this.data[i][j] - prop['chart.ymin']) / (this.max - prop['chart.ymin'])) * this.radius;
+                                        endRadius = endRadius * prop['chart.animation.grow.multiplier'];
+                        
+                                    co.arc(this.centerx + explodedX,
+                                           this.centery + explodedY,
+                                           prop['chart.animation.roundrobin.radius'] ? endRadius * prop['chart.animation.roundrobin.factor'] : endRadius,
+                                           startAngle,
+                                           endAngle,
+                                           0);
+                                    co.lineTo(this.centerx + explodedX, this.centery + explodedY);
+                                co.closePath(); // End the segment
+                                co.stroke();
+                                co.fill();
+        
+                                this.angles.push([
+                                                  startAngle,
+                                                  endAngle,
+                                                  0,
+                                                  endRadius * prop['chart.animation.roundrobin.factor'],
+                                                  this.centerx + explodedX,
+                                                  this.centery + explodedY
+                                                 ]);
+        
+                                this.angles2[i].push([
+                                                      startAngle,
+                                                      endAngle,
+                                                      0,
+                                                      endRadius * prop['chart.animation.roundrobin.factor'],
+                                                      this.centerx + explodedX,
+                                                      this.centery + explodedY
+                                                     ]);
+                            
+                            } else {
+    
+                                co.beginPath(); // Begin the segment
+                                    
+                                    var startRadius = endRadius; // This comes from the prior iteration of this loop
+                                    var endRadius = (((this.data[i][j] - prop['chart.ymin']) / (this.max - prop['chart.ymin'])) * this.radius) + startRadius;
+                                        endRadius = endRadius * prop['chart.animation.grow.multiplier'];
+                    
+                                    co.arc(this.centerx + explodedX,
+                                           this.centery + explodedY,
+                                           startRadius  * prop['chart.animation.roundrobin.factor'],
+                                           startAngle,
+                                           endAngle,
+                                           0);
+                    
+                                    co.arc(this.centerx + explodedX,
+                                           this.centery + explodedY,
+                                           endRadius  * prop['chart.animation.roundrobin.factor'],
+                                           endAngle,
+                                           startAngle,
+                                           true);
+                    
+                                co.closePath(); // End the segment
+                                co.stroke();
+                                co.fill();
+        
+                                this.angles.push([
+                                                  startAngle,
+                                                  endAngle,
+                                                  startRadius * prop['chart.animation.roundrobin.factor'],
+                                                  endRadius * prop['chart.animation.roundrobin.factor'],
+                                                  this.centerx + explodedX,
+                                                  this.centery + explodedY
+                                                 ]);
+        
+                                this.angles2[i].push([
+                                                      startAngle,
+                                                      endAngle,
+                                                      startRadius * prop['chart.animation.roundrobin.factor'],
+                                                      endRadius * prop['chart.animation.roundrobin.factor'],
+                                                      this.centerx + explodedX,
+                                                      this.centery + explodedY
+                                                     ]);
+                            }
+                        }
+                    }
+        
+                    this.startRadians += segmentRadians;
+                }
+            }
+    
+            // Turn off the transparency
+            if (prop['chart.colors.alpha']) {
+                co.globalAlpha = 1;
+            }
+    
+            // Draw the title if any has been set
+            if (prop['chart.title']) {
+                RG.DrawTitle(this,
+                             prop['chart.title'],
+                             (ca.height / 2) - this.radius,
+                             this.centerx,
+                             prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);
+            }
+        }
+
+
+
+
+        /**
+        * Unsuprisingly, draws the labels
+        */
+        this.DrawLabels = function ()
+        {
+            co.lineWidth = 1;
+            var key = prop['chart.key'];
+    
+            if (key && key.length) {
+                RG.DrawKey(this, key, prop['chart.colors']);
+            }
+            
+            // Set the color to black
+            co.fillStyle = prop['chart.text.color'];
+            co.strokeStyle = 'black';
+            
+            var radius     = this.radius;
+            var font       = prop['chart.text.font'];
+            var size       = prop['chart.text.size'];
+            var axes       = prop['chart.labels.axes'].toLowerCase();
+            var decimals   = prop['chart.scale.decimals'];
+            var units_pre  = prop['chart.units.pre'];
+            var units_post = prop['chart.units.post'];
+            var centerx    = this.centerx;
+            var centery    = this.centery;
+    
+            // Draw any circular labels
+            if (typeof(prop['chart.labels']) == 'object' && prop['chart.labels']) {
+                this.DrawCircularLabels(co, prop['chart.labels'], font, size, radius + 10);
+            }
+    
+    
+            // Size can be specified seperately for the scale now
+            if (typeof(prop['chart.text.size.scale']) == 'number') {
+                size = prop['chart.text.size.scale'];
+            }
+    
+    
+            var color = 'rgba(255,255,255,0.8)';
+    
+            // The "North" axis labels
+            if (axes.indexOf('n') > -1) {
+                for (var i=0; i<prop['chart.labels.count']; ++i) {
+                    RG.Text2(this, {'font':font,
+                                    'size':size,
+                                    'x':centerx,
+                                    'y':centery - (radius * ((i+1) / prop['chart.labels.count'])),
+                                    'text':this.scale2.labels[i],
+                                    'valign':'center',
+                                    'halign':'center',
+                                    'bounding':true,
+                                    'boundingFill':color,
+                                    'tag': 'scale'
+                                   });
+                }
+            }
+    
+            // The "South" axis labels
+            if (axes.indexOf('s') > -1) {
+                for (var i=0; i<prop['chart.labels.count']; ++i) {
+                    RG.Text2(this, {'font':font,
+                                    'size':size,
+                                    'x':centerx,
+                                    'y':centery + (radius * ((i+1) / prop['chart.labels.count'])),
+                                    'text':this.scale2.labels[i],
+                                    'valign':'center',
+                                    'halign':'center',
+                                    'bounding':true,
+                                    'boundingFill':color,
+                                    'tag': 'scale'
+                                   });
+                }
+            }
+            
+            // The "East" axis labels
+            if (axes.indexOf('e') > -1) {
+                for (var i=0; i<prop['chart.labels.count']; ++i) {
+                    RG.Text2(this, {'font':font,
+                                    'size':size,
+                                    'x':centerx + (radius * ((i+1) / prop['chart.labels.count'])),
+                                    'y':centery,
+                                    'text':this.scale2.labels[i],
+                                    'valign':'center',
+                                    'halign':'center',
+                                    'bounding':true,
+                                    'boundingFill':color,
+                                    'tag': 'scale'
+                                   });
+                }
+            }
+    
+            // The "West" axis labels
+            if (axes.indexOf('w') > -1) {
+                for (var i=0; i<prop['chart.labels.count']; ++i) {
+                    RG.Text2(this, {'font':font,
+                                    'size':size,
+                                    'x':centerx - (radius * ((i+1) / prop['chart.labels.count'])),
+                                    'y':centery,
+                                    'text':this.scale2.labels[i],
+                                    'valign':'center',
+                                    'halign':'center',
+                                    'bounding':true,
+                                    'boundingFill':color,
+                                    'tag': 'scale'
+                                   });
+                }
+            }
+    
+            if (axes.length > 0) {
+                RG.Text2(this, {'font':font,
+                                'size':size,
+                                'x':centerx,
+                                'y':centery,
+                                'text':typeof(prop['chart.ymin']) == 'number' ? RG.number_format(this, Number(prop['chart.ymin']).toFixed(prop['chart.scale.decimals']), units_pre, units_post) : '0',
+                                'valign':'center',
+                                'halign':'center',
+                                'bounding':true,
+                                'boundingFill':color,
+                                'tag': 'scale'
+                               });
+            }
+        }
+
+
+
+
+        /**
+        * Draws the circular labels that go around the charts
+        * 
+        * @param labels array The labels that go around the chart
+        */
+        this.DrawCircularLabels = function (co, labels, font, size, radius)
+        {
+            var variant = prop['chart.variant'];
+            var position = prop['chart.labels.position'];
+            var radius   = radius + 5 + prop['chart.labels.offset'];
+            var centerx  = this.centerx;
+            var centery  = this.centery;
+    
+            for (var i=0; i<labels.length; ++i) {
+                if (typeof(variant) == 'string' && variant == 'non-equi-angular') {
+                    var a = Number(this.angles[i][0]) + ((this.angles[i][1] - this.angles[i][0]) / 2);
+                } else {
+                    var a = (TWOPI / labels.length) * (i + 1) - (TWOPI / (labels.length * 2));
+                    var a = a - HALFPI + (prop['chart.labels.position'] == 'edge' ? ((TWOPI / labels.length) / 2) : 0);
+                }
+    
+                var x = centerx + (Math.cos(a) * radius);
+                var y = centery + (Math.sin(a) * radius);
+    
+                // Horizontal alignment
+                if (x > centerx) {
+                    halign = 'left';
+                } else if (Math.round(x) == centerx) {
+                    halign = 'center';
+                } else {
+                    halign = 'right';
+                }
+    
+                RG.Text2(this, {'font':font,
+                                'size':size,
+                                'x':x,
+                                'y':y,
+                                'text':String(labels[i]),
+                                'halign':halign,
+                                'valign':'center',
+                                    'tag': 'labels'
+                               });
+            }
+        }
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+        /**
+        * This function is for use with circular graph types, eg the Pie or Rose. Pass it your event object
+        * and it will pass you back the corresponding segment details as an array:
+        * 
+        * [x, y, r, startAngle, endAngle]
+        * 
+        * Angles are measured in degrees, and are measured from the "east" axis (just like the canvas).
+        * 
+        * @param object e   Your event object
+        */
+        this.getShape =
+        this.getSegment = function (e)
+        {
+            RG.FixEventObject(e);
+    
+            var angles  = this.angles;
+            var ret     = [];
+    
+            /**
+            * Go through all of the angles checking each one
+            */
+            for (var i=0; i<angles.length ; ++i) {
+    
+                var angleStart  = angles[i][0];
+                var angleEnd    = angles[i][1];
+                var radiusStart = angles[i][2];
+                var radiusEnd   = angles[i][3];
+                var centerX     = angles[i][4];
+                var centerY     = angles[i][5];
+                var mouseXY     = RG.getMouseXY(e);
+                var mouseX      = mouseXY[0] - centerX;
+                var mouseY      = mouseXY[1] - centerY;
+    
+                // New click testing (the 0.01 is there because Opera doesn't like 0 as the radius)
+                co.beginPath();
+                    co.arc(centerX, centerY, radiusStart ? radiusStart : 0.01, angleStart, angleEnd, false);
+                    co.arc(centerX, centerY, radiusEnd, angleEnd, angleStart, true);
+                co.closePath();
+    
+                // No stroke() or fill()
+    
+    
+                if (co.isPointInPath(mouseXY[0], mouseXY[1])) {
+    
+                    angles[i][6] = i;
+                    
+                    if (RG.parseTooltipText) {
+                        var tooltip = RG.parseTooltipText(prop['chart.tooltips'], angles[i][6]);
+                    }
+    
+                    // Add the textual keys
+                    angles[i]['object']       = this;
+                    angles[i]['x']            = angles[i][4];
+                    angles[i]['y']            = angles[i][5];
+                    angles[i]['angle.start']  = angles[i][0];
+                    angles[i]['angle.end']    = angles[i][1];
+                    angles[i]['radius.start'] = angles[i][2];
+                    angles[i]['radius.end']   = angles[i][3];
+                    angles[i]['index']        = angles[i][6];
+                    angles[i]['tooltip']      = tooltip ? tooltip : null;
+    
+                    return angles[i];
+                }
+            }
+    
+            return null;
+        }
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+        /**
+        * Returns any exploded for a particular segment
+        */
+        this.getexploded = function (index, startAngle, endAngle, exploded)
+        {
+            var explodedx, explodedy;
+    
+            /**
+            * Retrieve any exploded - the exploded can be an array of numbers or a single number
+            * (which is applied to all segments)
+            */
+            if (typeof(exploded) == 'object' && typeof(exploded[index]) == 'number') {
+                explodedx = Math.cos(((endAngle - startAngle) / 2) + startAngle) * exploded[index];
+                explodedy = Math.sin(((endAngle - startAngle) / 2) + startAngle) * exploded[index];
+            
+            } else if (typeof(exploded) == 'number') {
+                explodedx = Math.cos(((endAngle - startAngle) / 2) + startAngle) * exploded;
+                explodedy = Math.sin(((endAngle - startAngle) / 2) + startAngle) * exploded;
+    
+            } else {
+                explodedx = 0;
+                explodedy = 0;
+            }
+            
+            return [explodedx, explodedy];
+        }
+
+
+
+
+        /**
+        * This function facilitates the installation of tooltip event listeners if
+        * tooltips are defined.
+        */
+        this.AllowTooltips = function ()
+        {
+            // Preload any tooltip images that are used in the tooltips
+            RG.PreLoadTooltipImages(this);
+    
+    
+            /**
+            * This installs the window mousedown event listener that lears any
+            * highlight that may be visible.
+            */
+            RG.InstallWindowMousedownTooltipListener(this);
+    
+    
+            /**
+            * This installs the canvas mousemove event listener. This function
+            * controls the pointer shape.
+            */
+            RG.InstallCanvasMousemoveTooltipListener(this);
+    
+    
+            /**
+            * This installs the canvas mouseup event listener. This is the
+            * function that actually shows the appropriate tooltip (if any).
+            */
+            RG.InstallCanvasMouseupTooltipListener(this);
+        }
+
+
+
+
+        /**
+        * Each object type has its own Highlight() function which highlights the appropriate shape
+        * 
+        * @param object shape The shape to highlight
+        */
+        this.Highlight = function (shape)
+        {
+            if (prop['chart.tooltips.highlight']) {
+                // Add the new segment highlight
+                co.beginPath();
+                
+                    co.strokeStyle = prop['chart.highlight.stroke'];
+                    co.fillStyle = prop['chart.highlight.fill'];
+                
+                    co.arc(shape['x'], shape['y'], shape['radius.end'], shape['angle.start'], shape['angle.end'], false);
+
+                    if (shape['radius.start'] > 0) {
+                        co.arc(shape['x'], shape['y'], shape['radius.start'], shape['angle.end'], shape['angle.start'], true);
+                    } else {
+                        co.lineTo(shape['x'], shape['y']);
+                    }
+                co.closePath();
+        
+                co.stroke();
+                co.fill();
+            }
+        }
+
+
+
+
+        /**
+        * The getObjectByXY() worker method. Don't call this call:
+        * 
+        * RGraph.ObjectRegistry.getObjectByXY(e)
+        * 
+        * @param object e The event object
+        */
+        this.getObjectByXY = function (e)
+        {
+            var mouseXY = RGraph.getMouseXY(e);
+    
+            // Work out the radius
+            var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);
+    
+            if (
+                   mouseXY[0] > (this.centerx - this.radius)
+                && mouseXY[0] < (this.centerx + this.radius)
+                && mouseXY[1] > (this.centery - this.radius)
+                && mouseXY[1] < (this.centery + this.radius)
+                && radius <= this.radius
+                ) {
+    
+                return this;
+            }
+        }
+
+
+
+
+        /**
+        * This function positions a tooltip when it is displayed
+        * 
+        * @param obj object    The chart object
+        * @param int x         The X coordinate specified for the tooltip
+        * @param int y         The Y coordinate specified for the tooltip
+        * @param objec tooltip The tooltips DIV element
+        */
+        this.positionTooltip = function (obj, x, y, tooltip, idx)
+        {
+            var coordX      = obj.angles[idx][4];
+            var coordY      = obj.angles[idx][5];
+            var angleStart  = obj.angles[idx][0];
+            var angleEnd    = obj.angles[idx][1];
+            var radius      = ((obj.angles[idx][3] - obj.angles[idx][2]) / 2) + obj.angles[idx][2];
+    
+            var angleCenter = ((angleEnd - angleStart) / 2) + angleStart;
+            var canvasXY    = RG.getCanvasXY(obj.canvas);
+            var gutterLeft  = this.gutterLeft;
+            var gutterTop   = this.gutterTop;
+            var width       = tooltip.offsetWidth;
+            var height      = tooltip.offsetHeight;
+    
+            
+            // By default any overflow is hidden
+            tooltip.style.overflow = '';
+    
+            // The arrow
+            var img = new Image();
+                img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAFCAYAAACjKgd3AAAARUlEQVQYV2NkQAN79+797+RkhC4M5+/bd47B2dmZEVkBCgcmgcsgbAaA9GA1BCSBbhAuA/AagmwQPgMIGgIzCD0M0AMMAEFVIAa6UQgcAAAAAElFTkSuQmCC';
+                img.style.position = 'absolute';
+                img.id = '__rgraph_tooltip_pointer__';
+                img.style.top = (tooltip.offsetHeight - 2) + 'px';
+            tooltip.appendChild(img);
+            
+            // Reposition the tooltip if at the edges:
+    
+            // LEFT edge
+            if ((canvasXY[0] + coordX + (Math.cos(angleCenter) * radius) - (width / 2)) < 10) {
+                tooltip.style.left = (canvasXY[0] + coordX + (Math.cos(angleCenter) * radius)- (width * 0.1)) + 'px';
+                tooltip.style.top = (canvasXY[1] + coordY + (Math.sin(angleCenter) * radius)- height - 5) + 'px';
+                img.style.left = ((width * 0.1) - 8.5) + 'px';
+    
+            // RIGHT edge
+            } else if ((canvasXY[0] + coordX + (Math.cos(angleCenter) * radius) + (width / 2)) > (document.body.offsetWidth - 10) ) {
+                tooltip.style.left = (canvasXY[0] + coordX + (Math.cos(angleCenter) * radius) - (width * 0.9)) + 'px';
+                tooltip.style.top = (canvasXY[1] + coordY + (Math.sin(angleCenter) * radius)- height - 5) + 'px';
+                img.style.left = ((width * 0.9) - 8.5) + 'px';
+    
+            // Default positioning - CENTERED
+            } else {
+                tooltip.style.left = (canvasXY[0] + coordX + (Math.cos(angleCenter) * radius)- (width / 2)) + 'px';
+                tooltip.style.top = (canvasXY[1] + coordY + (Math.sin(angleCenter) * radius)- height - 5) + 'px';
+                img.style.left = ((width * 0.5) - 8.5) + 'px';
+            }
+        }
+
+
+
+
+        /**
+        * This method gives you the relevant radius for a particular value
+        * 
+        * @param number value The relevant value to get the radius for
+        */
+        this.getRadius = function (value)
+        {
+            // Range checking (the Rose minimum is always 0)
+            if (value < 0 || value > this.max) {
+                return null;
+            }
+            
+            var r = (value / this.max) * this.radius;
+            
+            return r;
+        }
+
+
+
+
+        /**
+        * This allows for easy specification of gradients
+        */
+        this.parseColors = function ()
+        {
+            for (var i=0; i<prop['chart.colors'].length; ++i) {
+                prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);
+            }
+    
+            /**
+            * Key colors
+            */
+            if (!RG.is_null(prop['chart.key.colors'])) {
+                for (var i=0; i<prop['chart.key.colors'].length; ++i) {
+                    prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);
+                }
+            }
+            
+            prop['chart.text.color']       = this.parseSingleColorForGradient(prop['chart.text.color']);
+            prop['chart.title.color']      = this.parseSingleColorForGradient(prop['chart.title.color']);
+            prop['chart.highlight.fill']   = this.parseSingleColorForGradient(prop['chart.highlight.fill']);
+            prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);
+        }
+
+
+
+
+        /**
+        * This parses a single color value
+        */
+        this.parseSingleColorForGradient = function (color)
+        {
+            if (!color || typeof(color) != 'string') {
+                return color;
+            }
+    
+            if (color.match(/^gradient\((.*)\)$/i)) {
+    
+                var parts = RegExp.$1.split(':');
+    
+                // Create the gradient
+                //var grad = context.createLinearGradient(0,0,canvas.width,0);
+                var grad = co.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);
+    
+                var diff = 1 / (parts.length - 1);
+    
+                grad.addColorStop(0, RG.trim(parts[0]));
+    
+                for (var j=1; j<parts.length; ++j) {
+                    grad.addColorStop(j * diff, RG.trim(parts[j]));
+                }
+            }
+
+            return grad ? grad : color;
+        }
+
+
+
+
+        /**
+        * This function handles highlighting an entire data-series for the interactive
+        * key
+        * 
+        * @param int index The index of the data series to be highlighted
+        */
+        this.interactiveKeyHighlight = function (index)
+        {
+            this.angles2.forEach(function (val, idx, arr)
+            {
+                var segment = val[index];
+
+                if (segment) {
+                    co.beginPath();
+                        co.lineWidth = 2;
+                        co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];
+                        co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];
+                        co.arc(segment[4], segment[5], segment[2], segment[0], segment[1], false);
+                        co.arc(segment[4], segment[5], segment[3], segment[1], segment[0], true);
+                    co.closePath();
+                    co.fill();
+                    co.stroke();
+                }
+            });
+
+        }
+
+
+
+
+        /**
+        * Register this object
+        */
+        RG.Register(this);
+    }
\ No newline at end of file
diff --git a/mod/questionnaire/javascript/RGraph/RGraph.vprogress.js b/mod/questionnaire/javascript/RGraph/RGraph.vprogress.js
new file mode 100644
index 0000000..726acfc
--- /dev/null
+++ b/mod/questionnaire/javascript/RGraph/RGraph.vprogress.js
@@ -0,0 +1,1077 @@
+    /**
+    * o-------------------------------------------------------------------------------o
+    * | This file is part of the RGraph package. RGraph is Free software, licensed    |
+    * | under the MIT license - so it's free to use for all purposes. Extended        |
+    * | support is available if required and donations are always welcome! You can    |
+    * | read more here:                                                               |
+    * |                         http://www.rgraph.net/support                         |
+    * o-------------------------------------------------------------------------------o
+    */
+
+    if (typeof(RGraph) == 'undefined') RGraph = {};
+
+    /**
+    * The progress bar constructor
+    * 
+    * @param int id    The ID of the canvas tag
+    * @param int value The indicated value of the meter.
+    * @param int max   The end value (the upper most) of the meter
+    */
+    RGraph.VProgress = function (id, value, max)
+    {
+        this.id                = id;
+        this.max               = max;
+        this.value             = value;
+        this.canvas            = document.getElementById(typeof id === 'object' ? id.id : id);
+        this.context           = this.canvas.getContext('2d');
+        this.canvas.__object__ = this;
+        this.type              = 'vprogress';
+        this.coords            = [];
+        this.isRGraph          = true;
+        this.currentValue      = null;
+        this.uid               = RGraph.CreateUID();
+        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();
+        this.colorsParsed      = false;
+        this.coordsText        = [];
+
+
+        /**
+        * Compatibility with older browsers
+        */
+        RGraph.OldBrowserCompat(this.context);
+
+        this.properties = {
+            'chart.colors':             ['Gradient(white:#0c0)','Gradient(white:red)','Gradient(white:green)','yellow','pink','cyan','black','white','gray'],
+            'chart.strokestyle.inner':  '#999',
+            'chart.strokestyle.outer':  '#999',
+            'chart.tickmarks':          true,
+            'chart.tickmarks.zerostart':true,
+            'chart.tickmarks.color':    '#999',
+            'chart.tickmarks.inner':    false,
+            'chart.gutter.left':        25,
+            'chart.gutter.right':       25,
+            'chart.gutter.top':         25,
+            'chart.gutter.bottom':      25,
+            'chart.numticks':           10,
+            'chart.numticks.inner':     50,
+            'chart.background.color':   '#eee',
+            'chart.shadow':             false,
+            'chart.shadow.color':       'rgba(0,0,0,0.5)',
+            'chart.shadow.blur':        3,
+            'chart.shadow.offsetx':     3,
+            'chart.shadow.offsety':     3,
+            'chart.title':              '',
+            'chart.title.bold':         true,
+            'chart.title.font':         null,
+            'chart.title.size':         null,
+            'chart.title.color':        'black',
+            
+            'chart.title.side':         null,
+            'chart.title.side.font':    'Arial',
+            'chart.title.side.size':    12,
+            'chart.title.side.color':   'black',
+            'chart.title.side.bold':    true,
+            
+            'chart.text.size':          10,
+            'chart.text.color':         'black',
+            'chart.text.font':          'Arial',
+            'chart.contextmenu':        null,
+            'chart.units.pre':          '',
+            'chart.units.post':         '',
+            'chart.tooltips':           null,
+            'chart.tooltips.effect':    'fade',
+            'chart.tooltips.css.class': 'RGraph_tooltip',
+            'chart.tooltips.highlight': true,
+            'chart.tooltips.event':         'onclick',
+            'chart.highlight.stroke':   'rgba(0,0,0,0)',
+            'chart.highlight.fill':     'rgba(255,255,255,0.7)',
+            'chart.annotatable':        false,
+            'chart.annotate.color':     'black',
+            'chart.zoom.factor':        1.5,
+            'chart.zoom.fade.in':       true,
+            'chart.zoom.fade.out':      true,
+            'chart.zoom.hdir':          'right',
+            'chart.zoom.vdir':          'down',
+            'chart.zoom.frames':        25,
+            'chart.zoom.delay':         16.666,
+            'chart.zoom.shadow':        true,
+            'chart.zoom.background':    true,
+            'chart.zoom.action':        'zoom',
+            'chart.arrows':             false,
+            'chart.margin':             0,
+            'chart.resizable':              false,
+            'chart.resize.handle.adjust':   [0,0],
+            'chart.resize.handle.background': null,
+            'chart.label.inner':        false,
+            'chart.labels.count':       10,
+            'chart.labels.position':    'right',
+            'chart.adjustable':         false,
+            'chart.min':                0,
+            'chart.scale.decimals':     0,
+            'chart.scale.thousand':     ',',
+            'chart.scale.point':        '.',
+            'chart.key':                null,
+            'chart.key.background':     'white',
+            'chart.key.position':       'graph',
+            'chart.key.halign':             'right',
+            'chart.key.shadow':         false,
+            'chart.key.shadow.color':   '#666',
+            'chart.key.shadow.blur':    3,
+            'chart.key.shadow.offsetx': 2,
+            'chart.key.shadow.offsety': 2,
+            'chart.key.position.gutter.boxed': false,
+            'chart.key.position.x':     null,
+            'chart.key.position.y':     null,
+            'chart.key.color.shape':    'square',
+            'chart.key.rounded':        true,
+            'chart.key.linewidth':      1,
+            'chart.key.colors':         null,
+            'chart.key.interactive':    false,
+            'chart.key.interactive.highlight.chart.stroke': '#000',
+            'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)',
+            'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)',
+            'chart.key.text.color':     'black',
+            'chart.events.click':       null,
+            'chart.events.mousemove':   null,
+            'chart.border.inner':       true
+        }
+        
+        /**
+        * Allow for new style method of passing arguments to the constructor
+        */
+        if (arguments.length == 4) {
+
+            this.min   = arguments[1];
+            this.max   = arguments[2];
+            this.value = arguments[3];
+            
+            this.properties['chart.min'] = arguments[1];
+        
+        } else if (arguments.length == 3) {
+
+            this.min   = 0;
+            this.max   = arguments[2];
+            this.value = arguments[1];
+            
+            this.properties['chart.min'] = 0;
+        }
+
+        // Check for support
+        if (!this.canvas) {
+            alert('[PROGRESS] No canvas support');
+            return;
+        }
+
+
+        /**
+        * Create the dollar objects so that functions can be added to them
+        */
+        var linear_data = RGraph.array_linearize(value);
+        for (var i=0; i<linear_data.length; ++i) {
+            this['$' + i] = {};
+        }
+
+
+        /**
+        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen
+        * done already
+        */
+        if (!this.canvas.__rgraph_aa_translated__) {
+            this.context.translate(0.5,0.5);
+            
+            this.canvas.__rgraph_aa_translated__ = true;
+        }
+
+
+
+
+        ///////////////////////////////// SHORT PROPERTIES /////////////////////////////////
+
+
+
+
+        var RG   = RGraph;
+        var ca   = this.canvas;
+        var co   = ca.getContext('2d');
+        var prop = this.properties;
+        //var $jq  = jQuery;
+
+
+
+
+        //////////////////////////////////// METHODS ///////////////////////////////////////
+
+
+
+
+        /**
+        * A generic setter
+        * 
+        * @param string name  The name of the property to set
+        * @param string value The value of the poperty
+        */
+        this.Set = function (name, value)
+        {
+            /**
+            * This should be done first - prepend the propertyy name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            /**
+            * chart.strokestyle now sets both chart.strokestyle.inner and chart.strokestyle.outer
+            */
+            if (name == 'chart.strokestyle') {
+                prop['chart.strokestyle.inner'] = value;
+                prop['chart.strokestyle.outer'] = value;
+
+                return;
+            }
+    
+            prop[name.toLowerCase()] = value;
+    
+            return this;
+        }
+
+
+
+
+        /**
+        * A generic getter
+        * 
+        * @param string name  The name of the property to get
+        */
+        this.Get = function (name)
+        {
+            /**
+            * This should be done first - prepend the property name with "chart." if necessary
+            */
+            if (name.substr(0,6) != 'chart.') {
+                name = 'chart.' + name;
+            }
+    
+            return prop[name.toLowerCase()];
+        }
+
+
+
+
+        /**
+        * Draws the progress bar
+        */
+        this.Draw = function ()
+        {
+            /**
+            * Fire the onbeforedraw event
+            */
+            RG.FireCustomEvent(this, 'onbeforedraw');
+    
+    
+    
+            /**
+            * Parse the colors. This allows for simple gradient syntax
+            */
+            if (!this.colorsParsed) {
+    
+                this.parseColors();
+    
+                
+                // Don't want to do this again
+                this.colorsParsed = true;
+            }
+    
+            
+            /**
+            * Set the current value
+            */
+            this.currentValue = this.value;
+            
+            /**
+            * This is new in May 2011 and facilitates indiviual gutter settings,
+            * eg chart.gutter.left
+            */
+            this.gutterLeft   = prop['chart.gutter.left'];
+            this.gutterRight  = prop['chart.gutter.right'];
+            this.gutterTop    = prop['chart.gutter.top'];
+            this.gutterBottom = prop['chart.gutter.bottom'];
+    
+            // Figure out the width and height
+            this.width  = ca.width - this.gutterLeft - this.gutterRight;
+            this.height = ca.height - this.gutterTop - this.gutterBottom;
+            this.coords = [];
+    
+            this.Drawbar();
+            this.DrawTickMarks();
+            this.DrawLabels();
+            this.DrawTitles();
+    
+            co.stroke();
+            co.fill();
+            
+            
+            /**
+            * Draw the bevel effect if requested
+            */
+            if (prop['chart.bevel']) {
+                this.DrawBevel();
+            }
+    
+    
+    
+            /**
+            * Setup the context menu if required
+            */
+            if (prop['chart.contextmenu']) {
+                RG.ShowContext(this);
+            }
+    
+    
+            /**
+            * This installs the event listeners
+            */
+            RG.InstallEventListeners(this);
+            
+            // Draw a key if necessary
+            if (prop['chart.key'] && prop['chart.key'].length) {
+                RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);
+            }
+    
+    
+            
+            /**
+            * This function enables resizing
+            */
+            if (prop['chart.resizable']) {
+                RG.AllowResizing(this);
+            }
+            
+            /**
+            * Instead of using RGraph.common.adjusting.js, handle them here
+            */
+            this.AllowAdjusting();
+            
+            /**
+            * Fire the RGraph ondraw event
+            */
+            RG.FireCustomEvent(this, 'ondraw');
+            
+            return this;
+        }
+
+
+
+
+        /**
+        * Draw the bar itself
+        */
+        this.Drawbar = function ()
+        {
+            /**
+            * First get the scale
+            */
+                this.scale2 = RGraph.getScale2(this, {
+                                                    'max':this.max,
+                                                    'min':this.min,
+                                                    'strict':true,
+                                                    'scale.thousand':prop['chart.scale.thousand'],
+                                                    'scale.point':prop['chart.scale.point'],
+                                                    'scale.decimals':prop['chart.scale.decimals'],
+                                                    'ylabels.count':prop['chart.labels.count'],
+                                                    'scale.round':prop['chart.scale.round'],
+                                                    'units.pre': prop['chart.units.pre'],
+                                                    'units.post': prop['chart.units.post']
+                                                   });
+    
+    
+            // Set a shadow if requested
+            if (prop['chart.shadow']) {
+                RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);
+            }
+    
+            // Draw the shadow for MSIE
+            if (ISOLD && prop['chart.shadow']) {
+                co.fillStyle = prop['chart.shadow.color'];
+                co.fillRect(this.gutterLeft + prop['chart.shadow.offsetx'], this.gutterTop + prop['chart.shadow.offsety'], this.width, this.height);
+            }
+    
+            // Draw the outline
+            co.fillStyle   = prop['chart.background.color'];
+            co.strokeStyle = prop['chart.strokestyle.outer'];
+            co.strokeRect(this.gutterLeft, this.gutterTop, this.width, this.height);
+            co.fillRect(this.gutterLeft, this.gutterTop, this.width, this.height);
+    
+            // Turn off any shadow
+            RG.NoShadow(this);
+    
+            co.strokeStyle = prop['chart.strokestyle.outer'];
+            co.fillStyle   = prop['chart.colors'][0];
+            var margin     = prop['chart.margin'];
+            var barHeight  = (ca.height - this.gutterTop - this.gutterBottom) * (RG.array_sum(this.value) / this.max);
+    
+            // Draw the actual bar itself
+            if (typeof(this.value) == 'number') {
+    
+                co.lineWidth   = 1;
+                co.strokeStyle = prop['chart.strokestyle.inner'];
+    
+            } else if (typeof(this.value) == 'object') {
+    
+                co.beginPath();
+                co.strokeStyle = prop['chart.strokestyle.inner'];
+    
+                var startPoint = ca.height - this.gutterBottom;
+    
+                for (var i=0; i<this.value.length; ++i) {
+    
+                    var segmentHeight = ( (this.value[i] - prop['chart.min']) / (this.max - prop['chart.min']) ) * (ca.height - this.gutterBottom - this.gutterTop);
+    
+                    co.fillStyle = prop['chart.colors'][i];
+                    
+                    if (prop['chart.border.inner']) {
+                        co.strokeRect(this.gutterLeft + margin, startPoint - segmentHeight, this.width - margin - margin, segmentHeight);
+                    }
+                    co.fillRect(this.gutterLeft + margin, startPoint - segmentHeight, this.width - margin - margin, segmentHeight);
+    
+    
+    
+                    // Store the coords
+                    this.coords.push([this.gutterLeft + margin, startPoint - segmentHeight, this.width - margin - margin, segmentHeight]);
+    
+                    startPoint -= segmentHeight;
+                }
+    
+                
+                co.stroke();
+                co.fill();
+            }
+
+            /**
+            * Inner tickmarks
+            */
+            if (prop['chart.tickmarks.inner']) {
+            
+                var spacing = (ca.height - this.gutterTop - this.gutterBottom) / prop['chart.numticks.inner'];
+    
+                co.lineWidth   = 1;
+                co.strokeStyle = prop['chart.strokestyle.outer'];
+    
+                co.beginPath();
+    
+                for (var y = this.gutterTop; y<ca.height - this.gutterBottom; y+=spacing) {
+                    co.moveTo(this.gutterLeft, Math.round(y));
+                    co.lineTo(this.gutterLeft + 3, Math.round(y));
+    
+                    co.moveTo(ca.width - this.gutterRight, Math.round(y));
+                    co.lineTo(ca.width - this.gutterRight - 3, Math.round(y));
+                }
+    
+                co.stroke();
+            }
+    
+            co.beginPath();
+            co.strokeStyle = prop['chart.strokestyle.inner'];
+    
+            if (typeof(this.value) == 'number') {
+                
+                if (prop['chart.border.inner']) {
+                    co.strokeRect(this.gutterLeft + margin, this.gutterTop + this.height - barHeight, this.width - margin - margin, barHeight);
+                }
+                co.fillRect(this.gutterLeft + margin, this.gutterTop + this.height - barHeight, this.width - margin - margin, barHeight);
+    
+                // Store the coords
+                this.coords.push([this.gutterLeft + margin, this.gutterTop + this.height - barHeight, this.width - margin - margin, barHeight]);
+            }
+    
+    
+            /**
+            * Draw the arrows indicating the level if requested
+            */
+            if (prop['chart.arrows']) {
+                var x = this.gutterLeft - 4;
+                var y = ca.height - this.gutterBottom - barHeight;
+                
+                co.lineWidth = 1;
+                co.fillStyle = 'black';
+                co.strokeStyle = 'black';
+    
+                co.beginPath();
+                    co.moveTo(x, y);
+                    co.lineTo(x - 4, y - 2);
+                    co.lineTo(x - 4, y + 2);
+                co.closePath();
+    
+                co.stroke();
+                co.fill();
+    
+                x +=  this.width + 8;
+    
+                co.beginPath();
+                    co.moveTo(x, y);
+                    co.lineTo(x + 4, y - 2);
+                    co.lineTo(x + 4, y + 2);
+                co.closePath();
+    
+                co.stroke();
+                co.fill();
+            }
+    
+    
+    
+    
+            /**
+            * Draw the "in-bar" label
+            */
+            if (prop['chart.label.inner']) {
+                co.fillStyle = 'black';
+                RG.Text2(this, {'font':prop['chart.text.font'],
+                                'size':prop['chart.text.size'],
+                                'x':((ca.width - this.gutterLeft - this.gutterRight) / 2) + this.gutterLeft,'y':this.coords[this.coords.length - 1][1] - 5,'text':RGraph.number_format(this, (typeof(this.value) == 'number' ? this.value : RG.array_sum(this.value)).toFixed(prop['chart.scale.decimals'])),
+                                'valign':'bottom',
+                                'halign':'center',
+                                'bounding':true,
+                                'boundingFill':'white',
+                                'tag': 'label.inner'
+                               });
+            }
+        }
+
+
+
+
+        /**
+        * The function that draws the tick marks.
+        */
+        this.DrawTickMarks = function ()
+        {
+            co.strokeStyle = prop['chart.tickmarks.color'];
+    
+            if (prop['chart.tickmarks']) {
+                co.beginPath();
+                    for (var i=0; prop['chart.tickmarks.zerostart'] ? i<=prop['chart.numticks'] : i<prop['chart.numticks']; i++) {
+                        
+                        var startX = prop['chart.labels.position'] == 'left' ? this.gutterLeft : ca.width - prop['chart.gutter.right'];
+                        var endX   = prop['chart.labels.position'] == 'left' ? startX - 4 : startX + 4;
+                        var yPos   = (this.height * (i / prop['chart.numticks'])) + this.gutterTop
+    
+                        co.moveTo(startX, Math.round(yPos));
+                        co.lineTo(endX, Math.round(yPos));
+                    }
+                co.stroke();
+            }
+        }
+
+
+
+
+        /**
+        * The function that draws the labels
+        */
+        this.DrawLabels = function ()
+        {
+            if (!RG.is_null(prop['chart.labels.specific'])) {
+                return this.DrawSpecificLabels();
+            }
+    
+            co.fillStyle = prop['chart.text.color'];
+
+            var position   = prop['chart.labels.position'];
+            var xAlignment = position == 'left' ? 'right' : 'left';
+            var yAlignment = 'center';
+            var count      = prop['chart.labels.count'];
+            var units_pre  = prop['chart.units.pre'];
+            var units_post = prop['chart.units.post'];
+            var text_size  = prop['chart.text.size'];
+            var text_font  = prop['chart.text.font'];
+            var decimals   = prop['chart.scale.decimals'];
+    
+            if (prop['chart.tickmarks']) {
+                
+                for (var i=0; i<count ; ++i) {
+                    RG.Text2(this, {'font':text_font,
+                                    'size':text_size,
+                                    'x':position == 'left' ? (this.gutterLeft - 7) : (ca.width - this.gutterRight + 7),
+                                    'y':(((ca.height - this.gutterTop - this.gutterBottom) / count) * i) + this.gutterTop,
+                                    'text':this.scale2.labels[this.scale2.labels.length - (i+1)],
+                                    'valign':yAlignment,
+                                    'halign':xAlignment,
+                                    'tag': 'scale'
+                                   });
+                }
+                
+                /**
+                * Show zero?
+                */            
+                if (prop['chart.tickmarks.zerostart'] && prop['chart.min'] == 0) {
+                    RG.Text2(this, {'font':text_font,
+                                    'size':text_size,
+                                    'x':position == 'left' ? (this.gutterLeft - 5) : (ca.width - this.gutterRight + 5),
+                                    'y':ca.height - this.gutterBottom,'text':RG.number_format(this, prop['chart.min'].toFixed(decimals), units_pre, units_post),
+                                    'valign':yAlignment,
+                                    'halign':xAlignment,
+                                    'tag': 'scale'
+                                   });
+                }
+    
+                /**
+                * chart.ymin is set
+                */
+                if (prop['chart.min'] != 0) {
+                    RG.Text2(this, {'font':text_font,
+                                    'size':text_size,
+                                    'x':position == 'left' ? (this.gutterLeft - 5) : (ca.width - this.gutterRight + 5),
+                                    'y':ca.height - this.gutterBottom,
+                                    'text':RG.number_format(this, prop['chart.min'].toFixed(decimals), units_pre, units_post),
+                                    'valign':yAlignment,
+                                    'halign':xAlignment,
+                                    'tag': 'scale'
+                                   });
+                }
+            }
+        }
+
+
+
+
+        /**
+        * Draws titles
+        */
+        this.DrawTitles = function ()
+        {
+            var text_size  = prop['chart.text.size'];
+            var text_font  = prop['chart.text.font'];
+            var title_size = prop['chart.title.size'] ? prop['chart.title.size'] : text_size + 2;
+    
+            // Draw the title text
+            if (prop['chart.title'].length > 0) {
+    
+                co.fillStyle = prop['chart.title.color'];
+    
+                RG.Text2(this, {'font':prop['chart.title.font'] ? prop['chart.title.font'] : text_font,
+                                'size':title_size,
+                                'x':this.gutterLeft + ((ca.width - this.gutterLeft - this.gutterRight) / 2),
+                                'y':this.gutterTop - 5,
+                                'text':prop['chart.title'],
+                                'valign':'bottom',
+                                'halign':'center',
+                                'bold': prop['chart.title.bold'],
+                                'tag': 'title'
+                               });
+            }
+
+            // Draw side title
+            if (typeof(prop['chart.title.side']) == 'string') {
+    
+                co.fillStyle = prop['chart.title.side.color'];
+    
+                RG.Text2(this, {'font':prop['chart.title.side.font'],
+                                'size':prop['chart.title.side.size'],
+                                'x':prop['chart.labels.position'] == 'right' ? this.gutterLeft - 10 : (ca.width - this.gutterRight) + 10,
+                                'y':this.gutterTop + (this.height / 2),
+                                'text': prop['chart.title.side'],
+                                'valign':'bottom',
+                                'halign':'center',
+                                'angle': prop['chart.labels.position'] == 'right' ? 270 : 90,
+                                'bold': prop['chart.title.side.bold'],
+                                'tag': 'title.side'
+                               });
+            }
+        }
+
+
+
+
+        /**
+        * Returns the focused bar
+        * 
+        * @param event e The event object
+        */
+        this.getShape =
+        this.getBar = function (e)
+        {
+            var mouseCoords = RG.getMouseXY(e)
+    
+            for (var i=0; i<this.coords.length; i++) {
+    
+                var mouseCoords = RG.getMouseXY(e);
+                var mouseX = mouseCoords[0];
+                var mouseY = mouseCoords[1];
+                var left   = this.coords[i][0];
+                var top    = this.coords[i][1];
+                var width  = this.coords[i][2];
+                var height = this.coords[i][3];
+                var idx    = i;
+    
+                if (mouseX >= left && mouseX <= (left + width) && mouseY >= top && mouseY <= (top + height) ) {
+                
+                    var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);
+                
+                    return {0: this,   'object': this,
+                            1: left,   'x':      left,
+                            2: top,    'y':      top,
+                            3: width,  'width':  width,
+                            4: height, 'height': height,
+                            5: i,      'index':  i,
+                                       'tooltip': tooltip };
+                }
+            }
+        }
+
+
+
+
+        /**
+        * This function returns the value that the mouse is positioned at, regardless of
+        * the actual indicated value.
+        * 
+        * @param object e The event object
+        */
+        this.getValue = function (e)
+        {
+            var mouseCoords = RG.getMouseXY(e);
+            var mouseX      = mouseCoords[0];
+            var mouseY      = mouseCoords[1];
+    
+            var value = (this.height - (mouseY - this.gutterTop)) / this.height;
+                value *= this.max - prop['chart.min'];
+                value += prop['chart.min'];
+
+            // Bounds checking
+            if (value > this.max) value = this.max;
+            if (value < this.min) value = this.min;
+
+            return value;
+        }
+
+
+
+
+        /**
+        * Each object type has its own Highlight() function which highlights the appropriate shape
+        * 
+        * @param object shape The shape to highlight
+        */
+        this.Highlight = function (shape)
+        {
+            // Add the new highlight
+            RG.Highlight.Rect(this, shape);
+        }
+
+
+
+
+        /**
+        * The getObjectByXY() worker method. Don't call this call:
+        * 
+        * RGraph.ObjectRegistry.getObjectByXY(e)
+        * 
+        * @param object e The event object
+        */
+        this.getObjectByXY = function (e)
+        {
+            var mouseXY = RG.getMouseXY(e);
+    
+            if (
+                   mouseXY[0] > this.gutterLeft
+                && mouseXY[0] < (ca.width - this.gutterRight)
+                && mouseXY[1] >= this.gutterTop
+                && mouseXY[1] <= (ca.height - this.gutterBottom)
+                ) {
+
+                return this;
+            }
+        }
+
+
+
+
+        /**
+        * This function allows the VProgress to be  adjustable.
+        */
+        this.AllowAdjusting = function () {return;}
+
+
+
+
+        /**
+        * This method handles the adjusting calculation for when the mouse is moved
+        * 
+        * @param object e The event object
+        */
+        this.Adjusting_mousemove = function (e)
+        {
+            /**
+            * Handle adjusting for the HProgress
+            */
+            if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {
+    
+                var mouseXY = RG.getMouseXY(e);
+                var value   = this.getValue(e);
+                
+                if (typeof(value) == 'number') {
+    
+                    // Fire the onadjust event
+                    RG.FireCustomEvent(this, 'onadjust');
+        
+                    this.value = Number(value.toFixed(prop['chart.scale.decimals']));
+                    RG.Redraw();
+                }
+            }
+        }
+
+
+
+
+        /**
+        * Draws chart.labels.specific
+        */
+        this.DrawSpecificLabels = function ()
+        {
+            var labels = prop['chart.labels.specific'];
+    
+            if (labels) {
+    
+                var font   = prop['chart.text.font'];
+                var size   = prop['chart.text.size'];
+                var halign = prop['chart.labels.position'] == 'right' ? 'left' : 'right';
+                var step   = this.height / (labels.length - 1);
+        
+                co.beginPath();
+    
+                    co.fillStyle = prop['chart.text.color'];
+    
+                    for (var i=0; i<labels.length; ++i) {
+    
+                        RG.Text2(this,{'font':font,
+                                       'size':size,
+                                       'x': prop['chart.labels.position'] == 'right' ? ca.width - this.gutterRight + 7 : this.gutterLeft - 7,
+                                       'y':(this.height + this.gutterTop) - (step * i),
+                                       'text':labels[i],
+                                       'valign':'center',
+                                       'halign':halign,
+                                        'tag': 'labels.specific'
+                                      });
+                    }
+                co.fill();
+            }
+        }
+
+
+
+
+        /**
+        * This function positions a tooltip when it is displayed
+        * 
+        * @param obj object    The chart object
+        * @param int x         The X coordinate specified for the tooltip
+        * @param int y         The Y coordinate specified for the tooltip
+        * @param objec tooltip The tooltips DIV element
+        */
+        this.positionTooltip = function (obj, x, y, tooltip, idx)
+        {
+            var coordX     = obj.coords[tooltip.__index__][0];
+            var coordY     = obj.coords[tooltip.__index__][1];
+            var coordW     = obj.coords[tooltip.__index__][2];
+            var coordH     = obj.coords[tooltip.__index__][3];
+            var canvasXY   = RG.getCanvasXY(obj.canvas);
+            var gutterLeft = obj.gutterLeft;
+            var gutterTop  = obj.gutterTop;
+            var width      = tooltip.offsetWidth;
+            var height     = tooltip.offsetHeight;
+    
+            // Set the top position
+            tooltip.style.left = 0;
+            tooltip.style.top  = canvasXY[1] + coordY - height - 7 + 'px';
+            
+            // By default any overflow is hidden
+            tooltip.style.overflow = '';
+    
+            // The arrow
+            var img = new Image();
+                img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAFCAYAAACjKgd3AAAARUlEQVQYV2NkQAN79+797+RkhC4M5+/bd47B2dmZEVkBCgcmgcsgbAaA9GA1BCSBbhAuA/AagmwQPgMIGgIzCD0M0AMMAEFVIAa6UQgcAAAAAElFTkSuQmCC';
+                img.style.position = 'absolute';
+                img.id = '__rgraph_tooltip_pointer__';
+                img.style.top = (tooltip.offsetHeight - 2) + 'px';
+            tooltip.appendChild(img);
+            
+            // Reposition the tooltip if at the edges:
+            
+            // LEFT edge
+            if ((canvasXY[0] + coordX + (coordW / 2) - (width / 2)) < 10) {
+                tooltip.style.left = (canvasXY[0] + coordX - (width * 0.1)) + (coordW / 2) + 'px';
+                img.style.left = ((width * 0.1) - 8.5) + 'px';
+    
+            // RIGHT edge
+            } else if ((canvasXY[0] + coordX + (coordW / 2) + (width / 2)) > document.body.offsetWidth) {
+                tooltip.style.left = canvasXY[0] + coordX - (width * 0.9) + (coordW / 2) + 'px';
+                img.style.left = ((width * 0.9) - 8.5) + 'px';
+    
+            // Default positioning - CENTERED
+            } else {
+                tooltip.style.left = (canvasXY[0] + coordX + (coordW / 2) - (width * 0.5)) + 'px';
+                img.style.left = ((width * 0.5) - 8.5) + 'px';
+            }
+        }
+
+
+
+
+        /**
+        * This function returns the appropriate Y coordinate for the given Y value
+        * 
+        * @param  int value The Y value you want the coordinate for
+        * @returm int       The coordinate
+        */
+        this.getYCoord = function (value)
+        {
+            if (value > this.max || value < prop['chart.min']) {
+                return null;
+            }
+    
+            var barHeight = ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'];
+            var coord = ((value - prop['chart.min']) / (this.max - prop['chart.min'])) * barHeight;
+            coord = ca.height - coord - prop['chart.gutter.bottom'];
+            
+            return coord;
+        }
+
+
+
+
+        /**
+        * This returns true/false as to whether the cursor is over the chart area.
+        * The cursor does not necessarily have to be over the bar itself.
+        */
+        this.overChartArea = function  (e)
+        {
+            var mouseXY = RGraph.getMouseXY(e);
+            var mouseX  = mouseXY[0];
+            var mouseY  = mouseXY[1];
+    
+            if (   mouseX >= this.gutterLeft
+                && mouseX <= (ca.width - this.gutterRight)
+                && mouseY >= this.gutterTop
+                && mouseY <= (ca.height - this.gutterBottom)
+                ) {
+                
+                return true;
+            }
+    
+            return false;
+        }
+
+
+
+
+        /**
+        * 
+        */
+        this.parseColors = function ()
+        {
+            var colors = prop['chart.colors'];
+    
+            for (var i=0; i<colors.length; ++i) {
+                colors[i] = this.parseSingleColorForGradient(colors[i]);
+            }
+        }
+
+
+
+
+        /**
+        * This parses a single color value
+        */
+        this.parseSingleColorForGradient = function (color)
+        {
+            if (!color || typeof(color) != 'string') {
+                return color;
+            }
+    
+            if (color.match(/^gradient\((.*)\)$/i)) {
+                var parts = RegExp.$1.split(':');
+    
+                // Create the gradient
+                var grad = co.createLinearGradient(0, ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);
+    
+                var diff = 1 / (parts.length - 1);
+    
+                grad.addColorStop(0, RG.trim(parts[0]));
+    
+                for (var j=1; j<parts.length; ++j) {
+                    grad.addColorStop(j * diff, RG.trim(parts[j]));
+                }
+                
+                return grad ? grad : color;
+            }
+    
+            return grad ? grad : color;
+        }
+
+
+
+
+        /**
+        * Draws the bevel effect
+        */
+        this.DrawBevel = function ()
+        {
+            // In case of multiple segments - this adds up all the lengths
+            for (var i=0,len=0; i<this.coords.length; ++i) len += this.coords[i][3];
+    
+            co.save();
+                // Draw a path to clip to
+                co.beginPath();
+                    co.rect(this.coords[0][0], this.coords[this.coords.length - 1][1] - 1, this.coords[0][2], len);
+                    co.clip();
+                
+                // Now draw the rect with a shadow
+                co.beginPath();
+                    
+                    co.shadowColor = 'black';
+                    co.shadowOffsetX = 0;
+                    co.shadowOffsetY = 0;
+                    co.shadowBlur    = 15;
+                    
+                    co.lineWidth = 2;
+                    co.rect(this.coords[0][0] - 1, this.coords[this.coords.length - 1][1] - 1, this.coords[0][2] + 2, len + 2);
+                
+                co.stroke();
+    
+            co.restore();
+        }
+
+
+
+
+        /**
+        * This function handles highlighting an entire data-series for the interactive
+        * key
+        * 
+        * @param int index The index of the data series to be highlighted
+        */
+        this.interactiveKeyHighlight = function (index)
+        {
+            var coords = this.coords[index];
+
+            co.beginPath();
+
+                co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];
+                co.lineWidth    = 2;
+                co.fillStyle   = prop['chart.key.interactive.highlight.chart.fill'];
+
+                co.rect(coords[0], coords[1], coords[2], coords[3]);
+            co.fill();
+            co.stroke();
+            
+            // Reset the linewidth
+            co.lineWidth    = 1;
+        }
+
+
+
+
+        /**
+        * The chart is now always registered
+        */
+        RG.Register(this);
+    }
\ No newline at end of file
diff --git a/mod/questionnaire/javascript/RGraph/license.txt b/mod/questionnaire/javascript/RGraph/license.txt
new file mode 100644
index 0000000..b17021a
--- /dev/null
+++ b/mod/questionnaire/javascript/RGraph/license.txt
@@ -0,0 +1,35 @@
+
+The RGraph license
+==================
+RGraph is free to use under the MIT license.
+
+Extended support
+================
+Free support is available at the link below. If your needs go beyond the free support though
+there is Extended Support available to subscribe to. You can read more about this on
+the support page.
+
+                         http://www.rgraph.net/support
+
+
+o-----------------------------------------------------------------------------------------o
+| Copyright (c) 2013 Richard Heyes http://www.rgraph.net                                  |
+|                                                                                         |
+| Permission is hereby granted, free of charge, to any person obtaining a copy            |
+| of this software and associated documentation files (the "Software"), to deal           |
+| in the Software without restriction, including without limitation the rights            |
+| to use, copy, modify, merge, publish, distribute, sublicense, and/or sell               |
+| copies of the Software, and to permit persons to whom the Software is                   |
+| furnished to do so, subject to the following conditions:                                |
+|                                                                                         |
+| The above copyright notice and this permission notice shall be included in              |
+| all copies or substantial portions of the Software.                                     |
+|                                                                                         |
+| THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR              |
+| IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                |
+| FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE             |
+| AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                  |
+| LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,           |
+| OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN               |
+| THE SOFTWARE.                                                                           |
+o-----------------------------------------------------------------------------------------o
\ No newline at end of file
diff --git a/mod/questionnaire/lang/en/questionnaire.php b/mod/questionnaire/lang/en/questionnaire.php
new file mode 100644
index 0000000..8ea0f49
--- /dev/null
+++ b/mod/questionnaire/lang/en/questionnaire.php
@@ -0,0 +1,556 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Strings for component 'questionnaire', language 'en', branch 'MOODLE_24_STABLE'
+ *
+ * @package    mod
+ * @subpackage quiz
+ * @copyright  1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+$string['action'] = 'Action';
+$string['activityoverview'] = 'You have questionnaires that are due';
+$string['additionalinfo'] = 'Additional Info';
+$string['additionalinfo_help'] = 'Text to be displayed at the top of the first page of this questionnaire. (i.e. instructions, background info, etc.)';
+$string['addnewquestion'] = 'Adding {$a} question';
+$string['addquestions'] = 'Add questions';
+$string['addselqtype'] = 'Add selected question type';
+$string['alignment'] = 'Radio buttons Alignment';
+$string['alignment_help'] = 'Select buttons alignment: vertical (default) or horizontal.';
+$string['alignment_link'] = 'mod/questionnaire/questions#Radio_Buttons';
+$string['all'] = 'All';
+$string['alreadyfilled'] = 'You have already filled out this questionnaire for us{$a}. Thank you.';
+$string['andaveragevalues'] = 'and average values';
+$string['anonymous'] = 'Anonymous';
+$string['answerquestions'] = 'Answer the questions...';
+$string['attempted'] = 'This questionnaire has been submitted.';
+$string['attemptstillinprogress'] = 'In progress. Saved on:';
+$string['autonumbering'] = 'Auto numbering';
+$string['autonumbering_help'] = 'Automatic numbering of questions and pages. You might want to disable automatic numbering
+ for questionnaires with conditional branching.';
+$string['autonumberno'] = 'Do not number questions or pages';
+$string['autonumberquestions'] = 'Auto number questions';
+$string['autonumberpages'] = 'Auto number pages';
+$string['autonumberpagesandquestions'] = 'Auto number pages and questions';
+$string['average'] = 'Average';
+$string['averagerank'] = 'Average rank';
+$string['averageposition'] = 'Average position';
+$string['bodytext'] = 'Body text';
+$string['boxesnbexact'] = 'exactly {$a} box(es).';
+$string['boxesnbmax'] = 'a maximum of {$a} box(es).';
+$string['boxesnbmin'] = 'a minimum of {$a} box(es).';
+$string['boxesnbreq'] = 'For this question you must tick ';
+$string['by'] = ' by ';
+$string['missingname'] = 'Question {$a} cannot be used in this feedback section because it does not have a name.';
+$string['missingrequired'] = 'Question {$a} cannot be used in this feedback section because it is not required.';
+$string['missingnameandrequired'] = 'Question {$a} cannot be used in this feedback section because it does not have a name and it is not required.';
+$string['cannotviewpublicresponses'] = 'You cannot view responses to this public questionnaire.';
+$string['chart:bipolar'] = 'Bipolar bars';
+$string['chart:hbar'] = 'Horizontal bars';
+$string['chart:radar'] = 'Radar';
+$string['chart:rose'] = 'Rose';
+$string['chart:type'] = 'Chart type';
+$string['chart:type_help'] = 'Select the Chart type you want to use for this feedback';
+$string['chart:vprogress'] = 'Vertical Progress bar';
+$string['checkallradiobuttons'] = 'Please check <strong>{$a}</strong> radio buttons!';
+$string['checkboxes'] = 'Check Boxes';
+$string['checkboxes_help'] = 'Enter one option per line for the user to select one or multiple answers from. ';
+$string['checkboxes_link'] = 'mod/questionnaire/questions#Check_Boxes';
+$string['checkbreaksadded'] = 'New Page Break(s) inserted at position(s):';
+$string['checkbreaksok'] = 'All the required Page breaks are present!';
+$string['checkbreaksremoved'] = 'Removed {$a} extra Page break(s).';
+$string['checknotstarted'] = 'Select not started';
+$string['checkstarted'] = 'Select started';
+$string['clicktoswitch'] = '(click to switch)';
+$string['closed'] = 'The questionnaire was closed on {$a}. Thanks.';
+$string['closedate'] = 'Use Close Date';
+$string['closeson'] = 'Questionnaire closes on {$a}';
+$string['closedate_help'] = 'You can specify a date to close the questionnaire here. Check the check box, and select the date and time you want.
+ Users will not be able to fill out the questionnaire after that date. If this is not selected, it will never be closed.';
+$string['completionsubmit'] = 'Student must submit this questionnaire to complete it';
+$string['confalts'] = '- OR - <br />Confirmation page';
+$string['configusergraph'] = 'Display charts for "Personality Test" feedback';
+$string['configusergraphlong'] = 'Use the <a href="http://www.rgraph.net/">Rgraph</a> library to display "Personality Test" feedback charts.';
+$string['configmaxsections'] = 'Maximum feedback sections';
+$string['confirmdelallresp'] = 'Are you sure you want to delete ALL the responses in this questionnaire?';
+$string['confirmdelchildren'] = 'If you delete this question, its child(ren) question(s) will also be deleted:';
+$string['confirmdelgroupresp'] = 'Are you sure you want to delete ALL the responses of {$a}?';
+$string['confirmdelquestion'] = 'Are you sure you want to delete the question at position {$a}?';
+$string['confirmdelquestionresps'] = 'This will also delete the {$a} response(s) already given to that question.';
+$string['confirmdelresp'] = 'Are you sure you want to delete the response by&nbsp;{$a}&nbsp;?';
+$string['confpage'] = 'Heading text';
+$string['confpage_help'] = 'Heading (in bold) and body text for the "Confirmation" page displayed after a user completes this questionnaire. (URL, if present, takes precedence over confirmation text.) If you leave this field empty, a default message will be displayed upon questionnaire completion (Thank you for completing this Questionnaire).';
+$string['confpagedesc'] = 'Heading (in bold) and body text for the &quot;Confirmation&quot; page displayed after a user completes this questionnaire. (URL, if present, takes precedence over confirmation text.)';
+$string['contentoptions'] = 'Content options';
+$string['couldnotdelresp'] = 'Could not delete response ';
+$string['couldnotcreatenewsurvey'] = 'Could not create a new survey!';
+$string['createcontent'] = 'Define New Content';
+$string['createcontent_help'] = 'Select one of the radio button options. \'Create new\' is the default.';
+$string['createcontent_link'] = 'mod/questionnaire/mod#Content_Options';
+$string['createnew'] = 'Create new';
+$string['date'] = 'Date';
+$string['date_help'] = 'Use this question type if you expect the response to be a correctly formatted date.';
+$string['date_link'] = 'mod/questionnaire/questions#Date';
+$string['dateformatting'] = 'Use the day/month/year format, e.g. for March 14th, 1945:&nbsp; <strong>14/3/1945</strong>';
+$string['deleteallresponses'] = 'Delete ALL Responses';
+$string['deletecurrentquestion'] = 'Delete question {$a}';
+$string['deletedallgroupresp'] = 'Deleted ALL Responses in group {$a}';
+$string['deletedallresp'] = 'Questionnaire responses deleted';
+$string['deletedisabled'] = 'This item cannot be deleted';
+$string['deletedresp'] = 'Deleted Response';
+$string['deleteresp'] = 'Delete this Response';
+$string['deletingresp'] = 'Deleting Response';
+$string['dependquestion'] = 'Parent Question';
+$string['dependquestion_help'] = 'You can select a parent question and a choice option for this question. A child question will only be displayed
+                to the student if its parent question and parent choice have been previously selected.';
+$string['dependquestion_link'] = 'mod/questionnaire/questions#Parent_Question';
+$string['displaymethod'] = 'Display method not defined for question.';
+$string['download'] = 'Download';
+$string['downloadtextformat'] = 'Download in text format';
+$string['downloadtextformat_help'] = 'This feature enables you to save all the responses of a questionnaire to a text file (CSV).
+ This file can then be imported into a spreadsheet (e.g. MS Excel or Open Office Calc) or a statistical package for further processing the data.';
+$string['downloadtextformat_link'] = 'mod/questionnaire/report#Download_in_text_format';
+$string['dropdown'] = 'Dropdown Box';
+$string['dropdown_help'] = 'There is no real advantage to using the Dropdown Box over using the Radio Buttons
+ except perhaps for longish lists of options, to save screen space.';
+$string['dropdown_link'] = 'mod/questionnaire/questions#Dropdown_Box';
+$string['edit'] = 'Edit';
+$string['editingquestionnaire'] = 'Editing Questionnaire Settings';
+$string['editquestion'] = 'Editing {$a} question';
+$string['email'] = 'Email';
+$string['errnewname'] = 'Sorry, name already in use. Pick a new name.';
+$string['erroropening'] = 'Error opening questionnaire.';
+$string['errortable'] = 'Error system table corrupt.';
+$string['essaybox'] = 'Essay Box';
+$string['essaybox_help'] = 'This question will display a plain text box with x Textarea columns (or area width) and y Textarea rows (number of text lines).
+
+If you leave both x and y to their default 0 value (or if you set it to 0), then moodle\'s HTML editor will be displayed
+ with standard height and width (if available in the course/user context & user profile). ';
+$string['event_all_responses_deleted'] = 'All Responses deleted';
+$string['event_all_responses_saved_as_text'] = 'All Responses saved as text';
+$string['event_all_responses_viewed'] = 'All Responses report viewed';
+$string['event_individual_responses_viewed'] = 'Individual Responses report viewed';
+$string['event_previewed'] = 'Questionnaire previewed';
+$string['event_non_respondents_viewed'] = 'Non-respondents viewed';
+$string['event_question_created'] = 'Question created';
+$string['event_question_deleted'] = 'Question deleted';
+$string['event_response_deleted'] = 'Individual Response deleted';
+$string['event_resumed'] = 'Attempt resumed';
+$string['event_saved'] = 'Responses saved';
+$string['event_submitted'] = 'Responses submitted';
+$string['feedback'] = 'Feedback';
+$string['feedback_help'] = 'Feedback Help';
+$string['feedback_link'] = 'mod/questionnaire/personality_test#Editing_Questionnaire_Feedback_Messages';
+$string['feedbackaddmorefeedbacks'] = 'Add {no} more feedback fields';
+$string['feedbackbysection'] = 'Sections Feedback';
+$string['feedbackeditingglobal'] = 'Editing Questionnaire Global Feedback';
+$string['feedbackeditingsections'] = 'Editing Questionnaire Feedback Sections';
+$string['feedbackeditingmessages'] = 'Editing Questionnaire Feedback Messages';
+$string['feedbackeditmessages'] = 'Save Sections settings and edit Feedback Messages';
+$string['feedbackeditsections'] = 'Save settings and edit Feedback Sections';
+$string['feedbackerrorboundaryformat'] = 'Feedback score boundaries must be either a percentage or a number. The value you entered in boundary {$a} is not recognised.';
+$string['feedbackerrorboundaryoutofrange'] = 'Feedback score boundaries must be between 0% and 100%. The value you entered in boundary {$a} is out of range.';
+$string['feedbackerrorjunkinboundary'] = 'You must fill in the feedback score boundary boxes without leaving any gaps.';
+$string['feedbackerrorjunkinfeedback'] = 'You must fill in the feedback boxes without leaving any gaps.';
+$string['feedbackerrororder'] = 'Feedback score boundaries must be in order, highest first. The value you entered in boundary {$a} is out of sequence.';
+$string['feedbackglobal'] = 'Global Feedback';
+$string['feedbackglobalmessages'] = 'Global Feedback messages';
+$string['feedbackglobalheading'] = 'Global Feedback heading';
+$string['feedbackheading'] = 'Feedback heading';
+$string['feedbackheading_help'] = 'In the feedback heading field you can use 2 variables: $scorepercent and $oppositescorepercent.';
+$string['feedbackmessages'] = 'Feedback messages for section {$a}';
+$string['feedbacknextsection'] = 'Next section {$a}';
+$string['feedbacknone'] = 'No Feedback messages';
+$string['feedbacknotes'] = 'Feedback notes';
+$string['feedbacknotes_help'] = 'Text entered here will be displayed to the respondents at the end of their Feedback Report';
+$string['feedbackoptions'] = 'Feedback options';
+$string['feedbackoptions_help'] = 'Feedback options are available if your questionnaire contains the following question types and question settings:
+Radio buttons; Dropdown box or Rate. Those questions must be set as Required, their Question Name field must NOT be empty and the Possible answers choices must contain a value.';
+$string['feedbackoptions_link'] = 'mod/questionnaire/personality_test';
+$string['feedbackremovequestionfromsection'] = 'This question is part of feedback section [{$a}]';
+$string['feedbackremovesection'] = 'Removing this question will completely remove feedback section [{$a}]';
+$string['feedbackreport'] = 'Feedback Report';
+$string['feedbackscore'] = 'Feedback Score';
+$string['feedbackscores'] = 'Display Scores';
+$string['feedbackscores_help'] = 'Display the table of feedback scores';
+$string['feedbackscoreboundary'] = 'Feedback Score boundary';
+$string['feedbacksectionlabel'] = 'Label';
+$string['feedbacksectionlabel_help'] = 'This label will be used in the charts/diagrams. Please keep it as short as possible!';
+$string['feedbacksectionheading'] = 'Feedback heading for section {$a}';
+$string['feedbacksectionheadingmissing'] = 'You must enter a Heading for this Feedback section!';
+$string['feedbacksectionheadingtext'] = 'Heading';
+$string['feedbackhdr'] = 'Feedbacks';
+$string['feedbacksection'] = 'Section';
+$string['feedbacksections'] = '{$a} Feedback sections';
+$string['feedbacksectionsselect'] = 'Sections';
+$string['feedbacksectionsselect_help'] = 'Place your questions into those Sections';
+$string['feedbacksectionsselect_link'] = 'mod/questionnaire/personality_test#Editing_Questionnaire_Feedback_Sections_2';
+$string['feedbacksettingssaved'] = 'Feedback settings saved';
+$string['feedbacktype'] = 'Feedback type';
+$string['field'] = 'Question {$a}';
+$string['fieldlength'] = 'Input box length';
+$string['fieldlength_help'] = 'For the **Text Box** question type, enter the **Input Box length** and the **Maximum text length** of text to be entered by
+respondent.
+
+Default values are 20 characters for the Input Box width and 25 characters for the maximum length of text entered.';
+$string['finished'] = 'You have answered all the questions in this questionnaire!';
+$string['firstrespondent'] = 'First Respondent';
+$string['formateditor'] = 'HTML editor';
+$string['formatplain'] = 'Plain text';
+$string['grade'] = 'Submission grade';
+$string['gradesdeleted'] = 'Questionnaire grades deleted';
+$string['headingtext'] = 'Heading text';
+$string['horizontal'] = 'Horizontal';
+$string['id'] = 'ID';
+$string['includechoicecodes'] = 'Include choice codes';
+$string['includechoicetext'] = 'Include choice text';
+$string['incorrectcourseid'] = 'Course ID is incorrect';
+$string['incorrectmodule'] = 'Course Module ID was incorrect';
+$string['incorrectquestionnaire'] = 'Questionnaire is incorrect';
+$string['invalidresponse'] = 'Invalid response specified.';
+$string['invalidresponserecord'] = 'Invalid response record specified.';
+$string['invalidsurveyid'] = 'Invalid questionnaire ID.';
+$string['kindofratescale'] = 'Type of rate scale';
+$string['kindofratescale_help'] = 'Right-click on the More Help link below.';
+$string['kindofratescale_link'] = 'mod/questionnaire/questions#Type_of_rate_scale';
+$string['lastrespondent'] = 'Last Respondent';
+$string['length'] = 'Length';
+$string['managequestions'] = 'Manage questions';
+$string['managequestions_help'] = 'In the Manage questions section of the Edit Questions page, you can conduct a number of operations on a Questionnaire\'s questions.';
+$string['managequestions_link'] = 'mod/questionnaire/questions#Manage_questions';
+$string['maxdigitsallowed'] = 'Max. digits allowed';
+$string['maxdigitsallowed_help'] = 'Use **Max. digits allowed** to set a limit to the number of characters entered for a Numeric question. Note that the
+decimal point also counts as one character!';
+$string['maxdigitsallowed_link'] = 'mod/questionnaire/questions#Numeric';
+$string['maxforcedresponses'] = 'Max. forced responses';
+$string['maxforcedresponses_help'] = 'Use these parameters to force respondent to tick a minimum of **Min.** boxes and a maximum of **Max.** check boxes. To
+force an exact number of check boxes to be ticked, set **Min.** and **Max.** to the same value. If only a min or a max value is desired, just leave the other
+value to its default **0** value. If you set **Min.** or **Max.** to values other than their default **0** value, a warning message will be displayed if
+respondent does not comply with your requirements. Obviously you should make any requirements clear to the respondent either in the general instructions of
+your Questionnaire or in the text of relevant questions.';
+$string['maxtextlength'] = 'Max. text length';
+$string['maxtextlength_help'] = 'For the Text Box question type, enter the Input Box length and the Maximum text length of text to be entered by respondent.
+Default values are 20 characters for the Input Box width and 25 characters for the maximum length of text entered.';
+$string['messageprovider:message'] = 'Questionnaire reminder';
+$string['messageprovider:notification'] = 'Questionnaire submission';
+$string['minforcedresponses'] = 'Min. forced responses';
+$string['minforcedresponses_help'] = 'Use these parameters to force respondent to tick a minimum of **Min.** boxes and a maximum of **Max.** check boxes. To
+force an exact number of check boxes to be ticked, set **Min.** and **Max.** to the same value. If only a min or a max value is desired, just leave the other
+value to its default **0** value. If you set **Min.** or **Max.** to values other than their default **0** value, a warning message will be displayed if
+respondent does not comply with your requirements. Obviously you should make any requirements clear to the respondent either in the general instructions of
+your Questionnaire or in the text of relevant questions.';
+$string['misconfigured'] = 'Course is misconfigured';
+$string['missingquestion'] = 'Please answer Required question ';
+$string['missingquestions'] = 'Please answer Required questions: ';
+$string['modulename'] = 'Questionnaire';
+$string['modulename_help'] = 'The questionnaire module allows you to construct surveys using a variety of question types, for the purpose of gathering data from users.';
+$string['modulenameplural'] = 'Questionnaires';
+$string['movedisabled'] = 'This item cannot be moved';
+$string['myresponses'] = 'All your responses';
+$string['myresponsetitle'] = 'Your {$a} response(s)';
+$string['myresults'] = 'Your Results';
+$string['name'] = 'Name';
+$string['navigate'] = 'Allow branching questions';
+$string['navigate_help'] = 'Enable Yes/No and Radio Buttons questions to have Child questions dependent on their choices in your questionnaire.';
+$string['navigate_link'] = 'mod/questionnaire/conditional_branching';
+$string['next'] = 'Next';
+$string['nextpage'] = 'Next Page';
+$string['nlines'] = '{$a} lines';
+$string['noanswer'] = 'No answer';
+$string['noattempts'] = 'No attempts have been made on this questionnaire';
+$string['nodata'] = 'No data posted.';
+$string['noduplicates'] = 'No duplicate choices';
+$string['noduplicateschoiceserror'] = 'You must enter at least 2 Possible answers for the "No duplicate choices" option!';
+$string['notenoughscaleitems'] = 'You must enter a minimum value of 2 scale items!';
+$string['noneinuse'] = 'This questionnaire does not contain any questions.';
+$string['non_respondents'] = 'Users who have not yet submitted their responses to this questionnaire';
+$string['nopublicsurveys'] = 'No public questionnaires.';
+$string['noresponsedata'] = 'No responses for this question.';
+$string['noresponses'] = 'No responses';
+$string['normal'] = 'Normal';
+$string['notanumber'] = '<strong>{$a}</strong> is not an accepted number format.';
+$string['notapplicable'] = 'N/A';
+$string['notapplicablecolumn'] = 'N/A column';
+$string['notavail'] = 'This questionnaire is no longer available. Ask your teacher to delete it.';
+$string['noteligible'] = 'You are not eligible to take this questionnaire.';
+$string['notemplatesurveys'] = 'No template questionnaires.';
+$string['notifications'] = 'Send submission notifications';
+$string['notifications_help'] = 'Notify roles with the "mod/questionnaire:submissionnotification" capability when a submission is made.';
+$string['notifications_link'] = 'mod/questionnaire/mod#Submission_Notifications';
+$string['notopen'] = 'This questionnaire will not open until {$a}.';
+$string['notrequired'] = 'Response is not required';
+$string['not_started'] = 'not started';
+$string['nousersselected'] = 'No users selected';
+$string['num'] = '#';
+$string['numattemptsmade'] = '{$a} attempts made on this questionnaire';
+$string['numberfloat'] = 'The number you entered <strong>{$a->number}</strong> has been reformatted/rounded with <strong>{$a->precision}</strong> decimal place(s).';
+$string['numberofdecimaldigits'] = 'Nb of decimal digits';
+$string['numberofdecimaldigits_help'] = 'Use **Nb of decimal digits** to specify the format of the Average value counted and displayed at the Questionnaire Report page.';
+$string['numberofdecimaldigits_link'] = 'mod/questionnaire/questions#Numeric';
+$string['numberscaleitems'] = 'Nb of scale items';
+$string['numberscaleitems_help'] = 'Nb of scale items is the *number of items* to be used in your rate scale. You would normally use a value of 3 to 5. Default value: **5**.';
+$string['numeric'] = 'Numeric';
+$string['numeric_help'] = 'Use this question type if you expect the response to be a correctly formatted number.';
+$string['of'] = 'of';
+$string['opendate'] = 'Use Open Date';
+$string['opendate_help'] = 'You can specify a date to open the questionnaire here. Check the check box, and select the date and time you want.
+ Users will not be able to fill out the questionnaire before that date. If this is not selected, it will be open immediately.';
+$string['option'] = 'option {$a}';
+$string['optionalname'] = 'Question Name';
+$string['optionalname_help'] = 'The Question Name is only used when you export responses to CSV/Excel format.
+ If you never export to CSV, then you needn\'t worry about Question names at all.
+ If you plan to regularly export your questionnaire data to CSV, then you have a choice of two options for question naming. ';
+$string['optionalname_link'] = 'mod/questionnaire/questions#Question_Name';
+$string['or'] = '- OR -';
+$string['order_ascending'] = 'Ascending order';
+$string['order_default'] = 'View Default order';
+$string['order_descending'] = 'Descending order';
+$string['orderresponses'] = 'Order Responses';
+$string['orderresponses_help'] = 'When displaying All Responses you can order the choices by number of responses (the Average column) for the following
+ 4 types of questions.
+
+* single choices radio button
+* single choices dropdown list
+* multiple choices (check boxes)
+* rate questions (including Likert scales).
+
+When you arrive on the All Responses page, by default all responses are ordered in the order that the questionnaire creator entered the question choices.
+ You can choose to order them by ascending or descending order.';
+$string['orderresponses_link'] = 'mod/questionnaire/report#Order_Responses';
+$string['osgood'] = 'Osgood';
+$string['other'] = 'Other:';
+$string['otherempty'] = 'If you tick this choice you must enter some text in the text box!';
+$string['overviewnumresplog'] = 'responses';
+$string['overviewnumresplog1'] = 'response';
+$string['overviewnumrespvw'] = 'responses';
+$string['overviewnumrespvw1'] = 'response';
+$string['owner'] = 'Owner';
+$string['page'] = 'Page';
+$string['pageof'] = 'Page {$a->page} of {$a->totpages}';
+$string['participant'] = 'Participant';
+$string['pleasecomplete'] = 'Please complete this choice.';
+$string['pluginadministration'] = 'Questionnaire administration';
+$string['pluginname'] = 'Questionnaire';
+$string['position'] = 'position';
+$string['possibleanswers'] = 'Possible answers';
+$string['posteddata'] = 'Reached page with posted data:';
+$string['preview_label'] = 'Preview';
+$string['preview_questionnaire'] = 'Questionnaire Preview';
+$string['previewing'] = ' Previewing Questionnaire ';
+$string['previous'] = 'Previous';
+$string['previouspage'] = 'Previous Page';
+$string['print'] = 'Print this Response';
+$string['printblank'] = 'Print Blank';
+$string['printblanktooltip'] = 'Opens printer-friendly window with blank Questionnaire';
+$string['printtooltip'] = 'Opens printer-friendly window with current Response';
+$string['private'] = 'Private';
+$string['public'] = 'Public';
+$string['publiccopy'] = 'Copy:';
+$string['publicoriginal'] = 'Original:';
+$string['qtype'] = 'Type';
+$string['qtype_help'] = 'Select whether users will be allowed to respond once, daily, weekly, monthly or an unlimited number of times (many).';
+$string['qtypedaily'] = 'respond daily';
+$string['qtypemonthly'] = 'respond monthly';
+$string['qtypeonce'] = 'respond once';
+$string['qtypeunlimited'] = 'respond many';
+$string['qtypeweekly'] = 'respond weekly';
+$string['questionnaire:addinstance'] = 'Add a new questionnaire';
+$string['questionnaire:copysurveys'] = 'Copy template and private questionnaires';
+$string['questionnaire:createpublic'] = 'Create public questionnaires';
+$string['questionnaire:createtemplates'] = 'Create template questionnaires';
+$string['questionnaire:deleteresponses'] = 'Delete any response';
+$string['questionnaire:downloadresponses'] = 'Download responses in a CSV file';
+$string['questionnaire:editquestions'] = 'Create and edit questionnaire questions';
+$string['questionnaire:manage'] = 'Create and edit questionnaires';
+$string['questionnaire:message'] = 'Send message to non-respondents';
+$string['questionnaire:preview'] = 'Preview questionnaires';
+$string['questionnaire:printblank'] = 'Print blank questionnaire';
+$string['questionnaire:readallresponseanytime'] = 'Read all responses any time';
+$string['questionnaire:readallresponses'] = 'Read response summaries, subject to open times';
+$string['questionnaire:readownresponses'] = 'Read own responses';
+$string['questionnaire:submissionnotification'] = 'Receive notification for each submission';
+$string['questionnaire:submit'] = 'Complete and submit a questionnaire';
+$string['questionnaire:view'] = 'View a questionnaire';
+$string['questionnaire:viewsingleresponse'] = 'View complete individual responses';
+$string['questionnaireadministration'] = 'Questionnaire Administration';
+$string['questionnairecloses'] = 'Questionnaire Closes';
+$string['questionnaireopens'] = 'Questionnaire Opens';
+$string['questionnairereport'] = 'Questionnaire Report';
+$string['questionnum'] = 'Question #';
+$string['questions'] = 'Questions';
+$string['questionsinsection'] = 'Questions in this section:';
+$string['questiontypes'] = 'Question types';
+$string['questiontypes_help'] = 'See the Moodle Documentation below';
+$string['questiontypes_link'] = 'mod/questionnaire/questions#Question_Types';
+$string['radiobuttons'] = 'Radio Buttons';
+$string['radiobuttons_help'] = 'In this question type, the respondent must select one out of the choices offered.';
+$string['radiobuttons_link'] = 'mod/questionnaire/questions#Radio_Buttons';
+$string['rank'] = 'Rank';
+$string['ratescale'] = 'Rate (scale 1..5)';
+$string['ratescale_help'] = 'See the Moodle Documentation below';
+$string['ratescale_link'] = 'mod/questionnaire/questions#Rate_.28scale_1..5.29';
+$string['realm'] = 'Questionnaire Type';
+$string['realm_help'] = '* **There are  three types of questionnaires:**
+ * Private - belongs to the course it is defined in only.
+ * Template - can be copied and edited.
+ * Public - can be shared among courses.';
+$string['realm_link'] = 'mod/questionnaire/qsettings#Questionnaire_Type';
+$string['redirecturl'] = 'The URL to which a user is redirected after completing this questionnaire.';
+$string['remove'] = 'Delete';
+$string['removenotinuse'] = 'This questionnaire used to depend on a Public questionnaire which has been deleted.
+It can no longer be used and should be deleted.';
+$string['required'] = 'Response is required';
+$string['required_help'] = 'If you select ***Yes***, response to this question will be required, i.e.
+the respondent will not be able to submit the questionnaire
+until this question has been answered.';
+$string['required_link'] = 'mod/questionnaire/questions#Response_Required';
+$string['requiredparameter'] = 'A required parameter was missing.';
+$string['reset'] = 'Reset';
+$string['removeallquestionnaireattempts'] = 'Delete all questionnaire responses';
+$string['respeligiblerepl'] = '(replaced by role overrides)';
+$string['respondent'] = 'Respondent';
+$string['respondenteligibleall'] = 'all';
+$string['respondenteligiblestudents'] = 'students only';
+$string['respondenteligibleteachers'] = 'teachers only';
+$string['respondents'] = 'Respondents';
+$string['respondenttype'] = 'Respondent Type';
+$string['respondenttype_help'] = 'You can display your users\' full names with each response by setting this to "fullname".
+You can hide your users\' identities from the responses by setting this to "anonymous".';
+$string['respondenttype_link'] = 'mod/questionnaire/mod#Respondent_Type';
+$string['respondenttypeanonymous'] = 'anonymous';
+$string['respondenttypefullname'] = 'fullname';
+$string['response'] = 'Response';
+$string['responsefieldlines'] = 'Input box size';
+$string['responseformat'] = 'Response format';
+$string['responseoptions'] = 'Response options';
+$string['responses'] = 'Responses';
+$string['responseview'] = 'Students can view ALL responses';
+$string['responseview_help'] = 'You can specify who can see the responses of all respondents to submitted questionnaires (general statistics tables).';
+$string['responseview_link'] = 'mod/questionnaire/mod#Response_viewing';
+$string['responseviewstudentsalways'] = 'Always';
+$string['responseviewstudentsnever'] = 'Never';
+$string['responseviewstudentswhenanswered'] = 'After answering the questionnaire';
+$string['responseviewstudentswhenclosed'] = 'After the questionnaire is closed';
+$string['restrictedtoteacher'] = 'These functions are restricted to editing teachers only!';
+$string['resume'] = 'Save/Resume answers';
+$string['resume_help'] = 'Setting this option allows users to save their answers to a questionnaire before submitting them.
+ Users can leave the questionnaire unfinished and resume from the save point at a later date.';
+$string['resume_link'] = 'mod/questionnaire/mod#Save/Resume_answers';
+$string['resumesurvey'] = 'Resume questionnaire';
+$string['return'] = 'Return';
+$string['save'] = 'Save';
+$string['saveasnew'] = 'Save as New Question';
+$string['savedbutnotsubmitted'] = 'This questionnaire has been saved but not yet submitted.';
+$string['savedprogress'] = 'Your progress has been saved.  You may return at any time to complete this questionnaire.';
+$string['saveeditedquestion'] = 'Save question {$a}';
+$string['savesettings'] = 'Save settings';
+$string['search:activity'] = 'Questionnaire - activity information';
+$string['search:question'] = 'Questionnaire - questions';
+$string['section'] = 'Description';
+$string['sectionbreak'] = '----- Page Break -----';
+$string['sectionbreak_help'] = '----- Page Break -----';
+$string['sectionsnotset'] = 'You must select at least ONE question per section!<br />Section(s) not selected: {$a}';
+$string['sectiontext'] = 'Label';
+$string['sectiontext_help'] = 'This is not a question but a (short) text which will be displayed to introduce a series of questions.';
+$string['selecttheme'] = 'Select a theme (css) to use with this questionnaire.';
+$string['send'] = 'Send';
+$string['sendemail'] = 'Send email';
+$string['send_message'] = 'Send message to selected users';
+$string['send_message_to'] = 'Send message to:';
+$string['sendemail_help'] = 'Sends a copy of each submission to the specified address or addresses.
+You can provide more than one address by separating them with commas.
+Leave blank for no email backup.';
+$string['settings'] = 'Settings';
+$string['settingssaved'] = 'Settings saved';
+$string['show_nonrespondents'] = 'Non-respondents';
+$string['started'] = 'started';
+$string['strfdate'] = '%d/%m/%Y';
+$string['strfdateformatcsv'] = 'd/m/Y H:i:s';
+$string['submissionnotificationhtmlanon'] = 'There is a new <a href="{$a->submissionurl}">submission</a> to the "{$a->name}" questionnaire.';
+$string['submissionnotificationhtmluser'] = 'There is a new <a href="{$a->submissionurl}">submission</a> to the "{$a->name}" questionnaire from "<a href="{$a->profileurl}">{$a->username}</a>".';
+$string['submissionnotificationsubject'] = 'New questionnaire submission';
+$string['submissionnotificationtextanon'] = 'There is a new submission ({$a->submissionurl}) to the "{$a->name}" questionnaire.';
+$string['submissionnotificationtextuser'] = 'There is a new submission ({$a->submissionurl}) to the "{$a->name}" questionnaire from "{$a->username}" ({$a->profileurl}).';
+$string['submitoptions'] = 'Submission options';
+$string['submitpreview'] = 'Submit preview';
+$string['submitpreviewcorrect'] = 'This submission would be accepted as correctly filled in.';
+$string['submitsurvey'] = 'Submit questionnaire';
+$string['submitted'] = 'Submitted on:';
+$string['subtitle'] = 'Subtitle';
+$string['subtitle_help'] = 'Subtitle of this questionnaire. Appears below the title on the first page only.';
+$string['subject'] = 'Subject';
+$string['summary'] = 'Summary';
+$string['surveynotexists'] = 'questionnaire does not exist.';
+$string['surveyowner'] = 'You must be a questionnaire owner to perform this operation.';
+$string['surveyresponse'] = 'Response from questionnaire';
+$string['template'] = 'Template';
+$string['templatenotviewable'] = 'Template questionnaires are not viewable.';
+$string['text'] = 'Question Text';
+$string['textareacolumns'] = 'Textarea columns';
+$string['textareacolumns_help'] = 'This question will display a plain text box with **x** *Textarea columns* (or area *width*) and **y** *Textarea rows* (number of text
+*lines*).
+If you leave both x and y to their default **0** value (or if you set it to **0**), then HTML editor will be displayed with standard height and width (if
+available in the course/user context &amp; user profile).';
+$string['textarearows'] = 'Textarea rows';
+$string['textbox'] = 'Text Box';
+$string['textbox_help'] = 'For the Text Box question type, enter the Input Box length and the Maximum text length of text to be entered by respondent.
+Default values are 20 characters for the Input Box width and 25 characters for the maximum length of text entered.';
+$string['textdownloadoptions'] = 'Options for text download (CSV)';
+$string['thank_head'] = 'Thank you for completing this Questionnaire.';
+$string['theme'] = 'Theme';
+$string['thismonth'] = 'this month';
+$string['thisresponse'] = 'This response';
+$string['thisweek'] = 'this week';
+$string['title'] = 'Title';
+$string['title_help'] = 'Title of this questionnaire, which will appear at the top of every page. By default Title is set to the questionnaire Name, but you can edit it as you like.';
+$string['today'] = 'today';
+$string['total'] = 'Total';
+$string['type'] = 'Question Type';
+$string['undefinedquestiontype'] = 'Undefined question type!';
+$string['unknown'] = 'Unknown';
+$string['unknownaction'] = 'Unknown questionnaire action specified...';
+$string['url'] = 'Confirmation URL';
+$string['url_help'] = 'The URL to which a user is redirected after completing this questionnaire.';
+$string['useprivate'] = 'Copy existing';
+$string['usepublic'] = 'Use public';
+$string['usetemplate'] = 'Use template';
+$string['vertical'] = 'Vertical';
+$string['view'] = 'View';
+$string['viewallresponses'] = 'View All Responses';
+$string['viewallresponses_help'] = 'If the questionnaire is set to **Group Mode**: *Visible groups*, or is set to *Separate groups* and the current user
+ has the *moodle/site:accessallgroups* capability (in the current context), and groups have been defined in the current course,
+ then the user has access to a dropdown list of groups. This dropdown list enables the user to "filter" the questionnaire responses by groups.
+ If the setting is **Group Mode**: *Separate groups*, then users who do not have the *moodle/site:accessallgroups* capability
+ (usually students, or non-editing teachers, etc.) will only be able to view the responses of the group(s) they belong to.';
+$string['viewallresponses_link'] = 'Viewing_Questionnaire_responses#Group_filtering';
+$string['viewbyresponse'] = 'List of responses';
+$string['viewindividualresponse'] = 'Individual responses';
+$string['viewindividualresponse_help'] = 'Click on the respondents\' names in the list below to view their individual responses.';
+$string['viewresponses'] = 'All responses ({$a})';
+$string['viewyourresponses'] = 'Your responses- view {$a}';
+$string['warning'] = 'Warning, error encountered.';
+$string['wronganswers'] = 'There is something wrong with your answers (see below)';
+$string['wrongdateformat'] = 'The date entered: <strong>{$a}</strong> does not correspond to the format shown in the example.';
+$string['wrongdaterange'] = 'ERROR! The year must be set in the 1902 to 2037 range.';
+$string['wrongformat'] = 'There is something wrong with your answer to question:&nbsp;';
+$string['wrongformats'] = 'There is something wrong with your answer to questions:&nbsp;';
+$string['yesno'] = 'Yes/No';
+$string['yesno_help'] = 'Simple Yes/No question.';
+$string['yourresponse'] = 'Your response';
+$string['yourresponses'] = 'Your responses';
+$string['crontask'] = 'Questionnaire cleanup job';
\ No newline at end of file
diff --git a/mod/questionnaire/lib.php b/mod/questionnaire/lib.php
new file mode 100644
index 0000000..4e37280
--- /dev/null
+++ b/mod/questionnaire/lib.php
@@ -0,0 +1,1158 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+// Library of functions and constants for module questionnaire.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+define('QUESTIONNAIRE_RESETFORM_RESET', 'questionnaire_reset_data_');
+define('QUESTIONNAIRE_RESETFORM_DROP', 'questionnaire_drop_questionnaire_');
+
+function questionnaire_supports($feature) {
+    switch($feature) {
+        case FEATURE_BACKUP_MOODLE2:
+            return true;
+        case FEATURE_COMPLETION_TRACKS_VIEWS:
+            return false;
+        case FEATURE_COMPLETION_HAS_RULES:
+            return true;
+        case FEATURE_GRADE_HAS_GRADE:
+            return false;
+        case FEATURE_GRADE_OUTCOMES:
+            return false;
+        case FEATURE_GROUPINGS:
+            return true;
+        case FEATURE_GROUPMEMBERSONLY:
+            return true;
+        case FEATURE_GROUPS:
+            return true;
+        case FEATURE_MOD_INTRO:
+            return true;
+        case FEATURE_SHOW_DESCRIPTION:
+            return true;
+
+        default:
+            return null;
+    }
+}
+
+/**
+ * @return array all other caps used in module
+ */
+function questionnaire_get_extra_capabilities() {
+    return array('moodle/site:accessallgroups');
+}
+
+function questionnaire_add_instance($questionnaire) {
+    // Given an object containing all the necessary data,
+    // (defined by the form in mod.html) this function
+    // will create a new instance and return the id number
+    // of the new instance.
+    global $DB, $CFG;
+    require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+    require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+    // Check the realm and set it to the survey if it's set.
+
+    if (empty($questionnaire->sid)) {
+        // Create a new survey.
+        $course = get_course($questionnaire->course);
+        $cm = new stdClass();
+        $qobject = new questionnaire(0, $questionnaire, $course, $cm);
+
+        if ($questionnaire->create == 'new-0') {
+            $sdata = new stdClass();
+            $sdata->name = $questionnaire->name;
+            $sdata->realm = 'private';
+            $sdata->title = $questionnaire->name;
+            $sdata->subtitle = '';
+            $sdata->info = '';
+            $sdata->theme = ''; // Theme is deprecated.
+            $sdata->thanks_page = '';
+            $sdata->thank_head = '';
+            $sdata->thank_body = '';
+            $sdata->email = '';
+            $sdata->feedbacknotes = '';
+            $sdata->courseid = $course->id;
+            if (!($sid = $qobject->survey_update($sdata))) {
+                print_error('couldnotcreatenewsurvey', 'questionnaire');
+            }
+        } else {
+            $copyid = explode('-', $questionnaire->create);
+            $copyrealm = $copyid[0];
+            $copyid = $copyid[1];
+            if (empty($qobject->survey)) {
+                $qobject->add_survey($copyid);
+                $qobject->add_questions($copyid);
+            }
+            // New questionnaires created as "use public" should not create a new survey instance.
+            if ($copyrealm == 'public') {
+                $sid = $copyid;
+            } else {
+                $sid = $qobject->sid = $qobject->survey_copy($course->id);
+                // All new questionnaires should be created as "private".
+                // Even if they are *copies* of public or template questionnaires.
+                $DB->set_field('questionnaire_survey', 'realm', 'private', array('id' => $sid));
+            }
+        }
+        $questionnaire->sid = $sid;
+    }
+
+    $questionnaire->timemodified = time();
+
+    // May have to add extra stuff in here.
+    if (empty($questionnaire->useopendate)) {
+        $questionnaire->opendate = 0;
+    }
+    if (empty($questionnaire->useclosedate)) {
+        $questionnaire->closedate = 0;
+    }
+
+    if ($questionnaire->resume == '1') {
+        $questionnaire->resume = 1;
+    } else {
+        $questionnaire->resume = 0;
+    }
+
+    if (!$questionnaire->id = $DB->insert_record("questionnaire", $questionnaire)) {
+        return false;
+    }
+
+    questionnaire_set_events($questionnaire);
+
+    return $questionnaire->id;
+}
+
+// Given an object containing all the necessary data,
+// (defined by the form in mod.html) this function
+// will update an existing instance with new data.
+function questionnaire_update_instance($questionnaire) {
+    global $DB, $CFG;
+    require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+    // Check the realm and set it to the survey if its set.
+    if (!empty($questionnaire->sid) && !empty($questionnaire->realm)) {
+        $DB->set_field('questionnaire_survey', 'realm', $questionnaire->realm, array('id' => $questionnaire->sid));
+    }
+
+    $questionnaire->timemodified = time();
+    $questionnaire->id = $questionnaire->instance;
+
+    // May have to add extra stuff in here.
+    if (empty($questionnaire->useopendate)) {
+        $questionnaire->opendate = 0;
+    }
+    if (empty($questionnaire->useclosedate)) {
+        $questionnaire->closedate = 0;
+    }
+
+    if ($questionnaire->resume == '1') {
+        $questionnaire->resume = 1;
+    } else {
+        $questionnaire->resume = 0;
+    }
+
+    // Get existing grade item.
+    questionnaire_grade_item_update($questionnaire);
+
+    questionnaire_set_events($questionnaire);
+
+    return $DB->update_record("questionnaire", $questionnaire);
+}
+
+// Given an ID of an instance of this module,
+// this function will permanently delete the instance
+// and any data that depends on it.
+function questionnaire_delete_instance($id) {
+    global $DB, $CFG;
+    require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+    if (! $questionnaire = $DB->get_record('questionnaire', array('id' => $id))) {
+        return false;
+    }
+
+    $result = true;
+
+    if (! $DB->delete_records('questionnaire', array('id' => $questionnaire->id))) {
+        $result = false;
+    }
+
+    if ($survey = $DB->get_record('questionnaire_survey', array('id' => $questionnaire->sid))) {
+        // If this survey is owned by this course, delete all of the survey records and responses.
+        if ($survey->courseid == $questionnaire->course) {
+            $result = $result && questionnaire_delete_survey($questionnaire->sid, $questionnaire->id);
+        }
+    }
+
+    if ($events = $DB->get_records('event', array("modulename" => 'questionnaire', "instance" => $questionnaire->id))) {
+        foreach ($events as $event) {
+            $event = calendar_event::load($event);
+            $event->delete();
+        }
+    }
+
+    return $result;
+}
+
+// Return a small object with summary information about what a
+// user has done with a given particular instance of this module
+// Used for user activity reports.
+// $return->time = the time they did it
+// $return->info = a short text description.
+/**
+ * $course and $mod are unused, but API requires them. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_user_outline($course, $user, $mod, $questionnaire) {
+    global $CFG;
+    require_once($CFG->dirroot . '/mod/questionnaire/locallib.php');
+
+    $result = new stdClass();
+    if ($responses = questionnaire_get_user_responses($questionnaire->sid, $user->id, true)) {
+        $n = count($responses);
+        if ($n == 1) {
+            $result->info = $n.' '.get_string("response", "questionnaire");
+        } else {
+            $result->info = $n.' '.get_string("responses", "questionnaire");
+        }
+        $lastresponse = array_pop($responses);
+        $result->time = $lastresponse->submitted;
+    } else {
+        $result->info = get_string("noresponses", "questionnaire");
+    }
+    return $result;
+}
+
+// Print a detailed representation of what a  user has done with
+// a given particular instance of this module, for user activity reports.
+/**
+ * $course and $mod are unused, but API requires them. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_user_complete($course, $user, $mod, $questionnaire) {
+    global $CFG;
+    require_once($CFG->dirroot . '/mod/questionnaire/locallib.php');
+
+    if ($responses = questionnaire_get_user_responses($questionnaire->sid, $user->id, false)) {
+        foreach ($responses as $response) {
+            if ($response->complete == 'y') {
+                echo get_string('submitted', 'questionnaire').' '.userdate($response->submitted).'<br />';
+            } else {
+                echo get_string('attemptstillinprogress', 'questionnaire').' '.userdate($response->submitted).'<br />';
+            }
+        }
+    } else {
+        print_string('noresponses', 'questionnaire');
+    }
+
+    return true;
+}
+
+// Given a course and a time, this module should find recent activity
+// that has occurred in questionnaire activities and print it out.
+// Return true if there was output, or false is there was none.
+/**
+ * $course, $isteacher and $timestart are unused, but API requires them. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_print_recent_activity($course, $isteacher, $timestart) {
+    return false;  // True if anything was printed, otherwise false.
+}
+
+// Must return an array of grades for a given instance of this module,
+// indexed by user.  It also returns a maximum allowed grade.
+/**
+ * $questionnaireid is unused, but API requires it. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_grades($questionnaireid) {
+    return null;
+}
+
+/**
+ * Return grade for given user or all users.
+ *
+ * @param int $questionnaireid id of assignment
+ * @param int $userid optional user id, 0 means all users
+ * @return array array of grades, false if none
+ */
+function questionnaire_get_user_grades($questionnaire, $userid=0) {
+    global $DB;
+    $params = array();
+    $usersql = '';
+    if (!empty($userid)) {
+        $usersql = "AND u.id = ?";
+        $params[] = $userid;
+    }
+
+    $sql = "SELECT a.id, u.id AS userid, r.grade AS rawgrade, r.submitted AS dategraded, r.submitted AS datesubmitted
+            FROM {user} u, {questionnaire_attempts} a, {questionnaire_response} r
+            WHERE u.id = a.userid AND a.qid = $questionnaire->id AND r.id = a.rid $usersql";
+    return $DB->get_records_sql($sql, $params);
+}
+
+/**
+ * Update grades by firing grade_updated event
+ *
+ * @param object $assignment null means all assignments
+ * @param int $userid specific user only, 0 mean all
+ *
+ * $nullifnone is unused, but API requires it. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_update_grades($questionnaire=null, $userid=0, $nullifnone=true) {
+    global $CFG, $DB;
+
+    if (!function_exists('grade_update')) { // Workaround for buggy PHP versions.
+        require_once($CFG->libdir.'/gradelib.php');
+    }
+
+    if ($questionnaire != null) {
+        if ($graderecs = questionnaire_get_user_grades($questionnaire, $userid)) {
+            $grades = array();
+            foreach ($graderecs as $v) {
+                if (!isset($grades[$v->userid])) {
+                    $grades[$v->userid] = new stdClass();
+                    if ($v->rawgrade == -1) {
+                        $grades[$v->userid]->rawgrade = null;
+                    } else {
+                        $grades[$v->userid]->rawgrade = $v->rawgrade;
+                    }
+                    $grades[$v->userid]->userid = $v->userid;
+                } else if (isset($grades[$v->userid]) && ($v->rawgrade > $grades[$v->userid]->rawgrade)) {
+                    $grades[$v->userid]->rawgrade = $v->rawgrade;
+                }
+            }
+            questionnaire_grade_item_update($questionnaire, $grades);
+        } else {
+            questionnaire_grade_item_update($questionnaire);
+        }
+
+    } else {
+        $sql = "SELECT q.*, cm.idnumber as cmidnumber, q.course as courseid
+                  FROM {questionnaire} q, {course_modules} cm, {modules} m
+                 WHERE m.name='questionnaire' AND m.id=cm.module AND cm.instance=q.id";
+        if ($rs = $DB->get_recordset_sql($sql)) {
+            foreach ($rs as $questionnaire) {
+                if ($questionnaire->grade != 0) {
+                    questionnaire_update_grades($questionnaire);
+                } else {
+                    questionnaire_grade_item_update($questionnaire);
+                }
+            }
+            $rs->close();
+        }
+    }
+}
+
+/**
+ * Create grade item for given questionnaire
+ *
+ * @param object $questionnaire object with extra cmidnumber
+ * @param mixed optional array/object of grade(s); 'reset' means reset grades in gradebook
+ * @return int 0 if ok, error code otherwise
+ */
+function questionnaire_grade_item_update($questionnaire, $grades = null) {
+    global $CFG;
+    if (!function_exists('grade_update')) { // Workaround for buggy PHP versions.
+        require_once($CFG->libdir.'/gradelib.php');
+    }
+
+    if (!isset($questionnaire->courseid)) {
+        $questionnaire->courseid = $questionnaire->course;
+    }
+
+    if ($questionnaire->cmidnumber != '') {
+        $params = array('itemname' => $questionnaire->name, 'idnumber' => $questionnaire->cmidnumber);
+    } else {
+        $params = array('itemname' => $questionnaire->name);
+    }
+
+    if ($questionnaire->grade > 0) {
+        $params['gradetype'] = GRADE_TYPE_VALUE;
+        $params['grademax']  = $questionnaire->grade;
+        $params['grademin']  = 0;
+
+    } else if ($questionnaire->grade < 0) {
+        $params['gradetype'] = GRADE_TYPE_SCALE;
+        $params['scaleid']   = -$questionnaire->grade;
+
+    } else if ($questionnaire->grade == 0) { // No Grade..be sure to delete the grade item if it exists.
+        $grades = null;
+        $params = array('deleted' => 1);
+
+    } else {
+        $params = null; // Allow text comments only.
+    }
+
+    if ($grades === 'reset') {
+        $params['reset'] = true;
+        $grades = null;
+    }
+
+    return grade_update('mod/questionnaire', $questionnaire->courseid, 'mod', 'questionnaire',
+                    $questionnaire->id, 0, $grades, $params);
+}
+
+/**
+ * This function returns if a scale is being used by one questionnaire
+ * it it has support for grading and scales. Commented code should be
+ * modified if necessary. See forum, glossary or journal modules
+ * as reference.
+ * @param $questionnaireid int
+ * @param $scaleid int
+ * @return boolean True if the scale is used by any questionnaire
+ *
+ * Function parameters are unused, but API requires them. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_scale_used ($questionnaireid, $scaleid) {
+    return false;
+}
+
+/**
+ * Checks if scale is being used by any instance of questionnaire
+ *
+ * This is used to find out if scale used anywhere
+ * @param $scaleid int
+ * @return boolean True if the scale is used by any questionnaire
+ *
+ * Function parameters are unused, but API requires them. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_scale_used_anywhere($scaleid) {
+    return false;
+}
+
+/**
+ * Serves the questionnaire attachments. Implements needed access control ;-)
+ *
+ * @param object $course
+ * @param object $cm
+ * @param object $context
+ * @param string $filearea
+ * @param array $args
+ * @param bool $forcedownload
+ * @return bool false if file not found, does not return if found - justsend the file
+ *
+ * $forcedownload is unused, but API requires it. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
+    global $DB;
+
+    if ($context->contextlevel != CONTEXT_MODULE) {
+        return false;
+    }
+
+    require_course_login($course, true, $cm);
+
+    $fileareas = array('intro', 'info', 'thankbody', 'question', 'feedbacknotes');
+    if (!in_array($filearea, $fileareas)) {
+        return false;
+    }
+
+    $componentid = (int)array_shift($args);
+
+    if ($filearea != 'question') {
+        if (!$DB->record_exists('questionnaire_survey', array('id' => $componentid))) {
+            return false;
+        }
+    } else {
+        if (!$DB->record_exists('questionnaire_question', array('id' => $componentid))) {
+            return false;
+        }
+    }
+
+    if (!$DB->record_exists('questionnaire', array('id' => $cm->instance))) {
+        return false;
+    }
+
+    $fs = get_file_storage();
+    $relativepath = implode('/', $args);
+    $fullpath = "/$context->id/mod_questionnaire/$filearea/$componentid/$relativepath";
+    if (!($file = $fs->get_file_by_hash(sha1($fullpath))) || $file->is_directory()) {
+        return false;
+    }
+
+    // Finally send the file.
+    send_stored_file($file, 0, 0, true); // Download MUST be forced - security!
+}
+/**
+ * Adds module specific settings to the settings block
+ *
+ * @param settings_navigation $settings The settings navigation object
+ * @param navigation_node $questionnairenode The node to add module settings to
+ *
+ * $settings is unused, but API requires it. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_extend_settings_navigation(settings_navigation $settings,
+        navigation_node $questionnairenode) {
+
+    global $PAGE, $DB, $USER, $CFG;
+    $individualresponse = optional_param('individualresponse', false, PARAM_INT);
+    $rid = optional_param('rid', false, PARAM_INT); // Response id.
+    $currentgroupid = optional_param('group', 0, PARAM_INT); // Group id.
+
+    require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+    $context = $PAGE->cm->context;
+    $cmid = $PAGE->cm->id;
+    $cm = $PAGE->cm;
+    $course = $PAGE->course;
+
+    if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $cm->instance))) {
+        print_error('invalidcoursemodule');
+    }
+
+    $courseid = $course->id;
+    $questionnaire = new questionnaire(0, $questionnaire, $course, $cm);
+
+    if ($owner = $DB->get_field('questionnaire_survey', 'courseid', ['id' => $questionnaire->sid])) {
+        $owner = (trim($owner) == trim($courseid));
+    } else {
+        $owner = true;
+    }
+
+    // On view page, currentgroupid is not yet sent as an optional_param, so get it.
+    $groupmode = groups_get_activity_groupmode($cm, $course);
+    if ($groupmode > 0 && $currentgroupid == 0) {
+        $currentgroupid = groups_get_activity_group($questionnaire->cm);
+        if (!groups_is_member($currentgroupid, $USER->id)) {
+            $currentgroupid = 0;
+        }
+    }
+
+    // We want to add these new nodes after the Edit settings node, and before the
+    // Locally assigned roles node. Of course, both of those are controlled by capabilities.
+    $keys = $questionnairenode->get_children_key_list();
+    $beforekey = null;
+    $i = array_search('modedit', $keys);
+    if (($i === false) && array_key_exists(0, $keys)) {
+        $beforekey = $keys[0];
+    } else if (array_key_exists($i + 1, $keys)) {
+        $beforekey = $keys[$i + 1];
+    }
+
+    if (has_capability('mod/questionnaire:manage', $context) && $owner) {
+        $url = '/mod/questionnaire/qsettings.php';
+        $node = navigation_node::create(get_string('advancedsettings'),
+            new moodle_url($url, array('id' => $cmid)),
+            navigation_node::TYPE_SETTING, null, 'advancedsettings',
+            new pix_icon('t/edit', ''));
+        $questionnairenode->add_node($node, $beforekey);
+    }
+
+    if (has_capability('mod/questionnaire:editquestions', $context) && $owner) {
+        $url = '/mod/questionnaire/questions.php';
+        $node = navigation_node::create(get_string('questions', 'questionnaire'),
+            new moodle_url($url, array('id' => $cmid)),
+            navigation_node::TYPE_SETTING, null, 'questions',
+            new pix_icon('t/edit', ''));
+        $questionnairenode->add_node($node, $beforekey);
+    }
+
+    if (has_capability('mod/questionnaire:preview', $context)) {
+        $url = '/mod/questionnaire/preview.php';
+        $node = navigation_node::create(get_string('preview_label', 'questionnaire'),
+            new moodle_url($url, array('id' => $cmid)),
+            navigation_node::TYPE_SETTING, null, 'preview',
+            new pix_icon('t/preview', ''));
+        $questionnairenode->add_node($node, $beforekey);
+    }
+
+    if ($questionnaire->user_can_take($USER->id)) {
+        $url = '/mod/questionnaire/complete.php';
+        if ($questionnaire->user_has_saved_response($USER->id)) {
+            $args = ['id' => $cmid, 'resume' => 1];
+            $text = get_string('resumesurvey', 'questionnaire');
+        } else {
+            $args = ['id' => $cmid];
+            $text = get_string('answerquestions', 'questionnaire');
+        }
+        $node = navigation_node::create($text, new moodle_url($url, $args),
+            navigation_node::TYPE_SETTING, null, '', new pix_icon('i/info', 'answerquestions'));
+        $questionnairenode->add_node($node, $beforekey);
+    }
+    $usernumresp = $questionnaire->count_submissions($USER->id);
+
+    if ($questionnaire->capabilities->readownresponses && ($usernumresp > 0)) {
+        $url = '/mod/questionnaire/myreport.php';
+
+        if ($usernumresp > 1) {
+            $urlargs = array('instance' => $questionnaire->id, 'userid' => $USER->id,
+                'byresponse' => 0, 'action' => 'summary', 'group' => $currentgroupid);
+            $node = navigation_node::create(get_string('yourresponses', 'questionnaire'),
+                new moodle_url($url, $urlargs), navigation_node::TYPE_SETTING, null, 'yourresponses');
+            $myreportnode = $questionnairenode->add_node($node, $beforekey);
+
+            $urlargs = array('instance' => $questionnaire->id, 'userid' => $USER->id,
+                'byresponse' => 0, 'action' => 'summary', 'group' => $currentgroupid);
+            $myreportnode->add(get_string('summary', 'questionnaire'), new moodle_url($url, $urlargs));
+
+            $urlargs = array('instance' => $questionnaire->id, 'userid' => $USER->id,
+                'byresponse' => 1, 'action' => 'vresp', 'group' => $currentgroupid);
+            $byresponsenode = $myreportnode->add(get_string('viewindividualresponse', 'questionnaire'),
+                new moodle_url($url, $urlargs));
+
+            $urlargs = array('instance' => $questionnaire->id, 'userid' => $USER->id,
+                'byresponse' => 0, 'action' => 'vall', 'group' => $currentgroupid);
+            $myreportnode->add(get_string('myresponses', 'questionnaire'), new moodle_url($url, $urlargs));
+            if ($questionnaire->capabilities->downloadresponses) {
+                $urlargs = array('instance' => $questionnaire->id, 'user' => $USER->id,
+                    'action' => 'dwnpg', 'group' => $currentgroupid);
+                $myreportnode->add(get_string('downloadtext'), new moodle_url('/mod/questionnaire/report.php', $urlargs));
+            }
+        } else {
+            $urlargs = array('instance' => $questionnaire->id, 'userid' => $USER->id,
+                'byresponse' => 1, 'action' => 'vresp', 'group' => $currentgroupid);
+            $node = navigation_node::create(get_string('yourresponse', 'questionnaire'),
+                new moodle_url($url, $urlargs), navigation_node::TYPE_SETTING, null, 'yourresponse');
+            $myreportnode = $questionnairenode->add_node($node, $beforekey);
+        }
+    }
+
+    // If questionnaire is set to separate groups, prevent user who is not member of any group
+    // and is not a non-editing teacher to view All responses.
+    if ($questionnaire->can_view_all_responses($usernumresp)) {
+
+        $url = '/mod/questionnaire/report.php';
+        $node = navigation_node::create(get_string('viewallresponses', 'questionnaire'),
+            new moodle_url($url, array('instance' => $questionnaire->id, 'action' => 'vall')),
+            navigation_node::TYPE_SETTING, null, 'vall');
+        $reportnode = $questionnairenode->add_node($node, $beforekey);
+
+        if ($questionnaire->capabilities->viewsingleresponse) {
+            $summarynode = $reportnode->add(get_string('summary', 'questionnaire'),
+                new moodle_url('/mod/questionnaire/report.php',
+                    array('instance' => $questionnaire->id, 'action' => 'vall')));
+        } else {
+            $summarynode = $reportnode;
+        }
+        $summarynode->add(get_string('order_default', 'questionnaire'),
+            new moodle_url('/mod/questionnaire/report.php',
+                array('instance' => $questionnaire->id, 'action' => 'vall', 'group' => $currentgroupid)));
+        $summarynode->add(get_string('order_ascending', 'questionnaire'),
+            new moodle_url('/mod/questionnaire/report.php',
+                array('instance' => $questionnaire->id, 'action' => 'vallasort', 'group' => $currentgroupid)));
+        $summarynode->add(get_string('order_descending', 'questionnaire'),
+            new moodle_url('/mod/questionnaire/report.php',
+                array('instance' => $questionnaire->id, 'action' => 'vallarsort', 'group' => $currentgroupid)));
+
+        if ($questionnaire->capabilities->deleteresponses) {
+            $summarynode->add(get_string('deleteallresponses', 'questionnaire'),
+                new moodle_url('/mod/questionnaire/report.php',
+                    array('instance' => $questionnaire->id, 'action' => 'delallresp', 'group' => $currentgroupid)));
+        }
+
+        if ($questionnaire->capabilities->downloadresponses) {
+            $summarynode->add(get_string('downloadtextformat', 'questionnaire'),
+                new moodle_url('/mod/questionnaire/report.php',
+                    array('instance' => $questionnaire->id, 'action' => 'dwnpg', 'group' => $currentgroupid)));
+        }
+        if ($questionnaire->capabilities->viewsingleresponse) {
+            $byresponsenode = $reportnode->add(get_string('viewbyresponse', 'questionnaire'),
+                new moodle_url('/mod/questionnaire/report.php',
+                    array('instance' => $questionnaire->id, 'action' => 'vresp', 'byresponse' => 1, 'group' => $currentgroupid)));
+
+            $byresponsenode->add(get_string('view', 'questionnaire'),
+                new moodle_url('/mod/questionnaire/report.php',
+                    array('instance' => $questionnaire->id, 'action' => 'vresp', 'byresponse' => 1, 'group' => $currentgroupid)));
+
+            if ($individualresponse) {
+                $byresponsenode->add(get_string('deleteresp', 'questionnaire'),
+                    new moodle_url('/mod/questionnaire/report.php',
+                        array('instance' => $questionnaire->id, 'action' => 'dresp', 'byresponse' => 1,
+                            'rid' => $rid, 'group' => $currentgroupid, 'individualresponse' => 1)));
+            }
+        }
+    }
+
+    $canviewgroups = true;
+    $groupmode = groups_get_activity_groupmode($cm, $course);
+    if ($groupmode == 1) {
+        $canviewgroups = groups_has_membership($cm, $USER->id);
+    }
+    $canviewallgroups = has_capability('moodle/site:accessallgroups', $context);
+    if ($questionnaire->capabilities->viewsingleresponse && ($canviewallgroups || $canviewgroups)) {
+        $url = '/mod/questionnaire/show_nonrespondents.php';
+        $node = navigation_node::create(get_string('show_nonrespondents', 'questionnaire'),
+            new moodle_url($url, array('id' => $cmid)),
+            navigation_node::TYPE_SETTING, null, 'nonrespondents');
+        $questionnairenode->add_node($node, $beforekey);
+
+    }
+}
+
+// Any other questionnaire functions go here.  Each of them must have a name that
+// starts with questionnaire_.
+
+function questionnaire_get_view_actions() {
+    return array('view', 'view all');
+}
+
+function questionnaire_get_post_actions() {
+    return array('submit', 'update');
+}
+
+function questionnaire_get_recent_mod_activity(&$activities, &$index, $timestart,
+                $courseid, $cmid, $userid = 0, $groupid = 0) {
+
+    global $CFG, $COURSE, $USER, $DB;
+    require_once($CFG->dirroot . '/mod/questionnaire/locallib.php');
+
+    if ($COURSE->id == $courseid) {
+        $course = $COURSE;
+    } else {
+        $course = $DB->get_record('course', array('id' => $courseid));
+    }
+
+    $modinfo = get_fast_modinfo($course);
+
+    $cm = $modinfo->cms[$cmid];
+    $questionnaire = $DB->get_record('questionnaire', array('id' => $cm->instance));
+
+    $context = context_module::instance($cm->id);
+    $grader = has_capability('mod/questionnaire:viewsingleresponse', $context);
+
+    // If this is a copy of a public questionnaire whose original is located in another course,
+    // current user (teacher) cannot view responses.
+    if ($grader && $survey = $DB->get_record('questionnaire_survey', array('id' => $questionnaire->sid))) {
+        // For a public questionnaire, look for the original public questionnaire that it is based on.
+        if ($survey->realm == 'public' && $survey->courseid != $course->id) {
+            // For a public questionnaire, look for the original public questionnaire that it is based on.
+            $originalquestionnaire = $DB->get_record('questionnaire', ['sid' => $survey->id, 'course' => $survey->courseid]);
+            $cmoriginal = get_coursemodule_from_instance("questionnaire", $originalquestionnaire->id, $survey->courseid);
+            $contextoriginal = context_course::instance($survey->courseid, MUST_EXIST);
+            if (!has_capability('mod/questionnaire:viewsingleresponse', $contextoriginal)) {
+                $tmpactivity = new stdClass();
+                $tmpactivity->type = 'questionnaire';
+                $tmpactivity->cmid = $cm->id;
+                $tmpactivity->cannotview = true;
+                $tmpactivity->anonymous = false;
+                $activities[$index++] = $tmpactivity;
+                return $activities;
+            }
+        }
+    }
+
+    if ($userid) {
+        $userselect = "AND u.id = :userid";
+        $params['userid'] = $userid;
+    } else {
+        $userselect = '';
+    }
+
+    if ($groupid) {
+        $groupselect = 'AND gm.groupid = :groupid';
+        $groupjoin   = 'JOIN {groups_members} gm ON  gm.userid=u.id';
+        $params['groupid'] = $groupid;
+    } else {
+        $groupselect = '';
+        $groupjoin   = '';
+    }
+
+    $params['timestart'] = $timestart;
+    $params['questionnaireid'] = $questionnaire->sid;
+
+    $ufields = user_picture::fields('u', null, 'useridagain');
+    if (!$attempts = $DB->get_records_sql("
+                    SELECT qr.*,
+                    {$ufields}
+                    FROM {questionnaire_response} qr
+                    JOIN {user} u ON u.id = qr.userid
+                    $groupjoin
+                    WHERE qr.submitted > :timestart
+                    AND qr.survey_id = :questionnaireid
+                    $userselect
+                    $groupselect
+                    ORDER BY qr.submitted ASC", $params)) {
+        return;
+    }
+
+    $accessallgroups = has_capability('moodle/site:accessallgroups', $context);
+    $viewfullnames   = has_capability('moodle/site:viewfullnames', $context);
+    $groupmode       = groups_get_activity_groupmode($cm, $course);
+
+    $usersgroups = null;
+    $aname = format_string($cm->name, true);
+    $userattempts = array();
+    foreach ($attempts as $attempt) {
+        if ($questionnaire->respondenttype != 'anonymous') {
+            if (!isset($userattempts[$attempt->lastname])) {
+                $userattempts[$attempt->lastname] = 1;
+            } else {
+                $userattempts[$attempt->lastname]++;
+            }
+        }
+        if ($attempt->userid != $USER->id) {
+            if (!$grader) {
+                // View complete individual responses permission required.
+                continue;
+            }
+
+            if (($groupmode == SEPARATEGROUPS) && !$accessallgroups) {
+                if ($usersgroups === null) {
+                    $usersgroups = groups_get_all_groups($course->id,
+                    $attempt->userid, $cm->groupingid);
+                    if (is_array($usersgroups)) {
+                        $usersgroups = array_keys($usersgroups);
+                    } else {
+                         $usersgroups = array();
+                    }
+                }
+                if (!array_intersect($usersgroups, $modinfo->groups[$cm->id])) {
+                    continue;
+                }
+            }
+        }
+
+        $tmpactivity = new stdClass();
+
+        $tmpactivity->type       = 'questionnaire';
+        $tmpactivity->cmid       = $cm->id;
+        $tmpactivity->cminstance = $cm->instance;
+        // Current user is admin - or teacher enrolled in original public course.
+        if (isset($cmoriginal)) {
+            $tmpactivity->cminstance = $cmoriginal->instance;
+        }
+        $tmpactivity->cannotview = false;
+        $tmpactivity->anonymous  = false;
+        $tmpactivity->name       = $aname;
+        $tmpactivity->sectionnum = $cm->sectionnum;
+        $tmpactivity->timestamp  = $attempt->submitted;
+        $tmpactivity->groupid    = $groupid;
+        if (isset($userattempts[$attempt->lastname])) {
+            $tmpactivity->nbattempts = $userattempts[$attempt->lastname];
+        }
+
+        $tmpactivity->content = new stdClass();
+        $tmpactivity->content->attemptid = $attempt->id;
+
+        $userfields = explode(',', user_picture::fields());
+        $tmpactivity->user = new stdClass();
+        foreach ($userfields as $userfield) {
+            if ($userfield == 'id') {
+                $tmpactivity->user->{$userfield} = $attempt->userid;
+            } else {
+                if (!empty($attempt->{$userfield})) {
+                    $tmpactivity->user->{$userfield} = $attempt->{$userfield};
+                } else {
+                    $tmpactivity->user->{$userfield} = null;
+                }
+            }
+        }
+        if ($questionnaire->respondenttype != 'anonymous') {
+            $tmpactivity->user->fullname  = fullname($attempt, $viewfullnames);
+        } else {
+            $tmpactivity->user = '';
+            unset ($tmpactivity->user);
+            $tmpactivity->anonymous = true;
+        }
+        $activities[$index++] = $tmpactivity;
+    }
+}
+
+/**
+ * Prints all users who have completed a specified questionnaire since a given time
+ *
+ * @global object
+ * @param object $activity
+ * @param int $courseid
+ * @param string $detail not used but needed for compability
+ * @param array $modnames
+ * @return void Output is echo'd
+ *
+ * $details and $modenames are unused, but API requires them. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_print_recent_mod_activity($activity, $courseid, $detail, $modnames) {
+    global $OUTPUT;
+
+    // If the questionnaire is "anonymous", then $activity->user won't have been set, so do not display respondent info.
+    if ($activity->anonymous) {
+        $stranonymous = ' ('.get_string('anonymous', 'questionnaire').')';
+        $activity->nbattempts = '';
+    } else {
+        $stranonymous = '';
+    }
+    // Current user cannot view responses to public questionnaire.
+    if ($activity->cannotview) {
+        $strcannotview = get_string('cannotviewpublicresponses', 'questionnaire');
+    }
+    echo html_writer::start_tag('div');
+    echo html_writer::start_tag('span', array('class' => 'clearfix',
+                    'style' => 'margin-top:0px; background-color: white; display: inline-block;'));
+
+    if (!$activity->anonymous && !$activity->cannotview) {
+        echo html_writer::tag('div', $OUTPUT->user_picture($activity->user, array('courseid' => $courseid)),
+                        array('style' => 'float: left; padding-right: 10px;'));
+    }
+    if (!$activity->cannotview) {
+        echo html_writer::start_tag('div');
+        echo html_writer::start_tag('div');
+
+        $urlparams = array('action' => 'vresp', 'instance' => $activity->cminstance,
+                        'group' => $activity->groupid, 'rid' => $activity->content->attemptid, 'individualresponse' => 1);
+
+        $context = context_module::instance($activity->cmid);
+        if (has_capability('mod/questionnaire:viewsingleresponse', $context)) {
+            $report = 'report.php';
+        } else {
+            $report = 'myreport.php';
+        }
+        echo html_writer::tag('a', get_string('response', 'questionnaire').' '.$activity->nbattempts.$stranonymous,
+                        array('href' => new moodle_url('/mod/questionnaire/'.$report, $urlparams)));
+        echo html_writer::end_tag('div');
+    } else {
+        echo html_writer::start_tag('div');
+        echo html_writer::start_tag('div');
+        echo html_writer::tag('div', $strcannotview);
+        echo html_writer::end_tag('div');
+    }
+    if (!$activity->anonymous  && !$activity->cannotview) {
+        $url = new moodle_url('/user/view.php', array('course' => $courseid, 'id' => $activity->user->id));
+        $name = $activity->user->fullname;
+        $link = html_writer::link($url, $name);
+        echo html_writer::start_tag('div', array('class' => 'user'));
+        echo $link .' - '. userdate($activity->timestamp);
+        echo html_writer::end_tag('div');
+    }
+
+    echo html_writer::end_tag('div');
+    echo html_writer::end_tag('span');
+    echo html_writer::end_tag('div');
+
+    return;
+}
+
+/**
+ * Prints questionnaire summaries on 'My home' page
+ *
+ * Prints questionnaire name, due date and attempt information on
+ * questionnaires that have a deadline that has not already passed
+ * and it is available for taking.
+ *
+ * @global object
+ * @global stdClass
+ * @global object
+ * @uses CONTEXT_MODULE
+ * @param array $courses An array of course objects to get questionnaire instances from
+ * @param array $htmlarray Store overview output array( course ID => 'questionnaire' => HTML output )
+ * @return void
+ */
+function questionnaire_print_overview($courses, &$htmlarray) {
+    global $USER, $CFG, $DB, $OUTPUT;
+
+    require_once($CFG->dirroot . '/mod/questionnaire/locallib.php');
+
+    if (!$questionnaires = get_all_instances_in_courses('questionnaire', $courses)) {
+        return;
+    }
+
+    // Get Necessary Strings.
+    $strquestionnaire       = get_string('modulename', 'questionnaire');
+    $strnotattempted = get_string('noattempts', 'questionnaire');
+    $strattempted    = get_string('attempted', 'questionnaire');
+    $strsavedbutnotsubmitted = get_string('savedbutnotsubmitted', 'questionnaire');
+
+    $now = time();
+    foreach ($questionnaires as $questionnaire) {
+
+        // The questionnaire has a deadline.
+        if (($questionnaire->closedate != 0)
+                        // And it is before the deadline has been met.
+                        && ($questionnaire->closedate >= $now)
+                        // And the questionnaire is available.
+                        && (($questionnaire->opendate == 0) || ($questionnaire->opendate <= $now))) {
+            if (!$questionnaire->visible) {
+                $class = ' class="dimmed"';
+            } else {
+                $class = '';
+            }
+            $str = $OUTPUT->box("$strquestionnaire:
+                            <a$class href=\"$CFG->wwwroot/mod/questionnaire/view.php?id=$questionnaire->coursemodule\">".
+                            format_string($questionnaire->name).'</a>', 'name');
+
+            // Deadline.
+            $str .= $OUTPUT->box(get_string('closeson', 'questionnaire', userdate($questionnaire->closedate)), 'info');
+            $select = 'qid = '.$questionnaire->id.' AND userid = '.$USER->id;
+            $attempts = $DB->get_records_select('questionnaire_attempts', $select);
+            $nbattempts = count($attempts);
+
+            // Do not display a questionnaire as due if it can only be sumbitted once and it has already been submitted!
+            if ($nbattempts != 0 && $questionnaire->qtype == QUESTIONNAIREONCE) {
+                continue;
+            }
+
+            // Attempt information.
+            if (has_capability('mod/questionnaire:manage', context_module::instance($questionnaire->coursemodule))) {
+                // Number of user attempts.
+                $attempts = $DB->count_records('questionnaire_attempts', array('id' => $questionnaire->id));
+                $str .= $OUTPUT->box(get_string('numattemptsmade', 'questionnaire', $attempts), 'info');
+            } else {
+                if ($responses = questionnaire_get_user_responses($questionnaire->sid, $USER->id, false)) {
+                    foreach ($responses as $response) {
+                        if ($response->complete == 'y') {
+                            $str .= $OUTPUT->box($strattempted, 'info');
+                            break;
+                        } else {
+                            $str .= $OUTPUT->box($strsavedbutnotsubmitted, 'info');
+                        }
+                    }
+                } else {
+                    $str .= $OUTPUT->box($strnotattempted, 'info');
+                }
+            }
+            $str = $OUTPUT->box($str, 'questionnaire overview');
+
+            if (empty($htmlarray[$questionnaire->course]['questionnaire'])) {
+                $htmlarray[$questionnaire->course]['questionnaire'] = $str;
+            } else {
+                $htmlarray[$questionnaire->course]['questionnaire'] .= $str;
+            }
+        }
+    }
+}
+
+
+/**
+ * Implementation of the function for printing the form elements that control
+ * whether the course reset functionality affects the questionnaire.
+ *
+ * @param $mform the course reset form that is being built.
+ */
+function questionnaire_reset_course_form_definition($mform) {
+    $mform->addElement('header', 'questionnaireheader', get_string('modulenameplural', 'questionnaire'));
+    $mform->addElement('advcheckbox', 'reset_questionnaire',
+                    get_string('removeallquestionnaireattempts', 'questionnaire'));
+}
+
+/**
+ * Course reset form defaults.
+ * @return array the defaults.
+ *
+ * Function parameters are unused, but API requires them. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_reset_course_form_defaults($course) {
+    return array('reset_questionnaire' => 1);
+}
+
+/**
+ * Actual implementation of the reset course functionality, delete all the
+ * questionnaire responses for course $data->courseid, if $data->reset_questionnaire_attempts is
+ * set and true.
+ *
+ * @param object $data the data submitted from the reset course.
+ * @return array status array
+ */
+function questionnaire_reset_userdata($data) {
+    global $CFG, $DB;
+    require_once($CFG->libdir . '/questionlib.php');
+    require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+    $componentstr = get_string('modulenameplural', 'questionnaire');
+    $status = array();
+
+    if (!empty($data->reset_questionnaire)) {
+        $surveys = questionnaire_get_survey_list($data->courseid, '');
+
+        // Delete responses.
+        foreach ($surveys as $survey) {
+            // Get all responses for this questionnaire.
+            $sql = "SELECT R.id, R.survey_id, R.submitted, R.userid
+                 FROM {questionnaire_response} R
+                 WHERE R.survey_id = ?
+                 ORDER BY R.id";
+            $resps = $DB->get_records_sql($sql, array($survey->id));
+            if (!empty($resps)) {
+                $questionnaire = $DB->get_record("questionnaire", ["sid" => $survey->id, "course" => $survey->courseid]);
+                $questionnaire->course = $DB->get_record("course", array("id" => $questionnaire->course));
+                foreach ($resps as $response) {
+                    questionnaire_delete_response($response, $questionnaire);
+                }
+            }
+            // Remove this questionnaire's grades (and feedback) from gradebook (if any).
+            $select = "itemmodule = 'questionnaire' AND iteminstance = ".$survey->qid;
+            $fields = 'id';
+            if ($itemid = $DB->get_record_select('grade_items', $select, null, $fields)) {
+                $itemid = $itemid->id;
+                $DB->delete_records_select('grade_grades', 'itemid = '.$itemid);
+
+            }
+        }
+        $status[] = array(
+                        'component' => $componentstr,
+                        'item' => get_string('deletedallresp', 'questionnaire'),
+                        'error' => false);
+
+        $status[] = array(
+                        'component' => $componentstr,
+                        'item' => get_string('gradesdeleted', 'questionnaire'),
+                        'error' => false);
+    }
+    return $status;
+}
+
+/**
+ * Obtains the automatic completion state for this questionnaire based on the condition
+ * in questionnaire settings.
+ *
+ * @param object $course Course
+ * @param object $cm Course-module
+ * @param int $userid User ID
+ * @param bool $type Type of comparison (or/and; can be used as return value if no conditions)
+ * @return bool True if completed, false if not, $type if conditions not set.
+ *
+ * $course is unused, but API requires it. Suppress PHPMD warning.
+ *
+ * @SuppressWarnings(PHPMD.UnusedFormalParameter)
+ */
+function questionnaire_get_completion_state($course, $cm, $userid, $type) {
+    global $DB;
+
+    // Get questionnaire details.
+    $questionnaire = $DB->get_record('questionnaire', array('id' => $cm->instance), '*', MUST_EXIST);
+
+    // If completion option is enabled, evaluate it and return true/false.
+    if ($questionnaire->completionsubmit) {
+        $params = array('userid' => $userid, 'qid' => $questionnaire->id);
+        return $DB->record_exists('questionnaire_attempts', $params);
+    } else {
+        // Completion option is not enabled so just return $type.
+        return $type;
+    }
+}
diff --git a/mod/questionnaire/locallib.php b/mod/questionnaire/locallib.php
new file mode 100644
index 0000000..0c26e3d
--- /dev/null
+++ b/mod/questionnaire/locallib.php
@@ -0,0 +1,1064 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This library replaces the phpESP application with Moodle specific code. It will eventually
+ * replace all of the phpESP application, removing the dependency on that.
+ */
+
+/**
+ * Updates the contents of the survey with the provided data. If no data is provided,
+ * it checks for posted data.
+ *
+ * @param int $survey_id The id of the survey to update.
+ * @param string $old_tab The function that was being executed.
+ * @param object $sdata The data to update the survey with.
+ *
+ * @return string|boolean The function to go to, or false on error.
+ *
+ */
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->libdir.'/eventslib.php');
+require_once($CFG->dirroot.'/calendar/lib.php');
+// Constants.
+
+define ('QUESTIONNAIREUNLIMITED', 0);
+define ('QUESTIONNAIREONCE', 1);
+define ('QUESTIONNAIREDAILY', 2);
+define ('QUESTIONNAIREWEEKLY', 3);
+define ('QUESTIONNAIREMONTHLY', 4);
+
+define ('QUESTIONNAIRE_STUDENTVIEWRESPONSES_NEVER', 0);
+define ('QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENANSWERED', 1);
+define ('QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENCLOSED', 2);
+define ('QUESTIONNAIRE_STUDENTVIEWRESPONSES_ALWAYS', 3);
+
+define('QUESTIONNAIRE_MAX_EVENT_LENGTH', 5 * 24 * 60 * 60);   // 5 days maximum.
+
+define('QUESTIONNAIRE_DEFAULT_PAGE_COUNT', 20);
+
+global $questionnairetypes;
+$questionnairetypes = array (QUESTIONNAIREUNLIMITED => get_string('qtypeunlimited', 'questionnaire'),
+                              QUESTIONNAIREONCE => get_string('qtypeonce', 'questionnaire'),
+                              QUESTIONNAIREDAILY => get_string('qtypedaily', 'questionnaire'),
+                              QUESTIONNAIREWEEKLY => get_string('qtypeweekly', 'questionnaire'),
+                              QUESTIONNAIREMONTHLY => get_string('qtypemonthly', 'questionnaire'));
+
+global $questionnairerespondents;
+$questionnairerespondents = array ('fullname' => get_string('respondenttypefullname', 'questionnaire'),
+                                    'anonymous' => get_string('respondenttypeanonymous', 'questionnaire'));
+
+global $questionnairerealms;
+$questionnairerealms = array ('private' => get_string('private', 'questionnaire'),
+                               'public' => get_string('public', 'questionnaire'),
+                               'template' => get_string('template', 'questionnaire'));
+
+global $questionnaireresponseviewers;
+$questionnaireresponseviewers = array (
+            QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENANSWERED => get_string('responseviewstudentswhenanswered', 'questionnaire'),
+            QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENCLOSED => get_string('responseviewstudentswhenclosed', 'questionnaire'),
+            QUESTIONNAIRE_STUDENTVIEWRESPONSES_ALWAYS => get_string('responseviewstudentsalways', 'questionnaire'),
+            QUESTIONNAIRE_STUDENTVIEWRESPONSES_NEVER => get_string('responseviewstudentsnever', 'questionnaire'));
+
+global $autonumbering;
+$autonumbering = array (0 => get_string('autonumberno', 'questionnaire'),
+        1 => get_string('autonumberquestions', 'questionnaire'),
+        2 => get_string('autonumberpages', 'questionnaire'),
+        3 => get_string('autonumberpagesandquestions', 'questionnaire'));
+
+function questionnaire_check_date ($thisdate, $insert=false) {
+    $dateformat = get_string('strfdate', 'questionnaire');
+    if (preg_match('/(%[mdyY])(.+)(%[mdyY])(.+)(%[mdyY])/', $dateformat, $matches)) {
+        $datepieces = explode($matches[2], $thisdate);
+        foreach ($datepieces as $datepiece) {
+            if (!is_numeric($datepiece)) {
+                return 'wrongdateformat';
+            }
+        }
+        $pattern = "/[^dmy]/i";
+        $dateorder = strtolower(preg_replace($pattern, '', $dateformat));
+        $countpieces = count($datepieces);
+        if ($countpieces == 1) { // Assume only year entered.
+            switch ($dateorder) {
+                case 'dmy': // Most countries.
+                case 'mdy': // USA.
+                    $datepieces[2] = $datepieces[0]; // year
+                    $datepieces[0] = '1'; // Assumed 1st month of year.
+                    $datepieces[1] = '1'; // Assumed 1st day of month.
+                    break;
+                case 'ymd': // ISO 8601 standard
+                    $datepieces[1] = '1'; // Assumed 1st month of year.
+                    $datepieces[2] = '1'; // Assumed 1st day of month.
+                    break;
+            }
+        }
+        if ($countpieces == 2) { // Assume only month and year entered.
+            switch ($dateorder) {
+                case 'dmy': // Most countries.
+                    $datepieces[2] = $datepieces[1]; // Year.
+                    $datepieces[1] = $datepieces[0]; // Month.
+                    $datepieces[0] = '1'; // Assumed 1st day of month.
+                    break;
+                case 'mdy': // USA
+                    $datepieces[2] = $datepieces[1]; // Year.
+                    $datepieces[0] = $datepieces[0]; // Month.
+                    $datepieces[1] = '1'; // Assumed 1st day of month.
+                    break;
+                case 'ymd': // ISO 8601 standard
+                    $datepieces[2] = '1'; // Assumed 1st day of month.
+                    break;
+            }
+        }
+        if (count($datepieces) > 1) {
+            if ($matches[1] == '%m') {
+                $month = $datepieces[0];
+            }
+            if ($matches[1] == '%d') {
+                $day = $datepieces[0];
+            }
+            if ($matches[1] == '%y') {
+                $year = strftime('%C').$datepieces[0];
+            }
+            if ($matches[1] == '%Y') {
+                $year = $datepieces[0];
+            }
+
+            if ($matches[3] == '%m') {
+                $month = $datepieces[1];
+            }
+            if ($matches[3] == '%d') {
+                $day = $datepieces[1];
+            }
+            if ($matches[3] == '%y') {
+                $year = strftime('%C').$datepieces[1];
+            }
+            if ($matches[3] == '%Y') {
+                $year = $datepieces[1];
+            }
+
+            if ($matches[5] == '%m') {
+                $month = $datepieces[2];
+            }
+            if ($matches[5] == '%d') {
+                $day = $datepieces[2];
+            }
+            if ($matches[5] == '%y') {
+                $year = strftime('%C').$datepieces[2];
+            }
+            if ($matches[5] == '%Y') {
+                $year = $datepieces[2];
+            }
+
+            $month = min(12, $month);
+            $month = max(1, $month);
+            if ($month == 2) {
+                $day = min(29, $day);
+            } else if ($month == 4 || $month == 6 || $month == 9 || $month == 11) {
+                $day = min(30, $day);
+            } else {
+                $day = min(31, $day);
+            }
+            $day = max(1, $day);
+            if (!$thisdate = gmmktime(0, 0, 0, $month, $day, $year)) {
+                return 'wrongdaterange';
+            } else {
+                if ($insert) {
+                    $thisdate = trim(userdate ($thisdate, '%Y-%m-%d', '1', false));
+                } else {
+                    $thisdate = trim(userdate ($thisdate, $dateformat, '1', false));
+                }
+            }
+            return $thisdate;
+        }
+    } else {
+        return ('wrongdateformat');
+    }
+}
+
+function questionnaire_choice_values($content) {
+
+    // If we run the content through format_text first, any filters we want to use (e.g. multilanguage) should work.
+    // examines the content of a possible answer from radio button, check boxes or rate question
+    // returns ->text to be displayed, ->image if present, ->modname name of modality, image ->title.
+    $contents = new stdClass();
+    $contents->text = '';
+    $contents->image = '';
+    $contents->modname = '';
+    $contents->title = '';
+    // Has image.
+    if (preg_match('/(<img)\s .*(src="(.[^"]{1,})")/isxmU', $content, $matches)) {
+        $contents->image = $matches[0];
+        $imageurl = $matches[3];
+        // Image has a title or alt text: use one of them.
+        if (preg_match('/(title=.)([^"]{1,})/', $content, $matches)
+             || preg_match('/(alt=.)([^"]{1,})/', $content, $matches) ) {
+            $contents->title = $matches[2];
+        } else {
+            // Image has no title nor alt text: use its filename (without the extension).
+            preg_match("/.*\/(.*)\..*$/", $imageurl, $matches);
+            $contents->title = $matches[1];
+        }
+        // Content has text or named modality plus an image.
+        if (preg_match('/(.*)(<img.*)/', $content, $matches)) {
+            $content = $matches[1];
+        } else {
+            // Just an image.
+            return $contents;
+        }
+    }
+
+    // Check for score value first (used e.g. by personality test feature).
+    $r = preg_match_all("/^(\d{1,2}=)(.*)$/", $content, $matches);
+    if ($r) {
+        $content = $matches[2][0];
+    }
+
+    // Look for named modalities.
+    $contents->text = $content;
+    // DEV JR from version 2.5, a double colon :: must be used here instead of the equal sign.
+    if ($pos = strpos($content, '::')) {
+        $contents->text = substr($content, $pos + 2);
+        $contents->modname = substr($content, 0, $pos);
+    }
+    return $contents;
+}
+
+/**
+ * Get the information about the standard questionnaire JavaScript module.
+ * @return array a standard jsmodule structure.
+ */
+function questionnaire_get_js_module() {
+    return array(
+            'name' => 'mod_questionnaire',
+            'fullpath' => '/mod/questionnaire/module.js',
+            'requires' => array('base', 'dom', 'event-delegate', 'event-key',
+                    'core_question_engine', 'moodle-core-formchangechecker'),
+            'strings' => array(
+                    array('cancel', 'moodle'),
+                    array('flagged', 'question'),
+                    array('functiondisabledbysecuremode', 'quiz'),
+                    array('startattempt', 'quiz'),
+                    array('timesup', 'quiz'),
+                    array('changesmadereallygoaway', 'moodle'),
+            ),
+    );
+}
+
+/**
+ * Get all the questionnaire responses for a user
+ */
+function questionnaire_get_user_responses($surveyid, $userid, $complete=true) {
+    global $DB;
+    $andcomplete = '';
+    if ($complete) {
+        $andcomplete = " AND complete = 'y' ";
+    }
+    return $DB->get_records_sql ("SELECT *
+        FROM {questionnaire_response}
+        WHERE survey_id = ?
+        AND userid = ?
+        ".$andcomplete."
+        ORDER BY submitted ASC ", array($surveyid, $userid));
+}
+
+/**
+ * get the capabilities for the questionnaire
+ * @param int $cmid
+ * @return object the available capabilities from current user
+ */
+function questionnaire_load_capabilities($cmid) {
+    static $cb;
+
+    if (isset($cb)) {
+        return $cb;
+    }
+
+    $context = questionnaire_get_context($cmid);
+
+    $cb = new stdClass();
+    $cb->view                   = has_capability('mod/questionnaire:view', $context);
+    $cb->submit                 = has_capability('mod/questionnaire:submit', $context);
+    $cb->viewsingleresponse     = has_capability('mod/questionnaire:viewsingleresponse', $context);
+    $cb->submissionnotification = has_capability('mod/questionnaire:submissionnotification', $context);
+    $cb->downloadresponses      = has_capability('mod/questionnaire:downloadresponses', $context);
+    $cb->deleteresponses        = has_capability('mod/questionnaire:deleteresponses', $context);
+    $cb->manage                 = has_capability('mod/questionnaire:manage', $context);
+    $cb->editquestions          = has_capability('mod/questionnaire:editquestions', $context);
+    $cb->createtemplates        = has_capability('mod/questionnaire:createtemplates', $context);
+    $cb->createpublic           = has_capability('mod/questionnaire:createpublic', $context);
+    $cb->readownresponses       = has_capability('mod/questionnaire:readownresponses', $context);
+    $cb->readallresponses       = has_capability('mod/questionnaire:readallresponses', $context);
+    $cb->readallresponseanytime = has_capability('mod/questionnaire:readallresponseanytime', $context);
+    $cb->printblank             = has_capability('mod/questionnaire:printblank', $context);
+    $cb->preview                = has_capability('mod/questionnaire:preview', $context);
+
+    $cb->viewhiddenactivities   = has_capability('moodle/course:viewhiddenactivities', $context, null, false);
+
+    return $cb;
+}
+
+/**
+ * returns the context-id related to the given coursemodule-id
+ * @param int $cmid the coursemodule-id
+ * @return object $context
+ */
+function questionnaire_get_context($cmid) {
+    static $context;
+
+    if (isset($context)) {
+        return $context;
+    }
+
+    if (!$context = context_module::instance($cmid)) {
+            print_error('badcontext');
+    }
+    return $context;
+}
+
+// This function *really* shouldn't be needed, but since sometimes we can end up with
+// orphaned surveys, this will clean them up.
+function questionnaire_cleanup() {
+    global $DB;
+
+    // Find surveys that don't have questionnaires associated with them.
+    $sql = 'SELECT qs.* FROM {questionnaire_survey} qs '.
+           'LEFT JOIN {questionnaire} q ON q.sid = qs.id '.
+           'WHERE q.sid IS NULL';
+
+    if ($surveys = $DB->get_records_sql($sql)) {
+        foreach ($surveys as $survey) {
+            questionnaire_delete_survey($survey->id, 0);
+        }
+    }
+    // Find deleted questions and remove them from database (with their associated choices, etc.).
+    return true;
+}
+
+function questionnaire_record_submission(&$questionnaire, $userid, $rid=0) {
+    global $DB;
+
+    $attempt['qid'] = $questionnaire->id;
+    $attempt['userid'] = $userid;
+    $attempt['rid'] = $rid;
+    $attempt['timemodified'] = time();
+    return $DB->insert_record("questionnaire_attempts", (object)$attempt, false);
+}
+
+function questionnaire_delete_survey($sid, $questionnaireid) {
+    global $DB;
+    $status = true;
+    // Delete all survey attempts and responses.
+    if ($responses = $DB->get_records('questionnaire_response', array('survey_id' => $sid), 'id')) {
+        foreach ($responses as $response) {
+            $status = $status && questionnaire_delete_response($response);
+        }
+    }
+
+    // There really shouldn't be any more, but just to make sure...
+    $DB->delete_records('questionnaire_response', array('survey_id' => $sid));
+    $DB->delete_records('questionnaire_attempts', array('qid' => $questionnaireid));
+
+    // Delete all question data for the survey.
+    if ($questions = $DB->get_records('questionnaire_question', array('survey_id' => $sid), 'id')) {
+        foreach ($questions as $question) {
+            $DB->delete_records('questionnaire_quest_choice', array('question_id' => $question->id));
+        }
+        $status = $status && $DB->delete_records('questionnaire_question', array('survey_id' => $sid));
+    }
+
+    // Delete all feedback sections and feedback messages for the survey.
+    if ($fbsections = $DB->get_records('questionnaire_fb_sections', array('survey_id' => $sid), 'id')) {
+        foreach ($fbsections as $fbsection) {
+            $DB->delete_records('questionnaire_feedback', array('section_id' => $fbsection->id));
+        }
+        $status = $status && $DB->delete_records('questionnaire_fb_sections', array('survey_id' => $sid));
+    }
+
+    $status = $status && $DB->delete_records('questionnaire_survey', array('id' => $sid));
+
+    return $status;
+}
+
+function questionnaire_delete_response($response, $questionnaire='') {
+    global $DB;
+    $status = true;
+    $cm = '';
+    $rid = $response->id;
+    // The questionnaire_delete_survey function does not send the questionnaire array.
+    if ($questionnaire != '') {
+        $cm = get_coursemodule_from_instance("questionnaire", $questionnaire->id, $questionnaire->course->id);
+    }
+
+    // Delete all of the response data for a response.
+    $DB->delete_records('questionnaire_response_bool', array('response_id' => $rid));
+    $DB->delete_records('questionnaire_response_date', array('response_id' => $rid));
+    $DB->delete_records('questionnaire_resp_multiple', array('response_id' => $rid));
+    $DB->delete_records('questionnaire_response_other', array('response_id' => $rid));
+    $DB->delete_records('questionnaire_response_rank', array('response_id' => $rid));
+    $DB->delete_records('questionnaire_resp_single', array('response_id' => $rid));
+    $DB->delete_records('questionnaire_response_text', array('response_id' => $rid));
+
+    $status = $status && $DB->delete_records('questionnaire_response', array('id' => $rid));
+    $status = $status && $DB->delete_records('questionnaire_attempts', array('rid' => $rid));
+
+    if ($status && $cm) {
+        // Update completion state if necessary.
+        $completion = new completion_info($questionnaire->course);
+        if ($completion->is_enabled($cm) == COMPLETION_TRACKING_AUTOMATIC && $questionnaire->completionsubmit) {
+            $completion->update_state($cm, COMPLETION_INCOMPLETE, $response->userid);
+        }
+    }
+
+    return $status;
+}
+
+function questionnaire_delete_responses($qid) {
+    global $DB;
+
+    $status = true;
+
+    // Delete all of the response data for a question.
+    $DB->delete_records('questionnaire_response_bool', array('question_id' => $qid));
+    $DB->delete_records('questionnaire_response_date', array('question_id' => $qid));
+    $DB->delete_records('questionnaire_resp_multiple', array('question_id' => $qid));
+    $DB->delete_records('questionnaire_response_other', array('question_id' => $qid));
+    $DB->delete_records('questionnaire_response_rank', array('question_id' => $qid));
+    $DB->delete_records('questionnaire_resp_single', array('question_id' => $qid));
+    $DB->delete_records('questionnaire_response_text', array('question_id' => $qid));
+
+    $status = $status && $DB->delete_records('questionnaire_response', array('id' => $qid));
+    $status = $status && $DB->delete_records('questionnaire_attempts', array('rid' => $qid));
+
+    return $status;
+}
+
+function questionnaire_get_survey_list($courseid=0, $type='') {
+    global $DB;
+
+    if ($courseid == 0) {
+        if (isadmin()) {
+            $sql = "SELECT id,name,courseid,realm,status " .
+                   "{questionnaire_survey} " .
+                   "ORDER BY realm,name ";
+            $params = null;
+        } else {
+            return false;
+        }
+    } else {
+        if ($type == 'public') {
+            $sql = "SELECT s.id,s.name,s.courseid,s.realm,s.status,s.title,q.id as qid,q.name as qname " .
+                   "FROM {questionnaire} q " .
+                   "INNER JOIN {questionnaire_survey} s ON s.id = q.sid AND s.courseid = q.course " .
+                   "WHERE realm = ? " .
+                   "ORDER BY realm,name ";
+            $params = [$type];
+        } else if ($type == 'template') {
+            $sql = "SELECT s.id,s.name,s.courseid,s.realm,s.status,s.title,q.id as qid,q.name as qname " .
+                   "FROM {questionnaire} q " .
+                   "INNER JOIN {questionnaire_survey} s ON s.id = q.sid AND s.courseid = q.course " .
+                   "WHERE (realm = ?) " .
+                   "ORDER BY realm,name ";
+            $params = [$type];
+        } else if ($type == 'private') {
+            $sql = "SELECT s.id,s.name,s.courseid,s.realm,s.status,q.id as qid,q.name as qname " .
+                "FROM {questionnaire} q " .
+                "INNER JOIN {questionnaire_survey} s ON s.id = q.sid " .
+                "WHERE s.courseid = ? and realm = ? " .
+                "ORDER BY realm,name ";
+            $params = [$courseid, $type];
+
+        } else {
+            // Current get_survey_list is called from function questionnaire_reset_userdata so we need to get a
+            // complete list of all questionnaires in current course to reset them.
+            $sql = "SELECT s.id,s.name,s.courseid,s.realm,s.status,q.id as qid,q.name as qname " .
+                   "FROM {questionnaire} q " .
+                    "INNER JOIN {questionnaire_survey} s ON s.id = q.sid AND s.courseid = q.course " .
+                   "WHERE s.courseid = ? " .
+                   "ORDER BY realm,name ";
+            $params = [$courseid];
+        }
+    }
+    return $DB->get_records_sql($sql, $params);
+}
+
+function questionnaire_get_survey_select($courseid=0, $type='') {
+    global $OUTPUT, $DB;
+
+    $surveylist = array();
+
+    if ($surveys = questionnaire_get_survey_list($courseid, $type)) {
+        $strpreview = get_string('preview_questionnaire', 'questionnaire');
+        foreach ($surveys as $survey) {
+            $originalcourse = $DB->get_record('course', ['id' => $survey->courseid]);
+            if (!$originalcourse) {
+                // This should not happen, but we found a case where a public survey
+                // still existed in a course that had been deleted, and so this
+                // code lead to a notice, and a broken link. Since that is useless
+                // we just skip surveys like this.
+                continue;
+            }
+
+            // Prevent creating a copy of a public questionnaire IN THE SAME COURSE as the original.
+            if (($type == 'public') && ($survey->courseid == $courseid)) {
+                continue;
+            } else {
+                $args = "sid={$survey->id}&popup=1";
+                if (!empty($survey->qid)) {
+                    $args .= "&qid={$survey->qid}";
+                }
+                $link = new moodle_url("/mod/questionnaire/preview.php?{$args}");
+                $action = new popup_action('click', $link);
+                $label = $OUTPUT->action_link($link, $survey->qname.' ['.$originalcourse->fullname.']',
+                    $action, array('title' => $strpreview));
+                $surveylist[$type.'-'.$survey->id] = $label;
+            }
+        }
+    }
+    return $surveylist;
+}
+
+function questionnaire_get_type ($id) {
+    switch ($id) {
+        case 1:
+            return get_string('yesno', 'questionnaire');
+        case 2:
+            return get_string('textbox', 'questionnaire');
+        case 3:
+            return get_string('essaybox', 'questionnaire');
+        case 4:
+            return get_string('radiobuttons', 'questionnaire');
+        case 5:
+            return get_string('checkboxes', 'questionnaire');
+        case 6:
+            return get_string('dropdown', 'questionnaire');
+        case 8:
+            return get_string('ratescale', 'questionnaire');
+        case 9:
+            return get_string('date', 'questionnaire');
+        case 10:
+            return get_string('numeric', 'questionnaire');
+        case 100:
+            return get_string('sectiontext', 'questionnaire');
+        case 99:
+            return get_string('sectionbreak', 'questionnaire');
+        default:
+        return $id;
+    }
+}
+
+/**
+ * This creates new events given as opendate and closedate by $questionnaire.
+ * @param object $questionnaire
+ * @return void
+ */
+ /* added by JR 16 march 2009 based on lesson_process_post_save script */
+
+function questionnaire_set_events($questionnaire) {
+    // Adding the questionnaire to the eventtable.
+    global $DB;
+    if ($events = $DB->get_records('event', array('modulename' => 'questionnaire', 'instance' => $questionnaire->id))) {
+        foreach ($events as $event) {
+            $event = calendar_event::load($event);
+            $event->delete();
+        }
+    }
+
+    // The open-event.
+    $event = new stdClass;
+    $event->description = $questionnaire->name;
+    $event->courseid = $questionnaire->course;
+    $event->groupid = 0;
+    $event->userid = 0;
+    $event->modulename = 'questionnaire';
+    $event->instance = $questionnaire->id;
+    $event->eventtype = 'open';
+    $event->timestart = $questionnaire->opendate;
+    $event->visible = instance_is_visible('questionnaire', $questionnaire);
+    $event->timeduration = ($questionnaire->closedate - $questionnaire->opendate);
+
+    if ($questionnaire->closedate && $questionnaire->opendate && ($event->timeduration <= QUESTIONNAIRE_MAX_EVENT_LENGTH)) {
+        // Single event for the whole questionnaire.
+        $event->name = $questionnaire->name;
+        calendar_event::create($event);
+    } else {
+        // Separate start and end events.
+        $event->timeduration  = 0;
+        if ($questionnaire->opendate) {
+            $event->name = $questionnaire->name.' ('.get_string('questionnaireopens', 'questionnaire').')';
+            calendar_event::create($event);
+            unset($event->id); // So we can use the same object for the close event.
+        }
+        if ($questionnaire->closedate) {
+            $event->name = $questionnaire->name.' ('.get_string('questionnairecloses', 'questionnaire').')';
+            $event->timestart = $questionnaire->closedate;
+            $event->eventtype = 'close';
+            calendar_event::create($event);
+        }
+    }
+}
+
+/**
+ * Get users who have not completed the questionnaire
+ *
+ * @global object
+ * @uses CONTEXT_MODULE
+ * @param object $cm
+ * @param int $group single groupid
+ * @param string $sort
+ * @param int $startpage
+ * @param int $pagecount
+ * @return object the userrecords
+ */
+function questionnaire_get_incomplete_users($cm, $sid,
+                $group = false,
+                $sort = '',
+                $startpage = false,
+                $pagecount = false) {
+
+    global $DB;
+
+    $context = context_module::instance($cm->id);
+
+    // First get all users who can complete this questionnaire.
+    $cap = 'mod/questionnaire:submit';
+    $fields = 'u.id, u.username';
+    if (!$allusers = get_users_by_capability($context,
+                    $cap,
+                    $fields,
+                    $sort,
+                    '',
+                    '',
+                    $group,
+                    '',
+                    true)) {
+        return false;
+    }
+    $allusers = array_keys($allusers);
+
+    // Nnow get all completed questionnaires.
+    $params = array('survey_id' => $sid, 'complete' => 'y');
+    $sql = "SELECT userid FROM {questionnaire_response} " .
+           "WHERE survey_id = :survey_id AND complete = :complete " .
+           "GROUP BY userid ";
+
+    if (!$completedusers = $DB->get_records_sql($sql, $params)) {
+        return $allusers;
+    }
+    $completedusers = array_keys($completedusers);
+    // Now strike all completedusers from allusers.
+    $allusers = array_diff($allusers, $completedusers);
+    // For paging I use array_slice().
+    if (($startpage !== false) && ($pagecount !== false)) {
+        $allusers = array_slice($allusers, $startpage, $pagecount);
+    }
+    return $allusers;
+}
+
+/**
+ * Called by HTML editor in showrespondents and Essay question. Based on question/essay/renderer.
+ * Pending general solution to using the HTML editor outside of moodleforms in Moodle pages.
+ */
+function questionnaire_get_editor_options($context) {
+    return array(
+                    'subdirs' => 0,
+                    'maxbytes' => 0,
+                    'maxfiles' => -1,
+                    'context' => $context,
+                    'noclean' => 0,
+                    'trusttext' => 0
+    );
+}
+
+// Skip logic: we need to find out how many questions will actually be displayed on next page/section.
+function questionnaire_nb_questions_on_page ($questionsinquestionnaire, $questionsinsection, $rid) {
+    global $DB;
+    $questionstodisplay = array();
+    foreach ($questionsinsection as $question) {
+        if ($question->dependquestion != 0) {
+            switch ($questionsinquestionnaire[$question->dependquestion]->type_id) {
+                case QUESYESNO:
+                    if ($question->dependchoice == 0) {
+                        $questiondependchoice = 'y';
+                    } else {
+                        $questiondependchoice = 'n';
+                    }
+                    $responsetable = 'response_bool';
+                    break;
+                default:
+                    $questiondependchoice = $question->dependchoice;
+                    $responsetable = 'resp_single';
+            }
+            $params = array('response_id' => $rid,
+                            'question_id' => $question->dependquestion,
+                            'choice_id' => $questiondependchoice);
+            if ($DB->record_exists('questionnaire_'.$responsetable, $params)) {
+                $questionstodisplay [] = $question->id;
+            }
+        } else {
+            $questionstodisplay [] = $question->id;
+        }
+    }
+    return $questionstodisplay;
+}
+
+function questionnaire_get_dependencies($questions, $position) {
+    $dependencies = array();
+    $dependencies[''][0] = get_string('choosedots');
+
+    foreach ($questions as $question) {
+        if (($question->type_id == QUESRADIO || $question->type_id == QUESDROP || $question->type_id == QUESYESNO)
+                        && $question->position < $position) {
+            if (($question->type_id == QUESRADIO || $question->type_id == QUESDROP) && $question->name != '') {
+                foreach ($question->choices as $key => $choice) {
+                    $contents = questionnaire_choice_values($choice->content);
+                    if ($contents->modname) {
+                        $choice->content = $contents->modname;
+                    } else if ($contents->title) { // Must be an image; use its title for the dropdown list.
+                        $choice->content = $contents->title;
+                    } else {
+                        $choice->content = $contents->text;
+                    }
+                    $dependencies[$question->name][$question->id.','.$key] = $question->name.'->'.$choice->content;
+                }
+            }
+            if ($question->type_id == QUESYESNO && $question->name != '') {
+                $dependencies[$question->name][$question->id.',0'] = $question->name.'->'.get_string('yes');
+                $dependencies[$question->name][$question->id.',1'] = $question->name.'->'.get_string('no');
+            }
+        }
+    }
+    return $dependencies;
+}
+
+// Get the parent of a child question.
+function questionnaire_get_parent ($question) {
+    global $DB;
+    $qid = $question->id;
+    $parent = array();
+    $dependquestion = $DB->get_record('questionnaire_question', array('id' => $question->dependquestion),
+                    $fields = 'id, position, name, type_id');
+    if (is_object($dependquestion)) {
+        $qdependchoice = '';
+        switch ($dependquestion->type_id) {
+            case QUESRADIO:
+            case QUESDROP:
+                $dependchoice = $DB->get_record('questionnaire_quest_choice', array('id' => $question->dependchoice),
+                    $fields = 'id,content');
+                $qdependchoice = $dependchoice->id;
+                $dependchoice = $dependchoice->content;
+
+                $contents = questionnaire_choice_values($dependchoice);
+                if ($contents->modname) {
+                    $dependchoice = $contents->modname;
+                }
+                break;
+            case QUESYESNO:
+                switch ($question->dependchoice) {
+                    case 0:
+                        $dependchoice = get_string('yes');
+                        $qdependchoice = 'y';
+                        break;
+                    case 1:
+                        $dependchoice = get_string('no');
+                        $qdependchoice = 'n';
+                        break;
+                }
+                break;
+        }
+        // Qdependquestion, parenttype and qdependchoice fields to be used in preview mode.
+        $parent [$qid]['qdependquestion'] = 'q'.$dependquestion->id;
+        $parent [$qid]['qdependchoice'] = $qdependchoice;
+        $parent [$qid]['parenttype'] = $dependquestion->type_id;
+        // Other fields to be used in Questions edit mode.
+        $parent [$qid]['position'] = $question->position;
+        $parent [$qid]['name'] = $question->name;
+        $parent [$qid]['content'] = $question->content;
+        $parent [$qid]['parentposition'] = $dependquestion->position;
+        $parent [$qid]['parent'] = $dependquestion->name.'->'.$dependchoice;
+    }
+    return $parent;
+}
+
+// Get parent position of all child questions in current questionnaire.
+function questionnaire_get_parent_positions ($questions) {
+    $parentpositions = array();
+    foreach ($questions as $question) {
+        $dependquestion = $question->dependquestion;
+        if ($dependquestion != 0) {
+            $childid = $question->id;
+            $parentpos = $questions[$dependquestion]->position;
+            $parentpositions[$childid] = $parentpos;
+        }
+    }
+    return $parentpositions;
+}
+
+// Get child position of all parent questions in current questionnaire.
+function questionnaire_get_child_positions ($questions) {
+    $childpositions = array();
+    foreach ($questions as $question) {
+        $dependquestion = $question->dependquestion;
+        if ($dependquestion != 0) {
+            $parentid = $questions[$dependquestion]->id;
+            if (!isset($firstchildfound[$parentid])) {
+                $firstchildfound[$parentid] = true;
+                $childpos = $question->position;
+                $childpositions[$parentid] = $childpos;
+            }
+        }
+    }
+    return $childpositions;
+}
+
+// Check if current questionnaire contains child questions.
+function questionnaire_has_dependencies($questions) {
+    foreach ($questions as $question) {
+        if ($question->dependquestion != 0) {
+            return true;
+            break;
+        }
+    }
+    return false;
+}
+
+// Check that the needed page breaks are present to separate child questions.
+function questionnaire_check_page_breaks($questionnaire) {
+    global $DB;
+    $msg = '';
+    // Store the new page breaks ids.
+    $newpbids = array();
+    $delpb = 0;
+    $sid = $questionnaire->survey->id;
+    $questions = $DB->get_records('questionnaire_question', array('survey_id' => $sid, 'deleted' => 'n'), 'id');
+    $positions = array();
+    foreach ($questions as $key => $qu) {
+        $positions[$qu->position]['question_id'] = $key;
+        $positions[$qu->position]['dependquestion'] = $qu->dependquestion;
+        $positions[$qu->position]['dependchoice'] = $qu->dependchoice;
+        $positions[$qu->position]['type_id'] = $qu->type_id;
+        $positions[$qu->position]['qname'] = $qu->name;
+        $positions[$qu->position]['qpos'] = $qu->position;
+    }
+    $count = count($positions);
+
+    for ($i = $count; $i > 0; $i--) {
+        $qu = $positions[$i];
+        $questionnb = $i;
+        if ($qu['type_id'] == QUESPAGEBREAK) {
+            $questionnb--;
+            // If more than one consecutive page breaks, remove extra one(s).
+            $prevqu = null;
+            $prevtypeid = null;
+            if ($i > 1) {
+                $prevqu = $positions[$i - 1];
+                $prevtypeid = $prevqu['type_id'];
+            }
+            // If $i == $count then remove that extra page break in last position.
+            if ($prevtypeid == QUESPAGEBREAK || $i == $count || $qu['qpos'] == 1) {
+                $qid = $qu['question_id'];
+                $delpb ++;
+                $msg .= get_string("checkbreaksremoved", "questionnaire", $delpb).'<br />';
+                // Need to reload questions.
+                $questions = $DB->get_records('questionnaire_question', array('survey_id' => $sid, 'deleted' => 'n'), 'id');
+                $DB->set_field('questionnaire_question', 'deleted', 'y', array('id' => $qid, 'survey_id' => $sid));
+                $select = 'survey_id = '.$sid.' AND deleted = \'n\' AND position > '.
+                                $questions[$qid]->position;
+                if ($records = $DB->get_records_select('questionnaire_question', $select, null, 'position ASC')) {
+                    foreach ($records as $record) {
+                        $DB->set_field('questionnaire_question', 'position', $record->position - 1, array('id' => $record->id));
+                    }
+                }
+            }
+        }
+        // Add pagebreak between question child and not dependent question that follows.
+        if ($qu['type_id'] != QUESPAGEBREAK) {
+            $j = $i - 1;
+            if ($j != 0) {
+                $prevtypeid = $positions[$j]['type_id'];
+                $prevdependquestion = $positions[$j]['dependquestion'];
+                $prevdependchoice = $positions[$j]['dependchoice'];
+                if (($prevtypeid != QUESPAGEBREAK && ($prevdependquestion != $qu['dependquestion']
+                                || $prevdependchoice != $qu['dependchoice']))
+                                || ($qu['dependquestion'] == 0 && $prevdependquestion != 0)) {
+                    $sql = 'SELECT MAX(position) as maxpos FROM {questionnaire_question} '.
+                                    'WHERE survey_id = '.$questionnaire->survey->id.' AND deleted = \'n\'';
+                    if ($record = $DB->get_record_sql($sql)) {
+                        $pos = $record->maxpos + 1;
+                    } else {
+                        $pos = 1;
+                    }
+                    $question = new stdClass();
+                    $question->survey_id = $questionnaire->survey->id;
+                    $question->type_id = QUESPAGEBREAK;
+                    $question->position = $pos;
+                    $question->content = 'break';
+                    if (!($newqid = $DB->insert_record('questionnaire_question', $question))) {
+                        return(false);
+                    }
+                    $newpbids[] = $newqid;
+                    $movetopos = $i;
+                    $questionnaire = new questionnaire($questionnaire->id, null, $course, $cm);
+                    $questionnaire->move_question($newqid, $movetopos);
+                }
+            }
+        }
+    }
+    if (empty($newpbids) && !$msg) {
+        $msg = get_string('checkbreaksok', 'questionnaire');
+    } else if ($newpbids) {
+        $msg .= get_string('checkbreaksadded', 'questionnaire').'&nbsp;';
+        $newpbids = array_reverse ($newpbids);
+        $questionnaire = new questionnaire($questionnaire->id, null, $course, $cm);
+        foreach ($newpbids as $newpbid) {
+            $msg .= $questionnaire->questions[$newpbid]->position.'&nbsp;';
+        }
+    }
+    return($msg);
+}
+
+// Get all descendants and choices for questions with descendants.
+function questionnaire_get_descendants_and_choices ($questions) {
+    $questions = array_reverse($questions, true);
+    $qu = array();
+    foreach ($questions as $question) {
+        if ($question->dependquestion) {
+            $dq = $question->dependquestion;
+            $dc = $question->dependchoice;
+            $qid = $question->id;
+
+            $qu['descendants'][$dq][] = 'qn-'.$qid;
+            if (array_key_exists($qid, $qu['descendants'])) {
+                foreach ($qu['descendants'][$qid] as $q) {
+                    $qu['descendants'][$dq][] = $q;
+                }
+            }
+            $qu['choices'][$dq][$dc][] = 'qn-'.$qid;
+        }
+    }
+    return($qu);
+}
+
+// Get all descendants for a question to be deleted.
+function questionnaire_get_descendants ($questions, $questionid) {
+    $questions = array_reverse($questions, true);
+    $qu = array();
+    foreach ($questions as $question) {
+        if ($question->dependquestion) {
+            $dq = $question->dependquestion;
+            $qid = $question->id;
+            $qu[$dq][] = $qid;
+            if (array_key_exists($qid, $qu)) {
+                foreach ($qu[$qid] as $q) {
+                    $qu[$dq][] = $q;
+                }
+            }
+        }
+    }
+    $descendants = array();
+    if (isset($qu[$questionid])) {
+        foreach ($qu[$questionid] as $descendant) {
+            $childquestion = $questions[$descendant];
+            $descendants += questionnaire_get_parent ($childquestion);
+        }
+        uasort($descendants, 'questionnaire_cmp');
+    }
+    return($descendants);
+}
+
+// Function to sort descendants array in questionnaire_get_descendants function.
+function questionnaire_cmp($a, $b) {
+    if ($a == $b) {
+        return 0;
+    } else if ($a < $b) {
+        return -1;
+    } else {
+        return 1;
+    }
+}
+
+/**
+ * Code snippet used to set up the questionform.
+ */
+function questionnaire_prep_for_questionform($questionnaire, $qid, $qtype) {
+    $context = context_module::instance($questionnaire->cm->id);
+    if ($qid != 0) {
+        $question = clone($questionnaire->questions[$qid]);
+        $question->qid = $question->id;
+        $question->sid = $questionnaire->survey->id;
+        $question->id = $questionnaire->cm->id;
+        $draftideditor = file_get_submitted_draft_itemid('question');
+        $content = file_prepare_draft_area($draftideditor, $context->id, 'mod_questionnaire', 'question',
+                                           $qid, array('subdirs' => true), $question->content);
+        $question->content = array('text' => $content, 'format' => FORMAT_HTML, 'itemid' => $draftideditor);
+    } else {
+        $question = \mod_questionnaire\question\base::question_builder($qtype);
+        $question->sid = $questionnaire->survey->id;
+        $question->id = $questionnaire->cm->id;
+        $question->type_id = $qtype;
+        $question->type = '';
+        $draftideditor = file_get_submitted_draft_itemid('question');
+        $content = file_prepare_draft_area($draftideditor, $context->id, 'mod_questionnaire', 'question',
+                                           null, array('subdirs' => true), '');
+        $question->content = array('text' => $content, 'format' => FORMAT_HTML, 'itemid' => $draftideditor);
+    }
+    return $question;
+}
+
+/**
+ * Get the standard page contructs and check for validity.
+ * @param int $id The coursemodule id.
+ * @param int $a  The module instance id.
+ * @return array An array with the $cm, $course, and $questionnaire records in that order.
+ */
+function questionnaire_get_standard_page_items($id = null, $a = null) {
+    global $DB;
+
+    if ($id) {
+        if (! $cm = get_coursemodule_from_id('questionnaire', $id)) {
+            print_error('invalidcoursemodule');
+        }
+
+        if (! $course = $DB->get_record("course", array("id" => $cm->course))) {
+            print_error('coursemisconf');
+        }
+
+        if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $cm->instance))) {
+            print_error('invalidcoursemodule');
+        }
+
+    } else {
+        if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $a))) {
+            print_error('invalidcoursemodule');
+        }
+        if (! $course = $DB->get_record("course", array("id" => $questionnaire->course))) {
+            print_error('coursemisconf');
+        }
+        if (! $cm = get_coursemodule_from_instance("questionnaire", $questionnaire->id, $course->id)) {
+            print_error('invalidcoursemodule');
+        }
+    }
+
+    return (array($cm, $course, $questionnaire));
+}
\ No newline at end of file
diff --git a/mod/questionnaire/mod_form.php b/mod/questionnaire/mod_form.php
new file mode 100644
index 0000000..7b86188
--- /dev/null
+++ b/mod/questionnaire/mod_form.php
@@ -0,0 +1,195 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * print the form to add or edit a questionnaire-instance
+ *
+ * @author Mike Churchward
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package questionnaire
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->dirroot.'/course/moodleform_mod.php');
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+class mod_questionnaire_mod_form extends moodleform_mod {
+
+    protected function definition() {
+        global $COURSE;
+        global $questionnairetypes, $questionnairerespondents, $questionnaireresponseviewers, $autonumbering;
+
+        $questionnaire = new questionnaire($this->_instance, null, $COURSE, $this->_cm);
+
+        $mform    =& $this->_form;
+
+        $mform->addElement('header', 'general', get_string('general', 'form'));
+
+        $mform->addElement('text', 'name', get_string('name', 'questionnaire'), array('size' => '64'));
+        $mform->setType('name', PARAM_TEXT);
+        $mform->addRule('name', null, 'required', null, 'client');
+
+        $this->standard_intro_elements(get_string('description'));
+
+        $mform->addElement('header', 'timinghdr', get_string('timing', 'form'));
+
+        $enableopengroup = array();
+        $enableopengroup[] =& $mform->createElement('checkbox', 'useopendate', get_string('opendate', 'questionnaire'));
+        $enableopengroup[] =& $mform->createElement('date_time_selector', 'opendate', '');
+        $mform->addGroup($enableopengroup, 'enableopengroup', get_string('opendate', 'questionnaire'), ' ', false);
+        $mform->addHelpButton('enableopengroup', 'opendate', 'questionnaire');
+        $mform->disabledIf('enableopengroup', 'useopendate', 'notchecked');
+
+        $enableclosegroup = array();
+        $enableclosegroup[] =& $mform->createElement('checkbox', 'useclosedate', get_string('closedate', 'questionnaire'));
+        $enableclosegroup[] =& $mform->createElement('date_time_selector', 'closedate', '');
+        $mform->addGroup($enableclosegroup, 'enableclosegroup', get_string('closedate', 'questionnaire'), ' ', false);
+        $mform->addHelpButton('enableclosegroup', 'closedate', 'questionnaire');
+        $mform->disabledIf('enableclosegroup', 'useclosedate', 'notchecked');
+
+        $mform->addElement('header', 'questionnairehdr', get_string('responseoptions', 'questionnaire'));
+
+        $mform->addElement('select', 'qtype', get_string('qtype', 'questionnaire'), $questionnairetypes);
+        $mform->addHelpButton('qtype', 'qtype', 'questionnaire');
+
+        $mform->addElement('hidden', 'cannotchangerespondenttype');
+        $mform->setType('cannotchangerespondenttype', PARAM_INT);
+        $mform->addElement('select', 'respondenttype', get_string('respondenttype', 'questionnaire'), $questionnairerespondents);
+        $mform->addHelpButton('respondenttype', 'respondenttype', 'questionnaire');
+        $mform->disabledIf('respondenttype', 'cannotchangerespondenttype', 'eq', 1);
+
+        $mform->addElement('select', 'resp_view', get_string('responseview', 'questionnaire'), $questionnaireresponseviewers);
+        $mform->addHelpButton('resp_view', 'responseview', 'questionnaire');
+
+        $mform->addElement('selectyesno', 'notifications', get_string('notifications', 'questionnaire'));
+        $mform->addHelpButton('notifications', 'notifications', 'questionnaire');
+
+        $options = array('0' => get_string('no'), '1' => get_string('yes'));
+        $mform->addElement('select', 'resume', get_string('resume', 'questionnaire'), $options);
+        $mform->addHelpButton('resume', 'resume', 'questionnaire');
+
+        $options = array('0' => get_string('no'), '1' => get_string('yes'));
+        $mform->addElement('select', 'navigate', get_string('navigate', 'questionnaire'), $options);
+        $mform->addHelpButton('navigate', 'navigate', 'questionnaire');
+
+        $mform->addElement('select', 'autonum', get_string('autonumbering', 'questionnaire'), $autonumbering);
+        $mform->addHelpButton('autonum', 'autonumbering', 'questionnaire');
+        // Default = autonumber both questions and pages.
+        $mform->setDefault('autonum', 3);
+
+        // Removed potential scales from list of grades. CONTRIB-3167.
+        $grades[0] = get_string('nograde');
+        for ($i = 100; $i >= 1; $i--) {
+            $grades[$i] = $i;
+        }
+        $mform->addElement('select', 'grade', get_string('grade', 'questionnaire'), $grades);
+
+        if (empty($questionnaire->sid)) {
+            if (!isset($questionnaire->id)) {
+                $questionnaire->id = 0;
+            }
+
+            $mform->addElement('header', 'contenthdr', get_string('contentoptions', 'questionnaire'));
+            $mform->addHelpButton('contenthdr', 'createcontent', 'questionnaire');
+
+            $mform->addElement('radio', 'create', get_string('createnew', 'questionnaire'), '', 'new-0');
+
+            // Retrieve existing private questionnaires from current course.
+            $surveys = questionnaire_get_survey_select($COURSE->id, 'private');
+            if (!empty($surveys)) {
+                $prelabel = get_string('useprivate', 'questionnaire');
+                foreach ($surveys as $value => $label) {
+                    $mform->addElement('radio', 'create', $prelabel, $label, $value);
+                    $prelabel = '';
+                }
+            }
+            // Retrieve existing template questionnaires from this site.
+            $surveys = questionnaire_get_survey_select($COURSE->id, 'template');
+            if (!empty($surveys)) {
+                $prelabel = get_string('usetemplate', 'questionnaire');
+                foreach ($surveys as $value => $label) {
+                    $mform->addElement('radio', 'create', $prelabel, $label, $value);
+                    $prelabel = '';
+                }
+            } else {
+                $mform->addElement('static', 'usetemplate', get_string('usetemplate', 'questionnaire'),
+                                '('.get_string('notemplatesurveys', 'questionnaire').')');
+            }
+
+            // Retrieve existing public questionnaires from this site.
+            $surveys = questionnaire_get_survey_select($COURSE->id, 'public');
+            if (!empty($surveys)) {
+                $prelabel = get_string('usepublic', 'questionnaire');
+                foreach ($surveys as $value => $label) {
+                    $mform->addElement('radio', 'create', $prelabel, $label, $value);
+                    $prelabel = '';
+                }
+            } else {
+                $mform->addElement('static', 'usepublic', get_string('usepublic', 'questionnaire'),
+                                   '('.get_string('nopublicsurveys', 'questionnaire').')');
+            }
+
+            $mform->setDefault('create', 'new-0');
+        }
+
+        $this->standard_coursemodule_elements();
+
+        // Buttons.
+        $this->add_action_buttons();
+    }
+
+    public function data_preprocessing(&$defaultvalues) {
+        global $DB;
+        if (empty($defaultvalues['opendate'])) {
+            $defaultvalues['useopendate'] = 0;
+        } else {
+            $defaultvalues['useopendate'] = 1;
+        }
+        if (empty($defaultvalues['closedate'])) {
+            $defaultvalues['useclosedate'] = 0;
+        } else {
+            $defaultvalues['useclosedate'] = 1;
+        }
+        // Prevent questionnaire set to "anonymous" to be reverted to "full name".
+        $defaultvalues['cannotchangerespondenttype'] = 0;
+        if (!empty($defaultvalues['respondenttype']) && $defaultvalues['respondenttype'] == "anonymous") {
+            // If this questionnaire has responses.
+            $numresp = $DB->count_records('questionnaire_response',
+                            array('survey_id' => $defaultvalues['sid'], 'complete' => 'y'));
+            if ($numresp) {
+                $defaultvalues['cannotchangerespondenttype'] = 1;
+            }
+        }
+    }
+
+    public function validation($data, $files) {
+        $errors = parent::validation($data, $files);
+        return $errors;
+    }
+
+    public function add_completion_rules() {
+        $mform =& $this->_form;
+        $mform->addElement('checkbox', 'completionsubmit', '', get_string('completionsubmit', 'questionnaire'));
+        return array('completionsubmit');
+    }
+
+    public function completion_rule_enabled($data) {
+        return !empty($data['completionsubmit']);
+    }
+
+}
\ No newline at end of file
diff --git a/mod/questionnaire/module.js b/mod/questionnaire/module.js
new file mode 100644
index 0000000..cd1647d
--- /dev/null
+++ b/mod/questionnaire/module.js
@@ -0,0 +1,240 @@
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * JavaScript library for the quiz module.
+ *
+ * @package    mod
+ * @subpackage questionnaire
+ * @copyright
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+/*
+ * A workaround for MSIE versions < 10 which do not recognize classList. Answer by Paulpro at:
+ * http://stackoverflow.com/questions/6787383/what-is-the-solution-to-remove-add-a-class-in-pure-javascript.
+ * */
+
+function addClass(el, aclass){
+    el.className += ' ' + aclass;
+}
+
+function removeClass(el, aclass){
+    var elClass = ' ' + el.className + ' ';
+    while(elClass.indexOf(' ' + aclass + ' ') != - 1) {
+         elClass = elClass.replace(' ' + aclass + ' ', '');
+    }
+    el.className = elClass;
+}
+// End classList workaround.
+
+/**
+ * Javascript for hiding/displaying children questions on preview page of
+ * questionnaire with conditional branching.
+ */
+
+function depend(children, choices) {
+    children = children.split(',');
+    choices = choices.split(',');
+    var childrenlength = children.length;
+    var choiceslength = choices.length;
+    var child = null;
+    var choice = null;
+    for (var i = 0; i < childrenlength; i++) {
+        child = children[i];
+        var q = document.getElementById(child);
+        if (q) {
+            var radios = q.getElementsByTagName('input');
+            var radiolength = radios.length;
+            var droplists = q.getElementsByTagName('select');
+            var droplistlength = droplists.length;
+            var textareas = q.getElementsByTagName('textarea');
+            var textarealength = textareas.length;
+            for (var k = 0; k < choiceslength; k++) {
+                var j, m, n;
+                choice = choices[k];
+                if (child == choice) {
+                    // If this browser version accepts classList.
+                    if (typeof document !== "undefined" && ("classList" in document.createElement("a"))) {
+                        q.classList.add('qn-container');
+                        // If this browser version DOES NOT accept classList (e.g. MSIE < 10)
+                    } else {
+                        addClass(q, 'qn-container');
+                    }
+                    for (j = 0; j < radiolength; j++) {
+                        var radio = radios[j];
+                        radio.disabled = false;
+                    }
+                    for (m = 0; m < droplistlength; m++) {
+                        var droplist = droplists[m];
+                        droplist.disabled = false;
+                    }
+                    delete children[i];
+                } else if (children[i]){
+                    if (typeof document !== "undefined" && ("classList" in document.createElement("a"))) {
+                        q.classList.remove('qn-container');
+                        q.classList.add('hidedependquestion');
+                    } else {
+                        removeClass(q, 'qn-container');
+                    }
+                    addClass(q, 'hidedependquestion');
+                    for (j = 0; j < radiolength; j++) {
+                        var radio = radios[j];
+                        radio.disabled = true;
+                        radio.checked = false;
+                        radio.value = '';
+                    }
+                    for (m = 0; m < droplistlength; m++) {
+                        var droplist = droplists[m];
+                        droplist.selectedIndex = 0;
+                        droplist.disabled = true;
+                        droplist.checked = false;
+                    }
+                    for (n = 0; n < textarealength; n++) {
+                        var textarea = textareas[n];
+                        textarea.value = '';
+                    }
+                }
+            }
+        }
+    }
+}
+
+/* exported dependdrop */
+
+function dependdrop(qId, children) {
+    var e = document.getElementById(qId);
+    var choice = e.options[e.selectedIndex].value;
+    depend(children, choice);
+}
+// End conditional branching functions.
+
+// When respondent enters text in !other field, corresponding
+// radio button OR check box is automatically checked.
+/* exported other_check */
+function other_check(name) {
+    var other = name.split("_");
+    var f = document.getElementById("phpesp_response");
+    for (var i = 0; i <= f.elements.length; i++) {
+        if (f.elements[i].value == "other_" + other[1]) {
+            f.elements[i].checked = true;
+            break;
+        }
+    }
+}
+
+// Automatically empty an !other text input field if another Radio button is clicked.
+/* exported other_check_empty */
+function other_check_empty(name, value) {
+    var f = document.getElementById("phpesp_response");
+    var i;
+    for (i = 0; i < f.elements.length; i++) {
+        if ((f.elements[i].name == name) && f.elements[i].value.substr(0, 6) == "other_") {
+            f.elements[i].checked = true;
+            var otherid = f.elements[i].name + "_" + f.elements[i].value.substring(6);
+            var other = document.getElementsByName(otherid);
+            if (value.substr(0,6) != "other_") {
+                other[0].value = "";
+            } else {
+                other[0].focus();
+            }
+            var actualbuttons = document.getElementsByName(name);
+            for (i = 0; i <= actualbuttons.length; i++) {
+                if (actualbuttons[i].value == value) {
+                    actualbuttons[i].checked = true;
+                    break;
+                }
+            }
+            break;
+        }
+    }
+}
+
+// In a Rate question type of sub-type Order : automatically uncheck a Radio button
+// when another radio button in the same column is clicked.
+/* exported other_rate_uncheck */
+function other_rate_uncheck(name, value) {
+    var col_name = name.substr(0, name.indexOf("_"));
+    var inputbuttons = document.getElementsByTagName("input");
+    for (var i = 0; i <= inputbuttons.length - 1; i++) {
+        var button = inputbuttons[i];
+        if (button.type == "radio" && button.name != name && button.value == value
+                    && button.name.substr(0, name.indexOf("_")) == col_name) {
+            button.checked = false;
+        }
+    }
+}
+
+// Empty an !other text input when corresponding Check Box is clicked (supposedly to empty it).
+/* exported checkbox_empty */
+function checkbox_empty(name) {
+    var actualbuttons = document.getElementsByName(name);
+    for (var i = 0; i <= actualbuttons.length; i++) {
+        if (actualbuttons[i].value.substr(0, 6) == "other_") {
+            name = name.substring(0, name.length - 2) + actualbuttons[i].value.substring(5);
+            var othertext = document.getElementsByName(name);
+            if (othertext[0].value == "" && actualbuttons[i].checked == true) {
+                othertext[0].focus();
+            } else {
+                othertext[0].value = "";
+            }
+            break;
+        }
+    }
+}
+
+
+M.mod_questionnaire = M.mod_questionnaire || {};
+
+/* exported Y */
+/* exported e */
+M.mod_questionnaire.init_attempt_form = function(Y) {
+    M.core_formchangechecker.init({formid: 'phpesp_response'});
+};
+
+M.mod_questionnaire.init_sendmessage = function(Y) {
+    Y.on('click', function(e) {
+        Y.all('input.usercheckbox').each(function() {
+            this.set('checked', 'checked');
+        });
+    }, '#checkall');
+
+    Y.on('click', function(e) {
+        Y.all('input.usercheckbox').each(function() {
+            this.set('checked', '');
+        });
+    }, '#checknone');
+
+    Y.on('click', function(e) {
+        Y.all('input.usercheckbox').each(function() {
+            if (this.get('alt') == 0) {
+                this.set('checked', 'checked');
+            } else {
+                this.set('checked', '');
+            }
+        });
+    }, '#checknotstarted');
+
+    Y.on('click', function(e) {
+        Y.all('input.usercheckbox').each(function() {
+            if (this.get('alt') == 1) {
+                this.set('checked', 'checked');
+            } else {
+                this.set('checked', '');
+            }
+        });
+    }, '#checkstarted');
+
+};
\ No newline at end of file
diff --git a/mod/questionnaire/myreport.php b/mod/questionnaire/myreport.php
new file mode 100644
index 0000000..9703f9b
--- /dev/null
+++ b/mod/questionnaire/myreport.php
@@ -0,0 +1,284 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+// This page shows results of a questionnaire to a student.
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+$instance = required_param('instance', PARAM_INT);   // Questionnaire ID.
+$userid = optional_param('user', $USER->id, PARAM_INT);
+$rid = optional_param('rid', null, PARAM_INT);
+$byresponse = optional_param('byresponse', 0, PARAM_INT);
+$action = optional_param('action', 'summary', PARAM_ALPHA);
+$currentgroupid = optional_param('group', 0, PARAM_INT); // Groupid.
+
+if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $instance))) {
+    print_error('incorrectquestionnaire', 'questionnaire');
+}
+if (! $course = $DB->get_record("course", array("id" => $questionnaire->course))) {
+    print_error('coursemisconf');
+}
+if (! $cm = get_coursemodule_from_instance("questionnaire", $questionnaire->id, $course->id)) {
+    print_error('invalidcoursemodule');
+}
+
+require_course_login($course, true, $cm);
+$context = context_module::instance($cm->id);
+$questionnaire->canviewallgroups = has_capability('moodle/site:accessallgroups', $context);
+// Should never happen, unless called directly by a snoop...
+if ( !has_capability('mod/questionnaire:readownresponses', $context)
+    || $userid != $USER->id) {
+    print_error('Permission denied');
+}
+$url = new moodle_url($CFG->wwwroot.'/mod/questionnaire/myreport.php', array('instance' => $instance));
+if (isset($userid)) {
+    $url->param('userid', $userid);
+}
+if (isset($byresponse)) {
+    $url->param('byresponse', $byresponse);
+}
+
+if (isset($currentgroupid)) {
+    $url->param('group', $currentgroupid);
+}
+
+if (isset($action)) {
+    $url->param('action', $action);
+}
+
+$PAGE->set_url($url);
+$PAGE->set_context($context);
+$PAGE->set_title(get_string('questionnairereport', 'questionnaire'));
+$PAGE->set_heading(format_string($course->fullname));
+
+$questionnaire = new questionnaire(0, $questionnaire, $course, $cm);
+// Add renderer and page objects to the questionnaire object for display use.
+$questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+$questionnaire->add_page(new \mod_questionnaire\output\reportpage());
+
+$sid = $questionnaire->survey->id;
+$courseid = $course->id;
+
+// Tab setup.
+if (!isset($SESSION->questionnaire)) {
+    $SESSION->questionnaire = new stdClass();
+}
+$SESSION->questionnaire->current_tab = 'myreport';
+
+switch ($action) {
+    case 'summary':
+        if (empty($questionnaire->survey)) {
+            print_error('surveynotexists', 'questionnaire');
+        }
+        $SESSION->questionnaire->current_tab = 'mysummary';
+        $params = ['survey_id' => $questionnaire->sid, 'userid' => $userid, 'complete' => 'y'];
+        $resps = $DB->get_records('questionnaire_response', $params);
+        $rids = array_keys($resps);
+        if (count($resps) > 1) {
+            $titletext = get_string('myresponsetitle', 'questionnaire', count($resps));
+        } else {
+            $titletext = get_string('yourresponse', 'questionnaire');
+        }
+
+        // Print the page header.
+        echo $questionnaire->renderer->header();
+
+        // Print the tabs.
+        include('tabs.php');
+
+        $questionnaire->page->add_to_page('myheaders', $titletext);
+        $questionnaire->survey_results(1, 1, '', '', $rids, $USER->id);
+
+        echo $questionnaire->renderer->render($questionnaire->page);
+
+        // Finish the page.
+        echo $questionnaire->renderer->footer($course);
+        break;
+
+    case 'vall':
+        if (empty($questionnaire->survey)) {
+            print_error('surveynotexists', 'questionnaire');
+        }
+        $SESSION->questionnaire->current_tab = 'myvall';
+        $params = ['survey_id' => $questionnaire->sid, 'userid' => $userid, 'complete' => 'y'];
+        $resps = $DB->get_records('questionnaire_response', $params, 'submitted ASC');
+        $titletext = get_string('myresponses', 'questionnaire');
+
+        // Print the page header.
+        echo $questionnaire->renderer->header();
+
+        // Print the tabs.
+        include('tabs.php');
+
+        $questionnaire->page->add_to_page('myheaders', $titletext);
+        $questionnaire->view_all_responses($resps);
+        echo $questionnaire->renderer->render($questionnaire->page);
+        // Finish the page.
+        echo $questionnaire->renderer->footer($course);
+        break;
+
+    case 'vresp':
+        if (empty($questionnaire->survey)) {
+            print_error('surveynotexists', 'questionnaire');
+        }
+        $SESSION->questionnaire->current_tab = 'mybyresponse';
+        $usergraph = get_config('questionnaire', 'usergraph');
+        if ($usergraph) {
+            $charttype = $questionnaire->survey->chart_type;
+            if ($charttype) {
+                $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.common.core.js');
+
+                switch ($charttype) {
+                    case 'bipolar':
+                        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.bipolar.js');
+                        break;
+                    case 'hbar':
+                        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.hbar.js');
+                        break;
+                    case 'radar':
+                        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.radar.js');
+                        break;
+                    case 'rose':
+                        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.rose.js');
+                        break;
+                    case 'vprogress':
+                        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.vprogress.js');
+                        break;
+                }
+            }
+        }
+        $params = ['survey_id' => $questionnaire->sid, 'userid' => $userid, 'complete' => 'y'];
+        $resps = $DB->get_records('questionnaire_response', $params, 'submitted ASC');
+
+        // All participants.
+        $params = ['survey_id' => $sid, 'complete' => 'y'];
+        $fields = 'id,survey_id,submitted,userid';
+        $respsallparticipants = $DB->get_records('questionnaire_response', $params, 'id', $fields);
+
+        $params = ['survey_id' => $questionnaire->sid, 'userid' => $userid, 'complete' => 'y'];
+        $fields = 'id,survey_id,submitted,userid';
+        $respsuser = $DB->get_records('questionnaire_response', $params, '', $fields);
+
+        $SESSION->questionnaire->numrespsallparticipants = count($respsallparticipants);
+        $SESSION->questionnaire->numselectedresps = $SESSION->questionnaire->numrespsallparticipants;
+        $iscurrentgroupmember = false;
+
+        // Available group modes (0 = no groups; 1 = separate groups; 2 = visible groups).
+        $groupmode = groups_get_activity_groupmode($cm, $course);
+        if ($groupmode > 0) {
+            // Check if current user is member of any group.
+            $usergroups = groups_get_user_groups($courseid, $userid);
+            $isgroupmember = count($usergroups[0]) > 0;
+            // Check if current user is member of current group.
+            $iscurrentgroupmember = groups_is_member($currentgroupid, $userid);
+
+            if ($groupmode == 1) {
+                $questionnairegroups = groups_get_all_groups($course->id, $userid);
+            }
+            if ($groupmode == 2 || $questionnaire->canviewallgroups) {
+                $questionnairegroups = groups_get_all_groups($course->id);
+            }
+
+            if (!empty($questionnairegroups)) {
+                $groupscount = count($questionnairegroups);
+                foreach ($questionnairegroups as $key) {
+                    $firstgroupid = $key->id;
+                    break;
+                }
+                if ($groupscount === 0 && $groupmode == 1) {
+                    $currentgroupid = 0;
+                }
+                if ($groupmode == 1 && !$questionnaire->canviewallgroups && $currentgroupid == 0) {
+                    $currentgroupid = $firstgroupid;
+                }
+                // If currentgroup is All Participants, current user is of course member of that "group"!
+                if ($currentgroupid == 0) {
+                    $iscurrentgroupmember = true;
+                }
+                // Current group members.
+                $sql = 'SELECT r.id, r.survey_id, r.submitted, r.userid '.
+                       'FROM {questionnaire_response} r, {groups_members} gm '.
+                       'WHERE r.survey_id = ? AND r.complete = \'y\' AND gm.groupid = ? AND r.userid = gm.userid '.
+                       'ORDER BY r.id';
+                $currentgroupresps = $DB->get_records_sql($sql, [$sid, $currentgroupid]);
+
+            } else {
+                // Groupmode = separate groups but user is not member of any group
+                // and does not have moodle/site:accessallgroups capability -> refuse view responses.
+                if (!$questionnaire->canviewallgroups) {
+                    $currentgroupid = 0;
+                }
+            }
+
+            if ($currentgroupid > 0) {
+                $groupname = get_string('group').' <strong>'.groups_get_group_name($currentgroupid).'</strong>';
+            } else {
+                $groupname = '<strong>'.get_string('allparticipants').'</strong>';
+            }
+        }
+
+        $rids = array_keys($resps);
+        if (!$rid) {
+            // If more than one response for this respondent, display most recent response.
+            $rid = end($rids);
+        }
+        $numresp = count($rids);
+        if ($numresp > 1) {
+            $titletext = get_string('myresponsetitle', 'questionnaire', $numresp);
+        } else {
+            $titletext = get_string('yourresponse', 'questionnaire');
+        }
+
+        $compare = false;
+        // Print the page header.
+        echo $questionnaire->renderer->header();
+
+        // Print the tabs.
+        include('tabs.php');
+        $questionnaire->page->add_to_page('myheaders', $titletext);
+
+        if (count($resps) > 1) {
+            $userresps = $resps;
+            $questionnaire->survey_results_navbar_student ($rid, $userid, $instance, $userresps);
+        }
+        $resps = array();
+        // Determine here which "global" responses should get displayed for comparison with current user.
+        // Current user is viewing his own group's results.
+        if (isset($currentgroupresps)) {
+            $resps = $currentgroupresps;
+        }
+
+        // Current user is viewing another group's results so we must add their own results to that group's results.
+
+        if (!$iscurrentgroupmember) {
+            $resps += $respsuser;
+        }
+        // No groups.
+        if ($groupmode == 0 || $currentgroupid == 0) {
+            $resps = $respsallparticipants;
+        }
+        $compare = true;
+        $questionnaire->view_response($rid, null, null, $resps, $compare, $iscurrentgroupmember, false, $currentgroupid);
+        // Finish the page.
+        echo $questionnaire->renderer->render($questionnaire->page);
+        echo $questionnaire->renderer->footer($course);
+        break;
+
+    case get_string('return', 'questionnaire'):
+    default:
+        redirect('view.php?id='.$cm->id);
+}
diff --git a/mod/questionnaire/pix/icon.gif b/mod/questionnaire/pix/icon.gif
new file mode 100644
index 0000000000000000000000000000000000000000..2f7b2aa5778a5ebc10ddb2ae2b2512bab1da6be9
GIT binary patch
literal 897
zcmchWF>94!424gn#j8^tT+~JAA_xw##o{6eRiU7C(Lu$FlF7mUps0&>69Q7ip^gf+
zP7W11C<IY(a&r;g+|(&Pd4Gf%K5j^Ia?Z(n&s|tKwLG2Iynaj7kyTOURaT|WGApCf
zE3HypjI4+XudoVruV;Cbd%2aXM=i^u%*(7yAeFKdB`;Zt1Z<$eVwi6Ao{q@$Ov_ZS
zC5y=L49ifnpy-kA>6Wf0MXyDgr&*fd$Y?53p0X5MVGS6hVF@j2ECw5BuozYg>YVTh
zi%{!hEtz|`g{$Slf}(ktg$ebLqBrCr3n33bpvg3LpdS(_gf(E0h9#}=U@_Q0gQa$^
z%jAT)tBph-Yst*qgs;ej1x1&+@DZmm0A93XG-|ODKcLApcEAb2D1<d&kY*BE@L)06
zK&wyG-IU1*aWRZUA8W}>{W#j!aqljU6SmFcD&0GbZr6u*Jv!{@BMgO&G)VVN29E|F
z&^!mOgn4LUm9(`rUgP-v|2{|m&dx|*b-Y*he?pV%+P-%9{Hteg?oM9LTzP-z+nIZN
z4=(L~pWj)0xc}Imoz2fTb{`#CTzdQGz^$|Q7v?su#@cjACvHApoxI*$eQ@&f<NR=G
g;p6(D<&E3>)_#0?y0ZS{%g<lacP}n(&&}%eKT7p=vH$=8

literal 0
HcmV?d00001

diff --git a/mod/questionnaire/pix/icon.svg b/mod/questionnaire/pix/icon.svg
new file mode 100644
index 0000000..358bd83
--- /dev/null
+++ b/mod/questionnaire/pix/icon.svg
@@ -0,0 +1,668 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Generator: Adobe Illustrator 15.1.0, SVG Export Plug-In  -->
+
+<svg
+   xmlns:a="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   version="1.1"
+   x="0px"
+   y="0px"
+   width="24px"
+   height="24px"
+   viewBox="0 0 24 24"
+   style="overflow:visible;enable-background:new 0 0 24 24;"
+   xml:space="preserve"
+   preserveAspectRatio="xMinYMid meet"
+   id="svg2"
+   inkscape:version="0.48.2 r9819"
+   sodipodi:docname="icon.svg"><metadata
+   id="metadata82"><rdf:RDF><cc:Work
+       rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type
+         rdf:resource="http://purl.org/dc/dcmitype/StillImage" /><dc:title></dc:title></cc:Work></rdf:RDF></metadata><sodipodi:namedview
+   pagecolor="#ffffff"
+   bordercolor="#666666"
+   borderopacity="1"
+   objecttolerance="10"
+   gridtolerance="10"
+   guidetolerance="10"
+   inkscape:pageopacity="0"
+   inkscape:pageshadow="2"
+   inkscape:window-width="1280"
+   inkscape:window-height="977"
+   id="namedview80"
+   showgrid="false"
+   inkscape:zoom="7.1541341"
+   inkscape:cx="5.8625098"
+   inkscape:cy="10.396588"
+   inkscape:window-x="-4"
+   inkscape:window-y="-4"
+   inkscape:window-maximized="1"
+   inkscape:current-layer="svg2"
+   showguides="true"
+   inkscape:guide-bbox="true"><sodipodi:guide
+     orientation="1,0"
+     position="-5.8707314,12.719918"
+     id="guide4399" /></sodipodi:namedview>
+<defs
+   id="defs4">
+<linearGradient
+   id="SVGID_8_-1"
+   gradientUnits="userSpaceOnUse"
+   x1="7.2484999"
+   y1="14.7998"
+   x2="7.2484999"
+   y2="20.8174"><stop
+     offset="0"
+     style="stop-color:#F17219"
+     id="stop74-7" /><stop
+     offset="1"
+     style="stop-color:#EA5B03"
+     id="stop76-4" /><a:midPointStop
+     offset="0"
+     style="stop-color:#F17219" /><a:midPointStop
+     offset="0.5"
+     style="stop-color:#F17219" /><a:midPointStop
+     offset="1"
+     style="stop-color:#EA5B03" /></linearGradient><linearGradient
+   id="SVGID_7_-0"
+   gradientUnits="userSpaceOnUse"
+   x1="9.5522003"
+   y1="9.0078001"
+   x2="9.5522003"
+   y2="22.383301"><stop
+     offset="0"
+     style="stop-color:#F6A55E"
+     id="stop65-9" /><stop
+     offset="1"
+     style="stop-color:#EA5B03"
+     id="stop67-4" /><a:midPointStop
+     offset="0"
+     style="stop-color:#F6A55E" /><a:midPointStop
+     offset="0.5"
+     style="stop-color:#F6A55E" /><a:midPointStop
+     offset="1"
+     style="stop-color:#EA5B03" /></linearGradient><linearGradient
+   id="SVGID_6_-8"
+   gradientUnits="userSpaceOnUse"
+   x1="11.8569"
+   y1="1.8521"
+   x2="11.8569"
+   y2="23.9487"><stop
+     offset="0"
+     style="stop-color:#DB6D17"
+     id="stop56-8" /><stop
+     offset="1"
+     style="stop-color:#BF3B08"
+     id="stop58-2" /><a:midPointStop
+     offset="0"
+     style="stop-color:#DB6D17" /><a:midPointStop
+     offset="0.5"
+     style="stop-color:#DB6D17" /><a:midPointStop
+     offset="1"
+     style="stop-color:#BF3B08" /></linearGradient><linearGradient
+   id="SVGID_5_-4"
+   gradientUnits="userSpaceOnUse"
+   x1="14.2793"
+   y1="7.5448999"
+   x2="17.4074"
+   y2="4.4168"
+   gradientTransform="translate(29.946611,-0.10169459)"><stop
+     offset="0"
+     style="stop-color:#E7F4FC"
+     id="stop39-5" /><stop
+     offset="0.5181"
+     style="stop-color:#E5F3FC"
+     id="stop41-5" /><stop
+     offset="0.7045"
+     style="stop-color:#DEF0FB"
+     id="stop43-1" /><stop
+     offset="0.8371"
+     style="stop-color:#D3EBFA"
+     id="stop45-7" /><stop
+     offset="0.872"
+     style="stop-color:#CEE9F9"
+     id="stop47-1" /><stop
+     offset="1"
+     style="stop-color:#BDD8F0"
+     id="stop49-1" /><a:midPointStop
+     offset="0"
+     style="stop-color:#E7F4FC" /><a:midPointStop
+     offset="0.87"
+     style="stop-color:#E7F4FC" /><a:midPointStop
+     offset="0.872"
+     style="stop-color:#CEE9F9" /><a:midPointStop
+     offset="0.5"
+     style="stop-color:#CEE9F9" /><a:midPointStop
+     offset="1"
+     style="stop-color:#BDD8F0" /></linearGradient><linearGradient
+   id="SVGID_4_-5"
+   gradientUnits="userSpaceOnUse"
+   x1="17.202101"
+   y1="0"
+   x2="17.202101"
+   y2="9.3593998"
+   gradientTransform="translate(29.946611,-0.10169459)"><stop
+     offset="0"
+     style="stop-color:#95BFF8"
+     id="stop30-2" /><stop
+     offset="0.5569"
+     style="stop-color:#84ADEF"
+     id="stop32-7" /><stop
+     offset="1"
+     style="stop-color:#7CA4EB"
+     id="stop34-6" /><a:midPointStop
+     offset="0"
+     style="stop-color:#95BFF8" /><a:midPointStop
+     offset="0.4"
+     style="stop-color:#95BFF8" /><a:midPointStop
+     offset="1"
+     style="stop-color:#7CA4EB" /></linearGradient><linearGradient
+   id="SVGID_3_-1"
+   gradientUnits="userSpaceOnUse"
+   x1="11.9565"
+   y1="2"
+   x2="11.9565"
+   y2="22.0005"><stop
+     offset="0"
+     style="stop-color:#CEE9F9"
+     id="stop23-4" /><stop
+     offset="1"
+     style="stop-color:#BBDFF8"
+     id="stop25-2" /><a:midPointStop
+     offset="0"
+     style="stop-color:#CEE9F9" /><a:midPointStop
+     offset="0.5"
+     style="stop-color:#CEE9F9" /><a:midPointStop
+     offset="1"
+     style="stop-color:#BBDFF8" /></linearGradient><linearGradient
+   id="SVGID_2_-3"
+   gradientUnits="userSpaceOnUse"
+   x1="11.9565"
+   y1="1"
+   x2="11.9565"
+   y2="23.0005"><stop
+     offset="0"
+     style="stop-color:#E7F4FC"
+     id="stop16-2" /><stop
+     offset="1"
+     style="stop-color:#DEEFFC"
+     id="stop18-2" /><a:midPointStop
+     offset="0"
+     style="stop-color:#E7F4FC" /><a:midPointStop
+     offset="0.5"
+     style="stop-color:#E7F4FC" /><a:midPointStop
+     offset="1"
+     style="stop-color:#DEEFFC" /></linearGradient><linearGradient
+   id="SVGID_1_-1"
+   gradientUnits="userSpaceOnUse"
+   x1="11.9565"
+   y1="0"
+   x2="11.9565"
+   y2="24.0005"><stop
+     offset="0"
+     style="stop-color:#95BFF8"
+     id="stop7-6" /><stop
+     offset="0.5569"
+     style="stop-color:#84ADEF"
+     id="stop9-8" /><stop
+     offset="1"
+     style="stop-color:#7CA4EB"
+     id="stop11-5" /><a:midPointStop
+     offset="0"
+     style="stop-color:#95BFF8" /><a:midPointStop
+     offset="0.4"
+     style="stop-color:#95BFF8" /><a:midPointStop
+     offset="1"
+     style="stop-color:#7CA4EB" /></linearGradient><linearGradient
+   y2="24.0005"
+   x2="11.9565"
+   y1="0"
+   x1="11.9565"
+   gradientUnits="userSpaceOnUse"
+   id="linearGradient3128"
+   xlink:href="#SVGID_1_-1"
+   inkscape:collect="always" /><linearGradient
+   id="SVGID_6_-8-2"
+   gradientUnits="userSpaceOnUse"
+   x1="11.8569"
+   y1="1.8521"
+   x2="11.8569"
+   y2="23.9487"><stop
+     offset="0"
+     style="stop-color:#DB6D17"
+     id="stop56-8-9" /><stop
+     offset="1"
+     style="stop-color:#BF3B08"
+     id="stop58-2-1" /><a:midPointStop
+     offset="0"
+     style="stop-color:#DB6D17" /><a:midPointStop
+     offset="0.5"
+     style="stop-color:#DB6D17" /><a:midPointStop
+     offset="1"
+     style="stop-color:#BF3B08" /></linearGradient><linearGradient
+   id="SVGID_7_-0-3"
+   gradientUnits="userSpaceOnUse"
+   x1="9.5522003"
+   y1="9.0078001"
+   x2="9.5522003"
+   y2="22.383301"><stop
+     offset="0"
+     style="stop-color:#F6A55E"
+     id="stop65-9-5" /><stop
+     offset="1"
+     style="stop-color:#EA5B03"
+     id="stop67-4-9" /><a:midPointStop
+     offset="0"
+     style="stop-color:#F6A55E" /><a:midPointStop
+     offset="0.5"
+     style="stop-color:#F6A55E" /><a:midPointStop
+     offset="1"
+     style="stop-color:#EA5B03" /></linearGradient><linearGradient
+   id="SVGID_8_-1-8"
+   gradientUnits="userSpaceOnUse"
+   x1="7.2484999"
+   y1="14.7998"
+   x2="7.2484999"
+   y2="20.8174"><stop
+     offset="0"
+     style="stop-color:#F17219"
+     id="stop74-7-4" /><stop
+     offset="1"
+     style="stop-color:#EA5B03"
+     id="stop76-4-0" /><a:midPointStop
+     offset="0"
+     style="stop-color:#F17219" /><a:midPointStop
+     offset="0.5"
+     style="stop-color:#F17219" /><a:midPointStop
+     offset="1"
+     style="stop-color:#EA5B03" /></linearGradient><linearGradient
+   y2="20.8174"
+   x2="7.2484999"
+   y1="14.7998"
+   x1="7.2484999"
+   gradientUnits="userSpaceOnUse"
+   id="linearGradient3121"><stop
+     id="stop3123"
+     style="stop-color:#F17219"
+     offset="0" /><stop
+     id="stop3125"
+     style="stop-color:#EA5B03"
+     offset="1" /><a:midPointStop
+     style="stop-color:#F17219"
+     offset="0" /><a:midPointStop
+     style="stop-color:#F17219"
+     offset="0.5" /><a:midPointStop
+     style="stop-color:#EA5B03"
+     offset="1" /></linearGradient><linearGradient
+   y2="22.383301"
+   x2="9.5522003"
+   y1="9.0078001"
+   x1="9.5522003"
+   gradientUnits="userSpaceOnUse"
+   id="linearGradient3113"><stop
+     id="stop3115"
+     style="stop-color:#F6A55E"
+     offset="0" /><stop
+     id="stop3117"
+     style="stop-color:#EA5B03"
+     offset="1" /><a:midPointStop
+     style="stop-color:#F6A55E"
+     offset="0" /><a:midPointStop
+     style="stop-color:#F6A55E"
+     offset="0.5" /><a:midPointStop
+     style="stop-color:#EA5B03"
+     offset="1" /></linearGradient><linearGradient
+   y2="23.9487"
+   x2="11.8569"
+   y1="1.8521"
+   x1="11.8569"
+   gradientUnits="userSpaceOnUse"
+   id="linearGradient3105"><stop
+     id="stop3107"
+     style="stop-color:#DB6D17"
+     offset="0" /><stop
+     id="stop3109"
+     style="stop-color:#BF3B08"
+     offset="1" /><a:midPointStop
+     style="stop-color:#DB6D17"
+     offset="0" /><a:midPointStop
+     style="stop-color:#DB6D17"
+     offset="0.5" /><a:midPointStop
+     style="stop-color:#BF3B08"
+     offset="1" /></linearGradient><linearGradient
+   inkscape:collect="always"
+   xlink:href="#SVGID_1_"
+   id="linearGradient4548"
+   gradientUnits="userSpaceOnUse"
+   x1="11.9565"
+   y1="0"
+   x2="11.9565"
+   y2="24.0005" /><linearGradient
+   inkscape:collect="always"
+   xlink:href="#SVGID_2_"
+   id="linearGradient4550"
+   gradientUnits="userSpaceOnUse"
+   x1="11.9565"
+   y1="1"
+   x2="11.9565"
+   y2="23.0005" /><linearGradient
+   inkscape:collect="always"
+   xlink:href="#SVGID_3_"
+   id="linearGradient4552"
+   gradientUnits="userSpaceOnUse"
+   x1="11.9565"
+   y1="2"
+   x2="11.9565"
+   y2="22.0005" /><linearGradient
+   inkscape:collect="always"
+   xlink:href="#SVGID_4_"
+   id="linearGradient4554"
+   gradientUnits="userSpaceOnUse"
+   x1="17.2021"
+   y1="0"
+   x2="17.2021"
+   y2="9.3594" /><linearGradient
+   inkscape:collect="always"
+   xlink:href="#SVGID_5_"
+   id="linearGradient4556"
+   gradientUnits="userSpaceOnUse"
+   x1="14.2793"
+   y1="7.5449"
+   x2="17.4074"
+   y2="4.4168" /><linearGradient
+   inkscape:collect="always"
+   xlink:href="#SVGID_6_"
+   id="linearGradient4558"
+   gradientUnits="userSpaceOnUse"
+   x1="11.8569"
+   y1="1.8521"
+   x2="11.8569"
+   y2="23.9487" /><linearGradient
+   inkscape:collect="always"
+   xlink:href="#SVGID_7_"
+   id="linearGradient4560"
+   gradientUnits="userSpaceOnUse"
+   x1="9.5522"
+   y1="9.0078"
+   x2="9.5522"
+   y2="22.3833" /><linearGradient
+   inkscape:collect="always"
+   xlink:href="#SVGID_8_"
+   id="linearGradient4562"
+   gradientUnits="userSpaceOnUse"
+   x1="7.2485"
+   y1="14.7998"
+   x2="7.2485"
+   y2="20.8174" /></defs>
+<linearGradient
+   id="SVGID_1_"
+   gradientUnits="userSpaceOnUse"
+   x1="11.9565"
+   y1="0"
+   x2="11.9565"
+   y2="24.0005">
+	<stop
+   offset="0"
+   style="stop-color:#95BFF8"
+   id="stop7" />
+	<stop
+   offset="0.5569"
+   style="stop-color:#84ADEF"
+   id="stop9" />
+	<stop
+   offset="1"
+   style="stop-color:#7CA4EB"
+   id="stop11" />
+	<a:midPointStop
+   offset="0"
+   style="stop-color:#95BFF8" />
+	<a:midPointStop
+   offset="0.4"
+   style="stop-color:#95BFF8" />
+	<a:midPointStop
+   offset="1"
+   style="stop-color:#7CA4EB" />
+</linearGradient>
+
+<linearGradient
+   id="SVGID_2_"
+   gradientUnits="userSpaceOnUse"
+   x1="11.9565"
+   y1="1"
+   x2="11.9565"
+   y2="23.0005">
+	<stop
+   offset="0"
+   style="stop-color:#E7F4FC"
+   id="stop16" />
+	<stop
+   offset="1"
+   style="stop-color:#DEEFFC"
+   id="stop18" />
+	<a:midPointStop
+   offset="0"
+   style="stop-color:#E7F4FC" />
+	<a:midPointStop
+   offset="0.5"
+   style="stop-color:#E7F4FC" />
+	<a:midPointStop
+   offset="1"
+   style="stop-color:#DEEFFC" />
+</linearGradient>
+
+<linearGradient
+   id="SVGID_3_"
+   gradientUnits="userSpaceOnUse"
+   x1="11.9565"
+   y1="2"
+   x2="11.9565"
+   y2="22.0005">
+	<stop
+   offset="0"
+   style="stop-color:#CEE9F9"
+   id="stop23" />
+	<stop
+   offset="1"
+   style="stop-color:#BBDFF8"
+   id="stop25" />
+	<a:midPointStop
+   offset="0"
+   style="stop-color:#CEE9F9" />
+	<a:midPointStop
+   offset="0.5"
+   style="stop-color:#CEE9F9" />
+	<a:midPointStop
+   offset="1"
+   style="stop-color:#BBDFF8" />
+</linearGradient>
+
+<linearGradient
+   id="SVGID_4_"
+   gradientUnits="userSpaceOnUse"
+   x1="17.2021"
+   y1="0"
+   x2="17.2021"
+   y2="9.3594">
+	<stop
+   offset="0"
+   style="stop-color:#95BFF8"
+   id="stop30" />
+	<stop
+   offset="0.5569"
+   style="stop-color:#84ADEF"
+   id="stop32" />
+	<stop
+   offset="1"
+   style="stop-color:#7CA4EB"
+   id="stop34" />
+	<a:midPointStop
+   offset="0"
+   style="stop-color:#95BFF8" />
+	<a:midPointStop
+   offset="0.4"
+   style="stop-color:#95BFF8" />
+	<a:midPointStop
+   offset="1"
+   style="stop-color:#7CA4EB" />
+</linearGradient>
+
+<linearGradient
+   id="SVGID_5_"
+   gradientUnits="userSpaceOnUse"
+   x1="14.2793"
+   y1="7.5449"
+   x2="17.4074"
+   y2="4.4168">
+	<stop
+   offset="0"
+   style="stop-color:#E7F4FC"
+   id="stop39" />
+	<stop
+   offset="0.5181"
+   style="stop-color:#E5F3FC"
+   id="stop41" />
+	<stop
+   offset="0.7045"
+   style="stop-color:#DEF0FB"
+   id="stop43" />
+	<stop
+   offset="0.8371"
+   style="stop-color:#D3EBFA"
+   id="stop45" />
+	<stop
+   offset="0.872"
+   style="stop-color:#CEE9F9"
+   id="stop47" />
+	<stop
+   offset="1"
+   style="stop-color:#BDD8F0"
+   id="stop49" />
+	<a:midPointStop
+   offset="0"
+   style="stop-color:#E7F4FC" />
+	<a:midPointStop
+   offset="0.87"
+   style="stop-color:#E7F4FC" />
+	<a:midPointStop
+   offset="0.872"
+   style="stop-color:#CEE9F9" />
+	<a:midPointStop
+   offset="0.5"
+   style="stop-color:#CEE9F9" />
+	<a:midPointStop
+   offset="1"
+   style="stop-color:#BDD8F0" />
+</linearGradient>
+
+
+
+
+<g
+   id="g4497"
+   transform="translate(-30.047027,0.0988389)"><polygon
+     transform="translate(29.946611,-0.10169459)"
+     id="polygon13-7"
+     points="22,24 22,7.9 14.4,0 13.4,0 3,0 2,0 2,24 3,24 21,24 "
+     style="fill:url(#linearGradient3128);overflow:visible" /><polygon
+     transform="translate(29.946611,-0.10169459)"
+     id="polygon20-6"
+     points="21,23 21,8.3 14,1 13,1 4,1 3,1 3,23 4,23 20,23 "
+     style="fill:url(#SVGID_2_-3);overflow:visible" /><polygon
+     transform="translate(29.946611,-0.10169459)"
+     id="polygon27-1"
+     points="20,22 20,8.7 13.6,2 12.6,2 5,2 4,2 4,22 5,22 19,22 "
+     style="fill:url(#SVGID_3_-1);overflow:visible" /><path
+     id="path36-8"
+     d="m 42.946611,8.8983054 c 0,0 5.2,-1.5 9,0.4 0,-0.1 0,-1.5 0,-1.5 l -7.6,-7.89999999 c 0,0 -1.8,0 -2,0 2.7,3.69999999 0.6,8.99999999 0.6,8.99999999 z"
+     style="fill:url(#SVGID_4_-5);overflow:visible"
+     inkscape:connector-curvature="0" /><path
+     id="path51-9"
+     d="m 50.346611,7.6983054 c -0.9,-0.2 -2,-0.3 -3.1,-0.3 -1.1,0 -2.1,0.1 -3,0.3 0.4,-1.6 0.7,-4.1 -0.2,-6.4 l 6.3,6.4 z"
+     style="fill:url(#SVGID_5_-4);overflow:visible"
+     inkscape:connector-curvature="0" /><g
+     id="g4367"><polygon
+       id="polygon60-7"
+       points="8,16.9 3.2,11.9 0,15.1 8.8,23.9 23.7,1.9 "
+       style="fill:#000080"
+       transform="matrix(0.33436055,0,0,0.33436055,34.681896,2.790139)" /><polygon
+       id="polygon69-5"
+       points="1.4,15.1 3.2,13.4 7.9,18.4 17.7,9 8.7,22.4 "
+       style="fill:#9191ff;fill-opacity:1"
+       transform="matrix(0.33436055,0,0,0.33436055,34.681896,2.790139)" /><polygon
+       id="polygon78-3"
+       points="2.8,15.1 3.1,14.8 7.9,19.8 11.7,16.2 8.5,20.8 "
+       style="fill:#3236be;fill-opacity:1"
+       transform="matrix(0.33436055,0,0,0.33436055,34.681896,2.790139)" /></g><g
+     id="g4367-1"
+     style="overflow:visible"
+     transform="translate(-0.021679,10.586581)"><polygon
+       id="polygon60-7-6"
+       points="23.7,1.9 8,16.9 3.2,11.9 0,15.1 8.8,23.9 "
+       style="fill:#000080"
+       transform="matrix(0.33436055,0,0,0.33436055,34.681896,2.790139)" /><polygon
+       id="polygon69-5-5"
+       points="8.7,22.4 1.4,15.1 3.2,13.4 7.9,18.4 17.7,9 "
+       style="fill:#9191ff;fill-opacity:1"
+       transform="matrix(0.33436055,0,0,0.33436055,34.681896,2.790139)" /><polygon
+       id="polygon78-3-7"
+       points="8.5,20.8 2.8,15.1 3.1,14.8 7.9,19.8 11.7,16.2 "
+       style="fill:#3236be;fill-opacity:1"
+       transform="matrix(0.33436055,0,0,0.33436055,34.681896,2.790139)" /></g><rect
+     y="12.610169"
+     x="35.084747"
+     height="2.0338984"
+     width="0.81355929"
+     id="rect4401"
+     style="fill:#000000;fill-opacity:0;stroke:none" /><g
+     transform="translate(0.03595458,0.32359124)"
+     id="g4483"><g
+       id="g4433"
+       transform="translate(0.07190916,0.08325071)"><path
+         inkscape:connector-curvature="0"
+         id="rect4403"
+         d="m 34.5625,11.5 0,2.685476 0.8125,0 0,-2.685476 -0.8125,0 z"
+         style="fill:#ff0000;fill-opacity:1;stroke:none" /><path
+         inkscape:connector-curvature="0"
+         id="rect4403-7"
+         d="m 34.75733,11.763024 0,2.182112 0.381046,0 0,-2.182112 -0.381046,0 z"
+         style="fill:#ff5f5f;fill-opacity:1;stroke:none;overflow:visible" /></g><g
+       transform="translate(4.5712513,0.08325071)"
+       style="overflow:visible"
+       id="g4433-8"><path
+         inkscape:connector-curvature="0"
+         id="rect4403-3"
+         d="m 34.5625,11.5 0,2.685476 0.8125,0 0,-2.685476 -0.8125,0 z"
+         style="fill:#ff0000;fill-opacity:1;stroke:none" /><path
+         inkscape:connector-curvature="0"
+         id="rect4403-7-6"
+         d="m 34.75733,11.763024 0,2.182112 0.381046,0 0,-2.182112 -0.381046,0 z"
+         style="fill:#ff5f5f;fill-opacity:1;stroke:none;overflow:visible" /></g><g
+       transform="translate(9.0705949,0.08325071)"
+       style="overflow:visible"
+       id="g4433-4"><path
+         inkscape:connector-curvature="0"
+         id="rect4403-4"
+         d="m 34.5625,11.5 0,2.685476 0.8125,0 0,-2.685476 -0.8125,0 z"
+         style="fill:#ff0000;fill-opacity:1;stroke:none" /><path
+         inkscape:connector-curvature="0"
+         id="rect4403-7-1"
+         d="m 34.75733,11.763024 0,2.182112 0.381046,0 0,-2.182112 -0.381046,0 z"
+         style="fill:#ff5f5f;fill-opacity:1;stroke:none;overflow:visible" /></g><g
+       transform="translate(13.569935,0.08325071)"
+       style="overflow:visible"
+       id="g4433-9"><path
+         inkscape:connector-curvature="0"
+         id="rect4403-5"
+         d="m 34.5625,11.5 0,2.685476 0.8125,0 0,-2.685476 -0.8125,0 z"
+         style="fill:#ff0000;fill-opacity:1;stroke:none" /><path
+         inkscape:connector-curvature="0"
+         id="rect4403-7-5"
+         d="m 34.75733,11.763024 0,2.182112 0.381046,0 0,-2.182112 -0.381046,0 z"
+         style="fill:#ff5f5f;fill-opacity:1;stroke:none;overflow:visible" /></g></g></g></svg>
\ No newline at end of file
diff --git a/mod/questionnaire/preview.php b/mod/questionnaire/preview.php
new file mode 100644
index 0000000..7df8eab
--- /dev/null
+++ b/mod/questionnaire/preview.php
@@ -0,0 +1,160 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+// This page displays a non-completable instance of questionnaire.
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+$id     = optional_param('id', 0, PARAM_INT);
+$sid    = optional_param('sid', 0, PARAM_INT);
+$popup  = optional_param('popup', 0, PARAM_INT);
+$qid    = optional_param('qid', 0, PARAM_INT);
+$currentgroupid = optional_param('group', 0, PARAM_INT); // Groupid.
+
+if ($id) {
+    if (! $cm = get_coursemodule_from_id('questionnaire', $id)) {
+        print_error('invalidcoursemodule');
+    }
+
+    if (! $course = $DB->get_record("course", array("id" => $cm->course))) {
+        print_error('coursemisconf');
+    }
+
+    if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $cm->instance))) {
+        print_error('invalidcoursemodule');
+    }
+} else {
+    if (! $survey = $DB->get_record("questionnaire_survey", array("id" => $sid))) {
+        print_error('surveynotexists', 'questionnaire');
+    }
+    if (! $course = $DB->get_record("course", ["id" => $survey->courseid])) {
+        print_error('coursemisconf');
+    }
+    // Dummy questionnaire object.
+    $questionnaire = new stdClass();
+    $questionnaire->id = 0;
+    $questionnaire->course = $course->id;
+    $questionnaire->name = $survey->title;
+    $questionnaire->sid = $sid;
+    $questionnaire->resume = 0;
+    // Dummy cm object.
+    if (!empty($qid)) {
+        $cm = get_coursemodule_from_instance('questionnaire', $qid, $course->id);
+    } else {
+        $cm = false;
+    }
+}
+
+// Check login and get context.
+// Do not require login if this questionnaire is viewed from the Add questionnaire page
+// to enable teachers to view template or public questionnaires located in a course where they are not enroled.
+if (!$popup) {
+    require_login($course->id, false, $cm);
+}
+$context = $cm ? context_module::instance($cm->id) : false;
+
+$url = new moodle_url('/mod/questionnaire/preview.php');
+if ($id !== 0) {
+    $url->param('id', $id);
+}
+if ($sid) {
+    $url->param('sid', $sid);
+}
+$PAGE->set_url($url);
+
+$PAGE->set_context($context);
+$PAGE->set_cm($cm);   // CONTRIB-5872 - I don't know why this is needed.
+
+$questionnaire = new questionnaire($qid, $questionnaire, $course, $cm);
+
+// Add renderer and page objects to the questionnaire object for display use.
+$questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+$questionnaire->add_page(new \mod_questionnaire\output\previewpage());
+
+$canpreview = (!isset($questionnaire->capabilities) &&
+               has_capability('mod/questionnaire:preview', context_course::instance($course->id))) ||
+              (isset($questionnaire->capabilities) && $questionnaire->capabilities->preview);
+if (!$canpreview && !$popup) {
+    // Should never happen, unless called directly by a snoop...
+    print_error('nopermissions', 'questionnaire', $CFG->wwwroot.'/mod/questionnaire/view.php?id='.$cm->id);
+}
+
+if (!isset($SESSION->questionnaire)) {
+    $SESSION->questionnaire = new stdClass();
+}
+$SESSION->questionnaire->current_tab = new stdClass();
+$SESSION->questionnaire->current_tab = 'preview';
+
+$qp = get_string('preview_questionnaire', 'questionnaire');
+$pq = get_string('previewing', 'questionnaire');
+
+// Print the page header.
+if ($popup) {
+    $PAGE->set_pagelayout('popup');
+}
+$PAGE->set_title(format_string($qp));
+if (!$popup) {
+    $PAGE->set_heading(format_string($course->fullname));
+}
+
+// Include the needed js.
+
+
+$PAGE->requires->js('/mod/questionnaire/module.js');
+// Print the tabs.
+
+
+echo $questionnaire->renderer->header();
+if (!$popup) {
+    require('tabs.php');
+}
+$questionnaire->page->add_to_page('heading', clean_text($pq));
+
+if ($questionnaire->capabilities->printblank) {
+    // Open print friendly as popup window.
+
+    $linkname = '&nbsp;'.get_string('printblank', 'questionnaire');
+    $title = get_string('printblanktooltip', 'questionnaire');
+    $url = '/mod/questionnaire/print.php?qid='.$questionnaire->id.'&amp;rid=0&amp;'.'courseid='.
+            $questionnaire->course->id.'&amp;sec=1';
+    $options = array('menubar' => true, 'location' => false, 'scrollbars' => true, 'resizable' => true,
+                    'height' => 600, 'width' => 800, 'title' => $title);
+    $name = 'popup';
+    $link = new moodle_url($url);
+    $action = new popup_action('click', $link, $name, $options);
+    $class = "floatprinticon";
+    $questionnaire->page->add_to_page('printblank',
+        $questionnaire->renderer->action_link($link, $linkname, $action, array('class' => $class, 'title' => $title),
+            new pix_icon('t/print', $title)));
+}
+$questionnaire->survey_print_render('', 'preview', $course->id, $rid = 0, $popup);
+if ($popup) {
+    $questionnaire->page->add_to_page('closebutton', $questionnaire->renderer->close_window_button());
+}
+echo $questionnaire->renderer->render($questionnaire->page);
+echo $questionnaire->renderer->footer($course);
+
+// Log this questionnaire preview.
+$context = context_module::instance($questionnaire->cm->id);
+$anonymous = $questionnaire->respondenttype == 'anonymous';
+
+$event = \mod_questionnaire\event\questionnaire_previewed::create(array(
+                'objectid' => $questionnaire->id,
+                'anonymous' => $anonymous,
+                'context' => $context
+));
+$event->trigger();
diff --git a/mod/questionnaire/print.php b/mod/questionnaire/print.php
new file mode 100644
index 0000000..d903aba
--- /dev/null
+++ b/mod/questionnaire/print.php
@@ -0,0 +1,71 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+$qid = required_param('qid', PARAM_INT);
+$rid = required_param('rid', PARAM_INT);
+$courseid = required_param('courseid', PARAM_INT);
+$sec = required_param('sec', PARAM_INT);
+$null = null;
+$referer = $CFG->wwwroot.'/mod/questionnaire/report.php';
+
+if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $qid))) {
+    print_error('invalidcoursemodule');
+}
+if (! $course = $DB->get_record("course", array("id" => $questionnaire->course))) {
+    print_error('coursemisconf');
+}
+if (! $cm = get_coursemodule_from_instance("questionnaire", $questionnaire->id, $course->id)) {
+    print_error('invalidcoursemodule');
+}
+
+// Check login and get context.
+require_login($courseid);
+
+$questionnaire = new questionnaire(0, $questionnaire, $course, $cm);
+
+// Add renderer and page objects to the questionnaire object for display use.
+$questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+if (!empty($rid)) {
+    $questionnaire->add_page(new \mod_questionnaire\output\reportpage());
+} else {
+    $questionnaire->add_page(new \mod_questionnaire\output\previewpage());
+}
+
+// If you can't view the questionnaire, or can't view a specified response, error out.
+if (!($questionnaire->capabilities->view && (($rid == 0) || $questionnaire->can_view_response($rid)))) {
+    // Should never happen, unless called directly by a snoop...
+    print_error('nopermissions', 'moodle', $CFG->wwwroot.'/mod/questionnaire/view.php?id='.$cm->id);
+}
+$blankquestionnaire = true;
+if ($rid != 0) {
+    $blankquestionnaire = false;
+}
+$url = new moodle_url($CFG->wwwroot.'/mod/questionnaire/print.php');
+$url->param('qid', $qid);
+$url->param('rid', $rid);
+$url->param('courseid', $courseid);
+$url->param('sec', $sec);
+$PAGE->set_url($url);
+$PAGE->set_title($questionnaire->survey->title);
+$PAGE->set_pagelayout('popup');
+echo $questionnaire->renderer->header();
+$questionnaire->page->add_to_page('closebutton', $questionnaire->renderer->close_window_button());
+$questionnaire->survey_print_render('', 'print', $courseid, $rid, $blankquestionnaire);
+echo $questionnaire->renderer->render($questionnaire->page);
+echo $questionnaire->renderer->footer();
diff --git a/mod/questionnaire/qsettings.php b/mod/questionnaire/qsettings.php
new file mode 100644
index 0000000..2766e0d
--- /dev/null
+++ b/mod/questionnaire/qsettings.php
@@ -0,0 +1,197 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+// This page prints a particular instance of questionnaire.
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+$id = required_param('id', PARAM_INT);    // Course module ID.
+$currentgroupid = optional_param('group', 0, PARAM_INT); // Groupid.
+$cancel = optional_param('cancel', '', PARAM_ALPHA);
+$submitbutton2 = optional_param('submitbutton2', '', PARAM_ALPHA);
+
+if (! $cm = get_coursemodule_from_id('questionnaire', $id)) {
+    print_error('invalidcoursemodule');
+}
+
+if (! $course = $DB->get_record("course", array("id" => $cm->course))) {
+    print_error('coursemisconf');
+}
+
+if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $cm->instance))) {
+    print_error('invalidcoursemodule');
+}
+
+// Needed here for forced language courses.
+require_course_login($course, true, $cm);
+$context = context_module::instance($cm->id);
+
+$url = new moodle_url($CFG->wwwroot.'/mod/questionnaire/qsettings.php', array('id' => $id));
+$PAGE->set_url($url);
+$PAGE->set_context($context);
+if (!isset($SESSION->questionnaire)) {
+    $SESSION->questionnaire = new stdClass();
+}
+$questionnaire = new questionnaire(0, $questionnaire, $course, $cm);
+
+// Add renderer and page objects to the questionnaire object for display use.
+$questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+$questionnaire->add_page(new \mod_questionnaire\output\qsettingspage());
+
+$SESSION->questionnaire->current_tab = 'settings';
+
+if (!$questionnaire->capabilities->manage) {
+    print_error('nopermissions', 'error', 'mod:questionnaire:manage');
+}
+
+$settingsform = new mod_questionnaire_settings_form('qsettings.php');
+$sdata = clone($questionnaire->survey);
+$sdata->sid = $questionnaire->survey->id;
+$sdata->id = $cm->id;
+
+$draftideditor = file_get_submitted_draft_itemid('info');
+$currentinfo = file_prepare_draft_area($draftideditor, $context->id, 'mod_questionnaire', 'info',
+                $sdata->sid, array('subdirs' => true), $questionnaire->survey->info);
+$sdata->info = array('text' => $currentinfo, 'format' => FORMAT_HTML, 'itemid' => $draftideditor);
+
+$draftideditor = file_get_submitted_draft_itemid('thankbody');
+$currentinfo = file_prepare_draft_area($draftideditor, $context->id, 'mod_questionnaire', 'thankbody',
+                $sdata->sid, array('subdirs' => true), $questionnaire->survey->thank_body);
+$sdata->thank_body = array('text' => $currentinfo, 'format' => FORMAT_HTML, 'itemid' => $draftideditor);
+
+$draftideditor = file_get_submitted_draft_itemid('feedbacknotes');
+$currentinfo = file_prepare_draft_area($draftideditor, $context->id, 'mod_questionnaire', 'feedbacknotes',
+        $sdata->sid, array('subdirs' => true), $questionnaire->survey->feedbacknotes);
+$sdata->feedbacknotes = array('text' => $currentinfo, 'format' => FORMAT_HTML, 'itemid' => $draftideditor);
+
+$settingsform->set_data($sdata);
+
+if ($settingsform->is_cancelled()) {
+    redirect ($CFG->wwwroot.'/mod/questionnaire/view.php?id='.$questionnaire->cm->id, '');
+}
+
+if ($settings = $settingsform->get_data()) {
+    $sdata = new stdClass();
+    $sdata->id = $settings->sid;
+    $sdata->name = $settings->name;
+    $sdata->realm = $settings->realm;
+    $sdata->title = $settings->title;
+    $sdata->subtitle = $settings->subtitle;
+
+    $sdata->infoitemid = $settings->info['itemid'];
+    $sdata->infoformat = $settings->info['format'];
+    $sdata->info       = $settings->info['text'];
+    $sdata->info       = file_save_draft_area_files($sdata->infoitemid, $context->id, 'mod_questionnaire', 'info',
+                                                    $sdata->id, array('subdirs' => true), $sdata->info);
+
+    $sdata->theme = ''; // Deprecated theme field.
+    $sdata->thanks_page = $settings->thanks_page;
+    $sdata->thank_head = $settings->thank_head;
+
+    $sdata->thankitemid = $settings->thank_body['itemid'];
+    $sdata->thankformat = $settings->thank_body['format'];
+    $sdata->thank_body  = $settings->thank_body['text'];
+    $sdata->thank_body  = file_save_draft_area_files($sdata->thankitemid, $context->id, 'mod_questionnaire', 'thankbody',
+                                                     $sdata->id, array('subdirs' => true), $sdata->thank_body);
+    $sdata->email = $settings->email;
+
+    if (isset ($settings->feedbackscores)) {
+        $sdata->feedbackscores = $settings->feedbackscores;
+    } else {
+        $sdata->feedbackscores = 0;
+    }
+
+    if (isset ($settings->feedbacknotes)) {
+        $sdata->fbnotesitemid = $settings->feedbacknotes['itemid'];
+        $sdata->fbnotesformat = $settings->feedbacknotes['format'];
+        $sdata->feedbacknotes  = $settings->feedbacknotes['text'];
+        $sdata->feedbacknotes  = file_save_draft_area_files($sdata->fbnotesitemid,
+                        $context->id, 'mod_questionnaire', 'feedbacknotes',
+                        $sdata->id, array('subdirs' => true), $sdata->feedbacknotes);
+    } else {
+        $sdata->feedbacknotes = '';
+    }
+
+    if (isset ($settings->feedbacksections)) {
+        $sdata->feedbacksections = $settings->feedbacksections;
+        $usergraph = get_config('questionnaire', 'usergraph');
+        if ($usergraph) {
+            if ($settings->feedbacksections == 1) {
+                $sdata->chart_type = $settings->chart_type_global;
+            } else if ($settings->feedbacksections == 2) {
+                $sdata->chart_type = $settings->chart_type_two_sections;
+            } else if ($settings->feedbacksections > 2) {
+                $sdata->chart_type = $settings->chart_type_sections;
+            }
+        }
+    } else {
+        $sdata->feedbacksections = '';
+    }
+    $sdata->courseid = $settings->courseid;
+    if (!($sid = $questionnaire->survey_update($sdata))) {
+        print_error('couldnotcreatenewsurvey', 'questionnaire');
+    } else {
+        if ($submitbutton2) {
+            $redirecturl = course_get_url($cm->course);
+        } else {
+            $redirecturl = $CFG->wwwroot.'/mod/questionnaire/view.php?id='.$questionnaire->cm->id;
+        }
+
+        // Save current advanced settings only.
+        if (isset($settings->submitbutton) || isset($settings->submitbutton2)) {
+            redirect ($redirecturl, get_string('settingssaved', 'questionnaire'));
+        }
+
+        // Delete existing section and feedback records for this questionnaire if any were previously set and None are wanted now
+        // or Global feedback is now wanted.
+        if ($sdata->feedbacksections == 0 || ($questionnaire->survey->feedbacksections > 1 && $sdata->feedbacksections == 1)) {
+            if ($feedbacksections = $DB->get_records('questionnaire_fb_sections',
+                    array('survey_id' => $sid), '', 'id') ) {
+                foreach ($feedbacksections as $key => $feedbacksection) {
+                    $DB->delete_records('questionnaire_feedback', array('section_id' => $key));
+                }
+                $DB->delete_records('questionnaire_fb_sections', array('survey_id' => $sid));
+            }
+        }
+
+        // Save current advanced settings and go to edit feedback page(s).
+        $SESSION->questionnaire->currentfbsection = 1;
+        switch ($settings->feedbacksections) {
+            // 1 fbsection means Global feedback, redirect immediately to the fb settings page.
+            case 1:
+                redirect ($CFG->wwwroot.'/mod/questionnaire/fbsettings.php?id='.$questionnaire->cm->id,
+                        get_string('settingssaved', 'questionnaire'), 0);
+                break;
+            // More than 1 section, go to fb sections page for user to put questions inside sections.
+            default:
+                // This questionnaire has more than one feedback sections, so needs to set sections questions first
+                // before setting feedback messages.
+                redirect ($CFG->wwwroot.'/mod/questionnaire/fbsections.php?id='.$questionnaire->cm->id, '', 0);
+                break;
+        }
+    }
+}
+
+// Print the page header.
+$PAGE->set_title(get_string('editingquestionnaire', 'questionnaire'));
+$PAGE->set_heading(format_string($course->fullname));
+$PAGE->navbar->add(get_string('editingquestionnaire', 'questionnaire'));
+echo $questionnaire->renderer->header();
+require('tabs.php');
+$questionnaire->page->add_to_page('formarea', $settingsform->render());
+echo $questionnaire->renderer->render($questionnaire->page);
+echo $questionnaire->renderer->footer($course);
diff --git a/mod/questionnaire/questionnaire.class.php b/mod/questionnaire/questionnaire.class.php
new file mode 100644
index 0000000..30a66fa
--- /dev/null
+++ b/mod/questionnaire/questionnaire.class.php
@@ -0,0 +1,3609 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+class questionnaire {
+
+    // Class Properties.
+
+    /**
+     * @var \mod_questionnaire\question\base[] $quesitons
+     */
+    public $questions = [];
+
+    /**
+     * The survey record.
+     * @var object $survey
+     */
+     // Todo var $survey; TODO.
+
+    /**
+     * @var $renderer Contains the page renderer when loaded, or false if not.
+     */
+    public $renderer = false;
+
+    /**
+     * @var $page Contains the renderable, templatable page when loaded, or false if not.
+     */
+    public $page = false;
+
+    // Class Methods.
+
+    /*
+     * The class constructor
+     *
+     */
+    public function __construct($id = 0, $questionnaire = null, &$course, &$cm, $addquestions = true) {
+        global $DB;
+
+        if ($id) {
+            $questionnaire = $DB->get_record('questionnaire', array('id' => $id));
+        }
+
+        if (is_object($questionnaire)) {
+            $properties = get_object_vars($questionnaire);
+            foreach ($properties as $property => $value) {
+                $this->$property = $value;
+            }
+        }
+
+        if (!empty($this->sid)) {
+            $this->add_survey($this->sid);
+        }
+
+        $this->course = $course;
+        $this->cm = $cm;
+        // When we are creating a brand new questionnaire, we will not yet have a context.
+        if (!empty($cm) && !empty($this->id)) {
+            $this->context = context_module::instance($cm->id);
+        } else {
+            $this->context = null;
+        }
+
+        if ($addquestions && !empty($this->sid)) {
+            $this->add_questions($this->sid);
+        }
+
+        // Load the capabilities for this user and questionnaire, if not creating a new one.
+        if (!empty($this->cm->id)) {
+            $this->capabilities = questionnaire_load_capabilities($this->cm->id);
+        }
+    }
+
+    /**
+     * Adding a survey record to the object.
+     *
+     */
+    public function add_survey($sid = 0, $survey = null) {
+        global $DB;
+
+        if ($sid) {
+            $this->survey = $DB->get_record('questionnaire_survey', array('id' => $sid));
+        } else if (is_object($survey)) {
+            $this->survey = clone($survey);
+        }
+    }
+
+    /**
+     * Adding questions to the object.
+     */
+    public function add_questions($sid = false) {
+        global $DB;
+
+        if ($sid === false) {
+            $sid = $this->sid;
+        }
+
+        if (!isset($this->questions)) {
+            $this->questions = array();
+            $this->questionsbysec = array();
+        }
+
+        $select = 'survey_id = '.$sid.' AND deleted != \'y\'';
+        if ($records = $DB->get_records_select('questionnaire_question', $select, null, 'position')) {
+            $sec = 1;
+            $isbreak = false;
+            foreach ($records as $record) {
+
+                $this->questions[$record->id] = \mod_questionnaire\question\base::question_builder($record->type_id,
+                    $record, $this->context);
+
+                if ($record->type_id != QUESPAGEBREAK) {
+                    $this->questionsbysec[$sec][$record->id] = &$this->questions[$record->id];
+                    $isbreak = false;
+                } else {
+                    // Sanity check: no section break allowed as first position, no 2 consecutive section breaks.
+                    if ($record->position != 1 && $isbreak == false) {
+                        $sec++;
+                        $isbreak = true;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Add the renderer to the questionnaire object.
+     * @param \plugin_renderer_base $renderer The module renderer, extended from core renderer.
+     */
+    public function add_renderer($renderer) {
+        $this->renderer = $renderer;
+    }
+
+    /**
+     * Add the templatable page to the questionnaire object.
+     * @param \renderable, \templatable $page The page to rendere, implementing core classes.
+     */
+    public function add_page($page) {
+        $this->page = $page;
+    }
+
+    public function view() {
+        global $CFG, $USER, $PAGE;
+
+        $PAGE->set_title(format_string($this->name));
+        $PAGE->set_heading(format_string($this->course->fullname));
+
+        // Initialise the JavaScript.
+        $PAGE->requires->js_init_call('M.mod_questionnaire.init_attempt_form', null, false, questionnaire_get_js_module());
+
+        $questionnaire = $this;
+
+        if (!$this->capabilities->view) {
+            $this->page->add_to_page('notifications',
+                $this->renderer->notification(get_string('noteligible', 'questionnaire', $this->name),
+                \core\output\notification::NOTIFY_ERROR));
+        } else if (!$this->is_active()) {
+            $this->page->add_to_page('notifications',
+                $this->renderer->notification(get_string('notavail', 'questionnaire'), \core\output\notification::NOTIFY_ERROR));
+        } else if (!$this->is_open()) {
+            $this->page->add_to_page('notifications',
+                $this->renderer->notification(get_string('notopen', 'questionnaire', userdate($this->opendate)),
+                \core\output\notification::NOTIFY_ERROR));
+        } else if ($this->is_closed()) {
+            $this->page->add_to_page('notifications',
+                $this->renderer->notification(get_string('closed', 'questionnaire', userdate($this->closedate)),
+                \core\output\notification::NOTIFY_ERROR));
+        } else if (!$this->user_is_eligible($USER->id)) {
+            $this->page->add_to_page('notifications',
+                $this->renderer->notification(get_string('noteligible', 'questionnaire'), \core\output\notification::NOTIFY_ERROR));
+        } else if ($this->survey->realm == 'template') {
+            $this->page->add_to_page('notifications',
+                $this->renderer->notification(get_string('templatenotviewable', 'questionnaire'),
+                \core\output\notification::NOTIFY_ERROR));
+        } else if (!$this->user_can_take($USER->id)) {
+            switch ($this->qtype) {
+                case QUESTIONNAIREDAILY:
+                    $msgstring = ' '.get_string('today', 'questionnaire');
+                    break;
+                case QUESTIONNAIREWEEKLY:
+                    $msgstring = ' '.get_string('thisweek', 'questionnaire');
+                    break;
+                case QUESTIONNAIREMONTHLY:
+                    $msgstring = ' '.get_string('thismonth', 'questionnaire');
+                    break;
+                default:
+                    $msgstring = '';
+                    break;
+            }
+            $this->page->add_to_page('notifications',
+                $this->renderer->notification(get_string('alreadyfilled', 'questionnaire', $msgstring),
+                \core\output\notification::NOTIFY_ERROR));
+        } else {
+            // Handle the main questionnaire completion page.
+            $quser = $USER->id;
+
+            $msg = $this->print_survey($USER->id, $quser);
+
+            // If Questionnaire was submitted with all required fields completed ($msg is empty),
+            // then record the submittal.
+            $viewform = data_submitted($CFG->wwwroot."/mod/questionnaire/complete.php");
+            if (!empty($viewform->rid)) {
+                $viewform->rid = (int)$viewform->rid;
+            }
+            if (!empty($viewform->sec)) {
+                $viewform->sec = (int)$viewform->sec;
+            }
+            if (data_submitted() && confirm_sesskey() && isset($viewform->submit) && isset($viewform->submittype) &&
+                ($viewform->submittype == "Submit Survey") && empty($msg)) {
+                $this->response_delete($viewform->rid, $viewform->sec);
+                $this->rid = $this->response_insert($this->survey->id, $viewform->sec, $viewform->rid, $quser);
+                $this->response_commit($this->rid);
+
+                // If it was a previous save, rid is in the form...
+                if (!empty($viewform->rid) && is_numeric($viewform->rid)) {
+                    $rid = $viewform->rid;
+
+                    // Otherwise its in this object.
+                } else {
+                    $rid = $this->rid;
+                }
+
+                questionnaire_record_submission($this, $USER->id, $rid);
+
+                if ($this->grade != 0) {
+                    $questionnaire = new stdClass();
+                    $questionnaire->id = $this->id;
+                    $questionnaire->name = $this->name;
+                    $questionnaire->grade = $this->grade;
+                    $questionnaire->cmidnumber = $this->cm->idnumber;
+                    $questionnaire->courseid = $this->course->id;
+                    questionnaire_update_grades($questionnaire, $quser);
+                }
+
+                // Update completion state.
+                $completion = new completion_info($this->course);
+                if ($completion->is_enabled($this->cm) && $this->completionsubmit) {
+                    $completion->update_state($this->cm, COMPLETION_COMPLETE);
+                }
+
+                // Log this submitted response.
+                $context = context_module::instance($this->cm->id);
+                $anonymous = $this->respondenttype == 'anonymous';
+                $params = array(
+                                'context' => $context,
+                                'courseid' => $this->course->id,
+                                'relateduserid' => $USER->id,
+                                'anonymous' => $anonymous,
+                                'other' => array('questionnaireid' => $questionnaire->id)
+                );
+                $event = \mod_questionnaire\event\attempt_submitted::create($params);
+                $event->trigger();
+
+                $this->submission_notify($this->rid);
+                $this->response_goto_thankyou();
+            }
+        }
+    }
+
+    /*
+    * Function to view an entire responses data.
+    *
+    */
+    public function view_response($rid, $referer= '', $blankquestionnaire = false, $resps = '', $compare = false,
+                        $isgroupmember = false, $allresponses = false, $currentgroupid = 0) {
+        $this->print_survey_start('', 1, 1, 0, $rid, false);
+
+        $data = new stdClass();
+        $i = 0;
+        $this->response_import_all($rid, $data);
+        if ($referer != 'print') {
+            $feedbackmessages = $this->response_analysis($rid, $resps, $compare, $isgroupmember, $allresponses, $currentgroupid);
+
+            if ($feedbackmessages) {
+                $msgout = '';
+                foreach ($feedbackmessages as $msg) {
+                    $msgout .= $msg;
+                }
+                $this->page->add_to_page('feedbackmessages', $msgout);
+            }
+
+            if ($this->survey->feedbacknotes) {
+                $text = file_rewrite_pluginfile_urls($this->survey->feedbacknotes, 'pluginfile.php',
+                    $this->context->id, 'mod_questionnaire', 'feedbacknotes', $this->survey->id);
+                $this->page->add_to_page('feedbacknotes', $this->renderer->box(format_text($text, FORMAT_HTML)));
+            }
+        }
+        foreach ($this->questions as $question) {
+            if ($question->type_id < QUESPAGEBREAK) {
+                $i++;
+            }
+            if ($question->type_id != QUESPAGEBREAK) {
+                $this->page->add_to_page('responses', $this->renderer->response_output($question, $data, $i));
+            }
+        }
+    }
+
+    /*
+    * Function to view an entire responses data.
+    *
+    * $value is unused, but is needed in order to get the $key elements of the array. Suppress PHPMD warning.
+    *
+    * @SuppressWarnings(PHPMD.UnusedLocalVariable)
+    */
+    public function view_all_responses($resps) {
+        $this->print_survey_start('', 1, 1, 0);
+
+        // If a student's responses have been deleted by teacher while student was viewing the report,
+        // then responses may have become empty, hence this test is necessary.
+        if ($resps) {
+            foreach ($resps as $resp) {
+                $data[$resp->id] = new stdClass();
+                $this->response_import_all($resp->id, $data[$resp->id]);
+            }
+
+            $i = 0;
+
+            $allrespdata = [];
+            foreach ($this->questions as $question) {
+                if ($question->type_id < QUESPAGEBREAK) {
+                    $i++;
+                }
+                $qid = preg_quote('q'.$question->id, '/');
+                if ($question->type_id != QUESPAGEBREAK) {
+                    $allrespdata[$i] = [];
+                    $allrespdata[$i]['question'] = $question;
+                    foreach ($data as $respid => $respdata) {
+                        $hasresp = false;
+                        foreach ($respdata as $key => $value) {
+                            if ($hasresp = preg_match("/$qid(_|$)/", $key)) {
+                                break;
+                            }
+                        }
+                        // Do not display empty responses.
+                        if ($hasresp) {
+                            $allrespdata[$i][] = [
+                                'respdate' => userdate($resps[$respid]->submitted),
+                                'respdata' => $respdata
+                            ];
+                        }
+                    }
+                }
+            }
+            $this->page->add_to_page('responses', $this->renderer->all_response_output($allrespdata));
+        } else {
+            $this->page->add_to_page('responses', $this->renderer->all_response_output(get_string('noresponses', 'questionnaire')));
+        }
+
+        $this->print_survey_end(1, 1);
+    }
+
+    // Access Methods.
+    public function is_active() {
+        return (!empty($this->survey));
+    }
+
+    public function is_open() {
+        return ($this->opendate > 0) ? ($this->opendate < time()) : true;
+    }
+
+    public function is_closed() {
+        return ($this->closedate > 0) ? ($this->closedate < time()) : false;
+    }
+
+    public function user_can_take($userid) {
+
+        if (!$this->is_active() || !$this->user_is_eligible($userid)) {
+            return false;
+        } else if ($this->qtype == QUESTIONNAIREUNLIMITED) {
+            return true;
+        } else if ($userid > 0) {
+            return $this->user_time_for_new_attempt($userid);
+        } else {
+            return false;
+        }
+    }
+
+    public function user_is_eligible($userid) {
+        return ($this->capabilities->view && $this->capabilities->submit);
+    }
+
+    public function user_has_saved_response($userid) {
+        global $DB;
+
+        return $DB->record_exists('questionnaire_response',
+            ['survey_id' => $this->survey->id, 'userid' => $userid, 'complete' => 'n']);
+    }
+
+    public function user_time_for_new_attempt($userid) {
+        global $DB;
+
+        $params = array('qid' => $this->id, 'userid' => $userid);
+        if (!($attempts = $DB->get_records('questionnaire_attempts', $params, 'timemodified DESC'))) {
+            return true;
+        }
+
+        $attempt = reset($attempts);
+        $timenow = time();
+
+        switch ($this->qtype) {
+
+            case QUESTIONNAIREUNLIMITED:
+                $cantake = true;
+                break;
+
+            case QUESTIONNAIREONCE:
+                $cantake = false;
+                break;
+
+            case QUESTIONNAIREDAILY:
+                $attemptyear = date('Y', $attempt->timemodified);
+                $currentyear = date('Y', $timenow);
+                $attemptdayofyear = date('z', $attempt->timemodified);
+                $currentdayofyear = date('z', $timenow);
+                $cantake = (($attemptyear < $currentyear) ||
+                            (($attemptyear == $currentyear) && ($attemptdayofyear < $currentdayofyear)));
+                break;
+
+            case QUESTIONNAIREWEEKLY:
+                $attemptyear = date('Y', $attempt->timemodified);
+                $currentyear = date('Y', $timenow);
+                $attemptweekofyear = date('W', $attempt->timemodified);
+                $currentweekofyear = date('W', $timenow);
+                $cantake = (($attemptyear < $currentyear) ||
+                            (($attemptyear == $currentyear) && ($attemptweekofyear < $currentweekofyear)));
+                break;
+
+            case QUESTIONNAIREMONTHLY:
+                $attemptyear = date('Y', $attempt->timemodified);
+                $currentyear = date('Y', $timenow);
+                $attemptmonthofyear = date('n', $attempt->timemodified);
+                $currentmonthofyear = date('n', $timenow);
+                $cantake = (($attemptyear < $currentyear) ||
+                            (($attemptyear == $currentyear) && ($attemptmonthofyear < $currentmonthofyear)));
+                break;
+
+            default:
+                $cantake = false;
+                break;
+        }
+
+        return $cantake;
+    }
+
+    public function is_survey_owner() {
+        return (!empty($this->survey->courseid) && ($this->course->id == $this->survey->courseid));
+    }
+
+    public function can_view_response($rid) {
+        global $USER, $DB;
+
+        if (!empty($rid)) {
+            $response = $DB->get_record('questionnaire_response', array('id' => $rid));
+
+            // If the response was not found, can't view it.
+            if (empty($response)) {
+                return false;
+            }
+
+            // If the response belongs to a different survey than this one, can't view it.
+            if ($response->survey_id != $this->survey->id) {
+                return false;
+            }
+
+            // If you can view all responses always, then you can view it.
+            if ($this->capabilities->readallresponseanytime) {
+                return true;
+            }
+
+            // If you are allowed to view this response for another user.
+            // If resp_view is set to QUESTIONNAIRE_STUDENTVIEWRESPONSES_NEVER, then this will always be false.
+            if ($this->capabilities->readallresponses &&
+                ($this->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_ALWAYS ||
+                 ($this->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENCLOSED && $this->is_closed()) ||
+                 ($this->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENANSWERED  && !$this->user_can_take($USER->id)))) {
+                return true;
+            }
+
+             // If you can read your own response.
+            if (($response->userid == $USER->id) && $this->capabilities->readownresponses &&
+                            ($this->count_submissions($USER->id) > 0)) {
+                return true;
+            }
+
+        } else {
+            // If you can view all responses always, then you can view it.
+            if ($this->capabilities->readallresponseanytime) {
+                return true;
+            }
+
+            // If you are allowed to view this response for another user.
+            // If resp_view is set to QUESTIONNAIRE_STUDENTVIEWRESPONSES_NEVER, then this will always be false.
+            if ($this->capabilities->readallresponses &&
+                ($this->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_ALWAYS ||
+                 ($this->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENCLOSED && $this->is_closed()) ||
+                 ($this->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENANSWERED  && !$this->user_can_take($USER->id)))) {
+                return true;
+            }
+
+             // If you can read your own response.
+            if ($this->capabilities->readownresponses && ($this->count_submissions($USER->id) > 0)) {
+                return true;
+            }
+        }
+    }
+
+    public function can_view_all_responses($usernumresp = null) {
+        global $USER, $DB, $SESSION;
+
+        if ($owner = $DB->get_field('questionnaire_survey', 'courseid', ['id' => $this->sid])) {
+            $owner = ($owner == $this->course->id);
+        } else {
+            $owner = true;
+        }
+        $numresp = $this->count_submissions();
+        if ($usernumresp === null) {
+            $usernumresp = $questionnaire->count_submissions($USER->id);
+        }
+
+        // Number of Responses in currently selected group (or all participants etc.).
+        if (isset($SESSION->questionnaire->numselectedresps)) {
+            $numselectedresps = $SESSION->questionnaire->numselectedresps;
+        } else {
+            $numselectedresps = $numresp;
+        }
+
+        // If questionnaire is set to separate groups, prevent user who is not member of any group
+        // to view All responses.
+        $canviewgroups = true;
+        $groupmode = groups_get_activity_groupmode($this->cm, $this->course);
+        if ($groupmode == 1) {
+            $canviewgroups = groups_has_membership($this->cm, $USER->id);
+        }
+
+        $canviewallgroups = has_capability('moodle/site:accessallgroups', $this->context);
+        return (( // Teacher or non-editing teacher (if can view all groups).
+                 ($canviewallgroups ||
+                  // Non-editing teacher (with canviewallgroups capability removed), if member of a group.
+                  ($canviewgroups && $this->capabilities->readallresponseanytime)) &&
+                 ($numresp > 0) && $owner && ($numselectedresps > 0)) ||
+                ($this->capabilities->readallresponses && ($numresp > 0) && $canviewgroups &&
+                 // If resp_view is set to QUESTIONNAIRE_STUDENTVIEWRESPONSES_NEVER, then this will always be false.
+                 ($this->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_ALWAYS ||
+                  ($this->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENCLOSED && $this->is_closed()) ||
+                  ($this->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENANSWERED && ($usernumresp > 0))) &&
+                 $this->is_survey_owner()));
+    }
+
+    public function count_submissions($userid=false) {
+        global $DB;
+
+        if (!$userid) {
+            // Provide for groups setting.
+            return $DB->count_records('questionnaire_response', array('survey_id' => $this->sid, 'complete' => 'y'));
+        } else {
+            return $DB->count_records('questionnaire_response', array('survey_id' => $this->sid, 'userid' => $userid,
+                                      'complete' => 'y'));
+        }
+    }
+
+    private function has_required($section = 0) {
+        if (empty($this->questions)) {
+            return false;
+        } else if ($section <= 0) {
+            foreach ($this->questions as $question) {
+                if ($question->required == 'y') {
+                    return true;
+                }
+            }
+        } else {
+            foreach ($this->questionsbysec[$section] as $question) {
+                if ($question->required == 'y') {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    // Display Methods.
+
+    public function print_survey($userid=false, $quser) {
+        global $SESSION, $CFG;
+
+        $formdata = new stdClass();
+        if (data_submitted() && confirm_sesskey()) {
+            $formdata = data_submitted();
+        }
+        $formdata->rid = $this->get_response($quser);
+        // If student saved a "resume" questionnaire OR left a questionnaire unfinished
+        // and there are more pages than one find the page of the last answered question.
+        if (!empty($formdata->rid) && (empty($formdata->sec) || intval($formdata->sec) < 1)) {
+            $formdata->sec = $this->response_select_max_sec($formdata->rid);
+        }
+        if (empty($formdata->sec)) {
+            $formdata->sec = 1;
+        } else {
+            $formdata->sec = (intval($formdata->sec) > 0) ? intval($formdata->sec) : 1;
+        }
+
+        $numsections = isset($this->questionsbysec) ? count($this->questionsbysec) : 0;    // Indexed by section.
+        $msg = '';
+        $action = $CFG->wwwroot.'/mod/questionnaire/complete.php?id='.$this->cm->id;
+
+        // TODO - Need to rework this. Too much crossover with ->view method.
+
+        // Skip logic :: if this is page 1, it cannot be the end page with no questions on it!
+        if ($formdata->sec == 1) {
+            $SESSION->questionnaire->end = false;
+        }
+        // Skip logic: reset this just in case.
+        $SESSION->questionnaire->nbquestionsonpage = '';
+
+        if (!empty($formdata->submit)) {
+            // Skip logic: we have reached the last page without any questions on it.
+            if (isset($SESSION->questionnaire->end) && $SESSION->questionnaire->end == true) {
+                return;
+            }
+
+            $msg = $this->response_check_format($formdata->sec, $formdata);
+            if (empty($msg)) {
+                return;
+            }
+        }
+
+        if (!empty($formdata->resume) && ($this->resume)) {
+            $this->response_delete($formdata->rid, $formdata->sec);
+            $formdata->rid = $this->response_insert($this->survey->id, $formdata->sec, $formdata->rid, $quser, $resume = true);
+            $this->response_goto_saved($action);
+            return;
+        }
+
+        // Save each section 's $formdata somewhere in case user returns to that page when navigating the questionnaire.
+        if (!empty($formdata->next)) {
+            $this->response_delete($formdata->rid, $formdata->sec);
+            $formdata->rid = $this->response_insert($this->survey->id, $formdata->sec, $formdata->rid, $quser);
+            $msg = $this->response_check_format($formdata->sec, $formdata);
+            if ( $msg ) {
+                $formdata->next = '';
+            } else {
+                // Skip logic.
+                $formdata->sec++;
+                if (questionnaire_has_dependencies($this->questions)) {
+                    $nbquestionsonpage = questionnaire_nb_questions_on_page($this->questions,
+                                    $this->questionsbysec[$formdata->sec], $formdata->rid);
+                    while (count($nbquestionsonpage) == 0) {
+                        $this->response_delete($formdata->rid, $formdata->sec);
+                        $formdata->sec++;
+                        // We have reached the end of questionnaire on a page without any question left.
+                        if ($formdata->sec > $numsections) {
+                            $SESSION->questionnaire->end = true; // End of questionnaire reached on a no questions page.
+                            break;
+                        }
+                        $nbquestionsonpage = questionnaire_nb_questions_on_page($this->questions,
+                                        $this->questionsbysec[$formdata->sec], $formdata->rid);
+                    }
+                    $SESSION->questionnaire->nbquestionsonpage = $nbquestionsonpage;
+                }
+            }
+        }
+
+        if (!empty($formdata->prev)) {
+            $this->response_delete($formdata->rid, $formdata->sec);
+
+            // If skip logic and this is last page reached with no questions,
+            // unlock questionnaire->end to allow navigate back to previous page.
+            if (isset($SESSION->questionnaire->end) && $SESSION->questionnaire->end == true) {
+                $SESSION->questionnaire->end = false;
+                $formdata->sec --;
+            }
+
+                $formdata->rid = $this->response_insert($this->survey->id, $formdata->sec, $formdata->rid, $quser);
+            // Prevent navigation to previous page if wrong format in answered questions).
+            $msg = $this->response_check_format($formdata->sec, $formdata, $checkmissing = false, $checkwrongformat = true);
+            if ( $msg ) {
+                $formdata->prev = '';
+            } else {
+                $formdata->sec--;
+                // Skip logic.
+                if (questionnaire_has_dependencies($this->questions)) {
+                    $nbquestionsonpage = questionnaire_nb_questions_on_page($this->questions,
+                                    $this->questionsbysec[$formdata->sec], $formdata->rid);
+                    while (count($nbquestionsonpage) == 0) {
+                        $formdata->sec--;
+                        $nbquestionsonpage = questionnaire_nb_questions_on_page($this->questions,
+                                        $this->questionsbysec[$formdata->sec], $formdata->rid);
+                    }
+                    $SESSION->questionnaire->nbquestionsonpage = $nbquestionsonpage;
+                }
+            }
+        }
+
+        if (!empty($formdata->rid)) {
+            $this->response_import_sec($formdata->rid, $formdata->sec, $formdata);
+        }
+
+        $formdatareferer = !empty($formdata->referer) ? htmlspecialchars($formdata->referer) : '';
+        $formdatarid = isset($formdata->rid) ? $formdata->rid : '0';
+        $this->page->add_to_page('formstart', $this->renderer->complete_formstart($action, ['referer' => $formdatareferer,
+            'a' => $this->id, 'sid' => $this->survey->id, 'rid' => $formdatarid, 'sec' => $formdata->sec, 'sesskey' => sesskey()]));
+        if (isset($this->questions) && $numsections) { // Sanity check.
+            $this->survey_render($formdata->sec, $msg, $formdata);
+            $controlbuttons = [];
+            if ($formdata->sec > 1) {
+                $controlbuttons['prev'] = ['type' => 'submit', 'value' => '<< '.get_string('previouspage', 'questionnaire')];
+            }
+            if ($this->resume) {
+                $controlbuttons['resume'] = ['type' => 'submit', 'value' => get_string('save', 'questionnaire')];
+            }
+
+            // Add a 'hidden' variable for the mod's 'view.php', and use a language variable for the submit button.
+
+            if ($formdata->sec == $numsections) {
+                $controlbuttons['submittype'] = ['type' => 'hidden', 'value' => 'Submit Survey'];
+                $controlbuttons['submit'] = ['type' => 'submit', 'value' => get_string('submitsurvey', 'questionnaire')];
+            } else {
+                $controlbuttons['next'] = ['type' => 'submit', 'value' => get_string('nextpage', 'questionnaire').' >>'];
+            }
+            $this->page->add_to_page('controlbuttons', $this->renderer->complete_controlbuttons($controlbuttons));
+        } else {
+            $this->page->add_to_page('controlbuttons',
+                $this->renderer->complete_controlbuttons(get_string('noneinuse', 'questionnaire')));
+        }
+        $this->page->add_to_page('formend', $this->renderer->complete_formend());
+
+        return $msg;
+    }
+
+    private function survey_render($section = 1, $message = '', &$formdata) {
+
+        $this->usehtmleditor = null;
+
+        if (empty($section)) {
+            $section = 1;
+        }
+        $numsections = isset($this->questionsbysec) ? count($this->questionsbysec) : 0;
+        if ($section > $numsections) {
+            $formdata->sec = $numsections;
+            $this->page->add_to_page('notifications',
+                $this->renderer->notification(get_string('finished', 'questionnaire'), \core\output\notification::NOTIFY_WARNING));
+            return(false);  // Invalid section.
+        }
+
+        // Check to see if there are required questions.
+        $hasrequired = $this->has_required($section);
+
+        // Find out what question number we are on $i New fix for question numbering.
+        $i = 0;
+        if ($section > 1) {
+            for ($j = 2; $j <= $section; $j++) {
+                foreach ($this->questionsbysec[$j - 1] as $question) {
+                    if ($question->type_id < QUESPAGEBREAK) {
+                        $i++;
+                    }
+                }
+            }
+        }
+
+        $this->print_survey_start($message, $section, $numsections, $hasrequired, '', 1);
+        foreach ($this->questionsbysec[$section] as $question) {
+            if ($question->type_id != QUESSECTIONTEXT) {
+                $i++;
+            }
+            $this->page->add_to_page('questions',
+                $this->renderer->question_output($question, $formdata, '', $i, $this->usehtmleditor));
+        }
+
+        $this->print_survey_end($section, $numsections);
+
+        return;
+    }
+
+    private function print_survey_start($message, $section, $numsections, $hasrequired, $rid='', $blankquestionnaire=false) {
+        global $CFG, $DB;
+        require_once($CFG->libdir.'/filelib.php');
+
+        $userid = '';
+        $resp = '';
+        $groupname = '';
+        $currentgroupid = 0;
+        $timesubmitted = '';
+        // Available group modes (0 = no groups; 1 = separate groups; 2 = visible groups).
+        if ($rid) {
+            $courseid = $this->course->id;
+            if ($resp = $DB->get_record('questionnaire_response', array('id' => $rid)) ) {
+                if ($this->respondenttype == 'fullname') {
+                    $userid = $resp->userid;
+                    // Display name of group(s) that student belongs to... if questionnaire is set to Groups separate or visible.
+                    if (groups_get_activity_groupmode($this->cm, $this->course)) {
+                        if ($groups = groups_get_all_groups($courseid, $resp->userid)) {
+                            if (count($groups) == 1) {
+                                $group = current($groups);
+                                $currentgroupid = $group->id;
+                                $groupname = ' ('.get_string('group').': '.$group->name.')';
+                            } else {
+                                $groupname = ' ('.get_string('groups').': ';
+                                foreach ($groups as $group) {
+                                    $groupname .= $group->name.', ';
+                                }
+                                $groupname = substr($groupname, 0, strlen($groupname) - 2).')';
+                            }
+                        } else {
+                            $groupname = ' ('.get_string('groupnonmembers').')';
+                        }
+                    }
+
+                    $params = array(
+                                    'objectid' => $this->survey->id,
+                                    'context' => $this->context,
+                                    'courseid' => $this->course->id,
+                                    'relateduserid' => $userid,
+                                    'other' => array('action' => 'vresp', 'currentgroupid' => $currentgroupid, 'rid' => $rid)
+                    );
+                    $event = \mod_questionnaire\event\response_viewed::create($params);
+                    $event->trigger();
+                }
+            }
+        }
+        $ruser = '';
+        if ($resp && !$blankquestionnaire) {
+            if ($userid) {
+                if ($user = $DB->get_record('user', array('id' => $userid))) {
+                    $ruser = fullname($user);
+                }
+            }
+            if ($this->respondenttype == 'anonymous') {
+                $ruser = '- '.get_string('anonymous', 'questionnaire').' -';
+            } else {
+                // JR DEV comment following line out if you do NOT want time submitted displayed in Anonymous surveys.
+                if ($resp->submitted) {
+                    $timesubmitted = '&nbsp;'.get_string('submitted', 'questionnaire').'&nbsp;'.userdate($resp->submitted);
+                }
+            }
+        }
+        if ($ruser) {
+            $respinfo = get_string('respondent', 'questionnaire').': <strong>'.$ruser.'</strong>';
+            if ($this->survey->realm == 'public') {
+                // For a public questionnaire, look for the course that used it.
+                $coursename = '';
+                $sql = 'SELECT q.id, q.course, c.fullname '.
+                       'FROM {questionnaire} q, {questionnaire_attempts} qa, {course} c '.
+                       'WHERE qa.rid = ? AND q.id = qa.qid AND c.id = q.course';
+                if ($record = $DB->get_record_sql($sql, array($rid))) {
+                    $coursename = $record->fullname;
+                }
+                $respinfo .= ' '.get_string('course'). ': '.$coursename;
+            }
+            $respinfo .= $groupname;
+            $respinfo .= $timesubmitted;
+            $this->page->add_to_page('respondentinfo', $this->renderer->respondent_info($respinfo));
+        }
+
+        // We don't want to display the print icon in the print popup window itself!
+        if ($this->capabilities->printblank && $blankquestionnaire && $section == 1) {
+            // Open print friendly as popup window.
+            $linkname = '&nbsp;'.get_string('printblank', 'questionnaire');
+            $title = get_string('printblanktooltip', 'questionnaire');
+            $url = '/mod/questionnaire/print.php?qid='.$this->id.'&amp;rid=0&amp;'.'courseid='.$this->course->id.'&amp;sec=1';
+            $options = array('menubar' => true, 'location' => false, 'scrollbars' => true, 'resizable' => true,
+                    'height' => 600, 'width' => 800, 'title' => $title);
+            $name = 'popup';
+            $link = new moodle_url($url);
+            $action = new popup_action('click', $link, $name, $options);
+            $class = "floatprinticon";
+            $this->page->add_to_page('printblank',
+                $this->renderer->action_link($link, $linkname, $action, array('class' => $class, 'title' => $title),
+                new pix_icon('t/print', $title)));
+        }
+        if ($section == 1) {
+            if (!empty($this->survey->title)) {
+                $this->page->add_to_page('title', clean_text($this->survey->title, FORMAT_HTML));
+            }
+            if (!empty($this->survey->subtitle)) {
+                $this->page->add_to_page('subtitle', clean_text($this->survey->subtitle, FORMAT_HTML));
+            }
+            if ($this->survey->info) {
+                $infotext = file_rewrite_pluginfile_urls($this->survey->info, 'pluginfile.php',
+                                $this->context->id, 'mod_questionnaire', 'info', $this->survey->id);
+                $this->page->add_to_page('addinfo', $infotext);
+            }
+        }
+
+        if ($message) {
+            $this->page->add_to_page('message', $this->renderer->notification($message, \core\output\notification::NOTIFY_ERROR));
+        }
+    }
+
+    private function print_survey_end($section, $numsections) {
+        $autonum = $this->autonum;
+        // If no questions autonumbering.
+        if ($autonum < 3) {
+            return;
+        }
+        if ($numsections > 1) {
+            $a = new stdClass();
+            $a->page = $section;
+            $a->totpages = $numsections;
+            $this->page->add_to_page('pageinfo',
+                $this->renderer->container(get_string('pageof', 'questionnaire', $a).'&nbsp;&nbsp;', 'surveyPage'));
+        }
+    }
+
+    // Blankquestionnaire : if we are printing a blank questionnaire.
+    public function survey_print_render($message = '', $referer='', $courseid, $rid=0, $blankquestionnaire=false) {
+        global $DB, $CFG;
+
+        if (! $course = $DB->get_record("course", array("id" => $courseid))) {
+            print_error('incorrectcourseid', 'questionnaire');
+        }
+
+        $this->course = $course;
+
+        if (!empty($rid)) {
+            // If we're viewing a response, use this method.
+            $this->view_response($rid, $referer, $blankquestionnaire);
+            return;
+        }
+
+        if (empty($section)) {
+            $section = 1;
+        }
+
+        if (isset($this->questionsbysec)) {
+            $numsections = count($this->questionsbysec);
+        } else {
+            $numsections = 0;
+        }
+
+        if ($section > $numsections) {
+            return(false);  // Invalid section.
+        }
+
+        $hasrequired = $this->has_required();
+
+        // Find out what question number we are on $i.
+        $i = 1;
+        for ($j = 2; $j <= $section; $j++) {
+            $i += count($this->questionsbysec[$j - 1]);
+        }
+
+        $action = $CFG->wwwroot.'/mod/questionnaire/preview.php?id='.$this->cm->id;
+        $this->page->add_to_page('formstart',
+            $this->renderer->complete_formstart($action));
+        // Print all sections.
+        $formdata = new stdClass();
+        $errors = 1;
+        if (data_submitted()) {
+            $formdata = data_submitted();
+            $pageerror = '';
+            $s = 1;
+            $errors = 0;
+            foreach ($this->questionsbysec as $section) {
+                $errormessage = $this->response_check_format($s, $formdata);
+                if ($errormessage) {
+                    if ($numsections > 1) {
+                        $pageerror = get_string('page', 'questionnaire').' '.$s.' : ';
+                    }
+                    $this->page->add_to_page('notifications',
+                        $this->renderer->notification($pageerror.$errormessage, \core\output\notification::NOTIFY_ERROR));
+                    $errors++;
+                }
+                $s ++;
+            }
+        }
+
+        $this->print_survey_start($message, $section = 1, 1, $hasrequired, $rid = '');
+
+        $descendantsandchoices = array();
+
+        if ($referer == 'preview' && questionnaire_has_dependencies($this->questions) ) {
+                $descendantsandchoices = questionnaire_get_descendants_and_choices($this->questions);
+        }
+        if ($errors == 0) {
+            $this->page->add_to_page('message',
+                $this->renderer->notification(get_string('submitpreviewcorrect', 'questionnaire'),
+                    \core\output\notification::NOTIFY_SUCCESS));
+        }
+
+        $page = 1;
+        foreach ($this->questionsbysec as $section) {
+            $output = '';
+            if ($numsections > 1) {
+                $output .= $this->renderer->print_preview_pagenumber(get_string('page', 'questionnaire').' '.$page);
+                $page++;
+            }
+            foreach ($section as $question) {
+                $descendantsdata = array();
+                if ($question->type_id == QUESSECTIONTEXT) {
+                    $i--;
+                }
+                if ($referer == 'preview' && $descendantsandchoices && ($question->type_id == QUESYESNO
+                                || $question->type_id == QUESRADIO || $question->type_id == QUESDROP) ) {
+                    if (isset ($descendantsandchoices['descendants'][$question->id])) {
+                        $descendantsdata['descendants'] = $descendantsandchoices['descendants'][$question->id];
+                        $descendantsdata['choices'] = $descendantsandchoices['choices'][$question->id];
+                    }
+                }
+
+                $output .= $this->renderer->question_output($question, $formdata, $descendantsdata, $i++, null);
+                $this->page->add_to_page('questions', $output);
+                $output = '';
+            }
+        }
+        // End of questions.
+        if ($referer == 'preview' && !$blankquestionnaire) {
+            $url = $CFG->wwwroot.'/mod/questionnaire/preview.php?id='.$this->cm->id;
+            $this->page->add_to_page('formend',
+                $this->renderer->print_preview_formend($url, get_string('submitpreview', 'questionnaire'), get_string('reset')));
+        }
+        return;
+    }
+
+    public function survey_update($sdata) {
+        global $DB;
+
+        $errstr = ''; // TODO: notused!
+
+        // New survey.
+        if (empty($this->survey->id)) {
+            // Create a new survey in the database.
+            $fields = array('name', 'realm', 'title', 'subtitle', 'email', 'theme', 'thanks_page', 'thank_head',
+                            'thank_body', 'feedbacknotes', 'info', 'feedbacksections', 'feedbackscores', 'chart_type');
+            // Theme field deprecated.
+            $record = new stdClass();
+            $record->id = 0;
+            $record->courseid = $sdata->courseid;
+            foreach ($fields as $f) {
+                if (isset($sdata->$f)) {
+                    $record->$f = $sdata->$f;
+                }
+            }
+
+            $this->survey = new stdClass();
+            $this->survey->id = $DB->insert_record('questionnaire_survey', $record);
+            $this->add_survey($this->survey->id);
+
+            if (!$this->survey->id) {
+                $errstr = get_string('errnewname', 'questionnaire') .' [ :  ]'; // TODO: notused!
+                return(false);
+            }
+        } else {
+            if (empty($sdata->name) || empty($sdata->title)
+                    || empty($sdata->realm)) {
+                return(false);
+            }
+            if (!isset($sdata->chart_type)) {
+                $sdata->chart_type = '';
+            }
+
+            $fields = array('name', 'realm', 'title', 'subtitle', 'email', 'theme', 'thanks_page',
+                    'thank_head', 'thank_body', 'feedbacknotes', 'info', 'feedbacksections', 'feedbackscores', 'chart_type');
+            $name = $DB->get_field('questionnaire_survey', 'name', array('id' => $this->survey->id));
+
+            // Trying to change survey name.
+            if (trim($name) != trim(stripslashes($sdata->name))) {  // $sdata will already have slashes added to it.
+                $count = $DB->count_records('questionnaire_survey', array('name' => $sdata->name));
+                if ($count != 0) {
+                    $errstr = get_string('errnewname', 'questionnaire');  // TODO: notused!
+                    return(false);
+                }
+            }
+
+            // UPDATE the row in the DB with current values.
+            $surveyrecord = new stdClass();
+            $surveyrecord->id = $this->survey->id;
+            foreach ($fields as $f) {
+                $surveyrecord->$f = trim($sdata->{$f});
+            }
+
+            $result = $DB->update_record('questionnaire_survey', $surveyrecord);
+            if (!$result) {
+                $errstr = get_string('warning', 'questionnaire').' [ :  ]';  // TODO: notused!
+                return(false);
+            }
+        }
+
+        return($this->survey->id);
+    }
+
+    /* Creates an editable copy of a survey. */
+    public function survey_copy($owner) {
+        global $DB;
+
+        // Clear the sid, clear the creation date, change the name, and clear the status.
+        $survey = clone($this->survey);
+
+        unset($survey->id);
+        $survey->courseid = $owner;
+        // Make sure that the survey name is not larger than the field size (CONTRIB-2999). Leave room for extra chars.
+        $survey->name = core_text::substr($survey->name, 0, (64 - 10));
+
+        $survey->name .= '_copy';
+        $survey->status = 0;
+
+        // Check for 'name' conflict, and resolve.
+        $i = 0;
+        $name = $survey->name;
+        while ($DB->count_records('questionnaire_survey', array('name' => $name)) > 0) {
+            $name = $survey->name.(++$i);
+        }
+        if ($i) {
+            $survey->name .= $i;
+        }
+
+        // Create new survey.
+        if (!($newsid = $DB->insert_record('questionnaire_survey', $survey))) {
+            return(false);
+        }
+
+        // Make copies of all the questions.
+        $pos = 1;
+        // Skip logic: some changes needed here for dependencies down below.
+        $qidarray = array();
+        $cidarray = array();
+        foreach ($this->questions as $question) {
+            // Fix some fields first.
+            $oldid = $question->id;
+            unset($question->id);
+            $question->survey_id = $newsid;
+            $question->position = $pos++;
+
+            // Copy question to new survey.
+            if (!($newqid = $DB->insert_record('questionnaire_question', $question))) {
+                return(false);
+            }
+            $qidarray[$oldid] = $newqid;
+            foreach ($question->choices as $key => $choice) {
+                $oldcid = $key;
+                unset($choice->id);
+                $choice->question_id = $newqid;
+                if (!$newcid = $DB->insert_record('questionnaire_quest_choice', $choice)) {
+                    return(false);
+                }
+                $cidarray[$oldcid] = $newcid;
+            }
+        }
+        // Skip logic: now we need to set the new values for dependencies.
+        if ($newquestions = $DB->get_records('questionnaire_question', array('survey_id' => $newsid), 'id')) {
+            foreach ($newquestions as $question) {
+                if ($question->dependquestion != 0) {
+                    $dependqtypeid = $this->questions[$question->dependquestion]->type_id;
+                    $record = new stdClass();
+                    $record->id = $question->id;
+                    $record->dependquestion = $qidarray[$question->dependquestion];
+                    if ($dependqtypeid != 1) {
+                        $record->dependchoice = $cidarray[$question->dependchoice];
+                    }
+                    $DB->update_record('questionnaire_question', $record);
+                }
+            }
+        }
+
+        return($newsid);
+    }
+
+    // RESPONSE LIBRARY.
+
+    private function response_check_format($section, $formdata, $checkmissing = true, $checkwrongformat = true) {
+        $missing = 0;
+        $strmissing = '';     // Missing questions.
+        $wrongformat = 0;
+        $strwrongformat = ''; // Wrongly formatted questions (Numeric, 5:Check Boxes, Date).
+        $i = 1;
+        for ($j = 2; $j <= $section; $j++) {
+            // ADDED A SIMPLE LOOP FOR MAKING SURE PAGE BREAKS (type 99) AND LABELS (type 100) ARE NOT ALLOWED.
+            foreach ($this->questionsbysec[$j - 1] as $sectionrecord) {
+                $tid = $sectionrecord->type_id;
+                if ($tid < QUESPAGEBREAK) {
+                    $i++;
+                }
+            }
+        }
+        $qnum = $i - 1;
+
+        foreach ($this->questionsbysec[$section] as $question) {
+            $qid = $question->id;
+            $tid = $question->type_id;
+            $lid = $question->length;
+            $pid = $question->precise;
+            if ($tid != QUESSECTIONTEXT) {
+                $qnum++;
+            }
+            if (!$question->response_complete($formdata)) {
+                $missing++;
+                $strmissing .= get_string('num', 'questionnaire').$qnum.'. ';
+            }
+            if (!$question->response_valid($formdata)) {
+                $wrongformat++;
+                $strwrongformat .= get_string('num', 'questionnaire').$qnum.'. ';
+            }
+        }
+        $message = '';
+        $nonumbering = false;
+        $autonum = $this->autonum;
+        // If no questions autonumbering do not display missing question(s) number(s).
+        if ($autonum != 1 && $autonum != 3) {
+            $nonumbering = true;
+        }
+        if ($checkmissing && $missing) {
+            if ($nonumbering) {
+                $strmissing = '';
+            }
+            if ($missing == 1) {
+                $message = get_string('missingquestion', 'questionnaire').$strmissing;
+            } else {
+                $message = get_string('missingquestions', 'questionnaire').$strmissing;
+            }
+            if ($wrongformat) {
+                $message .= '<br />';
+            }
+        }
+        if ($checkwrongformat && $wrongformat) {
+            if ($nonumbering) {
+                $message .= get_string('wronganswers', 'questionnaire');
+            } else {
+                if ($wrongformat == 1) {
+                    $message .= get_string('wrongformat', 'questionnaire').$strwrongformat;
+                } else {
+                    $message .= get_string('wrongformats', 'questionnaire').$strwrongformat;
+                }
+            }
+        }
+        return ($message);
+    }
+
+    private function response_delete($rid, $sec = null) {
+        global $DB;
+
+        if (empty($rid)) {
+            return;
+        }
+
+        if ($sec != null) {
+            if ($sec < 1) {
+                return;
+            }
+
+            // Skip logic.
+            $numsections = isset($this->questionsbysec) ? count($this->questionsbysec) : 0;
+            $sec = min($numsections , $sec);
+
+            /* get question_id's in this section */
+            $qids = array();
+            foreach ($this->questionsbysec[$sec] as $question) {
+                $qids[] = $question->id;
+            }
+            if (empty($qids)) {
+                return;
+            } else {
+                list($qsql, $params) = $DB->get_in_or_equal($qids);
+                $qsql = ' AND question_id ' . $qsql;
+            }
+
+        } else {
+            /* delete all */
+            $qsql = '';
+            $params = array();
+        }
+
+        /* delete values */
+        $select = 'response_id = \'' . $rid . '\' ' . $qsql;
+        foreach (array('response_bool', 'resp_single', 'resp_multiple', 'response_rank', 'response_text',
+                       'response_other', 'response_date') as $tbl) {
+            $DB->delete_records_select('questionnaire_'.$tbl, $select, $params);
+        }
+    }
+
+    private function response_import_sec($rid, $sec, &$varr) {
+        if ($sec < 1 || !isset($this->questionsbysec[$sec])) {
+            return;
+        }
+        $vals = $this->response_select($rid, 'content');
+        reset($vals);
+        foreach ($vals as $id => $arr) {
+            if (isset($arr[0]) && is_array($arr[0])) {
+                // Multiple.
+                $varr->{'q'.$id} = array_map('array_pop', $arr);
+            } else {
+                $varr->{'q'.$id} = array_pop($arr);
+            }
+        }
+    }
+
+    private function response_import_all($rid, &$varr) {
+
+        $vals = $this->response_select($rid, 'content');
+        reset($vals);
+        foreach ($vals as $id => $arr) {
+            if (strstr($id, '_') && isset($arr[4])) { // Single OR multiple with !other choice selected.
+                $varr->{'q'.$id} = $arr[4];
+            } else {
+                if (isset($arr[0]) && is_array($arr[0])) { // Multiple.
+                    $varr->{'q'.$id} = array_map('array_pop', $arr);
+                } else { // Boolean, rate and other.
+                    $varr->{'q'.$id} = array_pop($arr);
+                }
+            }
+        }
+    }
+
+    private function response_commit($rid) {
+        global $DB;
+
+        $record = new stdClass();
+        $record->id = $rid;
+        $record->complete = 'y';
+        $record->submitted = time();
+
+        if ($this->grade < 0) {
+            $record->grade = 1;  // Don't know what to do if its a scale...
+        } else {
+            $record->grade = $this->grade;
+        }
+        return $DB->update_record('questionnaire_response', $record);
+    }
+
+    private function get_response($userid, $rid = 0) {
+        global $DB;
+
+        $rid = intval($rid);
+        if ($rid != 0) {
+            // Check for valid rid.
+            $fields = 'id, userid';
+            $select = 'id = '.$rid.' AND survey_id = '.$this->sid.' AND userid = '.$userid.' AND complete = \'n\'';
+            return ($DB->get_record_select('questionnaire_response', $select, null, $fields) !== false) ? $rid : '';
+
+        } else {
+            // Find latest in progress rid.
+            $select = 'survey_id = '.$this->sid.' AND complete = \'n\' AND userid = '.$userid;
+            if ($records = $DB->get_records_select('questionnaire_response', $select, null, 'submitted DESC',
+                                              'id,survey_id', 0, 1)) {
+                $rec = reset($records);
+                return $rec->id;
+            } else {
+                return '';
+            }
+        }
+    }
+
+    // Returns the number of the section in which questions have been answered in a response.
+    private function response_select_max_sec($rid) {
+        global $DB;
+
+        $pos = $this->response_select_max_pos($rid);
+        $select = 'survey_id = \''.$this->sid.'\' AND type_id = 99 AND position < '.$pos.' AND deleted = \'n\'';
+        $max = $DB->count_records_select('questionnaire_question', $select) + 1;
+
+        return $max;
+    }
+
+    // Returns the position of the last answered question in a response.
+    private function response_select_max_pos($rid) {
+        global $DB;
+
+        $max = 0;
+
+        foreach (array('response_bool', 'resp_single', 'resp_multiple', 'response_rank', 'response_text',
+                       'response_other', 'response_date') as $tbl) {
+            $sql = 'SELECT MAX(q.position) as num FROM {questionnaire_'.$tbl.'} a, {questionnaire_question} q '.
+                   'WHERE a.response_id = ? AND '.
+                   'q.id = a.question_id AND '.
+                   'q.survey_id = ? AND '.
+                   'q.deleted = \'n\'';
+            if ($record = $DB->get_record_sql($sql, array($rid, $this->sid))) {
+                $newmax = (int)$record->num;
+                if ($newmax > $max) {
+                    $max = $newmax;
+                }
+            }
+        }
+        return $max;
+    }
+
+    /* {{{ proto array response_select_name(int survey_id, int response_id, array question_ids)
+       A wrapper around response_select(), that returns an array of
+       key/value pairs using the field name as the key.
+       $csvexport = true: a parameter to return a different response formatting for CSV export from normal report formatting
+     */
+    private function response_select_name($rid, $choicecodes, $choicetext) {
+        $res = $this->response_select($rid, 'position, type_id, name', true, $choicecodes, $choicetext);
+        $nam = array();
+        reset($res);
+        $subqnum = 0;
+        $oldpos = '';
+        while (list($qid, $arr) = each($res)) {
+            // Question position (there may be "holes" in positions list).
+            $qpos = $arr[0];
+            // Question type (1-bool,2-text,3-essay,4-radio,5-check,6-dropdn,7-rating(not used),8-rate,9-date,10-numeric).
+            $qtype = $arr[1];
+            // Variable name; (may be empty); for rate questions: 'variable group' name.
+            $qname = $arr[2];
+            // Modality; for rate questions: variable.
+            $qchoice = $arr[3];
+
+            // Strip potential html tags from modality name.
+            if (!empty($qchoice)) {
+                $qchoice = strip_tags($arr[3]);
+                $qchoice = preg_replace("/[\r\n\t]/", ' ', $qchoice);
+            }
+            // For rate questions: modality; for multichoice: selected = 1; not selected = 0.
+            $q4 = '';
+            if (isset($arr[4])) {
+                $q4 = $arr[4];
+            }
+            if (strstr($qid, '_')) {
+                if ($qtype == QUESRADIO) {     // Single.
+                    $nam[$qpos][$qname.'_'.get_string('other', 'questionnaire')] = $q4;
+                    continue;
+                }
+                // Multiple OR rank.
+                if ($oldpos != $qpos) {
+                    $subqnum = 1;
+                    $oldpos = $qpos;
+                } else {
+                        $subqnum++;
+                }
+                if ($qtype == QUESRATE) {     // Rate.
+                    $qname .= "->$qchoice";
+                    if ($q4 == -1) {
+                        // Here $q4 = get_string('notapplicable', 'questionnaire'); DEV JR choose one solution please.
+                        $q4 = '';
+                    } else {
+                        if (is_numeric($q4)) {
+                            $q4++;
+                        }
+                    }
+                } else {     // Multiple.
+                    $qname .= "->$qchoice";
+                }
+                $nam[$qpos][$qname] = $q4;
+                continue;
+            }
+            $val = $qchoice;
+            $nam[$qpos][$qname] = $val;
+        }
+        return $nam;
+    }
+
+    /**
+     * Handle all submission notification actions.
+     * @param int $rid The id of the response record.
+     * @return boolean Operation success.
+     *
+     */
+    private function submission_notify($rid) {
+        $success = true;
+
+        $success = $this->response_send_email($rid) && $success;
+
+        if ($this->notifications) {
+            // Handle notification of submissions.
+            $success = $this->send_submission_notifications($rid) && $success;
+        }
+
+        return $success;
+    }
+
+    /**
+     * Send submission notifications to users with "submissionnotification" capability.
+     * @param int $rid The id of the response record.
+     * @return boolean Operation success.
+     *
+     */
+    private function send_submission_notifications($rid) {
+        global $CFG, $USER;
+
+        $success = true;
+        if ($notifyusers = $this->get_notifiable_users($USER->id)) {
+            $info = new stdClass();
+            // Need to handle user differently for anonymous surveys.
+            if ($this->respondenttype != 'anonymous') {
+                $info->userfrom = $USER;
+                $info->username = fullname($info->userfrom, true);
+                $info->profileurl = $CFG->wwwroot.'/user/view.php?id='.$info->userfrom->id.'&course='.$this->course->id;
+                $langstringtext = 'submissionnotificationtextuser';
+                $langstringhtml = 'submissionnotificationhtmluser';
+            } else {
+                $info->userfrom = \core_user::get_noreply_user();
+                $info->username = '';
+                $info->profileurl = '';
+                $langstringtext = 'submissionnotificationtextanon';
+                $langstringhtml = 'submissionnotificationhtmlanon';
+            }
+            $info->name = format_string($this->name);
+            $info->submissionurl = $CFG->wwwroot.'/mod/questionnaire/report.php?action=vresp&sid='.$this->survey->id.
+                    '&rid='.$rid.'&instance='.$this->id;
+
+            $info->postsubject = get_string('submissionnotificationsubject', 'questionnaire');
+            $info->posttext = get_string($langstringtext, 'questionnaire', $info);
+            $info->posthtml = '<p>' . get_string($langstringhtml, 'questionnaire', $info) . '</p>';
+
+            foreach ($notifyusers as $notifyuser) {
+                $info->userto = $notifyuser;
+                $this->send_message($info, 'notification');
+            }
+        }
+
+        return $success;
+    }
+
+    /**
+     * Message someone about something.
+     *
+     * @param object $info The information for the message.
+     * @param string $eventtype
+     * @return void
+     */
+    private function send_message($info, $eventtype) {
+        global $USER;
+
+        $eventdata = new \core\message\message();
+        $eventdata->courseid         = $this->course->id;
+        $eventdata->modulename       = 'questionnaire';
+        $eventdata->userfrom         = $info->userfrom;
+        $eventdata->userto           = $info->userto;
+        $eventdata->subject          = $info->postsubject;
+        $eventdata->fullmessage      = $info->posttext;
+        $eventdata->fullmessageformat = FORMAT_PLAIN;
+        $eventdata->fullmessagehtml  = $info->posthtml;
+        $eventdata->smallmessage     = $info->postsubject;
+
+        $eventdata->name            = $eventtype;
+        $eventdata->component       = 'mod_questionnaire';
+        $eventdata->notification    = 1;
+        $eventdata->contexturl      = $info->submissionurl;
+        $eventdata->contexturlname  = $info->name;
+
+        message_send($eventdata);
+    }
+
+    /**
+     * Returns a list of users that should receive notification about given submission.
+     *
+     * @param int $userid The submission to grade
+     * @return array
+     */
+    protected function get_notifiable_users($userid) {
+        // Potential users should be active users only.
+        $potentialusers = get_enrolled_users($this->context, 'mod/questionnaire:submissionnotification',
+            null, 'u.*', null, null, null, true);
+
+        $notifiableusers = [];
+        if (groups_get_activity_groupmode($this->cm) == SEPARATEGROUPS) {
+            if ($groups = groups_get_all_groups($this->course->id, $userid, $this->cm->groupingid)) {
+                foreach ($groups as $group) {
+                    foreach ($potentialusers as $potentialuser) {
+                        if ($potentialuser->id == $userid) {
+                            // Do not send self.
+                            continue;
+                        }
+                        if (groups_is_member($group->id, $potentialuser->id)) {
+                            $notifiableusers[$potentialuser->id] = $potentialuser;
+                        }
+                    }
+                }
+            } else {
+                // User not in group, try to find graders without group.
+                foreach ($potentialusers as $potentialuser) {
+                    if ($potentialuser->id == $userid) {
+                        // Do not send self.
+                        continue;
+                    }
+                    if (!groups_has_membership($this->cm, $potentialuser->id)) {
+                        $notifiableusers[$potentialuser->id] = $potentialuser;
+                    }
+                }
+            }
+        } else {
+            foreach ($potentialusers as $potentialuser) {
+                if ($potentialuser->id == $userid) {
+                    // Do not send self.
+                    continue;
+                }
+                $notifiableusers[$potentialuser->id] = $potentialuser;
+            }
+        }
+        return $notifiableusers;
+    }
+
+    private function response_send_email($rid) {
+        global $CFG, $DB, $USER;
+
+        require_once($CFG->libdir.'/phpmailer/class.phpmailer.php');
+
+        $name = s($this->name);
+        if (isset($this->survey) && isset($this->survey->email)) {
+            $email = $this->survey->email;
+        } else if ($record = $DB->get_record('questionnaire_survey', ['id' => $this->survey->id])) {
+            $email = $record->email;
+        } else {
+            $email = '';
+        }
+
+        if (empty($email)) {
+            return(false);
+        }
+        $answers = $this->generate_csv($rid, '', null, 1, 0);
+
+        // Line endings for html and plaintext emails.
+        $endhtml = "\r\n<br>";
+        $endplaintext = "\r\n";
+
+        $subject = get_string('surveyresponse', 'questionnaire') .": $name [$rid]";
+        $url = $CFG->wwwroot.'/mod/questionnaire/report.php?action=vresp&amp;sid='.$this->survey->id.
+                '&amp;rid='.$rid.'&amp;instance='.$this->id;
+
+        // Html and plaintext body.
+        $bodyhtml        = '<a href="'.$url.'">'.$url.'</a>'.$endhtml;
+        $bodyplaintext   = $url.$endplaintext;
+        $bodyhtml       .= get_string('surveyresponse', 'questionnaire') .' "'.$name.'"'.$endhtml;
+        $bodyplaintext  .= get_string('surveyresponse', 'questionnaire') .' "'.$name.'"'.$endplaintext;
+
+        reset($answers);
+
+        for ($i = 0; $i < count($answers[0]); $i++) {
+            $sep = ' : ';
+
+            switch($i) {
+                case 1:
+                    $sep = ' ';
+                    break;
+                case 4:
+                    $bodyhtml        .= get_string('user').' ';
+                    $bodyplaintext   .= get_string('user').' ';
+                    break;
+                case 6:
+                    if ($this->respondenttype != 'anonymous') {
+                        $bodyhtml         .= get_string('email').$sep.$USER->email. $endhtml;
+                        $bodyplaintext    .= get_string('email').$sep.$USER->email. $endplaintext;
+                    }
+            }
+            $bodyhtml         .= $answers[0][$i].$sep.$answers[1][$i]. $endhtml;
+            $bodyplaintext    .= $answers[0][$i].$sep.$answers[1][$i]. $endplaintext;
+        }
+
+        // Use plaintext version for altbody.
+        $altbody = "\n$bodyplaintext\n";
+
+        $return = true;
+        $mailaddresses = preg_split('/,|;/', $email);
+        foreach ($mailaddresses as $email) {
+            $userto = new stdClass();
+            $userto->email = $email;
+            $userto->mailformat = 1;
+            // Dummy userid to keep email_to_user happy in moodle 2.6.
+            $userto->id = -10;
+            $userfrom = $CFG->noreplyaddress;
+            if (email_to_user($userto, $userfrom, $subject, $altbody, $bodyhtml)) {
+                $return = $return && true;
+            } else {
+                $return = false;
+            }
+        }
+        return $return;
+    }
+
+    public function response_insert($sid, $section, $rid, $userid, $resume=false) {
+        global $DB;
+
+        $record = new stdClass();
+        $record->submitted = time();
+
+        if (empty($rid)) {
+            // Create a uniqe id for this response.
+            $record->survey_id = $sid;
+            $record->userid = $userid;
+            $rid = $DB->insert_record('questionnaire_response', $record);
+        } else {
+            $record->id = $rid;
+            $DB->update_record('questionnaire_response', $record);
+        }
+        if ($resume) {
+            // Log this saved response.
+            // Needed for the event logging.
+            $context = context_module::instance($this->cm->id);
+            $anonymous = $this->respondenttype == 'anonymous';
+            $params = array(
+                            'context' => $context,
+                            'courseid' => $this->course->id,
+                            'relateduserid' => $userid,
+                            'anonymous' => $anonymous,
+                            'other' => array('questionnaireid' => $this->id)
+            );
+            $event = \mod_questionnaire\event\attempt_saved::create($params);
+            $event->trigger();
+        }
+
+        if (!empty($this->questionsbysec[$section])) {
+            foreach ($this->questionsbysec[$section] as $question) {
+                // NOTE *** $val really should be a value obtained from the caller or somewhere else.
+                // Note that "optional_param" accepting arrays is deprecated for optional_param_array.
+                if ($question->response_table == 'resp_multiple') {
+                    $val = optional_param_array('q'.$question->id, '', PARAM_RAW);
+                } else {
+                    $val = optional_param('q'.$question->id, '', PARAM_RAW);
+                }
+                $question->insert_response($rid, $val);
+            }
+        }
+        return($rid);
+    }
+
+    private function response_select($rid, $col = null, $csvexport = false, $choicecodes=0, $choicetext=1) {
+        global $DB;
+
+        $sid = $this->survey->id;
+        $values = array();
+        $stringother = get_string('other', 'questionnaire');
+        if ($col == null) {
+            $col = '';
+        }
+        if (!is_array($col) && !empty($col)) {
+            $col = explode(',', preg_replace("/\s/", '', $col));
+        }
+        if (is_array($col) && count($col) > 0) {
+            $callback = function($a) {
+                return 'q.'.$a;
+            };
+            $col = ',' . implode(',', array_map($callback, $col));
+        }
+
+        // Response_bool (yes/no).
+        $sql = 'SELECT q.id '.$col.', a.choice_id '.
+               'FROM {questionnaire_response_bool} a, {questionnaire_question} q '.
+               'WHERE a.response_id= ? AND a.question_id=q.id ';
+        if ($records = $DB->get_records_sql($sql, array($rid))) {
+            foreach ($records as $qid => $row) {
+                $choice = $row->choice_id;
+                if (isset ($row->name) && $row->name == '') {
+                    $noname = true;
+                }
+                unset ($row->id);
+                unset ($row->choice_id);
+                $row = (array)$row;
+                $newrow = array();
+                foreach ($row as $key => $val) {
+                    if (!is_numeric($key)) {
+                        $newrow[] = $val;
+                    }
+                }
+                $values[$qid] = $newrow;
+                array_push($values["$qid"], ($choice == 'y') ? '1' : '0');
+                if (!$csvexport) {
+                    array_push($values["$qid"], $choice); // DEV still needed for responses display.
+                }
+            }
+        }
+
+        // Response_single (radio button or dropdown).
+        $sql = 'SELECT q.id '.$col.', q.type_id as q_type, c.content as ccontent,c.id as cid '.
+               'FROM {questionnaire_resp_single} a, {questionnaire_question} q, {questionnaire_quest_choice} c '.
+               'WHERE a.response_id = ? AND a.question_id=q.id AND a.choice_id=c.id ';
+        if ($records = $DB->get_records_sql($sql, array($rid))) {
+            foreach ($records as $qid => $row) {
+                $cid = $row->cid;
+                $qtype = $row->q_type;
+                if ($csvexport) {
+                    static $i = 1;
+                    $qrecords = $DB->get_records('questionnaire_quest_choice', array('question_id' => $qid));
+                    foreach ($qrecords as $value) {
+                        if ($value->id == $cid) {
+                            $contents = questionnaire_choice_values($value->content);
+                            if ($contents->modname) {
+                                $row->ccontent = $contents->modname;
+                            } else {
+                                $content = $contents->text;
+                                if (preg_match('/^!other/', $content)) {
+                                    $row->ccontent = get_string('other', 'questionnaire');
+                                } else if (($choicecodes == 1) && ($choicetext == 1)) {
+                                    $row->ccontent = "$i : $content";
+                                } else if ($choicecodes == 1) {
+                                    $row->ccontent = "$i";
+                                } else {
+                                    $row->ccontent = $content;
+                                }
+                            }
+                            $i = 1;
+                            break;
+                        }
+                        $i++;
+                    }
+                }
+                unset($row->id);
+                unset($row->cid);
+                unset($row->q_type);
+                $arow = get_object_vars($row);
+                $newrow = array();
+                foreach ($arow as $key => $val) {
+                    if (!is_numeric($key)) {
+                        $newrow[] = $val;
+                    }
+                }
+                if (preg_match('/^!other/', $row->ccontent)) {
+                    $newrow[] = 'other_' . $cid;
+                } else {
+                    $newrow[] = (int)$cid;
+                }
+                $values[$qid] = $newrow;
+            }
+        }
+
+        // Response_multiple.
+        $sql = 'SELECT a.id as aid, q.id as qid '.$col.',c.content as ccontent,c.id as cid '.
+               'FROM {questionnaire_resp_multiple} a, {questionnaire_question} q, {questionnaire_quest_choice} c '.
+               'WHERE a.response_id = ? AND a.question_id=q.id AND a.choice_id=c.id '.
+               'ORDER BY a.id,a.question_id,c.id';
+        $records = $DB->get_records_sql($sql, array($rid));
+        if ($csvexport) {
+            $tmp = null;
+            if (!empty($records)) {
+                $qids2 = array();
+                $oldqid = '';
+                foreach ($records as $qid => $row) {
+                    if ($row->qid != $oldqid) {
+                        $qids2[] = $row->qid;
+                        $oldqid = $row->qid;
+                    }
+                }
+                list($qsql, $params) = $DB->get_in_or_equal($qids2);
+                $sql = 'SELECT * FROM {questionnaire_quest_choice} WHERE question_id ' . $qsql . ' ORDER BY id';
+                if ($records2 = $DB->get_records_sql($sql, $params)) {
+                    foreach ($records2 as $qid => $row2) {
+                        $selected = '0';
+                        $qid2 = $row2->question_id;
+                        $cid2 = $row2->id;
+                        $c2 = $row2->content;
+                        $otherend = false;
+                        if ($c2 == '!other') {
+                            $c2 = '!other='.get_string('other', 'questionnaire');
+                        }
+                        if (preg_match('/^!other/', $c2)) {
+                            $otherend = true;
+                        } else {
+                            $contents = questionnaire_choice_values($c2);
+                            if ($contents->modname) {
+                                $c2 = $contents->modname;
+                            } else if ($contents->title) {
+                                $c2 = $contents->title;
+                            }
+                        }
+                        $sql = 'SELECT a.name as name, a.type_id as q_type, a.position as pos ' .
+                                'FROM {questionnaire_question} a WHERE id = ?';
+                        if ($currentquestion = $DB->get_records_sql($sql, array($qid2))) {
+                            foreach ($currentquestion as $question) {
+                                $name1 = $question->name;
+                                $type1 = $question->q_type;
+                            }
+                        }
+                        $newrow = array();
+                        foreach ($records as $qid => $row1) {
+                            $qid1 = $row1->qid;
+                            $cid1 = $row1->cid;
+                            // If available choice has been selected by student.
+                            if ($qid1 == $qid2 && $cid1 == $cid2) {
+                                $selected = '1';
+                            }
+                        }
+                        if ($otherend) {
+                            $newrow2 = array();
+                            $newrow2[] = $question->pos;
+                            $newrow2[] = $type1;
+                            $newrow2[] = $name1;
+                            $newrow2[] = '['.get_string('other', 'questionnaire').']';
+                            $newrow2[] = $selected;
+                            $tmp2 = $qid2.'_other';
+                            $values["$tmp2"] = $newrow2;
+                        }
+                        $newrow[] = $question->pos;
+                        $newrow[] = $type1;
+                        $newrow[] = $name1;
+                        $newrow[] = $c2;
+                        $newrow[] = $selected;
+                        $tmp = $qid2.'_'.$cid2;
+                        $values["$tmp"] = $newrow;
+                    }
+                }
+            }
+            unset($tmp);
+            unset($row);
+
+        } else {
+                $arr = array();
+                $tmp = null;
+            if (!empty($records)) {
+                foreach ($records as $aid => $row) {
+                    $qid = $row->qid;
+                    $cid = $row->cid;
+                    unset($row->aid);
+                    unset($row->qid);
+                    unset($row->cid);
+                    $arow = get_object_vars($row);
+                    $newrow = array();
+                    foreach ($arow as $key => $val) {
+                        if (!is_numeric($key)) {
+                            $newrow[] = $val;
+                        }
+                    }
+                    if (preg_match('/^!other/', $row->ccontent)) {
+                        $newrow[] = 'other_' . $cid;
+                    } else {
+                        $newrow[] = (int)$cid;
+                    }
+                    if ($tmp == $qid) {
+                        $arr[] = $newrow;
+                        continue;
+                    }
+                    if ($tmp != null) {
+                        $values["$tmp"] = $arr;
+                    }
+                    $tmp = $qid;
+                    $arr = array($newrow);
+                }
+            }
+            if ($tmp != null) {
+                $values["$tmp"] = $arr;
+            }
+            unset($arr);
+            unset($tmp);
+            unset($row);
+        }
+
+            // Response_other.
+            // This will work even for multiple !other fields within one question
+            // AND for identical !other responses in different questions JR.
+        $sql = 'SELECT c.id as cid, c.content as content, a.response as aresponse, q.id as qid, q.position as position,
+                                    q.type_id as type_id, q.name as name '.
+               'FROM {questionnaire_response_other} a, {questionnaire_question} q, {questionnaire_quest_choice} c '.
+               'WHERE a.response_id= ? AND a.question_id=q.id AND a.choice_id=c.id '.
+               'ORDER BY a.question_id,c.id ';
+        if ($records = $DB->get_records_sql($sql, array($rid))) {
+            foreach ($records as $record) {
+                $newrow = array();
+                $position = $record->position;
+                $typeid = $record->type_id;
+                $name = $record->name;
+                $cid = $record->cid;
+                $qid = $record->qid;
+                $content = $record->content;
+
+                // The !other modality with no label.
+                if ($content == '!other') {
+                    $content = '!other='.$stringother;
+                }
+                $content = substr($content, 7);
+                $aresponse = $record->aresponse;
+                // The first two empty values are needed for compatibility with "normal" (non !other) responses.
+                // They are only needed for the CSV export, in fact.
+                $newrow[] = $position;
+                $newrow[] = $typeid;
+                $newrow[] = $name;
+                $content = $stringother;
+                $newrow[] = $content;
+                $newrow[] = $aresponse;
+                $values["${qid}_${cid}"] = $newrow;
+            }
+        }
+
+        // Response_rank.
+        $sql = 'SELECT a.id as aid, q.id AS qid, q.precise AS precise, c.id AS cid '.$col.', c.content as ccontent,
+                                a.rank as arank '.
+               'FROM {questionnaire_response_rank} a, {questionnaire_question} q, {questionnaire_quest_choice} c '.
+               'WHERE a.response_id= ? AND a.question_id=q.id AND a.choice_id=c.id '.
+               'ORDER BY aid, a.question_id, c.id';
+        if ($records = $DB->get_records_sql($sql, array($rid))) {
+            foreach ($records as $row) {
+                // Next two are 'qid' and 'cid', each with numeric and hash keys.
+                $osgood = false;
+                if ($row->precise == 3) {
+                    $osgood = true;
+                }
+                $qid = $row->qid.'_'.$row->cid;
+                unset($row->aid); // Get rid of the answer id.
+                unset($row->qid);
+                unset($row->cid);
+                unset($row->precise);
+                $row = (array)$row;
+                $newrow = array();
+                foreach ($row as $key => $val) {
+                    if ($key != 'content') { // No need to keep question text - ony keep choice text and rank.
+                        if ($key == 'ccontent') {
+                            if ($osgood) {
+                                list($contentleft, $contentright) = array_merge(preg_split('/[|]/', $val), array(' '));
+                                $contents = questionnaire_choice_values($contentleft);
+                                if ($contents->title) {
+                                    $contentleft = $contents->title;
+                                }
+                                $contents = questionnaire_choice_values($contentright);
+                                if ($contents->title) {
+                                    $contentright = $contents->title;
+                                }
+                                $val = strip_tags($contentleft.'|'.$contentright);
+                                $val = preg_replace("/[\r\n\t]/", ' ', $val);
+                            } else {
+                                $contents = questionnaire_choice_values($val);
+                                if ($contents->modname) {
+                                    $val = $contents->modname;
+                                } else if ($contents->title) {
+                                    $val = $contents->title;
+                                } else if ($contents->text) {
+                                    $val = strip_tags($contents->text);
+                                    $val = preg_replace("/[\r\n\t]/", ' ', $val);
+                                }
+                            }
+                        }
+                        $newrow[] = $val;
+                    }
+                }
+                $values[$qid] = $newrow;
+            }
+        }
+
+        // Response_text.
+        $sql = 'SELECT q.id '.$col.', a.response as aresponse '.
+               'FROM {questionnaire_response_text} a, {questionnaire_question} q '.
+               'WHERE a.response_id=\''.$rid.'\' AND a.question_id=q.id ';
+        if ($records = $DB->get_records_sql($sql)) {
+            foreach ($records as $qid => $row) {
+                unset($row->id);
+                $row = (array)$row;
+                $newrow = array();
+                foreach ($row as $key => $val) {
+                    if (!is_numeric($key)) {
+                        $newrow[] = $val;
+                    }
+                }
+                $values["$qid"] = $newrow;
+                $val = array_pop($values["$qid"]);
+                array_push($values["$qid"], $val, $val);
+            }
+        }
+
+        // Response_date.
+        $sql = 'SELECT q.id '.$col.', a.response as aresponse '.
+               'FROM {questionnaire_response_date} a, {questionnaire_question} q '.
+               'WHERE a.response_id=\''.$rid.'\' AND a.question_id=q.id ';
+        if ($records = $DB->get_records_sql($sql)) {
+            $dateformat = get_string('strfdate', 'questionnaire');
+            foreach ($records as $qid => $row) {
+                unset ($row->id);
+                $row = (array)$row;
+                $newrow = array();
+                foreach ($row as $key => $val) {
+                    if (!is_numeric($key)) {
+                        $newrow[] = $val;
+                        // Convert date from yyyy-mm-dd database format to actual questionnaire dateformat.
+                        // does not work with dates prior to 1900 under Windows.
+                        if (preg_match('/\d\d\d\d-\d\d-\d\d/', $val)) {
+                            $dateparts = preg_split('/-/', $val);
+                            $val = make_timestamp($dateparts[0], $dateparts[1], $dateparts[2]); // Unix timestamp.
+                            $val = userdate ( $val, $dateformat);
+                            $newrow[] = $val;
+                        }
+                    }
+                }
+                $values["$qid"] = $newrow;
+                $val = array_pop($values["$qid"]);
+                array_push($values["$qid"], '', '', $val);
+            }
+        }
+        return($values);
+    }
+
+    private function response_goto_thankyou() {
+        global $CFG, $USER, $DB;
+
+        $select = 'id = '.$this->survey->id;
+        $fields = 'thanks_page, thank_head, thank_body';
+        if ($result = $DB->get_record_select('questionnaire_survey', $select, null, $fields)) {
+            $thankurl = $result->thanks_page;
+            $thankhead = $result->thank_head;
+            $thankbody = $result->thank_body;
+        } else {
+            $thankurl = '';
+            $thankhead = '';
+            $thankbody = '';
+        }
+        if (!empty($thankurl)) {
+            if (!headers_sent()) {
+                header("Location: $thankurl");
+                exit;
+            }
+            echo '
+                <script language="JavaScript" type="text/javascript">
+                <!--
+                window.location="'.$thankurl.'"
+                //-->
+                </script>
+                <noscript>
+                <h2 class="thankhead">Thank You for completing this survey.</h2>
+                <blockquote class="thankbody">Please click
+                <a href="'.$thankurl.'">here</a> to continue.</blockquote>
+                </noscript>
+            ';
+            exit;
+        }
+        if (empty($thankhead)) {
+            $thankhead = get_string('thank_head', 'questionnaire');
+        }
+        $this->page->add_to_page('title', $thankhead);
+        $this->page->add_to_page('addinfo',
+            format_text(file_rewrite_pluginfile_urls($thankbody, 'pluginfile.php',
+            $this->context->id, 'mod_questionnaire', 'thankbody', $this->survey->id), FORMAT_HTML, ['noclean' => true]));
+        // Default set currentgroup to view all participants.
+        // TODO why not set to current respondent's groupid (if any)?
+        $currentgroupid = 0;
+        $currentgroupid = groups_get_activity_group($this->cm);
+        if (!groups_is_member($currentgroupid, $USER->id)) {
+            $currentgroupid = 0;
+        }
+        if ($this->capabilities->readownresponses) {
+            $this->page->add_to_page('message',
+                ('<a href="'.$CFG->wwwroot.'/mod/questionnaire/myreport.php?id='.
+                $this->cm->id.'&amp;instance='.$this->cm->instance.'&amp;user='.$USER->id.'&byresponse=0&action=vresp">'.
+                get_string("continue").'</a>'));
+        } else {
+            $this->page->add_to_page('message',
+                ('<a href="'.$CFG->wwwroot.'/course/view.php?id='.$this->course->id.'">'.
+                get_string("continue").'</a>'));
+        }
+        return;
+    }
+
+    private function response_goto_saved($url) {
+        global $CFG;
+        $resumesurvey = get_string('resumesurvey', 'questionnaire');
+        $savedprogress = get_string('savedprogress', 'questionnaire', '<strong>'.$resumesurvey.'</strong>');
+
+        $this->page->add_to_page('notifications',
+            $this->renderer->notification($savedprogress, \core\output\notification::NOTIFY_SUCCESS));
+        $this->page->add_to_page('respondentinfo',
+            $this->renderer->homelink($CFG->wwwroot.'/course/view.php?id='.$this->course->id,
+                get_string("backto", "moodle", $this->course->fullname)));
+        return;
+    }
+
+    // Survey Results Methods.
+
+    public function survey_results_navbar_alpha($currrid, $currentgroupid, $cm, $byresponse) {
+        global $CFG, $DB;
+
+        $output = '';
+
+        // Is this questionnaire set to fullname or anonymous?
+        $isfullname = $this->respondenttype != 'anonymous';
+        if ($isfullname) {
+            $selectgroupid = '';
+            $gmuserid = ', GM.userid ';
+            $groupmembers = ', {groups_members} GM ';
+            switch ($currentgroupid) {
+                case 0:     // All participants.
+                    $gmuserid = '';
+                    $groupmembers = '';
+                    break;
+                default:     // Members of a specific group.
+                    $selectgroupid = ' AND GM.groupid='.$currentgroupid.' AND R.userid = GM.userid ';
+            }
+            $sql = 'SELECT R.id AS responseid, R.submitted AS submitted, R.userid, U.username AS username,
+                            U.id as userid '.$gmuserid.
+            'FROM {questionnaire_response} R,
+                  {user} U
+                '.$groupmembers.
+            'WHERE R.survey_id=' . $this->survey->id . ' AND complete = \'y\' AND U.id = R.userid ' . $selectgroupid .
+            'ORDER BY U.lastname, U.firstname, R.submitted DESC';
+        } else {
+            $sql = 'SELECT R.id AS responseid, R.submitted
+                   FROM {questionnaire_response} R
+                   WHERE R.survey_id = ?
+                   AND complete = ?
+                   ORDER BY R.submitted DESC';
+        }
+        if (!$responses = $DB->get_records_sql ($sql, array('survey_id' => $this->survey->id, 'complete' => 'y'))) {
+            return;
+        }
+        $total = count($responses);
+        if ($total === 0) {
+            return;
+        }
+        $rids = array();
+        if ($isfullname) {
+            $ridssub = array();
+            $ridsuserfullname = array();
+            $ridsuserid = array();
+        }
+        $i = 0;
+        $currpos = -1;
+        foreach ($responses as $response) {
+            array_push($rids, $response->responseid);
+            if ($isfullname) {
+                $user = $DB->get_record('user', array('id' => $response->userid));
+                $userfullname = fullname($user);
+                array_push($ridssub, $response->submitted);
+                array_push($ridsuserfullname, fullname($user));
+                array_push($ridsuserid, $response->userid);
+            }
+            if ($response->responseid == $currrid) {
+                $currpos = $i;
+            }
+            $i++;
+        }
+
+        $url = $CFG->wwwroot.'/mod/questionnaire/report.php?action=vresp&group='.$currentgroupid.'&individualresponse=1';
+        if (!$byresponse) {     // Display navbar.
+            // Build navbar.
+            $navbar = new \stdClass();
+            $prevrid = ($currpos > 0) ? $rids[$currpos - 1] : null;
+            $nextrid = ($currpos < $total - 1) ? $rids[$currpos + 1] : null;
+            $firstrid = $rids[0];
+            $lastrid = $rids[$total - 1];
+            $displaypos = 1;
+            if ($prevrid != null) {
+                $pos = $currpos - 1;
+                $title = '';
+                $firstuserfullname = '';
+                $navbar->firstrespondent = ['url' => ($url.'&rid='.$firstrid)];
+                $navbar->previous = ['url' => ($url.'&rid='.$prevrid)];
+                if ($isfullname) {
+                    $responsedate = userdate($ridssub[$pos]);
+                    $title = $ridsuserfullname[$pos];
+                    // Only add date if more than one response by a student.
+                    if ($ridsuserid[$pos] == $ridsuserid[$currpos]) {
+                        $title .= ' | '.$responsedate;
+                    }
+                    $firstuserfullname = $ridsuserfullname[0];
+                }
+                $navbar->firstrespondent['title'] = $firstuserfullname;
+                $navbar->previous['title'] = $title;
+            }
+            $navbar->respnumber = ['currpos' => ($currpos + 1), 'total' => $total];
+            if ($nextrid != null) {
+                $pos = $currpos + 1;
+                $responsedate = '';
+                $title = '';
+                $lastuserfullname = '';
+                $navbar->lastrespondent = ['url' => ($url.'&rid='.$lastrid)];
+                $navbar->next = ['url' => ($url.'&rid='.$nextrid)];
+                if ($isfullname) {
+                    $responsedate = userdate($ridssub[$pos]);
+                    $title = $ridsuserfullname[$pos];
+                    // Only add date if more than one response by a student.
+                    if ($ridsuserid[$pos] == $ridsuserid[$currpos]) {
+                        $title .= ' | '.$responsedate;
+                    }
+                    $lastuserfullname = $ridsuserfullname[$total - 1];
+                }
+                $navbar->lastrespondent['title'] = $lastuserfullname;
+                $navbar->next['title'] = $title;
+            }
+            $url = $CFG->wwwroot.'/mod/questionnaire/report.php?action=vresp&byresponse=1&group='.$currentgroupid;
+            // Display navbar.
+            $navbar->listlink = $url;
+
+            // Display a "print this response" icon here in prevision of total removal of tabs in version 2.6.
+            $linkname = '&nbsp;'.get_string('print', 'questionnaire');
+            $url = '/mod/questionnaire/print.php?qid='.$this->id.'&rid='.$currrid.
+            '&courseid='.$this->course->id.'&sec=1';
+            $title = get_string('printtooltip', 'questionnaire');
+            $options = array('menubar' => true, 'location' => false, 'scrollbars' => true,
+                            'resizable' => true, 'height' => 600, 'width' => 800);
+            $name = 'popup';
+            $link = new moodle_url($url);
+            $action = new popup_action('click', $link, $name, $options);
+            $actionlink = $this->renderer->action_link($link, $linkname, $action, ['title' => $title],
+                new pix_icon('t/print', $title));
+            $navbar->printaction = $actionlink;
+            $this->page->add_to_page('navigationbar', $this->renderer->navigationbar($navbar));
+
+        } else { // Display respondents list.
+            $resparr = [];
+            for ($i = 0; $i < $total; $i++) {
+                if ($isfullname) {
+                    $responsedate = userdate($ridssub[$i]);
+                    $resparr[] = '<a title = "'.$responsedate.'" href="'.$url.'&amp;rid='.
+                        $rids[$i].'&amp;individualresponse=1" >'.$ridsuserfullname[$i].'</a> ';
+                } else {
+                    $responsedate = '';
+                    $resparr[] = '<a title = "'.$responsedate.'" href="'.$url.'&amp;rid='.
+                        $rids[$i].'&amp;individualresponse=1" >'.
+                        get_string('response', 'questionnaire').($i + 1).'</a> ';
+                }
+            }
+            // Table formatting from http://wikkawiki.org/PageAndCategoryDivisionInACategory.
+            $total = count($resparr);
+            $entries = count($resparr);
+            // Default max 3 columns, max 25 lines per column.
+            // TODO make this setting customizable.
+            $maxlines = 20;
+            $maxcols = 3;
+            if ($entries >= $maxlines) {
+                $colnumber = min (intval($entries / $maxlines), $maxcols);
+            } else {
+                $colnumber = 1;
+            }
+            $lines = 0;
+            $a = 0;
+            // How many lines with an entry in every column do we have?
+            while ($entries / $colnumber > 1) {
+                $lines++;
+                $entries = $entries - $colnumber;
+            }
+            // Prepare output.
+            $respcols = new stdClass();
+            for ($i = 0; $i < $colnumber; $i++) {
+                $colname = 'respondentscolumn'.$i;
+                for ($j = 0; $j < $lines; $j++) {
+                    $respcols->{$colname}->respondentlink[] = $resparr[$a];
+                    $a++;
+                }
+                // The rest of the entries (less than the number of cols).
+                if ($entries) {
+                    $respcols->{$colname}->respondentlink[] = $resparr[$a];
+                    $entries--;
+                    $a++;
+                }
+            }
+
+            $this->page->add_to_page('responses', $this->renderer->responselist($respcols));
+        }
+    }
+
+    // Display responses for current user (your responses).
+    public function survey_results_navbar_student($currrid, $userid, $instance, $resps, $reporttype='myreport', $sid='') {
+        global $DB;
+        $stranonymous = get_string('anonymous', 'questionnaire');
+        $output = '';
+
+        $total = count($resps);
+        $rids = array();
+        $ridssub = array();
+        $ridsusers = array();
+        $i = 0;
+        $currpos = -1;
+        $title = '';
+        foreach ($resps as $response) {
+            array_push($rids, $response->id);
+            array_push($ridssub, $response->submitted);
+            $ruser = '';
+            if ($reporttype == 'report') {
+                if ($this->respondenttype != 'anonymous') {
+                    if ($user = $DB->get_record('user', ['id' => $response->userid])) {
+                        $ruser = ' | ' .fullname($user);
+                    }
+                } else {
+                    $ruser = ' | ' . $stranonymous;
+                }
+            }
+            array_push($ridsusers, $ruser);
+            if ($response->id == $currrid) {
+                $currpos = $i;
+            }
+            $i++;
+        }
+        $prevrid = ($currpos > 0) ? $rids[$currpos - 1] : null;
+        $nextrid = ($currpos < $total - 1) ? $rids[$currpos + 1] : null;
+        $rowsperpage = 1;
+
+        if ($reporttype == 'myreport') {
+            $url = 'myreport.php?instance='.$instance.'&user='.$userid.'&action=vresp&byresponse=1&individualresponse=1';
+        } else {
+            $url = 'report.php?instance='.$instance.'&user='.$userid.'&action=vresp&byresponse=1&individualresponse=1&sid='.$sid;
+        }
+        $linkarr = array();
+        $navbar = new \stdClass();
+        $displaypos = 1;
+        if ($prevrid != null) {
+            $title = userdate($ridssub[$currpos - 1].$ridsusers[$currpos - 1]);
+            $navbar->previous = ['url' => ($url.'&rid='.$prevrid), 'title' => $title];
+        }
+        for ($i = 0; $i < $currpos; $i++) {
+            $title = userdate($ridssub[$i]).$ridsusers[$i];
+            $navbar->prevrespnumbers[] = ['url' => ($url.'&rid='.$rids[$i]), 'title' => $title, 'respnumber' => $displaypos];
+            $displaypos++;
+        }
+        $navbar->currrespnumber = $displaypos;
+        for (++$i; $i < $total; $i++) {
+            $displaypos++;
+            $title = userdate($ridssub[$i]).$ridsusers[$i];
+            $navbar->nextrespnumbers[] = ['url' => ($url.'&rid='.$rids[$i]), 'title' => $title, 'respnumber' => $displaypos];
+        }
+        if ($nextrid != null) {
+            $title = userdate($ridssub[$currpos + 1]).$ridsusers[$currpos + 1];
+            $navbar->next = ['url' => ($url.'&rid='.$nextrid), 'title' => $title];
+        }
+        $this->page->add_to_page('navigationbar', $this->renderer->usernavigationbar($navbar));
+        $this->page->add_to_page('bottomnavigationbar', $this->renderer->usernavigationbar($navbar));
+    }
+
+    /* {{{ proto string survey_results(int survey_id, int precision, bool show_totals, int question_id,
+     * array choice_ids, int response_id)
+        Builds HTML for the results for the survey. If a
+        question id and choice id(s) are given, then the results
+        are only calculated for respodants who chose from the
+        choice ids for the given question id.
+        Returns empty string on sucess, else returns an error
+        string. */
+
+    public function survey_results($precision = 1, $showtotals = 1, $qid = '', $cids = '', $rid = '',
+                $uid=false, $currentgroupid='', $sort='') {
+        global $SESSION, $DB;
+
+        $SESSION->questionnaire->noresponses = false;
+        if (empty($precision)) {
+            $precision  = 1;
+        }
+        if ($showtotals === '') {
+            $showtotals = 1;
+        }
+
+        if (is_int($cids)) {
+            $cids = array($cids);
+        }
+        if (is_string($cids)) {
+            $cids = preg_split("/ /", $cids); // Turn space seperated list into array.
+        }
+
+        // Build associative array holding whether each question
+        // type has answer choices or not and the table the answers are in
+        // TO DO - FIX BELOW TO USE STANDARD FUNCTIONS.
+        $haschoices = array();
+        $responsetable = array();
+        if (!($types = $DB->get_records('questionnaire_question_type', array(), 'typeid', 'typeid, has_choices, response_table'))) {
+            $errmsg = sprintf('%s [ %s: question_type ]',
+                    get_string('errortable', 'questionnaire'), 'Table');
+            return($errmsg);
+        }
+        foreach ($types as $type) {
+            $haschoices[$type->typeid] = $type->has_choices; // TODO is that variable actually used?
+            $responsetable[$type->typeid] = $type->response_table;
+        }
+
+        // Load survey title (and other globals).
+        if (empty($this->survey)) {
+            $errmsg = get_string('erroropening', 'questionnaire') ." [ ID:${sid} R:";
+            return($errmsg);
+        }
+
+        if (empty($this->questions)) {
+            $errmsg = get_string('erroropening', 'questionnaire') .' '. 'No questions found.';
+            return($errmsg);
+        }
+
+        // Find total number of survey responses and relevant response ID's.
+        if (!empty($rid)) {
+            $rids = $rid;
+            if (is_array($rids)) {
+                $navbar = false;
+            } else {
+                $navbar = true;
+            }
+            $total = 1;
+        } else {
+            $navbar = false;
+            $sql = "";
+            if ($uid !== false) { // One participant only.
+                $sql = "SELECT r.id, r.survey_id
+                          FROM {questionnaire_response} r
+                         WHERE r.survey_id='{$this->survey->id}' AND
+                               r.userid = $uid AND
+                               r.complete='y'
+                         ORDER BY r.id";
+                // All participants or all members of a group.
+            } else if ($currentgroupid == 0) {
+                $sql = "SELECT r.id, r.survey_id, r.userid as userid
+                          FROM {questionnaire_response} r
+                         WHERE r.survey_id='{$this->survey->id}' AND
+                               r.complete='y'
+                         ORDER BY r.id";
+            } else { // Members of a specific group.
+                $sql = "SELECT r.id, r.survey_id
+                          FROM {questionnaire_response} r,
+                                {groups_members} gm
+                         WHERE r.survey_id='{$this->survey->id}' AND
+                               r.complete='y' AND
+                               gm.groupid=".$currentgroupid." AND
+                               r.userid=gm.userid
+                         ORDER BY r.id";
+            }
+            if (!($rows = $DB->get_records_sql($sql))) {
+                $this->page->add_to_page('respondentinfo',
+                    $this->renderer->notification(get_string('noresponses', 'questionnaire'),
+                    \core\output\notification::NOTIFY_ERROR));
+                $SESSION->questionnaire->noresponses = true;
+                return;
+            }
+            $total = count($rows);
+            $this->page->add_to_page('respondentinfo',
+                ' '.get_string('responses', 'questionnaire').': <strong>'.$total.'</strong>');
+            if (empty($rows)) {
+                $errmsg = get_string('erroropening', 'questionnaire') .' '. get_string('noresponsedata', 'questionnaire');
+                    return($errmsg);
+            }
+
+            $rids = array();
+            foreach ($rows as $row) {
+                array_push($rids, $row->id);
+            }
+        }
+
+        if ($navbar) {
+            // Show response navigation bar.
+            $this->survey_results_navbar($rid);
+        }
+
+        $this->page->add_to_page('title', clean_text($this->survey->title));
+        if ($this->survey->subtitle) {
+            $this->page->add_to_page('subtitle', clean_text($this->survey->subtitle));
+        }
+        if ($this->survey->info) {
+            $infotext = file_rewrite_pluginfile_urls($this->survey->info, 'pluginfile.php',
+                $this->context->id, 'mod_questionnaire', 'info', $this->survey->id);
+            $this->page->add_to_page('addinfo', format_text($infotext, FORMAT_HTML, ['noclean' => true]));
+        }
+
+        $qnum = 0;
+
+        $anonymous = $this->respondenttype == 'anonymous';
+
+        foreach ($this->questions as $question) {
+            if ($question->type_id == QUESPAGEBREAK) {
+                continue;
+            }
+            $this->page->add_to_page('responses', $this->renderer->container_start('qn-container'));
+            if ($question->type_id != QUESSECTIONTEXT) {
+                $qnum++;
+                $this->page->add_to_page('responses', $this->renderer->container_start('qn-info'));
+                if ($question->type_id != QUESSECTIONTEXT) {
+                    $this->page->add_to_page('responses', $this->renderer->heading($qnum, 2, 'qn-number'));
+                }
+                $this->page->add_to_page('responses', $this->renderer->container_end()); // End qn-info.
+            }
+            $this->page->add_to_page('responses', $this->renderer->container_start('qn-content'));
+            // If question text is "empty", i.e. 2 non-breaking spaces were inserted, do not display any question text.
+            if ($question->content == '<p>  </p>') {
+                $question->content = '';
+            }
+            $this->page->add_to_page('responses',
+                $this->renderer->container(format_text(file_rewrite_pluginfile_urls($question->content, 'pluginfile.php',
+                $question->context->id, 'mod_questionnaire', 'question', $question->id),
+                FORMAT_HTML, ['noclean' => true]), 'qn-question'));
+            $this->page->add_to_page('responses', $this->renderer->results_output($question, $rids, $sort, $anonymous));
+            $this->page->add_to_page('responses', $this->renderer->container_end()); // End qn-content.
+            $this->page->add_to_page('responses', $this->renderer->container_end()); // End qn-container.
+        }
+
+        return;
+    }
+
+    /**
+     * Get unique list of question types used in the current survey.
+     *
+     * @author: Guy Thomas
+     * @param int $surveyid
+     * @param bool $uniquebytable
+     * @return array
+     * @throws moodle_exception
+     */
+    protected function get_survey_questiontypes($uniquebytable = false) {
+
+        $uniquetypes = [];
+        $uniquetables = [];
+
+        foreach ($this->questions as $question) {
+            $type = $question->type_id;
+            $responsetable = $question->response_table;
+            // Build SQL for this question type if not already done.
+            if (!$uniquebytable || !in_array($responsetable, $uniquetables)) {
+                if (!in_array($type, $uniquetypes)) {
+                    $uniquetypes[] = $type;
+                }
+                if (!in_array($responsetable, $uniquetables)) {
+                    $uniquetables[] = $responsetable;
+                }
+            }
+        }
+
+        return $uniquetypes;
+    }
+
+    /**
+     * Return array of all types considered to be choices.
+     *
+     * @return array
+     */
+    protected function choice_types() {
+        return [QUESRADIO, QUESDROP, QUESCHECK, QUESRATE];
+    }
+
+    /**
+     * Return all the fields to be used for users in questionnaire sql.
+     *
+     * @author: Guy Thomas
+     * @return array|string
+     */
+    protected function user_fields() {
+        $userfieldsarr = get_all_user_name_fields();
+        $userfieldsarr = array_merge($userfieldsarr, ['username', 'department', 'institution']);
+        return $userfieldsarr;
+    }
+
+    /**
+     * Get all survey responses in one go.
+     *
+     * @author: Guy Thomas
+     * @param string $rid
+     * @param string $userid
+     * @return array
+     */
+    protected function get_survey_all_responses($rid = '', $userid = '', $groupid = false) {
+        global $DB;
+        $uniquetypes = $this->get_survey_questiontypes(true);
+        $allresponsessql = "";
+        $allresponsesparams = [];
+
+        foreach ($uniquetypes as $type) {
+            $question = \mod_questionnaire\question\base::question_builder($type);
+            if (!isset($question->response)) {
+                continue;
+            }
+            $allresponsessql .= $allresponsessql == '' ? '' : ' UNION ALL ';
+            list ($sql, $params) = $question->response->get_bulk_sql($this->survey->id, $rid, $userid, $groupid);
+            $allresponsesparams = array_merge($allresponsesparams, $params);
+            $allresponsessql .= $sql;
+        }
+
+        $allresponsessql .= " ORDER BY uid, id";
+        $allresponses = $DB->get_recordset_sql($allresponsessql, $allresponsesparams);
+        return $allresponses;
+    }
+
+    /**
+     * Process individual row for csv output
+     * @param array $outputrow output row
+     * @param stdClass $resprow resultset row
+     * @param int $currentgroupid
+     * @param array $questionsbyposition
+     * @param int $nbinfocols
+     * @param int $numrespcols
+     * @return array
+     * @throws Exception
+     * @throws coding_exception
+     * @throws dml_exception
+     * @throws dml_missing_record_exception
+     * @throws dml_multiple_records_exception
+     */
+    protected function process_csv_row(array &$row,
+                                       stdClass $resprow,
+                                       $currentgroupid,
+                                       array &$questionsbyposition,
+                                       $nbinfocols,
+                                       $numrespcols) {
+        global $DB;
+
+        static $config = null;
+
+        if ($config === null) {
+            $config = get_config('questionnaire', 'downloadoptions');
+        }
+        $options = empty($config) ? array() : explode(',', $config);
+
+        $positioned = [];
+        $user = new stdClass();
+        foreach ($this->user_fields() as $userfield) {
+            $user->$userfield = $resprow->$userfield;
+        }
+        $user->id = $resprow->userid;
+        $isanonymous = $this->respondenttype == 'anonymous';
+
+        // Moodle:
+        // Get the course name that this questionnaire belongs to.
+        if ($this->survey->realm != 'public') {
+            $courseid = $this->course->id;
+            $coursename = $this->course->fullname;
+        } else {
+            // For a public questionnaire, look for the course that used it.
+            $sql = 'SELECT q.id, q.course, c.fullname '.
+                'FROM {questionnaire} q, {questionnaire_attempts} qa, {course} c '.
+                'WHERE qa.rid = ? AND q.id = qa.qid AND c.id = q.course';
+            if ($record = $DB->get_record_sql($sql, [$resprow->rid])) {
+                $courseid = $record->course;
+                $coursename = $record->fullname;
+            } else {
+                $courseid = $this->course->id;
+                $coursename = $this->course->fullname;
+            }
+        }
+
+        // Moodle:
+        // Determine if the user is a member of a group in this course or not.
+        // TODO - review for performance.
+        $groupname = '';
+        if (groups_get_activity_groupmode($this->cm, $this->course)) {
+            if ($currentgroupid > 0) {
+                $groupname = groups_get_group_name($currentgroupid);
+            } else {
+                if ($user->id) {
+                    if ($groups = groups_get_all_groups($courseid, $user->id)) {
+                        foreach ($groups as $group) {
+                            $groupname .= $group->name.', ';
+                        }
+                        $groupname = substr($groupname, 0, strlen($groupname) - 2);
+                    } else {
+                        $groupname = ' ('.get_string('groupnonmembers').')';
+                    }
+                }
+            }
+        }
+
+        if ($isanonymous) {
+            $fullname = get_string('anonymous', 'questionnaire');
+            $username = '';
+            $uid = '';
+        } else {
+            $uid = $user->id;
+            $fullname = fullname($user);
+            $username = $user->username;
+        }
+
+        if (in_array('response', $options)) {
+            array_push($positioned, $resprow->rid);
+        }
+        if (in_array('submitted', $options)) {
+            // For better compabitility & readability with Excel.
+            $submitted = date(get_string('strfdateformatcsv', 'questionnaire'), $resprow->submitted);
+            array_push($positioned, $submitted);
+        }
+        if (in_array('institution', $options)) {
+            array_push($positioned, $user->institution);
+        }
+        if (in_array('department', $options)) {
+            array_push($positioned, $user->department);
+        }
+        if (in_array('course', $options)) {
+            array_push($positioned, $coursename);
+        }
+        if (in_array('group', $options)) {
+            array_push($positioned, $groupname);
+        }
+        if (in_array('id', $options)) {
+            array_push($positioned, $uid);
+        }
+        if (in_array('fullname', $options)) {
+            array_push($positioned, $fullname);
+        }
+        if (in_array('username', $options)) {
+            array_push($positioned, $username);
+        }
+
+        for ($c = $nbinfocols; $c < $numrespcols; $c++) {
+            if (isset($row[$c])) {
+                $positioned[] = $row[$c];
+            } else if (isset($questionsbyposition[$c])) {
+                $question = $questionsbyposition[$c];
+                $qtype = intval($question->type_id);
+                if ($qtype === QUESCHECK) {
+                    $positioned[] = '0';
+                } else {
+                    $positioned[] = null;
+                }
+            } else {
+                $positioned[] = null;
+            }
+        }
+        return $positioned;
+    }
+
+    /* {{{ proto array survey_generate_csv(int survey_id)
+    Exports the results of a survey to an array.
+    */
+    public function generate_csv($rid='', $userid='', $choicecodes=1, $choicetext=0, $currentgroupid) {
+        global $DB;
+
+        raise_memory_limit('1G');
+
+        $output = array();
+        $stringother = get_string('other', 'questionnaire');
+
+        $config = get_config('questionnaire', 'downloadoptions');
+        $options = empty($config) ? array() : explode(',', $config);
+        $columns = array();
+        $types = array();
+        foreach ($options as $option) {
+            if (in_array($option, array('response', 'submitted', 'id'))) {
+                $columns[] = get_string($option, 'questionnaire');
+                $types[] = 0;
+            } else {
+                $columns[] = get_string($option);
+                $types[] = 1;
+            }
+        }
+        $nbinfocols = count($columns);
+
+        $idtocsvmap = array(
+            '0',    // 0: unused
+            '0',    // 1: bool -> boolean
+            '1',    // 2: text -> string
+            '1',    // 3: essay -> string
+            '0',    // 4: radio -> string
+            '0',    // 5: check -> string
+            '0',    // 6: dropdn -> string
+            '0',    // 7: rating -> number
+            '0',    // 8: rate -> number
+            '1',    // 9: date -> string
+            '0'     // 10: numeric -> number.
+        );
+
+        if (!$survey = $DB->get_record('questionnaire_survey', array('id' => $this->survey->id))) {
+            print_error ('surveynotexists', 'questionnaire');
+        }
+
+        // Get all responses for this survey in one go.
+        $allresponsesrs = $this->get_survey_all_responses($rid, $userid, $currentgroupid);
+
+        // Do we have any questions of type RADIO, DROP, CHECKBOX OR RATE? If so lets get all their choices in one go.
+        $choicetypes = $this->choice_types();
+
+        // Get unique list of question types used in this survey.
+        $uniquetypes = $this->get_survey_questiontypes();
+
+        if (count(array_intersect($choicetypes, $uniquetypes) > 0 )) {
+            $choiceparams = [$this->survey->id];
+            $choicesql = "
+                SELECT DISTINCT c.id as cid, q.id as qid, q.precise AS precise, q.name, c.content
+                  FROM {questionnaire_question} q
+                  JOIN {questionnaire_quest_choice} c ON question_id = q.id
+                 WHERE q.survey_id = ? ORDER BY cid ASC
+            ";
+            $choicerecords = $DB->get_records_sql($choicesql, $choiceparams);
+            $choicesbyqid = [];
+            if (!empty($choicerecords)) {
+                // Hash the options by question id.
+                foreach ($choicerecords as $choicerecord) {
+                    if (!isset($choicesbyqid[$choicerecord->qid])) {
+                        // New question id detected, intialise empty array to store choices.
+                        $choicesbyqid[$choicerecord->qid] = [];
+                    }
+                    $choicesbyqid[$choicerecord->qid][$choicerecord->cid] = $choicerecord;
+                }
+            }
+        }
+
+        $num = 1;
+
+        $questionidcols = [];
+
+        foreach ($this->questions as $question) {
+            // Skip questions that aren't response capable.
+            if (!isset($question->response)) {
+                continue;
+            }
+            // Establish the table's field names.
+            $qid = $question->id;
+            $qpos = $question->position;
+            $col = $question->name;
+            $type = $question->type_id;
+            if (in_array($type, $choicetypes)) {
+                /* single or multiple or rate */
+                if (!isset($choicesbyqid[$qid])) {
+                    throw new coding_exception('Choice question has no choices!', 'question id '.$qid.' of type '.$type);
+                }
+                $choices = $choicesbyqid[$qid];
+
+                $subqnum = 0;
+                switch ($type) {
+
+                    case QUESRADIO: // Single.
+                    case QUESDROP:
+                        $columns[][$qpos] = $col;
+                        $questionidcols[][$qpos] = $qid;
+                        array_push($types, $idtocsvmap[$type]);
+                        $thisnum = 1;
+                        foreach ($choices as $choice) {
+                            $content = $choice->content;
+                            // If "Other" add a column for the actual "other" text entered.
+                            if (preg_match('/^!other/', $content)) {
+                                $col = $choice->name.'_'.$stringother;
+                                $columns[][$qpos] = $col;
+                                $questionidcols[][$qpos] = null;
+                                array_push($types, '0');
+                            }
+                        }
+                        break;
+
+                    case QUESCHECK: // Multiple.
+                        $thisnum = 1;
+                        foreach ($choices as $choice) {
+                            $content = $choice->content;
+                            $modality = '';
+                            $contents = questionnaire_choice_values($content);
+                            if ($contents->modname) {
+                                $modality = $contents->modname;
+                            } else if ($contents->title) {
+                                $modality = $contents->title;
+                            } else {
+                                $modality = strip_tags($contents->text);
+                            }
+                            $col = $choice->name.'->'.$modality;
+                            $columns[][$qpos] = $col;
+                            $questionidcols[][$qpos] = $qid.'_'.$choice->cid;
+                            array_push($types, '0');
+                            // If "Other" add a column for the "other" checkbox.
+                            // Then add a column for the actual "other" text entered.
+                            if (preg_match('/^!other/', $content)) {
+                                $content = $stringother;
+                                $col = $choice->name.'->['.$content.']';
+                                $columns[][$qpos] = $col;
+                                $questionidcols[][$qpos] = null;
+                                array_push($types, '0');
+                            }
+                        }
+                        break;
+
+                    case QUESRATE: // Rate.
+                        foreach ($choices as $choice) {
+                            $nameddegrees = 0;
+                            $modality = '';
+                            $content = $choice->content;
+                            $osgood = false;
+                            if ($choice->precise == 3) {
+                                $osgood = true;
+                            }
+                            if (preg_match("/^[0-9]{1,3}=/", $content, $ndd)) {
+                                $nameddegrees++;
+                            } else {
+                                if ($osgood) {
+                                    list($contentleft, $contentright) = array_merge(preg_split('/[|]/', $content), array(' '));
+                                    $contents = questionnaire_choice_values($contentleft);
+                                    if ($contents->title) {
+                                        $contentleft = $contents->title;
+                                    }
+                                    $contents = questionnaire_choice_values($contentright);
+                                    if ($contents->title) {
+                                        $contentright = $contents->title;
+                                    }
+                                    $modality = strip_tags($contentleft.'|'.$contentright);
+                                    $modality = preg_replace("/[\r\n\t]/", ' ', $modality);
+                                } else {
+                                    $contents = questionnaire_choice_values($content);
+                                    if ($contents->modname) {
+                                        $modality = $contents->modname;
+                                    } else if ($contents->title) {
+                                        $modality = $contents->title;
+                                    } else {
+                                        $modality = strip_tags($contents->text);
+                                        $modality = preg_replace("/[\r\n\t]/", ' ', $modality);
+                                    }
+                                }
+                                $col = $choice->name.'->'.$modality;
+                                $columns[][$qpos] = $col;
+                                $questionidcols[][$qpos] = $qid.'_'.$choice->cid;
+                                array_push($types, $idtocsvmap[$type]);
+                            }
+                        }
+                        break;
+                }
+            } else {
+                $columns[][$qpos] = $col;
+                $questionidcols[][$qpos] = $qid;
+                array_push($types, $idtocsvmap[$type]);
+            }
+            $num++;
+        }
+
+        array_push($output, $columns);
+        $numrespcols = count($output[0]); // Number of columns used for storing question responses.
+
+        // Flatten questionidcols.
+        $tmparr = [];
+        for ($c = 0; $c < $nbinfocols; $c++) {
+            $tmparr[] = null; // Pad with non question columns.
+        }
+        foreach ($questionidcols as $i => $positions) {
+            foreach ($positions as $position => $qid) {
+                $tmparr[] = $qid;
+            }
+        }
+        $questionidcols = $tmparr;
+
+        // Create array of question positions hashed by question / question + choiceid.
+        // And array of questions hashed by position.
+        $questionpositions = [];
+        $questionsbyposition = [];
+        $p = 0;
+        foreach ($questionidcols as $qid) {
+            if ($qid === null) {
+                // This is just padding, skip.
+                $p++;
+                continue;
+            }
+            $questionpositions[$qid] = $p;
+            if (strpos($qid, '_') !== false) {
+                $tmparr = explode ('_', $qid);
+                $questionid = $tmparr[0];
+            } else {
+                $questionid = $qid;
+            }
+            $questionsbyposition[$p] = $this->questions[$questionid];
+            $p++;
+        }
+
+        $formatoptions = new stdClass();
+        $formatoptions->filter = false;  // To prevent any filtering in CSV output.
+
+        // Get textual versions of responses, add them to output at the correct col position.
+        $prevresprow = false; // Previous response row.
+        $row = [];
+        foreach ($allresponsesrs as $responserow) {
+            $rid = $responserow->rid;
+            $qid = $responserow->question_id;
+            $question = $this->questions[$qid];
+            $qtype = intval($question->type_id);
+            $questionobj = $this->questions[$qid];
+
+            if ($prevresprow !== false && $prevresprow->rid !== $rid) {
+                $output[] = $this->process_csv_row($row, $prevresprow, $currentgroupid, $questionsbyposition,
+                    $nbinfocols, $numrespcols);
+                $row = [];
+            }
+
+            if ($qtype === QUESRATE || $qtype === QUESCHECK) {
+                $key = $qid.'_'.$responserow->choice_id;
+                $position = $questionpositions[$key];
+                if ($qtype === QUESRATE) {
+                    $choicetxt = $responserow->rank + 1;
+                } else {
+                    $content = $choicesbyqid[$qid][$responserow->choice_id]->content;
+                    if (preg_match('/^!other/', $content)) {
+                        // If this is an "other" column, put the text entered in the next position.
+                        $row[$position + 1] = $responserow->response;
+                        $choicetxt = empty($responserow->choice_id) ? '0' : '1';
+                    } else if (!empty($responserow->choice_id)) {
+                        $choicetxt = '1';
+                    } else {
+                        $choicetxt = '0';
+                    }
+                }
+                $responsetxt = $choicetxt;
+                $row[$position] = $responsetxt;
+            } else {
+                $position = $questionpositions[$qid];
+                if ($questionobj->has_choices()) {
+                    // This is choice type question, so process as so.
+                    $c = 0;
+                    if (in_array(intval($question->type_id), $choicetypes)) {
+                        $choices = $choicesbyqid[$qid];
+                        // Get position of choice.
+                        foreach ($choices as $choice) {
+                            $c++;
+                            if ($responserow->choice_id === $choice->cid) {
+                                break;
+                            }
+                        }
+                    }
+
+                    $content = $choicesbyqid[$qid][$responserow->choice_id]->content;
+                    if (preg_match('/^!other/', $content)) {
+                        // If this has an "other" text, use it.
+                        $responsetxt = get_string('other', 'questionnaire');
+                        $responsetxt1 = $responserow->response;
+                    } else if (($choicecodes == 1) && ($choicetext == 1)) {
+                        $responsetxt = $c.' : '.$content;
+                    } else if ($choicecodes == 1) {
+                        $responsetxt = $c;
+                    } else {
+                        $responsetxt = $content;
+                    }
+                } else if (intval($qtype) === QUESYESNO) {
+                    // At this point, the boolean responses are returned as characters in the "response"
+                    // field instead of "choice_id" for csv exports (CONTRIB-6436).
+                    $responsetxt = $responserow->response === 'y' ? "1" : "0";
+                } else {
+                    // Strip potential html tags from modality name.
+                    $responsetxt = $responserow->response;
+                    if (!empty($responsetxt)) {
+                        $responsetxt = $responserow->response;
+                        $responsetxt = strip_tags($responsetxt);
+                        $responsetxt = preg_replace("/[\r\n\t]/", ' ', $responsetxt);
+                    }
+                }
+                $row[$position] = $responsetxt;
+                // Check for "other" text and set it to the next position if present.
+                if (!empty($responsetxt1)) {
+                    $row[$position + 1] = $responsetxt1;
+                    unset($responsetxt1);
+                }
+            }
+
+            $prevresprow = $responserow;
+        }
+
+        if ($prevresprow !== false) {
+            // Add final row to output. May not exist if no response data was ever present.
+            $output[] = $this->process_csv_row($row, $prevresprow, $currentgroupid, $questionsbyposition,
+                $nbinfocols, $numrespcols);
+        }
+
+        // Change table headers to incorporate actual question numbers.
+        $numcol = 0;
+        $numquestion = 0;
+        $out = '';
+        $oldkey = 0;
+
+        for ($i = $nbinfocols; $i < $numrespcols; $i++) {
+            $sep = '';
+            $thisoutput = current($output[0][$i]);
+            $thiskey = key($output[0][$i]);
+            // Case of unnamed rate single possible answer (full stop char is used for support).
+            if (strstr($thisoutput, '->.')) {
+                $thisoutput = str_replace('->.', '', $thisoutput);
+            }
+            // If variable is not named no separator needed between Question number and potential sub-variables.
+            if ($thisoutput == '' || strstr($thisoutput, '->.') || substr($thisoutput, 0, 2) == '->'
+                || substr($thisoutput, 0, 1) == '_') {
+                $sep = '';
+            } else {
+                $sep = '_';
+            }
+            if ($thiskey > $oldkey) {
+                $oldkey = $thiskey;
+                $numquestion++;
+            }
+            // Abbreviated modality name in multiple or rate questions (COLORS->blue=the color of the sky...).
+            $pos = strpos($thisoutput, '=');
+            if ($pos) {
+                $thisoutput = substr($thisoutput, 0, $pos);
+            }
+            $other = $sep.$stringother;
+            $out = 'Q'.sprintf("%02d", $numquestion).$sep.$thisoutput;
+            $output[0][$i] = $out;
+        }
+        return $output;
+    }
+
+    /* {{{ proto bool survey_export_csv(int survey_id, string filename)
+        Exports the results of a survey to a CSV file.
+        Returns true on success.
+        */
+
+    private function export_csv($filename) {
+        $umask = umask(0077);
+        $fh = fopen($filename, 'w');
+        umask($umask);
+        if (!$fh) {
+            return 0;
+        }
+
+        $data = survey_generate_csv($rid = '', $userid = '', $currentgroupid = '');
+
+        foreach ($data as $row) {
+            fputs($fh, join(', ', $row) . "\n");
+        }
+
+        fflush($fh);
+        fclose($fh);
+
+        return 1;
+    }
+
+
+    /**
+     * Function to move a question to a new position.
+     * Adapted from feedback plugin.
+     *
+     * @param int $moveqid The id of the question to be moved.
+     * @param int $movetopos The position to move question to.
+     *
+     */
+
+    public function move_question($moveqid, $movetopos) {
+        global $DB;
+
+        $questions = $this->questions;
+        $movequestion = $this->questions[$moveqid];
+
+        if (is_array($questions)) {
+            $index = 1;
+            foreach ($questions as $question) {
+                if ($index == $movetopos) {
+                    $index++;
+                }
+                if ($question->id == $movequestion->id) {
+                    $movequestion->position = $movetopos;
+                    $DB->update_record("questionnaire_question", $movequestion);
+                    continue;
+                }
+                $question->position = $index;
+                $DB->update_record("questionnaire_question", $question);
+                $index++;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    public function response_analysis ($rid, $resps, $compare, $isgroupmember, $allresponses, $currentgroupid) {
+        global $DB, $CFG;
+        $action = optional_param('action', 'vall', PARAM_ALPHA);
+
+        require_once($CFG->libdir.'/tablelib.php');
+        require_once($CFG->dirroot.'/mod/questionnaire/drawchart.php');
+        if ($resp = $DB->get_record('questionnaire_response', array('id' => $rid)) ) {
+            $userid = $resp->userid;
+            if ($user = $DB->get_record('user', array('id' => $userid))) {
+                $ruser = fullname($user);
+            }
+        }
+        // Available group modes (0 = no groups; 1 = separate groups; 2 = visible groups).
+        $groupmode = groups_get_activity_groupmode($this->cm, $this->course);
+        $groupname = get_string('allparticipants');
+        if ($groupmode > 0) {
+            if ($currentgroupid > 0) {
+                $groupname = groups_get_group_name($currentgroupid);
+            } else {
+                $groupname = get_string('allparticipants');
+            }
+        }
+        if ($this->survey->feedbackscores) {
+            $table = new html_table();
+            $table->size = array(null, null);
+            $table->align = array('left', 'right', 'right');
+            $table->head = array();
+            $table->wrap = array();
+            if ($compare) {
+                $table->head = array(get_string('feedbacksection', 'questionnaire'), $ruser, $groupname);
+            } else {
+                $table->head = array(get_string('feedbacksection', 'questionnaire'), $groupname);
+            }
+        }
+
+        $feedbacksections = $this->survey->feedbacksections;
+        $feedbackscores = $this->survey->feedbackscores;
+        $sid = $this->survey->id;
+        $questions = $this->questions;
+
+        // Find if there are any feedbacks in this questionnaire.
+        $sql = "SELECT * FROM {questionnaire_fb_sections} WHERE survey_id = $sid AND section IS NOT NULL";
+        if (!$fbsections = $DB->get_records_sql($sql)) {
+            return null;
+        }
+
+        $fbsectionsnb = array_keys($fbsections);
+        // Calculate max score per question in questionnaire.
+        $qmax = array();
+        $totalscore = 0;
+        $maxtotalscore = 0;
+        foreach ($questions as $question) {
+            $qid = $question->id;
+            $qtype = $question->type_id;
+            $required = $question->required;
+            if ((($qtype == QUESRADIO) || ($qtype == QUESDROP) || ($qtype == QUESRATE)) && ($required == 'y')) {
+                if (!isset($qmax[$qid])) {
+                    $qmax[$qid] = 0;
+                }
+                $nbchoices = 1;
+                if ($qtype == QUESRATE) {
+                    $nbchoices = 0;
+                }
+                foreach ($question->choices as $choice) {
+                    // Testing NULL and 'NULL' because I changed the automatic null value, must be fixed later... TODO.
+                    if (isset($choice->value) && $choice->value != null && $choice->value != 'NULL') {
+                        if ($choice->value > $qmax[$qid]) {
+                            $qmax[$qid] = $choice->value;
+                        }
+                    } else {
+                        $nbchoices ++;
+                    }
+                }
+                $qmax[$qid] = $qmax[$qid] * $nbchoices;
+                $maxtotalscore += $qmax[$qid];
+            }
+            if (($qtype == QUESYESNO) && ($required == 'y')) {
+                $qmax[$qid] = 1;
+                $maxtotalscore += 1;
+            }
+        }
+        // Just in case no values have been entered in the various questions possible answers field.
+        if ($maxtotalscore === 0) {
+            return;
+        }
+        $feedbackmessages = array();
+
+        // Get individual scores for each question in this responses set.
+        $qscore = array();
+        $allqscore = array();
+
+        // Get all response ids for all respondents.
+        $rids = array();
+        foreach ($resps as $key => $resp) {
+            $rids[] = $key;
+        }
+        $nbparticipants = count($rids);
+
+        if (!$allresponses && $groupmode != 0) {
+            $nbparticipants = max(1, $nbparticipants - !$isgroupmember);
+        }
+        foreach ($rids as $rrid) {
+            // Get responses for bool (Yes/No).
+            $sql = 'SELECT q.id, q.type_id as q_type, a.choice_id as cid '.
+                            'FROM {questionnaire_response_bool} a, {questionnaire_question} q '.
+                            'WHERE a.response_id = ? AND a.question_id=q.id ';
+            if ($responses = $DB->get_records_sql($sql, array($rrid))) {
+                foreach ($responses as $qid => $response) {
+                    $responsescore = ($response->cid == 'y' ? 1 : 0);
+                    // Individual score.
+                    // If this is current user's response OR if current user is viewing another group's results.
+                    if ($rrid == $rid || $allresponses) {
+                        if (!isset($qscore[$qid])) {
+                            $qscore[$qid] = 0;
+                        }
+                        $qscore[$qid] = $responsescore;
+                    }
+                    // Course score.
+                    if (!isset($allqscore[$qid])) {
+                        $allqscore[$qid] = 0;
+                    }
+                    // Only add current score if conditions below are met.
+                    if ($groupmode == 0 || $isgroupmember || (!$isgroupmember && $rrid != $rid) || $allresponses) {
+                        $allqscore[$qid] += $responsescore;
+                    }
+                }
+            }
+
+            // Get responses for single (Radio or Dropbox).
+            $sql = 'SELECT q.id, q.type_id as q_type, c.content as ccontent,c.id as cid, c.value as score  '.
+                            'FROM {questionnaire_resp_single} a, {questionnaire_question} q, {questionnaire_quest_choice} c '.
+                            'WHERE a.response_id = ? AND a.question_id=q.id AND a.choice_id=c.id ';
+            if ($responses = $DB->get_records_sql($sql, array($rrid))) {
+                foreach ($responses as $qid => $response) {
+                    // Individual score.
+                    // If this is current user's response OR if current user is viewing another group's results.
+                    if ($rrid == $rid || $allresponses) {
+                        if (!isset($qscore[$qid])) {
+                            $qscore[$qid] = 0;
+                        }
+                        $qscore[$qid] = $response->score;
+                    }
+                    // Course score.
+                    if (!isset($allqscore[$qid])) {
+                        $allqscore[$qid] = 0;
+                    }
+                    // Only add current score if conditions below are met.
+                    if ($groupmode == 0 || $isgroupmember || (!$isgroupmember && $rrid != $rid) || $allresponses) {
+                        $allqscore[$qid] += $response->score;
+                    }
+                }
+            }
+
+            // Get responses for response_rank (Rate).
+            $sql = 'SELECT a.id as aid, q.id AS qid, c.id AS cid, a.rank as arank '.
+                            'FROM {questionnaire_response_rank} a, {questionnaire_question} q, {questionnaire_quest_choice} c '.
+                            'WHERE a.response_id= ? AND a.question_id=q.id AND a.choice_id=c.id '.
+                            'ORDER BY aid, a.question_id,c.id';
+            if ($responses = $DB->get_records_sql($sql, array($rrid))) {
+                // We need to store the number of sub-questions for each rate questions.
+                $rank = array();
+                $firstcid = array();
+                foreach ($responses as $response) {
+                    $qid = $response->qid;
+                    $rank = $response->arank;
+                    if (!isset($qscore[$qid])) {
+                        $qscore[$qid] = 0;
+                        $allqscore[$qid] = 0;
+                    }
+                    $firstcid[$qid] = $DB->get_record('questionnaire_quest_choice',
+                                    array('question_id' => $qid), 'id', IGNORE_MULTIPLE);
+                    $firstcidid = $firstcid[$qid]->id;
+                    $cidvalue = $firstcidid + $rank;
+                    $sql = "SELECT * FROM {questionnaire_quest_choice} WHERE id = $cidvalue";
+
+                    if ($value = $DB->get_record_sql($sql)) {
+                        // Individual score.
+                        // If this is current user's response OR if current user is viewing another group's results.
+                        if ($rrid == $rid || $allresponses) {
+                            $qscore[$qid] += $value->value;
+                        }
+                        // Only add current score if conditions below are met.
+                        if ($groupmode == 0 || $isgroupmember || (!$isgroupmember && $rrid != $rid) || $allresponses) {
+                            $allqscore[$qid] += $value->value;
+                        }
+                    }
+                }
+            }
+        }
+        $totalscore = array_sum($qscore);
+        $scorepercent = round($totalscore / $maxtotalscore * 100);
+        $oppositescorepercent = 100 - $scorepercent;
+        $alltotalscore = array_sum($allqscore);
+        $allscorepercent = round($alltotalscore / $nbparticipants / $maxtotalscore * 100);
+
+        // No need to go further if feedback is global, i.e. only relying on total score.
+        if ($feedbacksections == 1) {
+            $sectionid = $fbsectionsnb[0];
+            $sectionlabel = $fbsections[$sectionid]->sectionlabel;
+
+            $sectionheading = $fbsections[$sectionid]->sectionheading;
+            $feedbacks = $DB->get_records('questionnaire_feedback', array('section_id' => $sectionid));
+            $labels = array();
+            foreach ($feedbacks as $feedback) {
+                if ($feedback->feedbacklabel != '') {
+                    $labels[] = $feedback->feedbacklabel;
+                }
+            }
+            $feedback = $DB->get_record_select('questionnaire_feedback',
+                            'section_id = ? AND minscore <= ? AND ? < maxscore', array($sectionid, $scorepercent, $scorepercent));
+
+            // To eliminate all potential % chars in heading text (might interfere with the sprintf function).
+            $sectionheading = str_replace('%', '', $sectionheading);
+            // Replace section heading placeholders with their actual value (if any).
+            $original = array('$scorepercent', '$oppositescorepercent');
+            $result = array('%s%%', '%s%%');
+            $sectionheading = str_replace($original, $result, $sectionheading);
+            $sectionheading = sprintf($sectionheading , $scorepercent, $oppositescorepercent);
+            $sectionheading = file_rewrite_pluginfile_urls($sectionheading, 'pluginfile.php',
+                            $this->context->id, 'mod_questionnaire', 'sectionheading', $sectionid);
+            $feedbackmessages[] = $this->renderer->box_start();
+            $feedbackmessages[] = format_text($sectionheading, FORMAT_HTML, ['noclean' => true]);
+            $feedbackmessages[] = $this->renderer->box_end();
+
+            if (!empty($feedback->feedbacktext)) {
+                // Clean the text, ready for display.
+                $formatoptions = new stdClass();
+                $formatoptions->noclean = true;
+                $feedbacktext = file_rewrite_pluginfile_urls($feedback->feedbacktext, 'pluginfile.php',
+                                $this->context->id, 'mod_questionnaire', 'feedback', $feedback->id);
+                $feedbacktext = format_text($feedbacktext, $feedback->feedbacktextformat, $formatoptions);
+                $feedbackmessages[] = $this->renderer->box_start();
+                $feedbackmessages[] = $feedbacktext;
+                $feedbackmessages[] = $this->renderer->box_end();
+            }
+            $score = array($scorepercent, 100 - $scorepercent);
+            $allscore = null;
+            if ($compare  || $allresponses) {
+                $allscore = array($allscorepercent, 100 - $allscorepercent);
+            }
+            $usergraph = get_config('questionnaire', 'usergraph');
+            if ($usergraph && $this->survey->chart_type) {
+                $this->page->add_to_page('feedbackcharts',
+                    draw_chart ($feedbacktype = 'global', $this->survey->chart_type, $labels,
+                                $score, $allscore, $sectionlabel, $groupname, $allresponses));
+            }
+            // Display class or group score. Pending chart library decision to display?
+            // Find out if this feedback sectionlabel has a pipe separator.
+            $lb = explode("|", $sectionlabel);
+            $oppositescore = '';
+            $oppositeallscore = '';
+            if (count($lb) > 1) {
+                $sectionlabel = $lb[0].' | '.$lb[1];
+                $oppositescore = ' | '.$score[1].'%';
+                $oppositeallscore = ' | '.$allscore[1].'%';
+            }
+            if ($this->survey->feedbackscores) {
+                if ($compare) {
+                    $table->data[] = array($sectionlabel, $score[0].'%'.$oppositescore, $allscore[0].'%'.$oppositeallscore);
+                } else {
+                    $table->data[] = array($sectionlabel, $allscore[0].'%'.$oppositeallscore);
+                }
+
+                $this->page->add_to_page('feedbackscores', html_writer::table($table));
+            }
+
+            return $feedbackmessages;
+        }
+
+        // Now process scores for more than one section.
+
+        // Initialize scores and maxscores to 0.
+        $score = array();
+        $allscore = array();
+        $maxscore = array();
+        $scorepercent = array();
+        $allscorepercent = array();
+        $oppositescorepercent = array();
+        $alloppositescorepercent = array();
+        $chartlabels = array();
+        $chartscore = array();
+        for ($i = 1; $i <= $feedbacksections; $i++) {
+            $score[$i] = 0;
+            $allscore[$i] = 0;
+            $maxscore[$i] = 0;
+            $scorepercent[$i] = 0;
+        }
+
+        for ($section = 1; $section <= $feedbacksections; $section++) {
+            foreach ($fbsections as $key => $fbsection) {
+                if ($fbsection->section == $section) {
+                    $feedbacksectionid = $key;
+                    $scorecalculation = unserialize($fbsection->scorecalculation);
+                    $sectionheading = $fbsection->sectionheading;
+                    $imageid = $fbsection->id;
+                    $chartlabels [$section] = $fbsection->sectionlabel;
+                }
+            }
+            foreach ($scorecalculation as $qid => $key) {
+                // Just in case a question pertaining to a section has been deleted or made not required
+                // after being included in scorecalculation.
+                if (isset($qscore[$qid])) {
+                    $score[$section] += $qscore[$qid];
+                    $maxscore[$section] += $qmax[$qid];
+                    if ($compare  || $allresponses) {
+                        $allscore[$section] += $allqscore[$qid];
+                    }
+                }
+            }
+
+            $scorepercent[$section] = round($score[$section] / $maxscore[$section] * 100);
+            $oppositescorepercent[$section] = 100 - $scorepercent[$section];
+
+            if (($compare || $allresponses) && $nbparticipants != 0) {
+                $allscorepercent[$section] = round( ($allscore[$section] / $nbparticipants) / $maxscore[$section] * 100);
+                $alloppositescorepercent[$section] = 100 - $allscorepercent[$section];
+            }
+
+            if (!$allresponses) {
+                // To eliminate all potential % chars in heading text (might interfere with the sprintf function).
+                $sectionheading = str_replace('%', '', $sectionheading);
+
+                // Replace section heading placeholders with their actual value (if any).
+                $original = array('$scorepercent', '$oppositescorepercent');
+                $result = array("$scorepercent[$section]%", "$oppositescorepercent[$section]%");
+                $sectionheading = str_replace($original, $result, $sectionheading);
+                $formatoptions = new stdClass();
+                $formatoptions->noclean = true;
+                $sectionheading = file_rewrite_pluginfile_urls($sectionheading, 'pluginfile.php',
+                                $this->context->id, 'mod_questionnaire', 'sectionheading', $imageid);
+                $sectionheading = format_text($sectionheading, 1, $formatoptions);
+                $feedbackmessages[] = $this->renderer->box_start('reportQuestionTitle');
+                $feedbackmessages[] = format_text($sectionheading, FORMAT_HTML, $formatoptions);
+                $feedback = $DB->get_record_select('questionnaire_feedback',
+                                'section_id = ? AND minscore <= ? AND ? < maxscore',
+                                array($feedbacksectionid, $scorepercent[$section], $scorepercent[$section]),
+                                'id,feedbacktext,feedbacktextformat');
+                $feedbackmessages[] = $this->renderer->box_end();
+                if (!empty($feedback->feedbacktext)) {
+                    // Clean the text, ready for display.
+                    $formatoptions = new stdClass();
+                    $formatoptions->noclean = true;
+                    $feedbacktext = file_rewrite_pluginfile_urls($feedback->feedbacktext, 'pluginfile.php',
+                                    $this->context->id, 'mod_questionnaire', 'feedback', $feedback->id);
+                    $feedbacktext = format_text($feedbacktext, $feedback->feedbacktextformat, $formatoptions);
+                    $feedbackmessages[] = $this->renderer->box_start('feedbacktext');
+                    $feedbackmessages[] = $feedbacktext;
+                    $feedbackmessages[] = $this->renderer->box_end();
+                }
+            }
+        }
+
+        // Display class or group score.
+        switch ($action) {
+            case 'vallasort':
+                asort($allscore);
+                break;
+            case 'vallarsort':
+                arsort($allscore);
+                break;
+            default:
+        }
+
+        foreach ($allscore as $key => $sc) {
+            $lb = explode("|", $chartlabels[$key]);
+            $oppositescore = '';
+            $oppositeallscore = '';
+            if (count($lb) > 1) {
+                $sectionlabel = $lb[0].' | '.$lb[1];
+                $oppositescore = ' | '.$oppositescorepercent[$key].'%';
+                $oppositeallscore = ' | '.$alloppositescorepercent[$key].'%';
+            } else {
+                $sectionlabel = $chartlabels[$key];
+            }
+            if ($compare) {
+                $table->data[] = array($sectionlabel, $scorepercent[$key].'%'.$oppositescore,
+                                $allscorepercent[$key].'%'.$oppositeallscore);
+            } else {
+                $table->data[] = array($sectionlabel, $allscorepercent[$key].'%'.$oppositeallscore);
+            }
+        }
+        $usergraph = get_config('questionnaire', 'usergraph');
+        if ($usergraph && $this->survey->chart_type) {
+            $this->page->add_to_page('feedbackcharts',
+                draw_chart($feedbacktype = 'sections', $this->survey->chart_type, array_values($chartlabels),
+                array_values($scorepercent), array_values($allscorepercent), $sectionlabel, $groupname, $allresponses));
+        }
+        if ($this->survey->feedbackscores) {
+            $this->page->add_to_page('feedbackscores', html_writer::table($table));
+        }
+
+        return $feedbackmessages;
+    }
+
+}
diff --git a/mod/questionnaire/questions.php b/mod/questionnaire/questions.php
new file mode 100644
index 0000000..363a341
--- /dev/null
+++ b/mod/questionnaire/questions.php
@@ -0,0 +1,440 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+require_once($CFG->dirroot.'/mod/questionnaire/classes/question/base.php'); // Needed for question type constants.
+
+$id     = required_param('id', PARAM_INT);                 // Course module ID
+$action = optional_param('action', 'main', PARAM_ALPHA);   // Screen.
+$qid    = optional_param('qid', 0, PARAM_INT);             // Question id.
+$moveq  = optional_param('moveq', 0, PARAM_INT);           // Question id to move.
+$delq   = optional_param('delq', 0, PARAM_INT);             // Question id to delete
+$qtype  = optional_param('type_id', 0, PARAM_INT);         // Question type.
+$currentgroupid = optional_param('group', 0, PARAM_INT); // Group id.
+
+if (! $cm = get_coursemodule_from_id('questionnaire', $id)) {
+    print_error('invalidcoursemodule');
+}
+
+if (! $course = $DB->get_record("course", array("id" => $cm->course))) {
+    print_error('coursemisconf');
+}
+
+if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $cm->instance))) {
+    print_error('invalidcoursemodule');
+}
+
+require_course_login($course, true, $cm);
+$context = context_module::instance($cm->id);
+
+$url = new moodle_url($CFG->wwwroot.'/mod/questionnaire/questions.php');
+$url->param('id', $id);
+if ($qid) {
+    $url->param('qid', $qid);
+}
+
+$PAGE->set_url($url);
+$PAGE->set_context($context);
+
+$questionnaire = new questionnaire(0, $questionnaire, $course, $cm);
+
+// Add renderer and page objects to the questionnaire object for display use.
+$questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+$questionnaire->add_page(new \mod_questionnaire\output\questionspage());
+
+if (!$questionnaire->capabilities->editquestions) {
+    print_error('nopermissions', 'error', 'mod:questionnaire:edit');
+}
+
+$questionnairehasdependencies = questionnaire_has_dependencies($questionnaire->questions);
+$haschildren = array();
+if (!isset($SESSION->questionnaire)) {
+    $SESSION->questionnaire = new stdClass();
+}
+$SESSION->questionnaire->current_tab = 'questions';
+$reload = false;
+$sid = $questionnaire->survey->id;
+// Process form data.
+
+// Delete question button has been pressed in questions_form AND deletion has been confirmed on the confirmation page.
+if ($delq) {
+    $qid = $delq;
+    $sid = $questionnaire->survey->id;
+    $questionnaireid = $questionnaire->id;
+
+    // Does the question to be deleted have any child questions?
+    if ($questionnairehasdependencies) {
+        $haschildren  = questionnaire_get_descendants ($questionnaire->questions, $qid);
+    }
+
+    // Need to reload questions before setting deleted question to 'y'.
+    $questions = $DB->get_records('questionnaire_question', array('survey_id' => $sid, 'deleted' => 'n'), 'id');
+    $DB->set_field('questionnaire_question', 'deleted', 'y', array('id' => $qid, 'survey_id' => $sid));
+
+    // Just in case the page is refreshed (F5) after a question has been deleted.
+    if (isset($questions[$qid])) {
+        $select = 'survey_id = '.$sid.' AND deleted = \'n\' AND position > '.
+                        $questions[$qid]->position;
+    } else {
+        redirect($CFG->wwwroot.'/mod/questionnaire/questions.php?id='.$questionnaire->cm->id);
+    }
+
+    if ($records = $DB->get_records_select('questionnaire_question', $select, null, 'position ASC')) {
+        foreach ($records as $record) {
+            $DB->set_field('questionnaire_question', 'position', $record->position - 1, array('id' => $record->id));
+        }
+    }
+    // Delete section breaks without asking for confirmation.
+    $qtype = $questionnaire->questions[$qid]->type_id;
+    // No need to delete responses to those "question types" which are not real questions.
+    if ($qtype == QUESPAGEBREAK || $qtype == QUESSECTIONTEXT) {
+        $reload = true;
+    } else {
+        // Delete responses to that deleted question.
+        questionnaire_delete_responses($qid);
+
+        // The deleted question was a parent, so now we must delete its child question(s).
+        if (count($haschildren) !== 0) {
+            foreach ($haschildren as $qid => $child) {
+                // Need to reload questions first.
+                $questions = $DB->get_records('questionnaire_question', array('survey_id' => $sid, 'deleted' => 'n'), 'id');
+                $DB->set_field('questionnaire_question', 'deleted', 'y', array('id' => $qid, 'survey_id' => $sid));
+                $select = 'survey_id = '.$sid.' AND deleted = \'n\' AND position > '.
+                                $questions[$qid]->position;
+                if ($records = $DB->get_records_select('questionnaire_question', $select, null, 'position ASC')) {
+                    foreach ($records as $record) {
+                        $DB->set_field('questionnaire_question', 'position', $record->position - 1, array('id' => $record->id));
+                    }
+                }
+                // Delete responses to that deleted question.
+                questionnaire_delete_responses($qid);
+            }
+        }
+
+        // If no questions left in this questionnaire, remove all attempts and responses.
+        if (!$questions = $DB->get_records('questionnaire_question', array('survey_id' => $sid, 'deleted' => 'n'), 'id') ) {
+            $DB->delete_records('questionnaire_response', array('survey_id' => $sid));
+            $DB->delete_records('questionnaire_attempts', array('qid' => $questionnaireid));
+        }
+    }
+
+    // Log question deleted event.
+    $context = context_module::instance($questionnaire->cm->id);
+    $questiontype = \mod_questionnaire\question\base::qtypename($qtype);
+    $params = array(
+                    'context' => $context,
+                    'courseid' => $questionnaire->course->id,
+                    'other' => array('questiontype' => $questiontype)
+    );
+    $event = \mod_questionnaire\event\question_deleted::create($params);
+    $event->trigger();
+
+    if ($questionnairehasdependencies) {
+        $SESSION->questionnaire->validateresults = questionnaire_check_page_breaks($questionnaire);
+    }
+    $reload = true;
+}
+
+if ($action == 'main') {
+    $questionsform = new mod_questionnaire_questions_form('questions.php', $moveq);
+    $sdata = clone($questionnaire->survey);
+    $sdata->sid = $questionnaire->survey->id;
+    $sdata->id = $cm->id;
+    if (!empty($questionnaire->questions)) {
+        $pos = 1;
+        foreach ($questionnaire->questions as $qidx => $question) {
+            $sdata->{'pos_'.$qidx} = $pos;
+            $pos++;
+        }
+    }
+    $questionsform->set_data($sdata);
+    if ($questionsform->is_cancelled()) {
+        // Switch to main screen.
+        $action = 'main';
+        redirect($CFG->wwwroot.'/mod/questionnaire/questions.php?id='.$questionnaire->cm->id);
+        $reload = true;
+    }
+    if ($qformdata = $questionsform->get_data()) {
+        // Quickforms doesn't return values for 'image' input types using 'exportValue', so we need to grab
+        // it from the raw submitted data.
+        $exformdata = data_submitted();
+
+        if (isset($exformdata->movebutton)) {
+            $qformdata->movebutton = $exformdata->movebutton;
+        } else if (isset($exformdata->moveherebutton)) {
+            $qformdata->moveherebutton = $exformdata->moveherebutton;
+        } else if (isset($exformdata->editbutton)) {
+            $qformdata->editbutton = $exformdata->editbutton;
+        } else if (isset($exformdata->removebutton)) {
+            $qformdata->removebutton = $exformdata->removebutton;
+        } else if (isset($exformdata->requiredbutton)) {
+            $qformdata->requiredbutton = $exformdata->requiredbutton;
+        }
+
+        // Insert a section break.
+        if (isset($qformdata->removebutton)) {
+            // Need to use the key, since IE returns the image position as the value rather than the specified
+            // value in the <input> tag.
+            $qid = key($qformdata->removebutton);
+            $qtype = $questionnaire->questions[$qid]->type_id;
+
+            // Delete section breaks without asking for confirmation.
+            if ($qtype == QUESPAGEBREAK) {
+                redirect($CFG->wwwroot.'/mod/questionnaire/questions.php?id='.$questionnaire->cm->id.'&amp;delq='.$qid);
+            }
+            if ($questionnairehasdependencies) {
+                $haschildren  = questionnaire_get_descendants ($questionnaire->questions, $qid);
+            }
+            if (count($haschildren) != 0) {
+                $action = "confirmdelquestionparent";
+            } else {
+                $action = "confirmdelquestion";
+            }
+
+        } else if (isset($qformdata->editbutton)) {
+            // Switch to edit question screen.
+            $action = 'question';
+            // Need to use the key, since IE returns the image position as the value rather than the specified
+            // value in the <input> tag.
+            $qid = key($qformdata->editbutton);
+            $reload = true;
+
+        } else if (isset($qformdata->requiredbutton)) {
+            // Need to use the key, since IE returns the image position as the value rather than the specified
+            // value in the <input> tag.
+
+            $qid = key($qformdata->requiredbutton);
+            if ($questionnaire->questions[$qid]->required == 'y') {
+                $questionnaire->questions[$qid]->set_required(false);
+
+            } else {
+                $questionnaire->questions[$qid]->set_required(true);
+            }
+
+            $reload = true;
+
+        } else if (isset($qformdata->addqbutton)) {
+            if ($qformdata->type_id == QUESPAGEBREAK) { // Adding section break is handled right away....
+                $questionrec = new stdClass();
+                $questionrec->survey_id = $qformdata->sid;
+                $questionrec->type_id = QUESPAGEBREAK;
+                $questionrec->content = 'break';
+                $question = \mod_questionnaire\question\base::question_builder(QUESPAGEBREAK);
+                $question->add($questionrec);
+                $reload = true;
+            } else {
+                // Switch to edit question screen.
+                $action = 'question';
+                $qtype = $qformdata->type_id;
+                $qid = 0;
+                $reload = true;
+            }
+
+        } else if (isset($qformdata->movebutton)) {
+            // Nothing I do will seem to reload the form with new data, except for moving away from the page, so...
+            redirect($CFG->wwwroot.'/mod/questionnaire/questions.php?id='.$questionnaire->cm->id.
+                     '&moveq='.key($qformdata->movebutton));
+            $reload = true;
+
+
+
+        } else if (isset($qformdata->moveherebutton)) {
+            // Need to use the key, since IE returns the image position as the value rather than the specified
+            // value in the <input> tag.
+
+            // No need to move question if new position = old position!
+            $qpos = key($qformdata->moveherebutton);
+            if ($qformdata->moveq != $qpos) {
+                $questionnaire->move_question($qformdata->moveq, $qpos);
+            }
+            if ($questionnairehasdependencies) {
+                $SESSION->questionnaire->validateresults = questionnaire_check_page_breaks($questionnaire);
+            }
+            // Nothing I do will seem to reload the form with new data, except for moving away from the page, so...
+            redirect($CFG->wwwroot.'/mod/questionnaire/questions.php?id='.$questionnaire->cm->id);
+            $reload = true;
+
+        } else if (isset($qformdata->validate)) {
+            // Validates page breaks for depend questions.
+            $SESSION->questionnaire->validateresults = questionnaire_check_page_breaks($questionnaire);
+            $reload = true;
+        }
+    }
+
+
+} else if ($action == 'question') {
+    $question = questionnaire_prep_for_questionform($questionnaire, $qid, $qtype);
+    $questionsform = new mod_questionnaire_edit_question_form('questions.php');
+    $questionsform->set_data($question);
+    if ($questionsform->is_cancelled()) {
+        // Switch to main screen.
+        $action = 'main';
+        $reload = true;
+
+    } else if ($qformdata = $questionsform->get_data()) {
+        // Saving question data.
+        if (isset($qformdata->makecopy)) {
+            $qformdata->qid = 0;
+        }
+
+        $question->form_update($qformdata, $questionnaire);
+
+        // Make these field values 'sticky' for further new questions.
+        if (!isset($qformdata->required)) {
+            $qformdata->required = 'n';
+        }
+        // Need to reload questions.
+        $questions = $DB->get_records('questionnaire_question', array('survey_id' => $sid, 'deleted' => 'n'), 'id');
+        $questionnairehasdependencies = questionnaire_has_dependencies($questions);
+        if (questionnaire_has_dependencies($questions)) {
+            questionnaire_check_page_breaks($questionnaire);
+        }
+        $SESSION->questionnaire->required = $qformdata->required;
+        $SESSION->questionnaire->type_id = $qformdata->type_id;
+        // Switch to main screen.
+        $action = 'main';
+        $reload = true;
+    }
+
+    // Log question created event.
+    if (isset($qformdata)) {
+        $context = context_module::instance($questionnaire->cm->id);
+        $questiontype = \mod_questionnaire\question\base::qtypename($qformdata->type_id);
+        $params = array(
+                        'context' => $context,
+                        'courseid' => $questionnaire->course->id,
+                        'other' => array('questiontype' => $questiontype)
+        );
+        $event = \mod_questionnaire\event\question_created::create($params);
+        $event->trigger();
+    }
+
+    $questionsform->set_data($question);
+}
+
+// Reload the form data if called for...
+if ($reload) {
+    unset($questionsform);
+    $questionnaire = new questionnaire($questionnaire->id, null, $course, $cm);
+    // Add renderer and page objects to the questionnaire object for display use.
+    $questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+    $questionnaire->add_page(new \mod_questionnaire\output\questionspage());
+    if ($action == 'main') {
+        $questionsform = new mod_questionnaire_questions_form('questions.php', $moveq);
+        $sdata = clone($questionnaire->survey);
+        $sdata->sid = $questionnaire->survey->id;
+        $sdata->id = $cm->id;
+        if (!empty($questionnaire->questions)) {
+            $pos = 1;
+            foreach ($questionnaire->questions as $qidx => $question) {
+                $sdata->{'pos_'.$qidx} = $pos;
+                $pos++;
+            }
+        }
+        $questionsform->set_data($sdata);
+    } else if ($action == 'question') {
+        $question = questionnaire_prep_for_questionform($questionnaire, $qid, $qtype);
+        $questionsform = new mod_questionnaire_edit_question_form('questions.php');
+        $questionsform->set_data($question);
+    }
+}
+
+// Print the page header.
+if ($action == 'question') {
+    if (isset($question->qid)) {
+        $streditquestion = get_string('editquestion', 'questionnaire', questionnaire_get_type($question->type_id));
+    } else {
+        $streditquestion = get_string('addnewquestion', 'questionnaire', questionnaire_get_type($question->type_id));
+    }
+} else {
+    $streditquestion = get_string('managequestions', 'questionnaire');
+}
+
+$PAGE->set_title($streditquestion);
+$PAGE->set_heading(format_string($course->fullname));
+$PAGE->navbar->add($streditquestion);
+echo $questionnaire->renderer->header();
+require('tabs.php');
+
+if ($action == "confirmdelquestion" || $action == "confirmdelquestionparent") {
+
+    $qid = key($qformdata->removebutton);
+    $question = $questionnaire->questions[$qid];
+    $qtype = $question->type_id;
+
+    // Count responses already saved for that question.
+    $countresps = 0;
+    if ($qtype != QUESSECTIONTEXT) {
+        $responsetable = $DB->get_field('questionnaire_question_type', 'response_table', array('typeid' => $qtype));
+        if (!empty($responsetable)) {
+            $countresps = $DB->count_records('questionnaire_'.$responsetable, array('question_id' => $qid));
+        }
+    }
+
+    // Needed to print potential media in question text.
+
+    // If question text is "empty", i.e. 2 non-breaking spaces were inserted, do not display any question text.
+
+    if ($question->content == '<p>  </p>') {
+        $question->content = '';
+    }
+
+    $qname = '';
+    if ($question->name) {
+        $qname = ' ('.$question->name.')';
+    }
+
+    $num = get_string('position', 'questionnaire');
+    $pos = $question->position.$qname;
+
+    $msg = '<div class="warning centerpara"><p>'.get_string('confirmdelquestion', 'questionnaire', $pos).'</p>';
+    if ($countresps !== 0) {
+        $msg .= '<p>'.get_string('confirmdelquestionresps', 'questionnaire', $countresps).'</p>';
+    }
+    $msg .= '</div>';
+    $msg .= '<div class = "qn-container">'.$num.' '.$pos.'<div class="qn-question">'.$question->content.'</div></div>';
+    $args = "id={$questionnaire->cm->id}";
+    $urlno = new moodle_url("/mod/questionnaire/questions.php?{$args}");
+    $args .= "&delq={$qid}";
+    $urlyes = new moodle_url("/mod/questionnaire/questions.php?{$args}");
+    $buttonyes = new single_button($urlyes, get_string('yes'));
+    $buttonno = new single_button($urlno, get_string('no'));
+    if ($action == "confirmdelquestionparent") {
+        $strnum = get_string('position', 'questionnaire');
+        $qid = key($qformdata->removebutton);
+        $msg .= '<div class="warning">'.get_string('confirmdelchildren', 'questionnaire').'</div><br />';
+        foreach ($haschildren as $child) {
+            $childname = '';
+            if ($child['name']) {
+                $childname = ' ('.$child['name'].')';
+            }
+            $msg .= '<div class = "qn-container">'.$strnum.' '.$child['position'].$childname.'<span class="qdepend"><strong>'.
+                            get_string('dependquestion', 'questionnaire').'</strong>'.
+                            ' ('.$strnum.' '.$child['parentposition'].') '.
+                            '&nbsp;:&nbsp;'.$child['parent'].'</span>'.
+                            '<div class="qn-question">'.
+                            $child['content'].
+                            '</div></div>';
+        }
+    }
+    $questionnaire->page->add_to_page('formarea', $questionnaire->renderer->confirm($msg, $buttonyes, $buttonno));
+
+} else {
+    $questionnaire->page->add_to_page('formarea', $questionsform->render());
+}
+echo $questionnaire->renderer->render($questionnaire->page);
+echo $questionnaire->renderer->footer();
\ No newline at end of file
diff --git a/mod/questionnaire/report.php b/mod/questionnaire/report.php
new file mode 100644
index 0000000..2b7bd27
--- /dev/null
+++ b/mod/questionnaire/report.php
@@ -0,0 +1,747 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+$instance = optional_param('instance', false, PARAM_INT);   // Questionnaire ID.
+$action = optional_param('action', 'vall', PARAM_ALPHA);
+$sid = optional_param('sid', null, PARAM_INT);              // Survey id.
+$rid = optional_param('rid', false, PARAM_INT);
+$type = optional_param('type', '', PARAM_ALPHA);
+$byresponse = optional_param('byresponse', false, PARAM_INT);
+$individualresponse = optional_param('individualresponse', false, PARAM_INT);
+$currentgroupid = optional_param('group', 0, PARAM_INT); // Groupid.
+$user = optional_param('user', '', PARAM_INT);
+$userid = $USER->id;
+switch ($action) {
+    case 'vallasort':
+        $sort = 'ascending';
+       break;
+    case 'vallarsort':
+        $sort = 'descending';
+       break;
+    default:
+        $sort = 'default';
+}
+
+if ($instance === false) {
+    if (!empty($SESSION->instance)) {
+        $instance = $SESSION->instance;
+    } else {
+        print_error('requiredparameter', 'questionnaire');
+    }
+}
+$SESSION->instance = $instance;
+$usergraph = get_config('questionnaire', 'usergraph');
+
+if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $instance))) {
+    print_error('incorrectquestionnaire', 'questionnaire');
+}
+if (! $course = $DB->get_record("course", array("id" => $questionnaire->course))) {
+    print_error('coursemisconf');
+}
+if (! $cm = get_coursemodule_from_instance("questionnaire", $questionnaire->id, $course->id)) {
+    print_error('invalidcoursemodule');
+}
+
+require_course_login($course, true, $cm);
+
+$questionnaire = new questionnaire(0, $questionnaire, $course, $cm);
+
+// Add renderer and page objects to the questionnaire object for display use.
+$questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+$questionnaire->add_page(new \mod_questionnaire\output\reportpage());
+
+// If you can't view the questionnaire, or can't view a specified response, error out.
+$context = context_module::instance($cm->id);
+if (!has_capability('mod/questionnaire:readallresponseanytime', $context) &&
+  !($questionnaire->capabilities->view && $questionnaire->can_view_response($rid))) {
+    // Should never happen, unless called directly by a snoop...
+    print_error('nopermissions', 'moodle', $CFG->wwwroot.'/mod/questionnaire/view.php?id='.$cm->id);
+}
+
+$questionnaire->canviewallgroups = has_capability('moodle/site:accessallgroups', $context);
+$sid = $questionnaire->survey->id;
+
+$url = new moodle_url($CFG->wwwroot.'/mod/questionnaire/report.php');
+if ($instance) {
+    $url->param('instance', $instance);
+}
+
+$url->param('action', $action);
+
+if ($type) {
+    $url->param('type', $type);
+}
+if ($byresponse || $individualresponse) {
+    $url->param('byresponse', 1);
+}
+if ($user) {
+    $url->param('user', $user);
+}
+if ($action == 'dresp') {
+    $url->param('action', 'dresp');
+    $url->param('byresponse', 1);
+    $url->param('rid', $rid);
+    $url->param('individualresponse', 1);
+}
+if ($currentgroupid !== null) {
+    $url->param('group', $currentgroupid);
+}
+
+$PAGE->set_url($url);
+$PAGE->set_context($context);
+
+// Tab setup.
+if (!isset($SESSION->questionnaire)) {
+    $SESSION->questionnaire = new stdClass();
+}
+$SESSION->questionnaire->current_tab = 'allreport';
+
+// Get all responses for further use in viewbyresp and deleteall etc.
+// All participants.
+$params = array('survey_id' => $sid, 'complete' => 'y');
+$respsallparticipants = $DB->get_records('questionnaire_response', $params, 'id', 'id,survey_id,submitted,userid');
+$SESSION->questionnaire->numrespsallparticipants = count ($respsallparticipants);
+$SESSION->questionnaire->numselectedresps = $SESSION->questionnaire->numrespsallparticipants;
+
+// Available group modes (0 = no groups; 1 = separate groups; 2 = visible groups).
+$groupmode = groups_get_activity_groupmode($cm, $course);
+$questionnairegroups = '';
+$groupscount = 0;
+$SESSION->questionnaire->respscount = 0;
+$SESSION->questionnaire_survey_id = $sid;
+
+if ($groupmode > 0) {
+    if ($groupmode == 1) {
+        $questionnairegroups = groups_get_all_groups($course->id, $userid);
+    }
+    if ($groupmode == 2 || $questionnaire->canviewallgroups) {
+        $questionnairegroups = groups_get_all_groups($course->id);
+    }
+
+    if (!empty($questionnairegroups)) {
+        $groupscount = count($questionnairegroups);
+        foreach ($questionnairegroups as $key) {
+            $firstgroupid = $key->id;
+            break;
+        }
+        if ($groupscount === 0 && $groupmode == 1) {
+            $currentgroupid = 0;
+        }
+        if ($groupmode == 1 && !$questionnaire->canviewallgroups && $currentgroupid == 0) {
+            $currentgroupid = $firstgroupid;
+        }
+    } else {
+        // Groupmode = separate groups but user is not member of any group
+        // and does not have moodle/site:accessallgroups capability -> refuse view responses.
+        if (!$questionnaire->canviewallgroups) {
+            $currentgroupid = 0;
+        }
+    }
+
+    if ($currentgroupid > 0) {
+        $groupname = get_string('group').' <strong>'.groups_get_group_name($currentgroupid).'</strong>';
+    } else {
+        $groupname = '<strong>'.get_string('allparticipants').'</strong>';
+    }
+}
+if ($usergraph) {
+    $charttype = $questionnaire->survey->chart_type;
+    if ($charttype) {
+        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.common.core.js');
+
+        switch ($charttype) {
+            case 'bipolar':
+                $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.bipolar.js');
+                break;
+            case 'hbar':
+                $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.hbar.js');
+                break;
+            case 'radar':
+                $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.radar.js');
+                break;
+            case 'rose':
+                $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.rose.js');
+                break;
+            case 'vprogress':
+                $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.vprogress.js');
+                break;
+        }
+    }
+}
+
+switch ($action) {
+
+    case 'dresp':  // Delete individual response? Ask for confirmation.
+
+        require_capability('mod/questionnaire:deleteresponses', $context);
+
+        if (empty($questionnaire->survey)) {
+            $id = $questionnaire->survey;
+            notify ("questionnaire->survey = /$id/");
+            print_error('surveynotexists', 'questionnaire');
+        } else if ($questionnaire->survey->courseid != $course->id) {
+            print_error('surveyowner', 'questionnaire');
+        } else if (!$rid || !is_numeric($rid)) {
+            print_error('invalidresponse', 'questionnaire');
+        } else if (!($resp = $DB->get_record('questionnaire_response', array('id' => $rid)))) {
+            print_error('invalidresponserecord', 'questionnaire');
+        }
+
+        $ruser = false;
+        if (!empty($resp->userid)) {
+            if ($user = $DB->get_record('user', ['id' => $resp->userid])) {
+                $ruser = fullname($user);
+            } else {
+                $ruser = '- '.get_string('unknown', 'questionnaire').' -';
+            }
+        } else {
+            $ruser = $resp->userid;
+        }
+
+        // Print the page header.
+        $PAGE->set_title(get_string('deletingresp', 'questionnaire'));
+        $PAGE->set_heading(format_string($course->fullname));
+        echo $questionnaire->renderer->header();
+
+        // Print the tabs.
+        $SESSION->questionnaire->current_tab = 'deleteresp';
+        include('tabs.php');
+
+        $timesubmitted = '<br />'.get_string('submitted', 'questionnaire').'&nbsp;'.userdate($resp->submitted);
+        if ($questionnaire->respondenttype == 'anonymous') {
+                $ruser = '- '.get_string('anonymous', 'questionnaire').' -';
+                $timesubmitted = '';
+        }
+
+        // Print the confirmation.
+        $msg = '<div class="warning centerpara">';
+        $msg .= get_string('confirmdelresp', 'questionnaire', $ruser.$timesubmitted);
+        $msg .= '</div>';
+        $urlyes = new moodle_url('report.php', array('action' => 'dvresp',
+                'rid' => $rid, 'individualresponse' => 1, 'instance' => $instance, 'group' => $currentgroupid));
+        $urlno = new moodle_url('report.php', array('action' => 'vresp', 'instance' => $instance,
+                'rid' => $rid, 'individualresponse' => 1, 'group' => $currentgroupid));
+        $buttonyes = new single_button($urlyes, get_string('delete'), 'post');
+        $buttonno = new single_button($urlno, get_string('cancel'), 'get');
+        $questionnaire->page->add_to_page('notifications', $questionnaire->renderer->confirm($msg, $buttonyes, $buttonno));
+        echo $questionnaire->renderer->render($questionnaire->page);
+        // Finish the page.
+        echo $questionnaire->renderer->footer($course);
+        break;
+
+    case 'delallresp': // Delete all responses? Ask for confirmation.
+        require_capability('mod/questionnaire:deleteresponses', $context);
+
+        if ($DB->count_records('questionnaire_response', array('survey_id' => $sid, 'complete' => 'y'))) {
+
+            // Print the page header.
+            $PAGE->set_title(get_string('deletingresp', 'questionnaire'));
+            $PAGE->set_heading(format_string($course->fullname));
+            echo $questionnaire->renderer->header();
+
+            // Print the tabs.
+            $SESSION->questionnaire->current_tab = 'deleteall';
+            include('tabs.php');
+
+            // Print the confirmation.
+            $msg = '<div class="warning centerpara">';
+            if ($groupmode == 0) {   // No groups or visible groups.
+                $msg .= get_string('confirmdelallresp', 'questionnaire');
+            } else {                 // Separate groups.
+                $msg .= get_string('confirmdelgroupresp', 'questionnaire', $groupname);
+            }
+            $msg .= '</div>';
+
+            $urlyes = new moodle_url('report.php', array('action' => 'dvallresp', 'sid' => $sid,
+                             'instance' => $instance, 'group' => $currentgroupid));
+            $urlno = new moodle_url('report.php', array('instance' => $instance, 'group' => $currentgroupid));
+            $buttonyes = new single_button($urlyes, get_string('delete'), 'post');
+            $buttonno = new single_button($urlno, get_string('cancel'), 'get');
+
+            $questionnaire->page->add_to_page('notifications', $questionnaire->renderer->confirm($msg, $buttonyes, $buttonno));
+            echo $questionnaire->renderer->render($questionnaire->page);
+            // Finish the page.
+            echo $questionnaire->renderer->footer($course);
+        }
+        break;
+
+    case 'dvresp': // Delete single response. Do it!
+
+        require_capability('mod/questionnaire:deleteresponses', $context);
+
+        if (empty($questionnaire->survey)) {
+            print_error('surveynotexists', 'questionnaire');
+        } else if ($questionnaire->survey->courseid != $course->id) {
+            print_error('surveyowner', 'questionnaire');
+        } else if (!$rid || !is_numeric($rid)) {
+            print_error('invalidresponse', 'questionnaire');
+        } else if (!($response = $DB->get_record('questionnaire_response', array('id' => $rid)))) {
+            print_error('invalidresponserecord', 'questionnaire');
+        }
+
+        if (questionnaire_delete_response($response, $questionnaire)) {
+            if (!$DB->count_records('questionnaire_response', array('survey_id' => $sid, 'complete' => 'y'))) {
+                $redirection = $CFG->wwwroot.'/mod/questionnaire/view.php?id='.$cm->id;
+            } else {
+                $redirection = $CFG->wwwroot.'/mod/questionnaire/report.php?action=vresp&amp;instance='.
+                    $instance.'&amp;byresponse=1';
+            }
+
+            // Log this questionnaire delete single response action.
+            $params = array('objectid' => $questionnaire->survey->id,
+                            'context' => $questionnaire->context,
+                            'courseid' => $questionnaire->course->id,
+                            'relateduserid' => $response->userid);
+            $event = \mod_questionnaire\event\response_deleted::create($params);
+            $event->trigger();
+
+            redirect($redirection);
+        } else {
+            if ($questionnaire->respondenttype == 'anonymous') {
+                    $ruser = '- '.get_string('anonymous', 'questionnaire').' -';
+            } else if (!empty($response->userid)) {
+                if ($user = $DB->get_record('user', ['id' => $response->userid])) {
+                    $ruser = fullname($user);
+                } else {
+                    $ruser = '- '.get_string('unknown', 'questionnaire').' -';
+                }
+            } else {
+                $ruser = $response->userid;
+            }
+            error (get_string('couldnotdelresp', 'questionnaire').$rid.get_string('by', 'questionnaire').$ruser.'?',
+                   $CFG->wwwroot.'/mod/questionnaire/report.php?action=vresp&amp;sid='.$sid.'&amp;&amp;instance='.
+                   $instance.'byresponse=1');
+        }
+        break;
+
+    case 'dvallresp': // Delete all responses in questionnaire (or group). Do it!
+
+        require_capability('mod/questionnaire:deleteresponses', $context);
+
+        if (empty($questionnaire->survey)) {
+            print_error('surveynotexists', 'questionnaire');
+        } else if ($questionnaire->survey->courseid != $course->id) {
+            print_error('surveyowner', 'questionnaire');
+        }
+
+        // Available group modes (0 = no groups; 1 = separate groups; 2 = visible groups).
+        if ($groupmode > 0) {
+            switch ($currentgroupid) {
+                case 0:     // All participants.
+                    $resps = $respsallparticipants;
+                    break;
+                default:     // Members of a specific group.
+                    $sql = "SELECT r.id, r.survey_id, r.submitted, r.userid
+                        FROM {questionnaire_response} r,
+                            {groups_members} gm
+                         WHERE r.survey_id = ? AND
+                           r.complete ='y' AND
+                           gm.groupid = ? AND r.userid = gm.userid
+                        ORDER BY r.id";
+                    if (!($resps = $DB->get_records_sql($sql, array($sid, $currentgroupid)))) {
+                        $resps = array();
+                    }
+            }
+            if (empty($resps)) {
+                $noresponses = true;
+            } else {
+                if ($rid === false) {
+                    $resp = current($resps);
+                    $rid = $resp->id;
+                } else {
+                    $resp = $DB->get_record('questionnaire_response', array('id' => $rid));
+                }
+                if (!empty($resp->userid)) {
+                    if ($user = $DB->get_record('user', ['id' => $resp->userid])) {
+                        $ruser = fullname($user);
+                    } else {
+                        $ruser = '- '.get_string('unknown', 'questionnaire').' -';
+                    }
+                } else {
+                    $ruser = $resp->userid;
+                }
+            }
+        } else {
+            $resps = $respsallparticipants;
+        }
+
+        if (!empty($resps)) {
+            foreach ($resps as $response) {
+                questionnaire_delete_response($response, $questionnaire);
+            }
+            if (!$DB->count_records('questionnaire_response', array('survey_id' => $sid, 'complete' => 'y'))) {
+                $redirection = $CFG->wwwroot.'/mod/questionnaire/view.php?id='.$cm->id;
+            } else {
+                $redirection = $CFG->wwwroot.'/mod/questionnaire/report.php?action=vall&amp;sid='.$sid.'&amp;instance='.$instance;
+            }
+
+            // Log this questionnaire delete all responses action.
+            $context = context_module::instance($questionnaire->cm->id);
+            $anonymous = $questionnaire->respondenttype == 'anonymous';
+
+            $event = \mod_questionnaire\event\all_responses_deleted::create(array(
+                            'objectid' => $questionnaire->id,
+                            'anonymous' => $anonymous,
+                            'context' => $context
+            ));
+            $event->trigger();
+
+            redirect($redirection);
+        } else {
+            error (get_string('couldnotdelresp', 'questionnaire'),
+                   $CFG->wwwroot.'/mod/questionnaire/report.php?action=vall&amp;sid='.$sid.'&amp;instance='.$instance);
+        }
+        break;
+
+    case 'dwnpg': // Download page options.
+
+        require_capability('mod/questionnaire:downloadresponses', $context);
+
+        $PAGE->set_title(get_string('questionnairereport', 'questionnaire'));
+        $PAGE->set_heading(format_string($course->fullname));
+        echo $questionnaire->renderer->header();
+
+        // Print the tabs.
+        // Tab setup.
+        if (empty($user)) {
+            $SESSION->questionnaire->current_tab = 'downloadcsv';
+        } else {
+            $SESSION->questionnaire->current_tab = 'mydownloadcsv';
+        }
+
+        include('tabs.php');
+
+        $groupname = '';
+        if ($groupmode > 0) {
+            switch ($currentgroupid) {
+                case 0:     // All participants.
+                    $groupname = get_string('allparticipants');
+                    break;
+                default:     // Members of a specific group.
+                    $groupname = get_string('membersofselectedgroup', 'group').' '.get_string('group').' '.
+                        $questionnairegroups[$currentgroupid]->name;
+            }
+        }
+        $output = '';
+        $output .= "<br /><br />\n";
+        $output .= $questionnaire->renderer->help_icon('downloadtextformat', 'questionnaire');
+        $output .= '&nbsp;'.(get_string('downloadtext')).':&nbsp;'.get_string('responses', 'questionnaire').'&nbsp;'.$groupname;
+        $output .= $questionnaire->renderer->heading(get_string('textdownloadoptions', 'questionnaire'));
+        $output .= $questionnaire->renderer->box_start();
+        $output .= "<form action=\"{$CFG->wwwroot}/mod/questionnaire/report.php\" method=\"GET\">\n";
+        $output .= "<input type=\"hidden\" name=\"instance\" value=\"$instance\" />\n";
+        $output .= "<input type=\"hidden\" name=\"user\" value=\"$user\" />\n";
+        $output .= "<input type=\"hidden\" name=\"sid\" value=\"$sid\" />\n";
+        $output .= "<input type=\"hidden\" name=\"action\" value=\"dcsv\" />\n";
+        $output .= "<input type=\"hidden\" name=\"group\" value=\"$currentgroupid\" />\n";
+        $output .= html_writer::checkbox('choicecodes', 1, true, get_string('includechoicecodes', 'questionnaire'));
+        $output .= "<br />\n";
+        $output .= html_writer::checkbox('choicetext', 1, true, get_string('includechoicetext', 'questionnaire'));
+        $output .= "<br />\n";
+        $output .= "<br />\n";
+        $output .= "<input type=\"submit\" name=\"submit\" value=\"".get_string('download', 'questionnaire')."\" />\n";
+        $output .= "</form>\n";
+        $output .= $questionnaire->renderer->box_end();
+
+        $questionnaire->page->add_to_page('respondentinfo', $output);
+        echo $questionnaire->renderer->render($questionnaire->page);
+
+        echo $questionnaire->renderer->footer('none');
+
+        // Log saved as text action.
+        $params = array('objectid' => $questionnaire->id,
+                        'context' => $questionnaire->context,
+                        'courseid' => $course->id,
+                        'other' => array('action' => $action, 'instance' => $instance, 'currentgroupid' => $currentgroupid)
+        );
+        $event = \mod_questionnaire\event\all_responses_saved_as_text::create($params);
+        $event->trigger();
+
+        exit();
+        break;
+
+    case 'dcsv': // Download responses data as text (cvs) format.
+        require_capability('mod/questionnaire:downloadresponses', $context);
+
+        // Use the questionnaire name as the file name. Clean it and change any non-filename characters to '_'.
+        $name = clean_param($questionnaire->name, PARAM_FILE);
+        $name = preg_replace("/[^A-Z0-9]+/i", "_", trim($name));
+
+        $choicecodes = optional_param('choicecodes', '0', PARAM_INT);
+        $choicetext  = optional_param('choicetext', '0', PARAM_INT);
+        $output = $questionnaire->generate_csv('', $user, $choicecodes, $choicetext, $currentgroupid);
+
+        // CSV
+        // SEP. 2007 JR changed file extension to *.txt for non-English Excel users' sake
+        // and changed separator to tabulation
+        // JAN. 2008 added \r carriage return for better Windows implementation.
+        header("Content-Disposition: attachment; filename=$name.txt");
+        header("Content-Type: text/comma-separated-values");
+        foreach ($output as $row) {
+            $text = implode("\t", $row);
+            echo $text."\r\n";
+        }
+        exit();
+        break;
+
+    case 'vall':         // View all responses.
+    case 'vallasort':    // View all responses sorted in ascending order.
+    case 'vallarsort':   // View all responses sorted in descending order.
+
+        $PAGE->set_title(get_string('questionnairereport', 'questionnaire'));
+        $PAGE->set_heading(format_string($course->fullname));
+        echo $questionnaire->renderer->header();
+        if (!$questionnaire->capabilities->readallresponses && !$questionnaire->capabilities->readallresponseanytime) {
+            // Should never happen, unless called directly by a snoop.
+            print_error('nopermissions', '', '', get_string('viewallresponses', 'questionnaire'));
+            // Finish the page.
+            echo $questionnaire->renderer->footer($course);
+            break;
+        }
+
+        // Print the tabs.
+        switch ($action) {
+            case 'vallasort':
+                $SESSION->questionnaire->current_tab = 'vallasort';
+                break;
+            case 'vallarsort':
+                $SESSION->questionnaire->current_tab = 'vallarsort';
+                break;
+            default:
+                $SESSION->questionnaire->current_tab = 'valldefault';
+        }
+        include('tabs.php');
+
+        $respinfo = '';
+        $resps = array();
+        // Enable choose_group if there are questionnaire groups and groupmode is not set to "no groups"
+        // and if there are more goups than 1 (or if user can view all groups).
+        if (is_array($questionnairegroups) && $groupmode > 0) {
+            $groupselect = groups_print_activity_menu($cm, $url->out(), true);
+            // Count number of responses in each group.
+            foreach ($questionnairegroups as $group) {
+                $sql = 'SELECT COUNT(r.id) ' .
+                       'FROM {questionnaire_response} r ' .
+                       'INNER JOIN {groups_members} gm ON r.userid = gm.userid ' .
+                       'WHERE r.survey_id = ? AND r.complete = ? AND gm.groupid = ?';
+                $respscount = $DB->count_records_sql($sql, array($sid, 'y', $group->id));
+                $thisgroupname = groups_get_group_name($group->id);
+                $escapedgroupname = preg_quote($thisgroupname, '/');
+                if (!empty ($respscount)) {
+                    // Add number of responses to name of group in the groups select list.
+                    $groupselect = preg_replace('/\<option value="'.$group->id.'">'.$escapedgroupname.'<\/option>/',
+                        '<option value="'.$group->id.'">'.$thisgroupname.' ('.$respscount.')</option>', $groupselect);
+                } else {
+                    // Remove groups with no responses from the groups select list.
+                    $groupselect = preg_replace('/\<option value="'.$group->id.'">'.$escapedgroupname.
+                            '<\/option>/', '', $groupselect);
+                }
+            }
+            $respinfo .= isset($groupselect) ? ($groupselect . ' ') : '';
+            $currentgroupid = groups_get_activity_group($cm);
+        }
+        if ($currentgroupid > 0) {
+             $groupname = get_string('group').': <strong>'.groups_get_group_name($currentgroupid).'</strong>';
+        } else {
+            $groupname = '<strong>'.get_string('allparticipants').'</strong>';
+        }
+
+        // Available group modes (0 = no groups; 1 = separate groups; 2 = visible groups).
+        if ($groupmode > 0) {
+            switch ($currentgroupid) {
+                case 0:     // All participants.
+                    $resps = $respsallparticipants;
+                    break;
+                default:     // Members of a specific group.
+                    $sql = 'SELECT r.id, gm.id as groupid ' .
+                           'FROM {questionnaire_response} r ' .
+                           'INNER JOIN {groups_members} gm ON r.userid = gm.userid ' .
+                           'WHERE r.survey_id = ? AND r.complete = ? AND gm.groupid = ?';
+                    if (!($resps = $DB->get_records_sql($sql, array($sid, 'y', $currentgroupid)))) {
+                        $resps = '';
+                    }
+            }
+            if (empty($resps)) {
+                $noresponses = true;
+            }
+        } else {
+            $resps = $respsallparticipants;
+        }
+        if (!empty($resps)) {
+            // NOTE: response_analysis uses $resps to get the id's of the responses only.
+            // Need to figure out what this function does.
+            $feedbackmessages = $questionnaire->response_analysis($rid = 0, $resps, $compare = false,
+                $isgroupmember = false, $allresponses = true, $currentgroupid);
+
+            if ($feedbackmessages) {
+                $msgout = '';
+                foreach ($feedbackmessages as $msg) {
+                    $msgout .= $msg;
+                }
+                $questionnaire->page->add_to_page('feedbackmessages', $msgout);
+            }
+        }
+
+        $params = array('objectid' => $questionnaire->id,
+                        'context' => $context,
+                        'courseid' => $course->id,
+                        'other' => array('action' => $action, 'instance' => $instance, 'groupid' => $currentgroupid)
+        );
+        $event = \mod_questionnaire\event\all_responses_viewed::create($params);
+        $event->trigger();
+
+        $respinfo .= get_string('viewallresponses', 'questionnaire').'. '.$groupname.'. ';
+        $strsort = get_string('order_'.$sort, 'questionnaire');
+        $respinfo .= $strsort;
+        $respinfo .= $questionnaire->renderer->help_icon('orderresponses', 'questionnaire');
+        $questionnaire->page->add_to_page('respondentinfo', $respinfo);
+
+        $ret = $questionnaire->survey_results(1, 1, '', '', '', $uid = false, $currentgroupid, $sort);
+
+        echo $questionnaire->renderer->render($questionnaire->page);
+
+        // Finish the page.
+        echo $questionnaire->renderer->footer($course);
+        break;
+
+    case 'vresp': // View by response.
+
+    default:
+        if (empty($questionnaire->survey)) {
+            print_error('surveynotexists', 'questionnaire');
+        } else if ($questionnaire->survey->courseid != $course->id) {
+            print_error('surveyowner', 'questionnaire');
+        }
+        $ruser = false;
+        $noresponses = false;
+        if ($usergraph) {
+            $charttype = $questionnaire->survey->chart_type;
+            if ($charttype) {
+                $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.common.core.js');
+
+                switch ($charttype) {
+                    case 'bipolar':
+                        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.bipolar.js');
+                        break;
+                    case 'hbar':
+                        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.hbar.js');
+                        break;
+                    case 'radar':
+                        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.radar.js');
+                        break;
+                    case 'rose':
+                        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.rose.js');
+                        break;
+                    case 'vprogress':
+                        $PAGE->requires->js('/mod/questionnaire/javascript/RGraph/RGraph.vprogress.js');
+                        break;
+                }
+            }
+        }
+
+        if ($byresponse || $rid) {
+            // Available group modes (0 = no groups; 1 = separate groups; 2 = visible groups).
+            if ($groupmode > 0) {
+                switch ($currentgroupid) {
+                    case 0:     // All participants.
+                        $resps = $respsallparticipants;
+                        break;
+                    default:     // Members of a specific group.
+                        $sql = 'SELECT r.id, r.survey_id, r.submitted, r.userid ' .
+                               'FROM {questionnaire_response} r ' .
+                               'INNER JOIN {groups_members} gm ON r.userid = gm.userid ' .
+                               'WHERE r.survey_id = ? AND r.complete = ? AND gm.groupid = ? ' .
+                               'ORDER BY r.id';
+                        $resps = $DB->get_records_sql($sql, array($sid, 'y', $currentgroupid));
+                }
+                if (empty($resps)) {
+                    $noresponses = true;
+                } else {
+                    if ($rid === false) {
+                        $resp = current($resps);
+                        $rid = $resp->id;
+                    } else {
+                        $resp = $DB->get_record('questionnaire_response', array('id' => $rid));
+                    }
+                    if (!empty($resp->userid)) {
+                        if ($user = $DB->get_record('user', ['id' => $resp->userid])) {
+                            $ruser = fullname($user);
+                        } else {
+                            $ruser = '- '.get_string('unknown', 'questionnaire').' -';
+                        }
+                    } else {
+                        $ruser = $resp->userid;
+                    }
+                }
+            } else {
+                $resps = $respsallparticipants;
+            }
+        }
+        $rids = array_keys($resps);
+        if (!$rid && !$noresponses) {
+            $rid = $rids[0];
+        }
+
+        // Print the page header.
+        $PAGE->set_title(get_string('questionnairereport', 'questionnaire'));
+        $PAGE->set_heading(format_string($course->fullname));
+        echo $questionnaire->renderer->header();
+
+        // Print the tabs.
+        if ($byresponse) {
+            $SESSION->questionnaire->current_tab = 'vrespsummary';
+        }
+        if ($individualresponse) {
+            $SESSION->questionnaire->current_tab = 'individualresp';
+        }
+        include('tabs.php');
+
+        // Print the main part of the page.
+        // TODO provide option to select how many columns and/or responses per page.
+
+        if ($noresponses) {
+            $questionnaire->page->add_to_page('respondentinfo',
+                get_string('group').' <strong>'.groups_get_group_name($currentgroupid).'</strong>: '.
+                get_string('noresponses', 'questionnaire'));
+        } else {
+            $groupname = get_string('group').': <strong>'.groups_get_group_name($currentgroupid).'</strong>';
+            if ($currentgroupid == 0 ) {
+                $groupname = get_string('allparticipants');
+            }
+            if ($byresponse) {
+                $respinfo = '';
+                $respinfo .= $questionnaire->renderer->box_start();
+                $respinfo .= $questionnaire->renderer->help_icon('viewindividualresponse', 'questionnaire').'&nbsp;';
+                $respinfo .= get_string('viewindividualresponse', 'questionnaire').' <strong> : '.$groupname.'</strong>';
+                $respinfo .= $questionnaire->renderer->box_end();
+                $questionnaire->page->add_to_page('respondentinfo', $respinfo);
+            }
+            $questionnaire->survey_results_navbar_alpha($rid, $currentgroupid, $cm, $byresponse);
+            if (!$byresponse) { // Show respondents individual responses.
+                $questionnaire->view_response($rid, $referer = '', $blankquestionnaire = false, $resps, $compare = true,
+                    $isgroupmember = true, $allresponses = false, $currentgroupid);
+            }
+        }
+
+        echo $questionnaire->renderer->render($questionnaire->page);
+
+        // Finish the page.
+        echo $questionnaire->renderer->footer($course);
+        break;
+}
\ No newline at end of file
diff --git a/mod/questionnaire/settings.php b/mod/questionnaire/settings.php
new file mode 100644
index 0000000..fede997
--- /dev/null
+++ b/mod/questionnaire/settings.php
@@ -0,0 +1,50 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Setting page for questionaire module
+ *
+ * @package    mod
+ * @subpackage questionnaire
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die;
+
+if ($ADMIN->fulltree) {
+    $options = array(0 => get_string('no'), 1 => get_string('yes'));
+    $str = get_string('configusergraphlong', 'questionnaire');
+    $settings->add(new admin_setting_configselect('questionnaire/usergraph',
+                                    get_string('configusergraph', 'questionnaire'),
+                                    $str, 0, $options));
+    $settings->add(new admin_setting_configtext('questionnaire/maxsections',
+                                    get_string('configmaxsections', 'questionnaire'),
+                                    '', 10, PARAM_INT));
+    $choices = array(
+        'response' => get_string('response', 'questionnaire'),
+        'submitted' => get_string('submitted', 'questionnaire'),
+        'institution' => get_string('institution'),
+        'department' => get_string('department'),
+        'course' => get_string('course'),
+        'group' => get_string('group'),
+        'id' => get_string('id', 'questionnaire'),
+        'fullname' => get_string('fullname'),
+        'username' => get_string('username')
+    );
+
+    $settings->add(new admin_setting_configmultiselect('questionnaire/downloadoptions',
+            get_string('textdownloadoptions', 'questionnaire'), '', array_keys($choices), $choices));
+}
diff --git a/mod/questionnaire/show_nonrespondents.php b/mod/questionnaire/show_nonrespondents.php
new file mode 100644
index 0000000..a5ae5f6
--- /dev/null
+++ b/mod/questionnaire/show_nonrespondents.php
@@ -0,0 +1,516 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ *
+ * @author Joseph Rézeau (copied from feedback plugin show_nonrespondents by original author Andreas Grabs)
+ * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
+ * @package    mod
+ * @subpackage questionnaire
+ *
+ */
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+require_once($CFG->libdir.'/tablelib.php');
+
+// Get the params.
+$id = required_param('id', PARAM_INT);
+$subject = optional_param('subject', '', PARAM_CLEANHTML);
+$message = optional_param('message', '', PARAM_CLEANHTML);
+$format = optional_param('format', FORMAT_MOODLE, PARAM_INT);
+$messageuser = optional_param_array('messageuser', false, PARAM_INT);
+$action = optional_param('action', '', PARAM_ALPHA);
+$selectedanonymous = optional_param('selectedanonymous', '', PARAM_ALPHA);
+$perpage = optional_param('perpage', QUESTIONNAIRE_DEFAULT_PAGE_COUNT, PARAM_INT);  // How many per page.
+$showall = optional_param('showall', false, PARAM_INT);  // Should we show all users?
+$sid    = optional_param('sid', 0, PARAM_INT);
+$qid    = optional_param('qid', 0, PARAM_INT);
+$currentgroupid = optional_param('group', 0, PARAM_INT); // Groupid.
+
+if (!isset($SESSION->questionnaire)) {
+    $SESSION->questionnaire = new stdClass();
+}
+
+$SESSION->questionnaire->current_tab = 'nonrespondents';
+
+// Get the objects.
+
+if ($id) {
+    if (! $cm = get_coursemodule_from_id('questionnaire', $id)) {
+        print_error('invalidcoursemodule');
+    }
+
+    if (! $course = $DB->get_record("course", array("id" => $cm->course))) {
+        print_error('coursemisconf');
+    }
+
+    if (! $questionnaire = $DB->get_record("questionnaire", array("id" => $cm->instance))) {
+        print_error('invalidcoursemodule');
+    }
+}
+
+if (!$context = context_module::instance($cm->id)) {
+        print_error('badcontext');
+}
+
+// We need the coursecontext to allow sending of mass mails.
+if (!$coursecontext = context_course::instance($course->id)) {
+        print_error('badcontext');
+}
+
+require_course_login($course, true, $cm);
+
+$url = new moodle_url('/mod/questionnaire/show_nonrespondents.php', array('id' => $cm->id));
+$PAGE->set_url($url);
+
+$questionnaire = new questionnaire($sid, $questionnaire, $course, $cm);
+
+// Add renderer and page objects to the questionnaire object for display use.
+$questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+$questionnaire->add_page(new \mod_questionnaire\output\nonrespondentspage());
+
+$resume = $questionnaire->resume;
+$fullname = $questionnaire->respondenttype == 'fullname';
+$sid = $questionnaire->sid;
+
+if (($formdata = data_submitted()) && !confirm_sesskey()) {
+    print_error('invalidsesskey');
+}
+
+require_capability('mod/questionnaire:viewsingleresponse', $context);
+
+// Anonymous questionnaire.
+if (!$fullname) {
+    $nonrespondents = questionnaire_get_incomplete_users($cm, $sid);
+    $countnonrespondents = count($nonrespondents);
+    if ($resume) {
+        $countstarted = 0;
+        $countnotstarted = 0;
+        $params = ['survey_id' => $sid, 'complete' => 'n'];
+        if ($startedusers = $DB->get_records('questionnaire_response', $params, '', 'userid')) {
+            $startedusers = array_keys($startedusers);
+            $countstarted = count($startedusers);
+            $countnotstarted = $countnonrespondents - $countstarted;
+        }
+    }
+}
+
+if ($action == 'sendmessage' && !empty($subject) && !empty($message)) {
+    if (!$fullname) {
+        switch ($selectedanonymous) {
+            case 'none':
+                $messageuser = '';
+                break;
+            case 'all':
+                $messageuser = $nonrespondents;
+                break;
+            case 'started':
+                $messageuser = $startedusers;
+                break;
+            case 'notstarted':
+                $messageuser = array_diff($nonrespondents, $startedusers);
+        }
+    }
+
+    $shortname = format_string($course->shortname,
+                            true,
+                            array('context' => context_course::instance($course->id)));
+    $strquestionnaires = get_string("modulenameplural", "questionnaire");
+
+    $htmlmessage = "<body id=\"email\">";
+
+    $link1 = $CFG->wwwroot.'/mod/questionnaire/view.php?id='.$cm->id;
+
+    $htmlmessage .= '<div class="navbar">'.
+    '<a target="_blank" href="'.$link1.'">'.format_string($questionnaire->name, true).'</a>'.
+    '</div>';
+
+    $htmlmessage .= $message;
+    $htmlmessage .= '</body>';
+
+    $good = 1;
+
+    if (is_array($messageuser)) {
+        foreach ($messageuser as $userid) {
+            $senduser = $DB->get_record('user', array('id' => $userid));
+            $eventdata = new \core\message\message();
+            $eventdata->courseid         = $course->id;
+            $eventdata->name             = 'message';
+            $eventdata->component        = 'mod_questionnaire';
+            $eventdata->userfrom         = $USER;
+            $eventdata->userto           = $senduser;
+            $eventdata->subject          = $subject;
+            $eventdata->fullmessage      = html_to_text($htmlmessage);
+            $eventdata->fullmessageformat = FORMAT_PLAIN;
+            $eventdata->fullmessagehtml  = $htmlmessage;
+            $eventdata->smallmessage     = '';
+            $good = $good && message_send($eventdata);
+        }
+        if (!empty($good)) {
+            $msg = $questionnaire->renderer->heading(get_string('messagedselectedusers'));
+        } else {
+            $msg = $questionnaire->renderer->heading(get_string('messagedselectedusersfailed'));
+        }
+
+        $url = new moodle_url('/mod/questionnaire/view.php', array('id' => $cm->id));
+        redirect($url, $msg, 4);
+        exit;
+    }
+}
+
+// Get the responses of given user.
+// Print the page header.
+$PAGE->navbar->add(get_string('show_nonrespondents', 'questionnaire'));
+$PAGE->set_heading(format_string($course->fullname));
+$PAGE->set_title(format_string($questionnaire->name));
+echo $questionnaire->renderer->header();
+
+require('tabs.php');
+
+$usedgroupid = false;
+$sort = '';
+$startpage = false;
+$pagecount = false;
+
+if ($fullname) {
+    // Print the main part of the page.
+    // Print the users with no responses
+    // Get the effective groupmode of this course and module.
+    $groupmode = groups_get_activity_groupmode($cm, $course);
+
+    $groupselect = groups_print_activity_menu($cm, $url->out(), true);
+    $mygroupid = groups_get_activity_group($cm);
+
+    // Preparing the table for output.
+    $baseurl = new moodle_url('/mod/questionnaire/show_nonrespondents.php');
+    $baseurl->params(array('id' => $cm->id, 'showall' => $showall));
+
+    $tablecolumns = array('userpic', 'fullname');
+
+    // Extra columns copied from participants view.
+    $extrafields = get_extra_user_fields($context);
+    $tableheaders = array(get_string('userpic'), get_string('fullnameuser'));
+
+    if (in_array('email', $extrafields) || has_capability('moodle/course:viewhiddenuserfields', $context)) {
+        $tablecolumns[] = 'email';
+        $tableheaders[] = get_string('email');
+    }
+
+    if (!isset($hiddenfields['city'])) {
+        $tablecolumns[] = 'city';
+        $tableheaders[] = get_string('city');
+    }
+    if (!isset($hiddenfields['country'])) {
+        $tablecolumns[] = 'country';
+        $tableheaders[] = get_string('country');
+    }
+    if (!isset($hiddenfields['lastaccess'])) {
+        $tablecolumns[] = 'lastaccess';
+        $tableheaders[] = get_string('lastaccess');
+    }
+    if ($resume) {
+        $tablecolumns[] = 'status';
+        $tableheaders[] = get_string('status');
+    }
+    if (has_capability('mod/questionnaire:message', $context)) {
+        $tablecolumns[] = 'select';
+        $tableheaders[] = get_string('select');
+    }
+
+    $table = new flexible_table('questionnaire-shownonrespondents-'.$course->id);
+
+    $table->define_columns($tablecolumns);
+    $table->define_headers($tableheaders);
+    $table->define_baseurl($baseurl);
+
+    $table->sortable(true, 'lastname', SORT_DESC);
+    $table->set_attribute('cellspacing', '0');
+    $table->set_attribute('id', 'showentrytable');
+    $table->set_attribute('class', 'flexible generaltable generalbox');
+    $table->set_control_variables(array(
+                TABLE_VAR_SORT    => 'ssort',
+                TABLE_VAR_IFIRST  => 'sifirst',
+                TABLE_VAR_ILAST   => 'silast',
+                TABLE_VAR_PAGE    => 'spage'
+                ));
+
+    $table->no_sorting('status');
+    $table->no_sorting('select');
+
+    $table->setup();
+
+    if ($table->get_sql_sort()) {
+        $sort = $table->get_sql_sort();
+    } else {
+        $sort = '';
+    }
+
+    // Get students in conjunction with groupmode.
+    if ($groupmode > 0) {
+        if ($mygroupid > 0) {
+            $usedgroupid = $mygroupid;
+        } else {
+            $usedgroupid = false;
+        }
+    } else {
+        $usedgroupid = false;
+    }
+    $nonrespondents = questionnaire_get_incomplete_users($cm, $sid, $usedgroupid);
+    $countnonrespondents = count($nonrespondents);
+
+    $table->initialbars(false);
+
+    if ($showall) {
+        $startpage = false;
+        $pagecount = false;
+    } else {
+        $table->pagesize($perpage, $countnonrespondents);
+        $startpage = $table->get_page_start();
+        $pagecount = $table->get_page_size();
+    }
+}
+
+$nonrespondents = questionnaire_get_incomplete_users($cm, $sid, $usedgroupid, $sort, $startpage, $pagecount);
+
+// Viewreports-start.
+// Print the list of students.
+
+$questionnaire->page->add_to_page('formarea', (isset($groupselect) ? $groupselect : ''));
+$questionnaire->page->add_to_page('formarea', html_writer::tag('div', '', ['class' => 'clearer']));
+$questionnaire->page->add_to_page('formarea', $questionnaire->renderer->box_start('left-align'));
+
+$countries = get_string_manager()->get_list_of_countries();
+
+$strnever = get_string('never');
+
+$datestring = new stdClass();
+$datestring->year  = get_string('year');
+$datestring->years = get_string('years');
+$datestring->day   = get_string('day');
+$datestring->days  = get_string('days');
+$datestring->hour  = get_string('hour');
+$datestring->hours = get_string('hours');
+$datestring->min   = get_string('min');
+$datestring->mins  = get_string('mins');
+$datestring->sec   = get_string('sec');
+$datestring->secs  = get_string('secs');
+
+if (!$nonrespondents) {
+    $questionnaire->page->add_to_page('formarea',
+        $questionnaire->renderer->notification(get_string('noexistingparticipants', 'enrol')));
+} else {
+    $questionnaire->page->add_to_page('formarea', get_string('non_respondents', 'questionnaire'));
+    $questionnaire->page->add_to_page('formarea', ' ('.$countnonrespondents.')');
+    if (!$fullname) {
+        $questionnaire->page->add_to_page('formarea', ' ['.get_string('anonymous', 'questionnaire').']');
+    }
+    $questionnaire->page->add_to_page('formarea', html_writer::start_tag('form',
+        ['class' => 'mform', 'action' => 'show_nonrespondents.php', 'method' => 'post', 'id' => 'questionnaire_sendmessageform']));
+
+    $buffering = false;
+    if ($fullname) {
+        // Since flexible tables only writes out directly, we need to start buffering in case anything gets written...
+        ob_start();
+        $buffering = true;
+        foreach ($nonrespondents as $nonrespondent) {
+            $user = $DB->get_record('user', array('id' => $nonrespondent));
+            // Userpicture and link to the profilepage.
+            $profileurl = $CFG->wwwroot.'/user/view.php?id='.$user->id.'&amp;course='.$course->id;
+            $profilelink = '<strong><a href="'.$profileurl.'">'.fullname($user).'</a></strong>';
+            $data = array ($questionnaire->renderer->user_picture($user, array('courseid' => $course->id)), $profilelink);
+            if (in_array('email', $tablecolumns)) {
+                $data[] = $user->email;
+            }
+            if (!isset($hiddenfields['city'])) {
+                $data[] = $user->city;
+            }
+            if (!isset($hiddenfields['country'])) {
+                $data[] = (!empty($user->country)) ? $countries[$user->country] : '';
+            }
+            if ($user->lastaccess) {
+                $lastaccess = format_time(time() - $user->lastaccess, $datestring);
+            } else {
+                $lastaccess = get_string('never');
+            }
+            $data[] = $lastaccess;
+            if (has_capability('mod/questionnaire:message', $context)) {
+                // If questionnaire is set to "resume", look for saved (not completed) responses
+                // we use the alt attribute of the checkboxes to store the started/not started value!
+                $checkboxaltvalue = '';
+                if ($resume) {
+                    if ($DB->record_exists('questionnaire_response', ['survey_id' => $sid,
+                            'userid' => $nonrespondent, 'complete' => 'n']) ) {
+                        $data[] = get_string('started', 'questionnaire');
+                        $checkboxaltvalue = 1;
+                    } else {
+                        $data[] = get_string('not_started', 'questionnaire');
+                        $checkboxaltvalue = 0;
+                    }
+                }
+                $data[] = '<input type="checkbox" class="usercheckbox" name="messageuser[]" value="'.
+                    $user->id.'" alt="'.$checkboxaltvalue.'" />';
+            }
+            $table->add_data($data);
+
+        }
+
+        if (isset($table)) {
+            $questionnaire->page->add_to_page('formarea', $questionnaire->renderer->flexible_table($table, $buffering));
+        } else if ($buffering) {
+            ob_end_clean();
+        }
+        $allurl = new moodle_url($baseurl);
+        if ($showall) {
+            $allurl->param('showall', 0);
+            $questionnaire->page->add_to_page('formarea',
+                $questionnaire->renderer->container(html_writer::link($allurl,
+                    get_string('showperpage', '', QUESTIONNAIRE_DEFAULT_PAGE_COUNT)), array(), 'showall'));
+
+        } else if ($countnonrespondents > 0 && $perpage < $countnonrespondents) {
+            $allurl->param('showall', 1);
+            $questionnaire->page->add_to_page('formarea', $questionnaire->renderer->container(html_writer::link($allurl,
+                get_string('showall', '', $countnonrespondents)), array(), 'showall'));
+        }
+        if (has_capability('mod/questionnaire:message', $context)) {
+            $questionnaire->page->add_to_page('formarea',
+                $questionnaire->renderer->box_start('mdl-align')); // Selection buttons container.
+            $questionnaire->page->add_to_page('formarea', '<div class="buttons">');
+            $questionnaire->page->add_to_page('formarea',
+                '<input type="button" id="checkall" value="'.get_string('selectall').'" /> ');
+            $questionnaire->page->add_to_page('formarea',
+                '<input type="button" id="checknone" value="'.get_string('deselectall').'" /> ');
+            if ($resume) {
+                if ($perpage >= $countnonrespondents) {
+                    $questionnaire->page->add_to_page('formarea',
+                        '<input type="button" id="checkstarted" value="'.get_string('checkstarted', 'questionnaire').'" />'."\n");
+                    $questionnaire->page->add_to_page('formarea', '<input type="button" id="checknotstarted" value="'.
+                        get_string('checknotstarted', 'questionnaire').'" />'."\n");
+                }
+            }
+            $questionnaire->page->add_to_page('formarea', '</div>');
+            $questionnaire->page->add_to_page('formarea', $questionnaire->renderer->box_end());
+            if ($action == 'sendmessage' && !is_array($messageuser)) {
+                $questionnaire->page->add_to_page('formarea',
+                    $questionnaire->renderer->notification(get_string('nousersselected', 'questionnaire')));
+            }
+        }
+    } else {// Anonymous questionnaire.
+        if (has_capability('mod/questionnaire:message', $context)) {
+            $questionnaire->page->add_to_page('formarea', '<fieldset>');
+            $questionnaire->page->add_to_page('formarea', '<legend>'.get_string('send_message_to', 'questionnaire').'</legend>');
+            $checked = ($selectedanonymous == '' || $selectedanonymous == 'none') ? 'checked = "checked"' : '';
+            $questionnaire->page->add_to_page('formarea',
+                '&nbsp;&nbsp;<input type="radio" name="selectedanonymous" value="none" id="none" '.$checked.' />
+                <label for="none">'.get_string('none').'</label>');
+            $checked = ($selectedanonymous == 'all') ? 'checked = "checked"' : '';
+            $questionnaire->page->add_to_page('formarea',
+                '<input type="radio" name="selectedanonymous" value="all" id="nonrespondents" '.$checked.' />
+                <label for="all">'.get_string('all', 'questionnaire').'</label>');
+            if ($resume) {
+                if ($countstarted > 0) {
+                        $checked = ($selectedanonymous == 'started') ? 'checked = "checked"' : '';
+                        $questionnaire->page->add_to_page('formarea',
+                            '<input type="radio" name="selectedanonymous" value="started" id="started" '.$checked.' />
+                            <label for="started">'.get_string('status').': '.
+                            get_string('started', 'questionnaire').' ('.$countstarted.')</label>');
+                }
+                if ($countnotstarted > 0) {
+                    if ($selectedanonymous == 'notstarted') {
+                        $checked = 'checked = "checked"';
+                    } else {
+                        $checked = '';
+                    }
+                    $checked = ($selectedanonymous == 'notstarted') ? 'checked = "checked"' : '';
+                    $questionnaire->page->add_to_page('formarea',
+                        '<input type="radio" name="selectedanonymous" value="notstarted" id="notstarted" '.$checked.' />
+                        <label for="notstarted">'.get_string('status').': '.
+                        get_string('not_started', 'questionnaire').' ('.$countnotstarted.')</label>');
+                }
+            }
+            if ($action == 'sendmessage' && $selectedanonymous == 'none') {
+                $questionnaire->page->add_to_page('formarea',
+                    $questionnaire->renderer->notification(get_string('nousersselected', 'questionnaire')));
+            }
+            $questionnaire->page->add_to_page('formarea', '</fieldset>');
+        }
+    }
+    if (has_capability('mod/questionnaire:message', $context)) {
+        // Message editor.
+        // Prepare data.
+        $questionnaire->page->add_to_page('formarea', '<fieldset class="clearfix">');
+        if ($action == 'sendmessage' && (empty($subject) || empty($message))) {
+            $questionnaire->page->add_to_page('formarea', $questionnaire->renderer->notification(get_string('allfieldsrequired')));
+        }
+        $questionnaire->page->add_to_page('formarea',
+            '<legend class="ftoggler">'.get_string('send_message', 'questionnaire').'</legend>');
+        $id = 'message' . '_id';
+        $subjecteditor = '&nbsp;&nbsp;&nbsp;<input type="text" id="questionnaire_subject" size="65"
+            maxlength="255" name="subject" value="'.$subject.'" />';
+        $format = '';
+            $editor = editors_get_preferred_editor();
+            $editor->use_editor($id, questionnaire_get_editor_options($context));
+            $texteditor = html_writer::tag('div', html_writer::tag('textarea', $message,
+                    array('id' => $id, 'name' => "message", 'rows' => '10', 'cols' => '60')));
+            $questionnaire->page->add_to_page('formarea', '<input type="hidden" name="format" value="'.FORMAT_HTML.'" />');
+
+
+        // Print editor.
+        $table = new html_table();
+        $table->align = array('left', 'left');
+        $table->data[] = array( '<strong>'.get_string('subject', 'questionnaire').'</strong>', $subjecteditor);
+        $table->data[] = array('<strong>'.get_string('messagebody').'</strong>', $texteditor);
+
+        $questionnaire->page->add_to_page('formarea', html_writer::table($table));
+
+        // Send button.
+        $questionnaire->page->add_to_page('formarea', $questionnaire->renderer->box_start('mdl-left'));
+        $questionnaire->page->add_to_page('formarea', '<div class="buttons">');
+        $questionnaire->page->add_to_page('formarea',
+            '<input type="submit" name="send_message" value="'.get_string('send', 'questionnaire').'" />');
+        $questionnaire->page->add_to_page('formarea', '</div>');
+        $questionnaire->page->add_to_page('formarea', $questionnaire->renderer->box_end());
+
+        $questionnaire->page->add_to_page('formarea', '<input type="hidden" name="sesskey" value="'.sesskey().'" />');
+        $questionnaire->page->add_to_page('formarea', '<input type="hidden" name="action" value="sendmessage" />');
+        $questionnaire->page->add_to_page('formarea', '<input type="hidden" name="id" value="'.$cm->id.'" />');
+
+        $questionnaire->page->add_to_page('formarea', '</fieldset>');
+
+        $questionnaire->page->add_to_page('formarea', html_writer::end_tag('form'));
+
+        // Include the needed js.
+        $module = array('name' => 'mod_questionnaire', 'fullpath' => '/mod/questionnaire/module.js');
+        $PAGE->requires->js_init_call('M.mod_questionnaire.init_sendmessage', null, false, $module);
+    }
+}
+$questionnaire->page->add_to_page('formarea', $questionnaire->renderer->box_end());
+
+// Finish the page.
+echo $questionnaire->renderer->render($questionnaire->page);
+echo $questionnaire->renderer->footer();
+
+// Log this questionnaire show non-respondents action.
+$context = context_module::instance($questionnaire->cm->id);
+$anonymous = $questionnaire->respondenttype == 'anonymous';
+
+$event = \mod_questionnaire\event\non_respondents_viewed::create(array(
+                'objectid' => $questionnaire->id,
+                'anonymous' => $anonymous,
+                'context' => $context
+));
+$event->trigger();
diff --git a/mod/questionnaire/styles.css b/mod/questionnaire/styles.css
new file mode 100644
index 0000000..5b3735b
--- /dev/null
+++ b/mod/questionnaire/styles.css
@@ -0,0 +1,352 @@
+/** Question editing **/
+
+/* !important is needed in moodle 2.6 to override the display block when window width is reduced. */
+#page-mod-questionnaire-questions .qcontainer .fitemtitle,
+#page-mod-questionnaire-questions #id_questionhdr .fitemtitle {
+    display: none !important;
+}
+
+#page-mod-questionnaire-questions .qcontainer .qnums {
+    font-weight: bold;
+    float: left;
+    color: gray;
+}
+
+#page-mod-questionnaire-questions .qcontainer .fstatic {
+    width: 97%;
+    margin-right: 1em;
+    margin-left: 5px;
+    /* Set a negative margin-bottom to save some vertical space! */
+    margin-bottom: -10px;
+}
+
+#page-mod-questionnaire-questions .mform .fitem fieldset.felement {
+    margin-left: 0%;
+    padding-left: 1%;
+    margin-bottom: 0px !important;
+}
+
+#page-mod-questionnaire-preview fieldset,
+#page-mod-questionnaire-complete fieldset {
+    margin-bottom: 0px !important;
+}
+
+#page-mod-questionnaire-questions .mform .fitem .fitemtitle {
+    text-align: left;
+    margin-left: 10px;
+    margin-bottom: 0px !important;
+}
+
+#page-mod-questionnaire-questions .moving {
+    border: medium dotted maroon;
+}
+
+div.qoptcontainer div.ftextarea {
+    clear: all;
+    float: none;
+    width: 600px;
+    margin: 0px auto 10px;
+}
+
+div.qoptcontainer div.ftextarea textarea.qopts {
+    width: 600px;
+    height: 10em;
+    margin-left: 1px;
+}
+
+.response span.selected,
+.generalboxcontent span.selected {
+    font-weight: bold;
+}
+
+td.selected {
+    background-color: #e4f1fa;
+    border: 1px solid gray;
+}
+
+#page-mod-questionnaire-myreport div.respdate {
+    font-size: 0.8em;
+    font-weight: bold;
+    margin-bottom: 6px;
+    padding-top: 6px;
+    border-bottom: 1px dashed gray;
+}
+
+#page-mod-questionnaire-complete .message,
+#page-mod-questionnaire-complete .notifyproblem,
+#page-mod-questionnaire-preview .message,
+#page-mod-questionnaire-preview .notifyproblem,
+#page-mod-questionnaire-complete .thankbody,
+#page-mod-questionnaire-complete .thankhead {
+    background-color: #FFFFFF;
+    border-style: solid;
+    border-width: 2px;
+    margin-bottom: 10px;
+    padding: 5px;
+}
+
+#page-mod-questionnaire-complete .notifyproblem,
+#page-mod-questionnaire-preview .notifyproblem {
+    border-color: red;
+}
+
+#page-mod-questionnaire-fbsections .notifyproblem {
+    text-align: left;
+    padding: 0px;
+}
+
+#page-mod-questionnaire-complete .message,
+#page-mod-questionnaire-preview .message,
+#page-mod-questionnaire-complete .thankbody,
+#page-mod-questionnaire-complete .thankhead {
+    border-color: blue;
+}
+
+#page-mod-questionnaire-complete .surveyTitle,
+#page-mod-questionnaire-complete .surveySubtitle,
+#page-mod-questionnaire-complete .addInfo {
+    clear: both;
+    margin: 0px;
+    margin-bottom: 4px;
+    padding: 10px;
+}
+
+.surveyPage {
+    background-color: #eee;
+    border-bottom-color: #000000;
+    border-bottom-style: solid;
+    border-bottom-width: 1px;
+    clear: right;
+    padding: 3px;
+    margin-bottom: 5px;
+    margin-top: 0px;
+}
+
+/* alternate columns formatting */
+
+#page-mod-questionnaire-complete .c0,
+#page-mod-questionnaire-preview .c0,
+#page-mod-questionnaire-print .c0,
+#page-mod-questionnaire-report .individual .c0,
+#page-mod-questionnaire-myreport .individual .c0 {
+    background-color: #fafafa;
+    border: 1px solid silver;
+    padding-left: 5px;
+    padding-right: 5px;
+}
+
+#page-mod-questionnaire-complete .raterow:hover,
+#page-mod-questionnaire-preview .raterow:hover {
+    background-color: #e4f1fa;
+}
+
+#page-mod-questionnaire-complete td.raterow:hover,
+#page-mod-questionnaire-preview td.raterow:hover {
+    border: 1px solid navy;
+}
+
+#page-mod-questionnaire-complete td.notanswered,
+#page-mod-questionnaire-preview td.notanswered {
+    /* border: none; */
+    background-color: #fafafa;;
+}
+
+#page-mod-questionnaire-complete td.notcompleted,
+#page-mod-questionnaire-preview td.notcompleted {
+    border: 2px solid red;
+    background-color: #fafafa;
+}
+
+#page-mod-questionnaire-complete .c1,
+#page-mod-questionnaire-preview .c1,
+#page-mod-questionnaire-print .c1,
+#page-mod-questionnaire-report .individual .c1,
+#page-mod-questionnaire-myreport .individual .c1 {
+    background-color: #eee;
+    border: 1px solid silver;
+    padding-left: 5px;
+    padding-right: 5px;
+}
+
+#page-mod-questionnaire-myreport .individualresp,
+#page-mod-questionnaire-preview .individualresp,
+#page-mod-questionnaire-print .individualresp {
+    border: #c0c0c0 1px solid;
+    padding-left: 5px;
+    padding-right: 5px;
+    padding-top: 5px;
+    padding-bottom: 0px;
+    margin-bottom: 10px;
+    margin-top: 10px;
+}
+
+#page-mod-questionnaire-complete .notice .buttons div,
+#page-mod-questionnaire-complete .notice .buttons form {
+    display: inline;
+}
+
+.floatprinticon {
+    margin-top: -30px;
+    float: right;
+}
+
+.qn-legend {
+    float: left;
+    font-size: inherit;
+    width: auto;
+}
+
+/* format paragraph top and bottom margins for better vertical positioning in questions text */
+.qn-question p {
+    margin-bottom: 0.6em;
+    margin-top: 0.5em;
+}
+
+.qn-question {
+    padding-left: 5px;
+    padding-right: 5px;
+    padding-bottom: 0.1em;
+    padding-top: 0.1em;
+    /* make background same color as quiz question text */
+    background-color: #e4f1fa;
+}
+
+#page-mod-questionnaire-questions .qn-question {
+    margin-left: 40px;
+}
+
+.unselected {
+    color: gray;
+}
+
+/*respondents list feature*/
+
+#respondentscolumn {
+    float: left;
+    margin-left: 20px;
+}
+.respondentsnavbar {
+    text-align: center;
+    padding-bottom: 5px;
+    padding-top: 5px;
+    margin-bottom: 5px;
+    background-color: #F2F2F2;
+}
+
+/* new quiz-like formatting for 2.5 */
+
+#page-mod-questionnaire-questions .qn-container {
+    border: 1px dotted gray;
+    margin-bottom: 1em;
+}
+
+.dir-rtl .qn-container {
+    text-align: right;
+}
+.qn-info {
+    float: left;
+    width: auto;
+    padding: 7px;
+    background: #eee;
+    font-weight: bold;
+}
+
+.qn-info h2.qn-number {
+    margin: 0px;
+    font-size: 1.5em;
+    line-height: 1.2em;
+}
+
+.qn-question,
+.qn-answer {
+    margin: 0 0 0.5em;
+    overflow: auto;
+}
+
+#notice .qn-question {
+    margin: 0;
+}
+
+.req {
+    font-size: x-small;
+}
+
+.qdepend {
+    color: red;
+    padding-left: 5px;
+    margin-bottom: 5px;
+}
+
+.qn-content {
+    margin-bottom: 10px;
+    margin-left: 55px;
+}
+
+/* move horizontal radio buttons closer to their labels */
+.qn-answer input[type="radio"],
+.qn-answer input[type="checkbox"] {
+    margin-right: 3px;
+}
+
+#page-mod-questionnaire-show_nonrespondents input[type="radio"] {
+    margin-right: 1px;
+}
+
+.qn-answer label,
+#page-mod-questionnaire-show_nonrespondents label {
+    margin-right: 0.6em;
+}
+
+.hidedependquestion {
+    color: red;
+    display: none;
+}
+.qn-container {
+    color: black;
+    display: inherit;
+    margin-left: 10px;
+}
+
+#page-mod-questionnaire-fbsections .c0,
+#page-mod-questionnaire-fbsections .c1 {
+    border: 1px solid silver;
+    padding-left: 4px;
+    padding-right: 4px;
+}
+
+#page-mod-questionnaire-fbsections .c0 {
+    background-color: #fafafa;
+}
+
+#page-mod-questionnaire-fbsections .c1 {
+    background-color: #eee;
+}
+
+#page-mod-questionnaire-fbsections input[type="radio"] {
+    margin-right: 0px;
+}
+
+#page-mod-questionnaire-fbsections .qn-legend {
+    padding-left: 8px;
+}
+
+#page-mod-questionnaire-fbsections .qcontainer.qcontent {
+    margin-bottom: -5em;
+}
+#page-mod-questionnaire-report div.chart {
+    overflow: auto;
+    margin-left: -40px;
+}
+
+#page-mod-questionnaire-report .generaltable.questionnairereport td {
+    border: 1px solid silver;
+}
+
+.qn-container .smalltext {
+    font-size: 0.75em;
+}
+
+/* !important is needed in moodle 2.6 to override the display block when window width is reduced. */
+#page-mod-questionnaire-questions #region-main .mform .fitem .felement {
+    margin-bottom: 0px;
+}
\ No newline at end of file
diff --git a/mod/questionnaire/tabs.php b/mod/questionnaire/tabs.php
new file mode 100644
index 0000000..e029eb9
--- /dev/null
+++ b/mod/questionnaire/tabs.php
@@ -0,0 +1,246 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * prints the tabbed bar
+ *
+ * @package mod_questionnaire
+ * @copyright  2016 Mike Churchward (mike.churchward@poetgroup.org)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+global $DB, $SESSION;
+$tabs = array();
+$row  = array();
+$inactive = array();
+$activated = array();
+if (!isset($SESSION->questionnaire)) {
+    $SESSION->questionnaire = new stdClass();
+}
+$currenttab = $SESSION->questionnaire->current_tab;
+
+// In a questionnaire instance created "using" a PUBLIC questionnaire, prevent anyone from editing settings, editing questions,
+// viewing all responses...except in the course where that PUBLIC questionnaire was originally created.
+
+$owner = !empty($questionnaire->sid) && ($questionnaire->survey->courseid == $questionnaire->course->id);
+if ($questionnaire->capabilities->manage  && $owner) {
+    $row[] = new tabobject('settings', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/qsettings.php?'.
+            'id='.$questionnaire->cm->id), get_string('advancedsettings'));
+}
+
+if ($questionnaire->capabilities->editquestions && $owner) {
+    $row[] = new tabobject('questions', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/questions.php?'.
+            'id='.$questionnaire->cm->id), get_string('questions', 'questionnaire'));
+}
+
+if ($questionnaire->capabilities->preview && $owner) {
+    if (!empty($questionnaire->questions)) {
+        $row[] = new tabobject('preview', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/preview.php?'.
+                        'id='.$questionnaire->cm->id), get_string('preview_label', 'questionnaire'));
+    }
+}
+
+$usernumresp = $questionnaire->count_submissions($USER->id);
+
+if ($questionnaire->capabilities->readownresponses && ($usernumresp > 0)) {
+    $argstr = 'instance='.$questionnaire->id.'&user='.$USER->id.'&group='.$currentgroupid;
+    if ($usernumresp == 1) {
+        $argstr .= '&byresponse=1&action=vresp';
+        $yourrespstring = get_string('yourresponse', 'questionnaire');
+    } else {
+        $yourrespstring = get_string('yourresponses', 'questionnaire');
+    }
+    $row[] = new tabobject('myreport', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/myreport.php?'.
+                           $argstr), $yourrespstring);
+
+    if ($usernumresp > 1 && in_array($currenttab, array('mysummary', 'mybyresponse', 'myvall', 'mydownloadcsv'))) {
+        $inactive[] = 'myreport';
+        $activated[] = 'myreport';
+        $row2 = array();
+        $argstr2 = $argstr.'&action=summary';
+        $row2[] = new tabobject('mysummary', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/myreport.php?'.$argstr2),
+                                get_string('summary', 'questionnaire'));
+        $argstr2 = $argstr.'&byresponse=1&action=vresp';
+        $row2[] = new tabobject('mybyresponse', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/myreport.php?'.$argstr2),
+                                get_string('viewindividualresponse', 'questionnaire'));
+        $argstr2 = $argstr.'&byresponse=0&action=vall&group='.$currentgroupid;
+        $row2[] = new tabobject('myvall', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/myreport.php?'.$argstr2),
+                                get_string('myresponses', 'questionnaire'));
+        if ($questionnaire->capabilities->downloadresponses) {
+            $argstr2 = $argstr.'&action=dwnpg';
+            $link  = $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2);
+            $row2[] = new tabobject('mydownloadcsv', $link, get_string('downloadtext'));
+        }
+    } else if (in_array($currenttab, array('mybyresponse', 'mysummary'))) {
+        $inactive[] = 'myreport';
+        $activated[] = 'myreport';
+    }
+}
+
+$numresp = $questionnaire->count_submissions();
+// Number of responses in currently selected group (or all participants etc.).
+if (isset($SESSION->questionnaire->numselectedresps)) {
+    $numselectedresps = $SESSION->questionnaire->numselectedresps;
+} else {
+    $numselectedresps = $numresp;
+}
+
+// If questionnaire is set to separate groups, prevent user who is not member of any group
+// to view All responses.
+$canviewgroups = true;
+$groupmode = groups_get_activity_groupmode($cm, $course);
+if ($groupmode == 1) {
+    $canviewgroups = groups_has_membership($cm, $USER->id);
+}
+$canviewallgroups = has_capability('moodle/site:accessallgroups', $context);
+
+if (($canviewallgroups || ($canviewgroups && $questionnaire->capabilities->readallresponseanytime))
+                && $numresp > 0 && $owner && $numselectedresps > 0) {
+    $argstr = 'instance='.$questionnaire->id;
+    $row[] = new tabobject('allreport', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.
+                           $argstr.'&action=vall'), get_string('viewallresponses', 'questionnaire'));
+    if (in_array($currenttab, array('vall', 'vresp', 'valldefault', 'vallasort', 'vallarsort', 'deleteall', 'downloadcsv',
+                                     'vrespsummary', 'individualresp', 'printresp', 'deleteresp'))) {
+        $inactive[] = 'allreport';
+        $activated[] = 'allreport';
+        if ($currenttab == 'vrespsummary' || $currenttab == 'valldefault') {
+            $inactive[] = 'vresp';
+        }
+        $row2 = array();
+        $argstr2 = $argstr.'&action=vall&group='.$currentgroupid;
+        $row2[] = new tabobject('vall', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                get_string('summary', 'questionnaire'));
+        if ($questionnaire->capabilities->viewsingleresponse) {
+            $argstr2 = $argstr.'&byresponse=1&action=vresp&group='.$currentgroupid;
+            $row2[] = new tabobject('vrespsummary', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                get_string('viewbyresponse', 'questionnaire'));
+            if ($currenttab == 'individualresp' || $currenttab == 'deleteresp') {
+                $argstr2 = $argstr.'&byresponse=1&action=vresp';
+                $row2[] = new tabobject('vresp', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                        get_string('viewindividualresponse', 'questionnaire'));
+            }
+        }
+    }
+    if (in_array($currenttab, array('valldefault',  'vallasort', 'vallarsort', 'deleteall', 'downloadcsv'))) {
+        $activated[] = 'vall';
+        $row3 = array();
+
+        $argstr2 = $argstr.'&action=vall&group='.$currentgroupid;
+        $row3[] = new tabobject('valldefault', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                get_string('order_default', 'questionnaire'));
+        if ($currenttab != 'downloadcsv' && $currenttab != 'deleteall') {
+            $argstr2 = $argstr.'&action=vallasort&group='.$currentgroupid;
+            $row3[] = new tabobject('vallasort', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                    get_string('order_ascending', 'questionnaire'));
+            $argstr2 = $argstr.'&action=vallarsort&group='.$currentgroupid;
+            $row3[] = new tabobject('vallarsort', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                    get_string('order_descending', 'questionnaire'));
+        }
+        if ($questionnaire->capabilities->deleteresponses) {
+            $argstr2 = $argstr.'&action=delallresp&group='.$currentgroupid;
+            $row3[] = new tabobject('deleteall', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                    get_string('deleteallresponses', 'questionnaire'));
+        }
+
+        if ($questionnaire->capabilities->downloadresponses) {
+            $argstr2 = $argstr.'&action=dwnpg&group='.$currentgroupid;
+            $link  = $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2);
+            $row3[] = new tabobject('downloadcsv', $link, get_string('downloadtext'));
+        }
+    }
+
+    if (in_array($currenttab, array('individualresp', 'deleteresp'))) {
+        $inactive[] = 'vresp';
+        if ($currenttab != 'deleteresp') {
+            $activated[] = 'vresp';
+        }
+        if ($questionnaire->capabilities->deleteresponses) {
+            $argstr2 = $argstr.'&action=dresp&rid='.$rid.'&individualresponse=1';
+            $row2[] = new tabobject('deleteresp', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                            get_string('deleteresp', 'questionnaire'));
+        }
+
+    }
+} else if ($canviewgroups && $questionnaire->capabilities->readallresponses && ($numresp > 0) && $canviewgroups &&
+           // If resp_view is set to QUESTIONNAIRE_STUDENTVIEWRESPONSES_NEVER, then this will always be false.
+           ($questionnaire->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_ALWAYS ||
+            ($questionnaire->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENCLOSED
+                && $questionnaire->is_closed()) ||
+            ($questionnaire->resp_view == QUESTIONNAIRE_STUDENTVIEWRESPONSES_WHENANSWERED
+                && $usernumresp > 0 )) &&
+           $questionnaire->is_survey_owner()) {
+    $argstr = 'instance='.$questionnaire->id.'&sid='.$questionnaire->sid;
+    $row[] = new tabobject('allreport', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.
+                           $argstr.'&action=vall&group='.$currentgroupid), get_string('viewallresponses', 'questionnaire'));
+    if (in_array($currenttab, array('valldefault',  'vallasort', 'vallarsort', 'deleteall', 'downloadcsv'))) {
+        $inactive[] = 'vall';
+        $activated[] = 'vall';
+        $row2 = array();
+        $argstr2 = $argstr.'&action=vall&group='.$currentgroupid;
+        $row2[] = new tabobject('valldefault', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                get_string('summary', 'questionnaire'));
+        $inactive[] = $currenttab;
+        $activated[] = $currenttab;
+        $row3 = array();
+        $argstr2 = $argstr.'&action=vall&group='.$currentgroupid;
+        $row3[] = new tabobject('valldefault', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                get_string('order_default', 'questionnaire'));
+        $argstr2 = $argstr.'&action=vallasort&group='.$currentgroupid;
+        $row3[] = new tabobject('vallasort', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                get_string('order_ascending', 'questionnaire'));
+        $argstr2 = $argstr.'&action=vallarsort&group='.$currentgroupid;
+        $row3[] = new tabobject('vallarsort', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                get_string('order_descending', 'questionnaire'));
+        if ($questionnaire->capabilities->deleteresponses) {
+            $argstr2 = $argstr.'&action=delallresp';
+            $row2[] = new tabobject('deleteall', $CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2),
+                                    get_string('deleteallresponses', 'questionnaire'));
+        }
+
+        if ($questionnaire->capabilities->downloadresponses) {
+            $argstr2 = $argstr.'&action=dwnpg';
+            $link  = htmlspecialchars('/mod/questionnaire/report.php?'.$argstr2);
+            $row2[] = new tabobject('downloadcsv', $link, get_string('downloadtext'));
+        }
+        if (count($row2) <= 1) {
+            $currenttab = 'allreport';
+        }
+    }
+}
+
+if ($questionnaire->capabilities->viewsingleresponse && ($canviewallgroups || $canviewgroups)) {
+    $nonrespondenturl = new moodle_url('/mod/questionnaire/show_nonrespondents.php', array('id' => $questionnaire->cm->id));
+    $row[] = new tabobject('nonrespondents',
+                    $nonrespondenturl->out(),
+                    get_string('show_nonrespondents', 'questionnaire'));
+}
+
+if ((count($row) > 1) || (!empty($row2) && (count($row2) > 1))) {
+    $tabs[] = $row;
+
+    if (!empty($row2) && (count($row2) > 1)) {
+        $tabs[] = $row2;
+    }
+
+    if (!empty($row3) && (count($row3) > 1)) {
+        $tabs[] = $row3;
+    }
+
+    $questionnaire->page->add_to_page('tabsarea', print_tabs($tabs, $currenttab, $inactive, $activated, true));
+}
\ No newline at end of file
diff --git a/mod/questionnaire/templates/completepage.mustache b/mod/questionnaire/templates/completepage.mustache
new file mode 100644
index 0000000..1d350d8
--- /dev/null
+++ b/mod/questionnaire/templates/completepage.mustache
@@ -0,0 +1,76 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/completepage
+
+    Template which defines a questionnaire completion page.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template: (Note sections have been used to allow non-inclusion)
+    * notifications - string: HTML of any notifications loaded.
+    * respondentinfo - string: HTML of any specific response/respondent information.
+    * title - string: Text title of the questionnaire.
+    * printblank - string: HTML of optional print blank questionnaire control.
+    * subtitle - string: Optional text subtitle.
+    * addinfo - string: Optional HTML additional information.
+    * message - string: Any message HTML text.
+    * formstart - string: Form start HTML.
+    * questions - array: Array of questions HTML.
+    * pageinfo - string: Page navigation HTML if present.
+    * controlbuttons - string: Questionnaire response management control HTML.
+    * formend - string: Form end HTML.
+
+    Example context (json):
+    {
+        "notifications": "<div>Notification one</div>",
+        "respondentinfo": "<div>This is respondent information</div>",
+        "title": "Test Questionnaire",
+        "subtitle": "This is a subtitle",
+        "addinfo": "<div>This is additional information.</div>",
+        "message": "<div>This is a message.</div>",
+        "formstart": "<form id=\"formid\" method=\"post\" action=\"\">",
+        "questions": [
+            "<div>Question 1 HTML</div>",
+            "<div>Question 2 HTML</div>"
+        ],
+        "pageinfo": "<div>This is the page information.",
+        "controlbuttons": "<div>control button HTML</div>",
+        "formend": "</form>"
+    }
+    }}
+<div class="mod_questionnaire_completepage generalbox">
+    {{#notifications}}{{{.}}}{{/notifications}}
+    {{{respondentinfo}}}
+    {{#title}}<h3 class="surveyTitle">{{.}}</h3>{{/title}}{{{printblank}}}
+    {{#subtitle}}<h4 class="surveySubTitle">{{.}}</h4>{{/subtitle}}
+    {{#addinfo}}<div class="addInfo">{{{.}}}</div>{{/addinfo}}
+    {{#message}}<div class="message">{{{.}}}</div>{{/message}}
+    <div class="generalbox">
+        {{{formstart}}}
+        {{#questions}}{{{.}}}{{/questions}}
+        {{#pageinfo}}{{{.}}}{{/pageinfo}}
+        <div class="notice" style="padding: 0.5em 0 0.5em 0.2em;"><div class="buttons">
+            {{{controlbuttons}}}
+            {{{formend}}}
+        </div></div>
+    </div>
+</div>
\ No newline at end of file
diff --git a/mod/questionnaire/templates/fbsectionspage.mustache b/mod/questionnaire/templates/fbsectionspage.mustache
new file mode 100644
index 0000000..cdceac2
--- /dev/null
+++ b/mod/questionnaire/templates/fbsectionspage.mustache
@@ -0,0 +1,44 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/fbsectionspage
+
+    Template which defines a questionnaire completion page.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+    * tabsarea - string: HTML of the tabs management area.
+    * formarea - string: HTML of the management form.
+
+    Example context (json):
+    {
+        "tabsarea": "<div>HTML of the tabs area.",
+        "formarea": "<div>HTML of the form area"
+    }
+    }}
+<div class="mod_questionnaire_fbsectionspage generalbox">
+    {{{tabsarea}}}
+    <form id="fbsections" method="post">
+    {{{notifications}}}
+    {{{formarea}}}
+    </form>
+</div>
\ No newline at end of file
diff --git a/mod/questionnaire/templates/navbaralpha.mustache b/mod/questionnaire/templates/navbaralpha.mustache
new file mode 100644
index 0000000..509d497
--- /dev/null
+++ b/mod/questionnaire/templates/navbaralpha.mustache
@@ -0,0 +1,71 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/navbaralpha
+
+    Template which defines a questionnaire all responses navigation bar for the report page.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+    * firstrespondent - object: "url" and "title" strings for first respondent link.
+    * previous - object: "url" and "title" strings for previous link.
+    * respnumber - object: Current positio ("currpos") and "total" number of responses.
+    * next - object: "url" and "title" strings for next link.
+    * lastrespondent - object: "url" and "title" strings for last respondent link.
+    * listlink - string: Url of the link back to the response list.
+    * printaction - string: HTML to launch the print function.
+
+    Example context (json):
+    {
+        "firstrespondent": {
+            "url": "http://somelink.com",
+            "title": "Link title"
+        },
+        "previous": {
+            "url": "http://somelink.com",
+            "title": "Link title"
+        },
+        "respnumber": {
+            "currpos": 1,
+            "total": 22
+        },
+        "next": {
+            "url": "http://somelink.com",
+            "title": "Link title"
+        },
+        "lastrespondent": {
+            "url": "http://somelink.com",
+            "title": "Link title"
+        },
+        "listlink": "http://somelink.com",
+        "printaction": "<div>HTML of the printaction.</div>"
+    }
+    }}
+<div class="box respondentsnavbar">
+    {{#firstrespondent}}<b>&lt;&lt;</b> <a href="{{url}}" title="{{title}}">{{# str }}firstrespondent, mod_questionnaire{{/ str }}</a> |{{/firstrespondent}}
+    {{#previous}}<b>&lt;</b> <a href="{{url}}" title="{{title}}">{{# str }}previous, moodle{{/ str }}</a> | {{/previous}}
+    {{#respnumber}}<b>{{currpos}} / {{total}}</b>{{/respnumber}}
+    {{#next}} | <a href="{{url}}" title="{{title}}">{{# str}}next, moodle{{/ str }}</a> <b>&gt;</b>{{/next}}
+    {{#lastrespondent}} | <a href="{{url}}" title="{{title}}">{{# str }}lastrespondent, mod_questionnaire{{/ str }}</a> <b>&gt;&gt;</b>
+    {{/lastrespondent}}
+    <br /><b>&lt;&lt;&lt; <a href="{{listlink}}">{{# str }}viewbyresponse, mod_questionnaire{{/ str }}</a></b> | {{{printaction}}}
+</div>
\ No newline at end of file
diff --git a/mod/questionnaire/templates/navbaruser.mustache b/mod/questionnaire/templates/navbaruser.mustache
new file mode 100644
index 0000000..5e85d6d
--- /dev/null
+++ b/mod/questionnaire/templates/navbaruser.mustache
@@ -0,0 +1,64 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/navbaruser
+
+    Template which defines a questionnaire user responses navigation bar for the report page.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+    * previous - object: "url" and "title" strings for previous link.
+    * prevrespnumbers - object: Array of "url"'s, "title"'s and response text ("respnumber") for each previous response link.
+    * currrespnumber - string: The current response number text.
+    * nextrespnumbers - object: Array of "url"'s, "title"'s and response text ("respnumber") for each next response link.
+    * next - object: "url" and "title" strings for "next" link.
+
+    Example context (json):
+    {
+        "previous": {
+            "url": "http://somelink.com",
+            "title": "Link title"
+        },
+        "prevrespnumbers": {
+            "url": "http://somelink.com",
+            "title": "Link title",
+            "respnumber": "3"
+        },
+        "currrespnumber": "4",
+        "nextrespnumbers": {
+            "url": "http://somelink.com",
+            "title": "Link title",
+            "respnumber": "5"
+        },
+        "next": {
+            "url": "http://somelink.com",
+            "title": "Link title"
+        }
+    }
+    }}
+<div class="box respondentsnavbar">
+    {{#previous}}<a href="{{url}}" title="{{title}}">{{# str }}previous, moodle{{/ str }}</a> | {{/previous}}
+    {{#prevrespnumbers}}<a href="{{url}}" title="{{title}}">{{respnumber}}</a> | {{/prevrespnumbers}}
+    {{#currrespnumber}}<b>{{.}}</b>{{/currrespnumber}}
+    {{#nextrespnumbers}} | <a href="{{url}}" title="{{title}}">{{respnumber}}</a>{{/nextrespnumbers}}
+    {{#next}} | <a href="{{url}}" title="{{title}}">{{# str}}next, moodle{{/ str }}</a>{{/next}}
+</div>
\ No newline at end of file
diff --git a/mod/questionnaire/templates/nonrespondentspage.mustache b/mod/questionnaire/templates/nonrespondentspage.mustache
new file mode 100644
index 0000000..71ccc89
--- /dev/null
+++ b/mod/questionnaire/templates/nonrespondentspage.mustache
@@ -0,0 +1,41 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/nonrespondentspage
+
+    Template which defines a questionnaire completion page.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+    * tabsarea - string: HTML of the tabs management area.
+    * formarea - string: HTML of the management form.
+
+    Example context (json):
+    {
+        "tabsarea": "<div>HTML of the tabs area.",
+        "formarea": "<div>HTML of the form area"
+    }
+    }}
+<div class="mod_questionnaire_nonrespondentspage generalbox">
+    {{{tabsarea}}}
+    {{{formarea}}}
+</div>
\ No newline at end of file
diff --git a/mod/questionnaire/templates/previewpage.mustache b/mod/questionnaire/templates/previewpage.mustache
new file mode 100644
index 0000000..17e8429
--- /dev/null
+++ b/mod/questionnaire/templates/previewpage.mustache
@@ -0,0 +1,75 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/previewpage
+
+    Template which defines a questionnaire view page.
+
+    Classes required for JS:
+    * none
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+    * tabsarea - string: HTML of the tabs management area.
+    * heading - string: HTML of the page heading.
+    * formstart - string: Form start HTML.
+    * notifications - string: HTML of any notifications loaded.
+    * title - string: Text title of the questionnaire.
+    * printblank - string: HTML of optional print blank questionnaire control.
+    * subtitle - string: Optional text subtitle.
+    * addinfo - string: Optional HTML additional information.
+    * message - string: Any message HTML text.
+    * questions - array: Array of questions HTML.
+    * formend - string: Form end HTML.
+    * closebutton - string: Close button HTML.
+
+    Example context (json):
+    {
+        "tabsarea": "<div>HTML of the tabs area</div>",
+        "heading": "<div>HTML of the page heading</div>",
+        "formstart": "<form id=\"formid\" method=\"post\" action=\"\">",
+        "notifications": "<div>Notification one</div>",
+        "title": "<div>Test Questionnaire</div>",
+        "printblank": "<div>HTML of the print blank control.</div>",
+        "subtitle": "This is a subtitle",
+        "addinfo": "<div>This is additional information.</div>",
+        "message": "<div>This is a message.</div>",
+        "questions": [
+            "<div>Question 1 HTML</div>",
+            "<div>Question 2 HTML</div>"
+        ],
+        "formend": "</form>",
+        "closebutton": "<div>close button HTML</div>"
+    }
+    }}
+<div class="mod_questionnaire_previewpage">
+    {{{tabsarea}}}
+    <h2>{{{heading}}}</h2>
+    {{{formstart}}}
+    {{#notifications}}{{{.}}}{{/notifications}}
+    <div class="box generalbox">
+        <h3 class="surveyTitle">{{{title}}}</h3>{{{printblank}}}
+        {{#subtitle}}<h4 class="surveySubTitle">{{.}}</h4>{{/subtitle}}
+        {{#addinfo}}<div class="addInfo">{{{.}}}</div>{{/addinfo}}
+        {{#message}}{{{.}}}{{/message}}
+        {{#questions}}{{{.}}}{{/questions}}
+    </div>
+    {{{formend}}}
+</div>
+{{#closebutton}}{{{.}}}{{/closebutton}}
\ No newline at end of file
diff --git a/mod/questionnaire/templates/qsettingspage.mustache b/mod/questionnaire/templates/qsettingspage.mustache
new file mode 100644
index 0000000..85a3653
--- /dev/null
+++ b/mod/questionnaire/templates/qsettingspage.mustache
@@ -0,0 +1,41 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/qsettingspage
+
+    Template which defines a questionnaire completion page.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+    * tabsarea - string: HTML of the tabs management area.
+    * formarea - string: HTML of the management form.
+
+    Example context (json):
+    {
+        "tabsarea": "<div>HTML of the tabs area.",
+        "formarea": "<div>HTML of the form area"
+    }
+    }}
+<div class="mod_questionnaire_qsettingspage generalbox">
+    {{{tabsarea}}}
+    {{{formarea}}}
+</div>
\ No newline at end of file
diff --git a/mod/questionnaire/templates/question_check.mustache b/mod/questionnaire/templates/question_check.mustache
new file mode 100644
index 0000000..f3ee0e7
--- /dev/null
+++ b/mod/questionnaire/templates/question_check.mustache
@@ -0,0 +1,65 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/question_check
+
+    Template which defines a check type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "qelements": [
+            {
+                "choice": {
+                    "id": "choiceid1",
+                    "value": "1",
+                    "name": "choiceid1",
+                    "checked": "",
+                    "label": "<div>Choice question label</div>"
+                }
+            },
+            {
+                "choice": {
+                    "id": "choiceid7",
+                    "value": "7",
+                    "name": "choiceid7",
+                    "checked": "1",
+                    "label": "<div>Choice question label</div>",
+                    "oname": "Other",
+                    "ovalue": "another choice"
+                }
+            }
+        ]
+    }
+    }}
+<!-- Begin HTML generated from question_check template. -->
+{{#qelements}}
+{{#choice}}
+<input id="{{choice.id}}" value="{{choice.value}}" name="{{choice.name}}" type="checkbox" {{#choice.checked}}checked="checked"{{/choice.checked}} />
+<label for="{{choice.id}}">{{{choice.label}}}</label>
+{{#choice.oname}}<input size="25" name="{{choice.oname}}" onclick="other_check(name)" value="{{choice.ovalue}}" type="text" />{{/choice.oname}}
+<br />
+{{/choice}}
+{{/qelements}}
+<!-- End HTML generated from question_check template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/question_container.mustache b/mod/questionnaire/templates/question_container.mustache
new file mode 100644
index 0000000..0e31d9f
--- /dev/null
+++ b/mod/questionnaire/templates/question_container.mustache
@@ -0,0 +1,70 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/question_container
+
+    Template which defines a check type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "fieldset": {
+            "id": "7",
+            "class": "questionclass"
+        },
+        "qnum": "<div>7</div>",
+        "required": "<div>*</div>",
+        "skippedclass": "skippedclass",
+        "label": {
+            "for": "qn-7"
+        },
+        "qcontent": "<div>HTML for the question content</div>",
+        "qformelement": "<div>HTML for the question form element</div>",
+        "notifications": "<div>HTML for the notifications area</div>"
+    }
+    }}
+<!-- Begin fieldset generated from question_container template. -->
+<fieldset id="qn-{{fieldset.id}}" class="{{fieldset.class}}">
+    {{#qnum}}
+    <legend class="qn-legend">
+        <div class="qn-info">
+            <div class="accesshide">{{# str }}questionnum, mod_questionnaire{{/ str}}</div>
+            <h2 class="qn-number">{{{qnum}}}</h2>
+        </div>
+        {{{required}}}
+    </legend>
+    {{/qnum}}
+    <div class="qn-content">
+        <div class="qn-question {{skippedclass}}">
+            {{#label}}<label for="{{label.for}}">{{/label}}
+            {{{qcontent}}}
+            {{#label}}</label>{{/label}}
+        </div>
+        <div class="qn-answer">
+            {{{qformelement}}}
+        </div>
+    </div>
+</fieldset>
+{{#notifications}}{{{.}}}{{/notifications}}
+<!-- End fieldset generated from question_container template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/question_date.mustache b/mod/questionnaire/templates/question_date.mustache
new file mode 100644
index 0000000..627cc91
--- /dev/null
+++ b/mod/questionnaire/templates/question_date.mustache
@@ -0,0 +1,50 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/question_date
+
+    Template which defines a date type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "qelements": {
+            "choice": {
+                "onkeypress": "dosomething()",
+                "name": "choiceid1",
+                "value": "10/10/2010"
+            }
+        }
+    }
+    }}
+<!-- Begin HTML generated from question_date template. -->
+{{#qelements}}
+{{#choice}}
+<div class="qn-datemsg">{{# str }}dateformatting, mod_questionnaire{{/ str}}</div>
+<div class="qn-date">
+    <input {{#choice.onkeypress}}onkeypress="{{.}}"{{/choice.onkeypress}} type="text" size="12" name="{{choice.name}}" maxlength="10" value="{{choice.value}}" />
+</div>
+{{/choice}}
+{{/qelements}}
+<!-- End HTML generated from question_date template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/question_drop.mustache b/mod/questionnaire/templates/question_drop.mustache
new file mode 100644
index 0000000..38e8784
--- /dev/null
+++ b/mod/questionnaire/templates/question_drop.mustache
@@ -0,0 +1,66 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/question_drop
+
+    Template which defines a radio button type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "qelements": {
+            "choice": {
+                "id": "choiceid1",
+                "label": "<div>Choice question label</div>",
+                "name": "choiceid1",
+                "class": "classname",
+                "onchange": "dosomething()",
+                "options": [
+                    {
+                        "selected": 1,
+                        "value": "34",
+                        "label": "Option 1"
+                    },
+                    {
+                        "selected": 0,
+                        "value": "35",
+                        "label": "Option 2"
+                    }
+                ]
+            }
+        }
+    }
+    }}
+<!-- Begin HTML generated from question_drop template. -->
+{{#qelements}}
+{{#choice}}
+<label for="{{choice.id}}">{{{choice.label}}}</label>
+<select id="{{choice.id}}" name="{{choice.name}}" class="{{choice.class}}" {{#choice.onchange}}onchange="{{.}}"{{/choice.onchange}}>
+{{#choice.options}}
+<option {{#selected}}selected="selected" {{/selected}}value="{{value}}">{{label}}</option>
+{{/choice.options}}
+</select>
+{{/choice}}
+{{/qelements}}
+<!-- End HTML generated from question_drop template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/question_numeric.mustache b/mod/questionnaire/templates/question_numeric.mustache
new file mode 100644
index 0000000..c5056d6
--- /dev/null
+++ b/mod/questionnaire/templates/question_numeric.mustache
@@ -0,0 +1,50 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/question_numeric
+
+    Template which defines a numeric type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "qelements": {
+            "choice": {
+                "onkeypress": "dosomething()",
+                "size": 30,
+                "name": "choiceid1",
+                "maxlength": 50,
+                "value": "473",
+                "id": "choiceid1"
+            }
+        }
+    }
+    }}
+<!-- Begin HTML generated from question_numeric template. -->
+{{#qelements}}
+{{#choice}}
+<input {{#choice.onkeypress}}onkeypress="{{.}}"{{/choice.onkeypress}} type="text" size="{{choice.size}}" name="{{choice.name}}" {{#choice.maxlength}}maxlength="{{choice.maxlength}}"{{/choice.maxlength}} value="{{choice.value}}" id="{{choice.id}}" />
+{{/choice}}
+{{/qelements}}
+<!-- End HTML generated from question_numeric template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/question_radio.mustache b/mod/questionnaire/templates/question_radio.mustache
new file mode 100644
index 0000000..4e2b8a8
--- /dev/null
+++ b/mod/questionnaire/templates/question_radio.mustache
@@ -0,0 +1,76 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/question_radio
+
+    Template which defines a radio button type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "qelements": [
+            {
+                "choice": {
+                    "horizontal": 1,
+                    "id": "choiceid1",
+                    "value": "1",
+                    "name": "choiceid1",
+                    "checked": "",
+                    "disabled": 1,
+                    "onclick": 1,
+                    "label": "<div>Choice question label</div>"
+                }
+            },
+            {
+                "choice": {
+                    "horizontal": 1,
+                    "id": "choiceid2",
+                    "value": "2",
+                    "name": "choiceid2",
+                    "checked": "1",
+                    "onclick": 1,
+                    "label": "<div>Choice question label</div>",
+                    "oid": "choiceid2_7",
+                    "olabel": "<div>Choice question other label</div>",
+                    "oname": "Other",
+                    "ovalue": "another choice"
+                }
+            }
+        ]
+    }
+    }}
+<!-- Begin HTML generated from question_radio template. -->
+{{#qelements}}
+{{#choice}}
+{{#choice.horizontal}}<span style="white-space:nowrap;">{{/choice.horizontal}}
+<input id="{{choice.id}}" value="{{choice.value}}" name="{{choice.name}}" type="radio" {{#choice.checked}}checked="checked"{{/choice.checked}} {{#choice.disabled}}disabled="disabled"{{/choice.disabled}} {{#choice.onclick}}onclick="{{choice.onclick}}"{{/choice.onclick}}/>
+<label for="{{choice.id}}">{{{choice.label}}}</label>
+{{#choice.oname}}
+<input size="25" name="{{choice.oname}}" id="{{choice.oid}}" onclick="other_check(name)" value="{{choice.ovalue}}" type="text" /><label for="{{choice.oid}}" class="accesshide">{{{choice.olabel}}}</label>&nbsp;
+{{/choice.oname}}
+{{#choice.horizontal}}</span>{{/choice.horizontal}}
+{{^choice.horizontal}}<br />{{/choice.horizontal}}
+{{/choice}}
+{{/qelements}}
+<!-- End HTML generated from question_radio template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/question_rate.mustache b/mod/questionnaire/templates/question_rate.mustache
new file mode 100644
index 0000000..2ecf9e2
--- /dev/null
+++ b/mod/questionnaire/templates/question_rate.mustache
@@ -0,0 +1,150 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/question_rate
+
+    Template which defines a rate type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "qelements": [
+            {
+                "twidth": "100%",
+                "headerrow": {
+                    "col1width": "100%",
+                    "colnya": 1,
+                    "cols": [
+                        {
+                            "colwidth": "100%",
+                            "coltext": "<div>Header 1</div>"
+                        },
+                        {
+                            "colwidth": "100%",
+                            "coltext": "<div>Header 1</div>"
+                        }
+                    ]
+                },
+                "rows": [
+                    {
+                        "cols": [
+                            {
+                                "colstyle": "columnstyle",
+                                "colclass": "columnclass",
+                                "coltitle": "columntitle",
+                                "coltext": "<div>HTML of column text.</div>",
+                                "colhiddentext": "<div>HTML of column hidden text.",
+                                "colinput": {
+                                    "name": "input1",
+                                    "id": "id1",
+                                    "checked": 1,
+                                    "disabled": 0,
+                                    "onclick": "dosomething()",
+                                    "label": "<div>HTML of label</div>"
+                                }
+                            },
+                            {
+                                "colstyle": "columnstyle",
+                                "colclass": "columnclass",
+                                "coltitle": "columntitle",
+                                "coltext": "<div>HTML of column text.</div>",
+                                "colhiddentext": "<div>HTML of column hidden text.",
+                                "colinput": {
+                                    "name": "input2",
+                                    "id": "id2",
+                                    "checked": 1,
+                                    "disabled": 0,
+                                    "onclick": "dosomething()",
+                                    "label": "<div>HTML of label</div>"
+                                }
+                            }
+                        ]
+                    },
+                    {
+                        "cols": [
+                            {
+                                "colstyle": "columnstyle",
+                                "colclass": "columnclass",
+                                "coltitle": "columntitle",
+                                "coltext": "<div>HTML of column text.</div>",
+                                "colhiddentext": "<div>HTML of column hidden text.",
+                                "colinput": {
+                                    "name": "input3",
+                                    "id": "id3",
+                                    "checked": 1,
+                                    "disabled": 0,
+                                    "onclick": "dosomething()",
+                                    "label": "<div>HTML of label</div>"
+                                }
+                            },
+                            {
+                                "colstyle": "columnstyle",
+                                "colclass": "columnclass",
+                                "coltitle": "columntitle",
+                                "coltext": "<div>HTML of column text.</div>",
+                                "colhiddentext": "<div>HTML of column hidden text.",
+                                "colinput": {
+                                    "name": "input4",
+                                    "id": "id4",
+                                    "checked": 1,
+                                    "disabled": 0,
+                                    "onclick": "dosomething()",
+                                    "label": "<div>HTML of label</div>"
+                                }
+                            }
+                        ]
+                    }
+                ]
+            }
+        ]
+    }
+    }}
+<!-- Begin HTML generated from question_rate template. -->
+{{#qelements}}
+<table style="width:{{qelements.twidth}}">
+  <tbody>
+    {{#qelements.headerrow}}
+    <tr>
+      <td style="width:{{col1width}}"></td>
+      {{#colnya}}<td title="nya"></td>{{/colnya}}
+      {{#cols}}
+      <td style="width:{{colwidth}}; text-align:center;" class="smalltext">{{{coltext}}}</td>
+      {{/cols}}
+    {{/qelements.headerrow}}
+    {{#qelements.rows}}
+    <tr class="raterow">
+      {{#cols}}
+      <td {{#colstyle}}style="{{.}}"{{/colstyle}}{{#colclass}} class="{{.}}"{{/colclass}}{{#coltitle}} title="{{.}}"{{/coltitle}}>
+        {{#coltext}}{{{.}}}{{/coltext}}
+        {{#colhiddentext}}<span class="accesshide">{{{.}}}</span>{{/colhiddentext}}
+        {{#colinput}}<input type="radio" name="{{name}}" id="{{id}}" value="{{value}}"{{#checked}} checked="checked"{{/checked}}{{#disabled}} disabled="disabled"{{/disabled}}{{#onclick}} onclick="{{.}}"{{/onclick}}>
+        {{#label}}<label for="{{id}}" class="accesshide">{{{.}}}</label>{{/label}}{{/colinput}}
+      </td>
+      {{/cols}}
+    </tr>
+    {{/qelements.rows}}
+  </tbody>
+</table>
+{{/qelements}}
+<!-- End HTML generated from question_rate template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/question_text.mustache b/mod/questionnaire/templates/question_text.mustache
new file mode 100644
index 0000000..1efd82c
--- /dev/null
+++ b/mod/questionnaire/templates/question_text.mustache
@@ -0,0 +1,50 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/question_text
+
+    Template which defines a text type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "qelements": {
+            "choice": {
+                "onkeypress": "dosomething()",
+                "size": 30,
+                "name": "choiceid1",
+                "maxlength": 50,
+                "value": "Answer text",
+                "id": "choiceid1"
+            }
+        }
+    }
+    }}
+<!-- Begin HTML generated from question_text template. -->
+{{#qelements}}
+{{#choice}}
+<input {{#choice.onkeypress}}onkeypress="{{.}}"{{/choice.onkeypress}} type="text" size="{{choice.size}}" name="{{choice.name}}" {{#choice.maxlength}}maxlength="{{choice.maxlength}}"{{/choice.maxlength}} value="{{choice.value}}" id="{{choice.id}}" />
+{{/choice}}
+{{/qelements}}
+<!-- End HTML generated from question_text template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/question_yesno.mustache b/mod/questionnaire/templates/question_yesno.mustache
new file mode 100644
index 0000000..6cc9da4
--- /dev/null
+++ b/mod/questionnaire/templates/question_yesno.mustache
@@ -0,0 +1,63 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/question_yesno
+
+    Template which defines a yes/no type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "qelements": {
+            "choice": [
+                {
+                    "id": "choice1",
+                    "value": "y",
+                    "name": "q23",
+                    "checked": 1,
+                    "disabled": "",
+                    "onclick": "dosomething()",
+                    "label": "Yes"
+                },
+                {
+                    "id": "choice1",
+                    "value": "n",
+                    "name": "q23",
+                    "checked": 0,
+                    "disabled": "",
+                    "onclick": "dosomething()",
+                    "label": "No"
+                }
+            ]
+        }
+    }
+    }}
+<!-- Begin HTML generated from question_yesno template. -->
+{{#qelements}}
+{{#choice}}
+<input id="{{id}}" value="{{value}}" name="{{name}}" type="radio" {{#checked}}checked="checked"{{/checked}} {{#disabled}}disabled="disabled"{{/disabled}} {{#onclick}}onclick="{{onclick}}"{{/onclick}}/>
+<label for="{{id}}">{{{label}}}</label>
+{{/choice}}
+{{/qelements}}
+<!-- End HTML generated from question_yesno template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/questionspage.mustache b/mod/questionnaire/templates/questionspage.mustache
new file mode 100644
index 0000000..cf8bcec
--- /dev/null
+++ b/mod/questionnaire/templates/questionspage.mustache
@@ -0,0 +1,41 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/questionspage
+
+    Template which defines a questionnaire completion page.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+    * tabsarea - string: HTML of the tabs management area.
+    * formarea - string: HTML of the management form.
+
+    Example context (json):
+    {
+        "tabsarea": "<div>HTML of the tabs area.",
+        "formarea": "<div>HTML of the form area"
+    }
+    }}
+<div class="mod_questionnaire_questionspage generalbox">
+    {{{tabsarea}}}
+    {{{formarea}}}
+</div>
\ No newline at end of file
diff --git a/mod/questionnaire/templates/reportpage.mustache b/mod/questionnaire/templates/reportpage.mustache
new file mode 100644
index 0000000..4a1b1d1
--- /dev/null
+++ b/mod/questionnaire/templates/reportpage.mustache
@@ -0,0 +1,86 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/reportpage
+
+    Template which defines a questionnaire completion page.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+    * tabsarea - string: HTML of the tabs management area.
+    * notifications - string: HTML of any notifications loaded.
+    * myheaders - string: HTML of the page header.
+    * navigationbar - string: HTML of the response navigation controls.
+    * respondentinfo - string: HTML of any specific response/respondent information.
+    * title - string: Text title of the questionnaire.
+    * printblank - string: HTML of optional print blank questionnaire control.
+    * subtitle - string: Optional text subtitle.
+    * addinfo - string: Optional HTML additional information.
+    * feedbackcharts - string: HTML of any chart displays.
+    * feedbackscores - string: HTML of any feedback scores.
+    * feedbackmessages - string: HTML of any feedback messages.
+    * feedbacknotes - string: HTML of any feedback notes.
+    * responses - array: Array of responses HTML.
+    * bottomnavigationbar - string: HTML of the bottom response navigation controls.
+
+    Example context (json):
+    {
+        "tabsarea": "<div>HTML of the tabs area.</div>",
+        "notifications": "<div>Notification one</div>",
+        "myheaders": "<div>HTML of the page header.</div>",
+        "navigationbar": "<div>HTML of the navigation bar.</div>",
+        "respondentinfo": "<div>This is respondent information HTML</div>",
+        "title": "Test Questionnaire HTML",
+        "subtitle": "This is a subtitle HTML",
+        "addinfo": "<div>This is additional information HTML.</div>",
+        "feedbackcharts": "<div>Feedback charts HTML.</div>",
+        "feedbackscores": "<div>Feedback scores HTML.</div>",
+        "feedbackmessages": "<div>Feedback messages HTML.</div>",
+        "feedbacknotes": "<div>Feedback notes HTML.</div>",
+        "responses": [
+            "Response 1 HTML",
+            "Response 2 HTML"
+        ],
+        "bottomnavigationbar": "Navigation bar HTML"
+    }
+    }}
+<div class="mod_questionnaire_reportpage generalbox">
+    {{#tabsarea}}{{{tabsarea}}}{{/tabsarea}}
+    {{#notifications}}{{{notifications}}}{{/notifications}}
+    <div class="box generalbox">
+        {{#myheaders}}<h2>{{{.}}}</h2>{{/myheaders}}
+        {{#navigationbar}}<div class="box respondentsnavbar">{{{.}}}</div>{{/navigationbar}}
+        {{{respondentinfo}}}
+        {{#title}}<h3 class="surveyTitle">{{{.}}}</h3>{{{printblank}}}{{/title}}
+        {{#subtitle}}<h4 class="surveySubTitle">{{{.}}}</h4>{{/subtitle}}
+        {{#addinfo}}<div class="addInfo">{{{.}}}</div>{{/addinfo}}
+        {{#feedbackcharts}}{{{.}}}{{/feedbackcharts}}
+        {{#feedbackscores}}{{{.}}}{{/feedbackscores}}
+        {{#feedbackmessages}}
+        <h3>{{# str }} feedbackreport, mod_questionnaire {{/ str }}</h3>
+        {{{.}}}
+        {{/feedbackmessages}}
+        {{#feedbacknotes}}{{{.}}}{{/feedbacknotes}}
+        {{#responses}}{{{.}}}{{/responses}}
+        {{#bottomnavigationbar}}<div class="box respondentsnavbar">{{{.}}}</div>{{/bottomnavigationbar}}
+    </div>
+</div>
\ No newline at end of file
diff --git a/mod/questionnaire/templates/response_check.mustache b/mod/questionnaire/templates/response_check.mustache
new file mode 100644
index 0000000..464d63f
--- /dev/null
+++ b/mod/questionnaire/templates/response_check.mustache
@@ -0,0 +1,62 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/response_check
+
+    Template which defines a check type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "choices": [
+            {
+                "selected": "1",
+                "name": "choice1",
+                "content": "HTML for choice 1",
+                "othercontent": "HTML for other content"
+            },
+            {
+                "selected": "",
+                "name": "choice2",
+                "content": "HTML for choice 2"
+            }
+        ]
+    }
+    }}
+<!-- Begin HTML generated from response_check template. -->
+<div class="questionnaire_response questionnaire_check">
+{{#choices}}
+    {{#selected}}
+    <span class="selected"><input type="checkbox" name="{{name}}" checked="checked" onclick="this.checked=true;" />
+        {{{content}}}</span>
+    {{#othercontent}}<span class="response text">{{{.}}}</span>{{/othercontent}}
+    {{/selected}}
+    {{^selected}}
+    <span class="unselected"><input type="checkbox" name="{{name}}" onclick="this.checked=true;" />
+        {{{content}}}</span>
+    {{/selected}}
+    <br />
+{{/choices}}
+</div>
+<!-- End HTML generated from response_check template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/response_container.mustache b/mod/questionnaire/templates/response_container.mustache
new file mode 100644
index 0000000..3ae343c
--- /dev/null
+++ b/mod/questionnaire/templates/response_container.mustache
@@ -0,0 +1,106 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/response_container
+
+    Template which defines a survey response display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "fieldset": {
+            "id": "7",
+            "class": "responseclass"
+        },
+        "qnum": "<div>7</div>",
+        "required": "<div>*</div>",
+        "skippedclass": "skippedclass",
+        "label": {
+            "for": "qn-7"
+        },
+        "qcontent": "<div>HTML for the response content</div>",
+        "responses": [
+            {
+                "respdate": "Friday, 19 December 2014, 5:58pm",
+                "fieldset": {
+                    "id": "10",
+                    "class": "fieldsetclass"
+                },
+                "required": "required html",
+                "skippedclass": "skippedclass",
+                "label": {
+                    "for": "qn-7"
+                },
+                "qcontent": "<div>HTML for the response content</div>",
+                "qformelement": "<div>HTML for the question form element</div>"
+            }
+        ]
+    }
+    }}
+<!-- Begin fieldset generated from response_container template. -->
+<div class="box individualresp">
+<fieldset id="{{fieldset.id}}" class="{{fieldset.class}}">
+    {{#qnum}}
+    <legend class="qn-legend">
+        <div class="qn-info">
+            <div class="accesshide">{{# str }}questionnum, mod_questionnaire{{/ str}}</div>
+            <h2 class="qn-number">{{{qnum}}}</h2>
+        </div>
+        {{{required}}}
+    </legend>
+    {{/qnum}}
+    <div class="qn-content">
+        <div class="qn-question {{skippedclass}}">
+            {{#label}}<label for="{{label.for}}">{{/label}}
+            {{{qcontent}}}
+            {{#label}}</label>{{/label}}
+        </div>
+        <div class="qn-answer">
+            {{#responses}}
+            {{#respdate}}<div class="respdate">{{respdate}}</div>{{/respdate}}
+            <fieldset id="{{fieldset.id}}" class="{{fieldset.class}}">
+                <legend class="qn-legend">
+                    <div class="qn-info">
+                        <div class="accesshide">{{# str }}questionnum, mod_questionnaire{{/ str}}</div>
+                        <h2 class="qn-number"></h2>
+                    </div>
+                    {{{required}}}
+                </legend>
+                <div class="qn-content">
+                    <div class="qn-question {{skippedclass}}">
+                        {{#label}}<label for="{{label.for}}">{{/label}}
+                        {{{qcontent}}}
+                        {{#label}}</label>{{/label}}
+                    </div>
+                    <div class="qn-answer">
+                    {{{qformelement}}}
+                    </div>
+                </div>
+            </fieldset>
+            {{/responses}}
+        </div>
+    </div>
+</fieldset>
+</div>
+<!-- End fieldset generated from response_container template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/response_date.mustache b/mod/questionnaire/templates/response_date.mustache
new file mode 100644
index 0000000..bfb8c21
--- /dev/null
+++ b/mod/questionnaire/templates/response_date.mustache
@@ -0,0 +1,39 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/response_date
+
+    Template which defines a check type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "content": "HTML for date"
+    }
+    }}
+<!-- Begin HTML generated from response_date template. -->
+<div class="questionnaire_response questionnaire_date">
+    <span class="selected">{{{content}}}</span>
+</div>
+<!-- End HTML generated from response_date template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/response_drop.mustache b/mod/questionnaire/templates/response_drop.mustache
new file mode 100644
index 0000000..b14eeb8
--- /dev/null
+++ b/mod/questionnaire/templates/response_drop.mustache
@@ -0,0 +1,59 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/response_drop
+
+    Template which defines a check type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "id": "q2610",
+        "name": "choice1",
+        "class": "select menuq2610",
+        "options": [
+            {
+                "selected": "",
+                "value": 23,
+                "label": "Drop one"
+            },
+            {
+                "selected": "1",
+                "value": 24,
+                "label": "Drop two"
+            }
+        ],
+        "selectedlabel": "Drop two"
+    }
+    }}
+<!-- Begin HTML generated from response_drop template. -->
+<div class="questionnaire_response questionnaire_drop">
+    <select id="{{id}}" name="{{name}}" class="{{class}}">
+        {{#options}}
+        <option {{#selected}}selected="selected" {{/selected}}value="{{value}}">{{label}}</option>
+        {{/options}}
+    </select>
+    {{#selectedlabel}}: <span class="selected">{{.}}</span>{{/selectedlabel}}
+</div>
+<!-- End HTML generated from response_drop template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/response_numeric.mustache b/mod/questionnaire/templates/response_numeric.mustache
new file mode 100644
index 0000000..dff09e5
--- /dev/null
+++ b/mod/questionnaire/templates/response_numeric.mustache
@@ -0,0 +1,39 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/response_numeric
+
+    Template which defines a check type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "content": "HTML for numeric"
+    }
+    }}
+<!-- Begin HTML generated from response_numeric template. -->
+<div class="questionnaire_response questionnaire_numeric">
+    <span class="selected">{{{content}}}</span>
+</div>
+<!-- End HTML generated from response_numeric template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/response_radio.mustache b/mod/questionnaire/templates/response_radio.mustache
new file mode 100644
index 0000000..ed5aa23
--- /dev/null
+++ b/mod/questionnaire/templates/response_radio.mustache
@@ -0,0 +1,67 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/response_radio
+
+    Template which defines a check type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "choices": [
+            {
+                "horizontal": 1,
+                "selected": "1",
+                "name": "choice1",
+                "content": "HTML for choice 1",
+                "othercontent": "Text other content"
+            },
+            {
+                "horizontal": 1,
+                "selected": "",
+                "name": "choice2",
+                "content": "HTML for choice 2"
+            }
+        ]
+    }
+}}
+<!-- Begin HTML generated from response_radio template. -->
+<div class="questionnaire_response questionnaire_radio">
+{{#choices}}
+    {{#horizontal}}<span style="white-space:nowrap;">{{/horizontal}}
+    {{#selected}}
+    <span class="selected">
+        <input type="radio" name="{{name}}" checked="checked" />
+        {{{content}}}{{#othercontent}} <span class="response text">{{.}}</span>{{/othercontent}}
+    </span>
+    {{/selected}}
+    {{^selected}}
+    <span class="unselected"><input type="radio" name="{{name}}" />
+        {{{content}}}</span>&nbsp;
+    {{/selected}}
+    {{#horizontal}}</span>{{/horizontal}}
+    {{^horizontal}}<br />{{/horizontal}}
+{{/choices}}
+</div>
+<!-- End HTML generated from response_radio template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/response_rate.mustache b/mod/questionnaire/templates/response_rate.mustache
new file mode 100644
index 0000000..2ba1719
--- /dev/null
+++ b/mod/questionnaire/templates/response_rate.mustache
@@ -0,0 +1,92 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/response_rate
+
+    Template which defines a rate type response survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "twidth": "50%",
+        "osgood": "1",
+        "sidecolwidth": "45%",
+        "colwidth": "10%",
+        "textalign": "right",
+        "headers": [
+            {
+                "bg": "c0",
+                "str": "Okay"
+            }
+        ],
+        "rows": [
+            {
+                "content": "HTML content",
+                "cols": [
+                    {
+                        "checked": "1",
+                        "bg": "c0",
+                        "str": "Okay",
+                        "name": "choice1"
+                    }
+                ],
+                "osgoodstr": "Something right."
+            }
+        ]
+    }
+}}
+<!-- Begin HTML generated from response_rate template. -->
+<div class="questionnaire_response questionnaire_radio">
+<table class="individual" border="0" cellspacing="1" cellpadding="0" style="width:{{twidth}}">
+  <tbody>
+    <tr>
+        {{#osgood}}<td style="width: {{sidecolwidth}}; text-align: right;"></td>{{/osgood}}
+        {{^osgood}}<td style="width: {{sidecolwidth}}"></td>{{/osgood}}
+        {{#headers}}
+        <td style="width:{{colwidth}}; text-align:center" class="{{bg}} smalltext">{{str}}</td>
+        {{/headers}}
+        {{#osgood}}<td style="width:{{sidecolwidth}};"></td></td>{{/osgood}}
+    </tr>
+    {{#rows}}
+    <tr>
+        <td style="text-align:{{textalign}}">{{{content}}}</td>
+        {{#cols}}
+        {{#checked}}
+        <td style="text-align:center;" class="selected">
+            <span class="selected"><input type="radio" name="{{str}}" checked="checked" /></span>
+        </td>
+        {{/checked}}
+        {{^checked}}
+        <td style="text-align:center;" class="{{bg}}">
+            <span class="unselected"><input type="radio" disabled="disabled" name="{{str}}" onclick="this.checked=false;" /></span>
+        </td>
+        {{/checked}}
+        {{/cols}}
+        {{#osgood}}<td>{{{osgoodstr}}}</td>{{/osgood}}
+    </tr>
+    {{/rows}}
+  </tbody>
+</table>
+</div>
+<!-- End HTML generated from response_rate template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/response_text.mustache b/mod/questionnaire/templates/response_text.mustache
new file mode 100644
index 0000000..9360d12
--- /dev/null
+++ b/mod/questionnaire/templates/response_text.mustache
@@ -0,0 +1,39 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/response_text
+
+    Template which defines a text type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "content": "HTML for numeric"
+    }
+    }}
+<!-- Begin HTML generated from response_text template. -->
+<div class="questionnaire_response questionnaire_text">
+    <span class="selected">{{{content}}}</span>
+</div>
+<!-- End HTML generated from response_text template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/response_yesno.mustache b/mod/questionnaire/templates/response_yesno.mustache
new file mode 100644
index 0000000..54b8ac3
--- /dev/null
+++ b/mod/questionnaire/templates/response_yesno.mustache
@@ -0,0 +1,55 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/response_yesno
+
+    Template which defines a yesno type question survey display.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "yesselected": 1,
+        "yesname": "id4102y",
+        "stryes": "Yes",
+        "noselected": 0,
+        "noname": "id4102n",
+        "strno": "No"
+    }
+    }}
+<!-- Begin HTML generated from response_yesno template. -->
+<div class="questionnaire_response questionnaire_yesno">
+    {{#yesselected}}
+    <span class="selected"><input type="radio" name="{{yesname}}" checked="checked" /> {{{stryes}}}</span>
+    {{/yesselected}}
+    {{^yesselected}}
+    <span class="unselected"><input type="radio" name="{{yesname}}" onclick="this.checked=false;" /> {{{stryes}}}</span>
+    {{/yesselected}}
+    {{#noselected}}
+    <span class="selected"><input type="radio" name="{{noname}}" checked="checked" /> {{{strno}}}</span>
+    {{/noselected}}
+    {{^noselected}}
+    <span class="unselected"><input type="radio" name="{{noname}}" onclick="this.checked=false;" /> {{{strno}}}</span>
+    {{/noselected}}
+</div>
+<!-- End HTML generated from response_yesno template. -->
\ No newline at end of file
diff --git a/mod/questionnaire/templates/responselist.mustache b/mod/questionnaire/templates/responselist.mustache
new file mode 100644
index 0000000..cc4058d
--- /dev/null
+++ b/mod/questionnaire/templates/responselist.mustache
@@ -0,0 +1,69 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/responselist
+
+    Template which defines a questionnaire response list on the report page.
+
+    Classes required for JS:
+    * /mod/questionnaire/module.js
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+
+    Example context (json):
+    {
+        "respondentscolumn0": [
+            "HTML of respondent link1",
+            "HTML of respondent link2"
+        ],
+        "respondentscolumn1": [
+            "HTML of respondent link3",
+            "HTML of respondent link4"
+        ],
+        "respondentscolumn2": [
+            "HTML of respondent link5",
+            "HTML of respondent link6"
+        ]
+    }
+    }}
+<div class="box generalbox">
+    {{#respondentscolumn0}}
+    <div id="respondentscolumn">
+    {{#respondentlink}}
+    {{{.}}}<br />
+    {{/respondentlink}}
+    </div>
+    {{/respondentscolumn0}}
+    {{#respondentscolumn1}}
+    <div id="respondentscolumn">
+    {{#respondentlink}}
+    {{{.}}}<br />
+    {{/respondentlink}}
+    </div>
+    {{/respondentscolumn1}}
+    {{#respondentscolumn2}}
+    <div id="respondentscolumn">
+    {{#respondentlink}}
+    {{{.}}}<br />
+    {{/respondentlink}}
+    </div>
+    {{/respondentscolumn2}}
+    <div style="clear: both;"></div>
+</div>
\ No newline at end of file
diff --git a/mod/questionnaire/templates/viewpage.mustache b/mod/questionnaire/templates/viewpage.mustache
new file mode 100644
index 0000000..0cbede3c
--- /dev/null
+++ b/mod/questionnaire/templates/viewpage.mustache
@@ -0,0 +1,56 @@
+{{!
+    This file is part of Moodle - http://moodle.org/
+
+    Moodle is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Moodle is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+}}
+{{!
+    @template mod_questionnaire/viewpage
+
+    Template which defines a questionnaire view page.
+
+    Classes required for JS:
+    * none
+
+    Data attributes required for JS:
+    * none
+
+    Context variables required for this template:
+    * questionnairename - string: The name of the questionnaire (no HTML).
+    * intro - string: The intro text (may have HTML).
+    * message - string: Any message text.
+    * complete - string: The text and link to complete the questionnaire.
+    * guestuser - string: Any content for a guest user.
+    * yourresponse - string: Content for responses by you.
+    * allresponses - string: Content for responses by other users.
+
+    Example context (json):
+    {
+        "questionnairename": "Questionnaire One",
+        "intro": "HTML of the intro text.",
+        "message": "HTML of the message text.",
+        "complete": "HTML of the completion notice and link.",
+        "guestuser": "HTML of guest user content.",
+        "yourresponse": "HTML for your responses link.",
+        "allresponses": "HTML for all responses link."
+    }
+    }}
+<div class="mod_questionnaire_viewpage">
+    <h2>{{questionnairename}}</h2>
+    {{#intro}}<div class="intro">{{{intro}}}</div>{{/intro}}
+    {{#message}}<div class="message">{{{message}}}</div>{{/message}}
+    {{#complete}}<div class="complete">{{{complete}}}</div>{{/complete}}
+    {{#guestuser}}<div class="guestuser">{{{guestuser}}}</div>{{/guestuser}}
+    {{#yourresponse}}<div class="yourresponse">{{{yourresponse}}}</div>{{/yourresponse}}
+    {{#allresponses}}<div class="allresponses">{{{allresponses}}}</div>{{/allresponses}}
+</div>
\ No newline at end of file
diff --git a/mod/questionnaire/tests/behat/add_questionnaire.feature b/mod/questionnaire/tests/behat/add_questionnaire.feature
new file mode 100644
index 0000000..cdbda80
--- /dev/null
+++ b/mod/questionnaire/tests/behat/add_questionnaire.feature
@@ -0,0 +1,26 @@
+@mod @mod_questionnaire
+Feature: Add a questionnaire activity
+  In order to conduct surveys of the users in a course
+  As a teacher
+  I need to add a questionnaire activity to a moodle course
+
+@javascript
+  Scenario: Add a questionnaire to a course without questions
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And I log in as "student1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    Then I should see "This questionnaire does not contain any questions."
\ No newline at end of file
diff --git a/mod/questionnaire/tests/behat/add_questions.feature b/mod/questionnaire/tests/behat/add_questions.feature
new file mode 100644
index 0000000..1eb9a16
--- /dev/null
+++ b/mod/questionnaire/tests/behat/add_questions.feature
@@ -0,0 +1,102 @@
+@mod @mod_questionnaire
+Feature: Add questions to a questionnaire activity
+  In order to conduct surveys of the users in a course
+  As a teacher
+  I need to add a questionnaire activity with questions to a moodle course
+
+@javascript
+  Scenario: Add a questionnaire to a course with one of each question type
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And I log in as "teacher1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Questions" in current page administration
+    And I add a "Check Boxes" question and I fill the form with:
+      | Question Name | Q1 |
+      | Yes | y |
+      | Min. forced responses | 1 |
+      | Max. forced responses | 2 |
+      | Question Text | Select one or two choices only |
+      | Possible answers | One,Two,Three,Four |
+    Then I should see "[Check Boxes] (Q1)"
+    And I should see "Select one or two choices only"
+    And I add a "Date" question and I fill the form with:
+      | Question Name | Q2 |
+      | Yes | y |
+      | Question Text | Enter today's date |
+    Then I should see "[Date] (Q2)"
+    And I should see "Enter today's date"
+    And I add a "Dropdown Box" question and I fill the form with:
+      | Question Name | Q3 |
+      | No | n |
+      | Question Text | Select one choice |
+      | Possible answers | One,Two,Three,Four |
+    Then I should see "[Dropdown Box] (Q3)"
+    And I should see "Select one choice"
+    And I add a "Essay Box" question and I fill the form with:
+      | Question Name | Q4 |
+      | No | n |
+      | Response format | 0 |
+      | Input box size | 10 lines |
+      | Question Text | Enter your essay |
+    Then I should see "[Essay Box] (Q4)"
+    And I should see "Enter your essay"
+    And I add a "Label" question and I fill the form with:
+      | Question Text | Section header |
+    Then I should see "[Label]"
+    And I should see "Section header"
+    And I add a "Numeric" question and I fill the form with:
+      | Question Name | Q5 |
+      | Yes | y |
+      | Max. digits allowed | 4 |
+      | Nb of decimal digits | 1 |
+      | Question Text | Enter a number with a decimal |
+    Then I should see "[Numeric] (Q5)"
+    And I should see "Enter a number with a decimal"
+    And I add a "Radio Buttons" question and I fill the form with:
+      | Question Name | Q6 |
+      | Yes | y |
+      | Horizontal | Checked |
+      | Question Text | Select one choice |
+      | Possible answers | One,Two,Three,Four |
+    Then I should see "[Radio Buttons] (Q6)"
+    And I should see "Select one choice"
+    And I add a "Rate (scale 1..5)" question and I fill the form with:
+      | Question Name | Q7 |
+      | Yes | y |
+      | Nb of scale items | 4 |
+      | Type of rate scale | N/A column |
+      | Question Text | Rate these |
+      | Possible answers | One,Two,Three,Four |
+    Then I should see "[Rate (scale 1..5)] (Q7)"
+    And I should see "Rate these"
+    And I add a "Text Box" question and I fill the form with:
+      | Question Name | Q8 |
+      | No | n |
+      | Input box length | 10 |
+      | Max. text length | 15 |
+      | Question Text | Enter some text |
+    Then I should see "[Text Box] (Q8)"
+    And I should see "Enter some text"
+    And I add a "Yes/No" question and I fill the form with:
+      | Question Name | Q9 |
+      | Yes | y |
+      | Question Text | Choose yes or no |
+    Then I should see "[Yes/No] (Q9)"
+    And I should see "Choose yes or no"
+    And I set the field "id_type_id" to "----- Page Break -----"
+    And I press "Add selected question type"
+    Then I should see "[----- Page Break -----]"
\ No newline at end of file
diff --git a/mod/questionnaire/tests/behat/anonymous_questionnaire.feature b/mod/questionnaire/tests/behat/anonymous_questionnaire.feature
new file mode 100644
index 0000000..7f64b7e
--- /dev/null
+++ b/mod/questionnaire/tests/behat/anonymous_questionnaire.feature
@@ -0,0 +1,50 @@
+@mod @mod_questionnaire
+Feature: Questionnaires can be anonymous
+  When anonymous questionnaires are viewed
+  The user name is dispplayed as "anonymous".
+
+  Background: Add an anonymous questionnaire
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Anonymous questionnaire | Anonymous questionnaire description | C1 | questionnaire0 |
+    And I log in as "teacher1"
+    And I am on "Course 1" course homepage
+    And I follow "Anonymous questionnaire"
+    And I navigate to "Edit settings" in current page administration
+    And I expand all fieldsets
+    And I should see "Response options"
+    And I set the field "id_respondenttype" to "anonymous"
+    And I press "Save and display"
+    Then I should see "Anonymous questionnaire"
+    And I navigate to "Questions" in current page administration
+    And I add a "Yes/No" question and I fill the form with:
+      | Question Name | Q1 |
+      | Yes | y |
+      | Question Text | Do you like this course |
+    And I log out
+
+@javascript
+  Scenario: Student completes an anonymous questionnaire
+    And I log in as "student1"
+    And I am on "Course 1" course homepage
+    And I follow "Anonymous questionnaire"
+    And I navigate to "Answer the questions..." in current page administration
+    Then I should see "Anonymous questionnaire"
+    And I click on "Yes" "radio"
+    And I press "Submit questionnaire"
+    Then I should see "Thank you for completing this Questionnaire."
+    And I follow "Continue"
+    Then I should see "Your response"
+    And I should see "Anonymous questionnaire"
+    And I should see "Respondent: - Anonymous -"
\ No newline at end of file
diff --git a/mod/questionnaire/tests/behat/behat_mod_questionnaire.php b/mod/questionnaire/tests/behat/behat_mod_questionnaire.php
new file mode 100644
index 0000000..8c5b38a
--- /dev/null
+++ b/mod/questionnaire/tests/behat/behat_mod_questionnaire.php
@@ -0,0 +1,372 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Steps definitions related with the questionnaire activity.
+ *
+ * @package    mod_questionnaire
+ * @category   test
+ * @copyright  2016 Mike Churchward - The POET Group
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+// NOTE: no MOODLE_INTERNAL test here, this file may be required by behat before including /config.php.
+
+require_once(__DIR__ . '/../../../../lib/behat/behat_base.php');
+
+use Behat\Behat\Context\Step\Given as Given,
+    Behat\Behat\Context\Step\When as When,
+    Behat\Gherkin\Node\TableNode as TableNode,
+    Behat\Gherkin\Node\PyStringNode as PyStringNode,
+    Behat\Mink\Exception\ExpectationException as ExpectationException;
+;
+/**
+ * Questionnaire-related steps definitions.
+ *
+ * @package    mod_questionnaire
+ * @category   test
+ * @copyright  2016 Mike Churchward - The POET Group
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class behat_mod_questionnaire extends behat_base {
+
+    /**
+     * Adds a question to the questionnaire with the provided data.
+     *
+     * @Given /^I add a "([^"]*)" question and I fill the form with:$/
+     *
+     * @param string $questiontype The question type by text name to enter.
+     * @param TableNode $fielddata
+     */
+    public function i_add_a_question_and_i_fill_the_form_with($questiontype, TableNode $fielddata) {
+        $validtypes = array(
+            '----- Page Break -----',
+            'Check Boxes',
+            'Date',
+            'Dropdown Box',
+            'Essay Box',
+            'Label',
+            'Numeric',
+            'Radio Buttons',
+            'Rate (scale 1..5)',
+            'Text Box',
+            'Yes/No');
+
+        if (!in_array($questiontype, $validtypes)) {
+            throw new ExpectationException('Invalid question type specified.', $this->getSession());
+        }
+
+        // We get option choices as CSV strings. If we have this, modify it for use in
+        // multiline data.
+        $rows = $fielddata->getRows();
+        $hashrows = $fielddata->getRowsHash();
+        $options = array();
+        if (isset($hashrows['Possible answers'])) {
+            $options = explode(',', $hashrows['Possible answers']);
+            $rownum = -1;
+            // Find the row that contained multiline data and add line breaks. Rows are two item arrays where the
+            // first is an identifier and the second is the value.
+            foreach ($rows as $key => $row) {
+                if ($row[0] == 'Possible answers') {
+                    $row[1] = str_replace(',', "\n", $row[1]);
+                    $rows[$key] = $row;
+                    break;
+                }
+            }
+            $fielddata = new TableNode($rows);
+        }
+
+        $this->execute('behat_forms::i_set_the_field_to', array('id_type_id', $questiontype));
+        $this->execute('behat_forms::press_button', 'Add selected question type');
+        $this->execute('behat_forms::i_set_the_following_fields_to_these_values', $fielddata);
+        $this->execute('behat_forms::press_button', 'Save changes');
+    }
+
+    /**
+     * Adds a questions and responses to the questionnaire with the provided name.
+     *
+     * @Given /^"([^"]*)" has questions and responses$/
+     *
+     * @param string $questionnairename The name of an existing questionnaire.
+     */
+    public function has_questions_and_responses($questionnairename) {
+        global $DB;
+
+        if (!$questionnaire = $DB->get_record('questionnaire', array('name' => $questionnairename), 'id,sid')) {
+            throw new ExpectationException('Invalid questionnaire name specified.', $this->getSession());
+        }
+
+        if (!$DB->record_exists('questionnaire_survey', array('id' => $questionnaire->sid))) {
+            throw new ExpectationException('Questionnaire survey does not exist.', $this->getSession());
+        }
+
+        $this->add_question_data($questionnaire->sid);
+        $this->add_response_data($questionnaire->id, $questionnaire->sid);
+    }
+
+    /**
+     * Adds a question data to the given survey id.
+     *
+     * @param int $sid The id field of an existing questionnaire_survey record.
+     * @return null
+     */
+    private function add_question_data($sid) {
+        $questiondata = array(
+            array("id", "survey_id", "name", "type_id", "result_id", "length", "precise", "position", "content", "required",
+                  "deleted", "dependquestion", "dependchoice"),
+            array("1", $sid, "own car", "1", null, "0", "0", "1", "<p>Do you own a car?</p>", "y", "n", "0", "0"),
+            array("2", $sid, "optional", "2", null, "20", "25", "3", "<p>What is the colour of your car?</p>", "y", "n", "121",
+                  "0"),
+            array("3", $sid, null, "99", null, "0", "0", "2", "break", "n", "n", "0", "0"),
+            array("4", $sid, "optional2", "1", null, "0", "0", "5", "<p>Do you sometimes use public transport to go to work?</p>",
+                  "y", "n", "0", "0"),
+            array("5", $sid, null, "99", null, "0", "0", "4", "break", "n", "n", "0", "0"),
+            array("6", $sid, "entertext", "2", null, "20", "10", "6", "<p>Enter no more than 10 characters.<br></p>", "n", "n", "0",
+                  "0"),
+            array("7", $sid, "q7", "5", null, "0", "0", "7", "<p>Check all that apply<br></p>", "n", "n", "0", "0"),
+            array("8", $sid, "q8", "9", null, "0", "0", "8", "<p>Enter today's date<br></p>", "n", "n", "0", "0"),
+            array("9", $sid, "q9", "6", null, "0", "0", "9", "<p>Choose One<br></p>", "n", "n", "0", "0"),
+            array("10", $sid, "q10", "3", null, "5", "0", "10", "<p>Write an essay<br></p>", "n", "n", "0", "0"),
+            array("11", $sid, "q11", "10", null, "10", "0", "11", "<p>Enter a number<br></p>", "n", "n", "0", "0"),
+            array("12", $sid, "q12", "4", null, "1", "0", "13", "<p>Choose a colour<br></p>", "n", "n", "0", "0"),
+            array("13", $sid, "q13", "8", null, "5", "1", "14", "<p>Rate this.<br></p>", "n", "n", "0", "0"),
+            array("14", $sid, null, "99", null, "0", "0", "12", "break", "n", "y", "0", "0"),
+            array("15", $sid, null, "99", null, "0", "0", "12", "break", "n", "n", "0", "0"),
+            array("16", $sid, "Q1", "10", null, "3", "2", "15", "Enter a number<br><p><br></p>", "y", "n", "0", "0")
+        );
+
+        $choicedata = array(
+            array("id", "question_id", "content", "value"),
+            array("1", "7", "1", null),
+            array("2", "7", "2", null),
+            array("3", "7", "3", null),
+            array("4", "7", "4", null),
+            array("5", "7", "5", null),
+            array("6", "9", "1", null),
+            array("7", "9", "One", null),
+            array("8", "9", "2", null),
+            array("9", "9", "Two", null),
+            array("10", "9", "3", null),
+            array("11", "9", "Three", null),
+            array("12", "12", "Red", null),
+            array("13", "12", "Toyota", null),
+            array("14", "12", "Bird", null),
+            array("15", "12", "Blew", null),
+            array("16", "13", "Good", null),
+            array("17", "13", "Great", null),
+            array("18", "13", "So-so", null),
+            array("19", "13", "Lamp", null),
+            array("20", "13", "Huh?", null),
+            array("21", "7", "!other=Another number", null),
+            array("22", "12", "!other=Something else", null)
+        );
+
+        $this->add_data($questiondata, 'questionnaire_question', 'questionmap');
+        $this->add_data($choicedata, 'questionnaire_quest_choice', 'choicemap', array('questionmap' => 'question_id'));
+    }
+
+    /**
+     * Adds response data to the given questionnaire and survey id.
+     *
+     * @param int $qid The id field of an existing questionnaire record.
+     * @param int $sid The id field of an existing questionnaire_survey record.
+     * @return null
+     */
+    private function add_response_data($qid, $sid) {
+        $responses = array(
+            array("id", "survey_id", "submitted", "complete", "grade", "userid"),
+            array("1", $sid, "1419011935", "y", "0", "2"),
+            array("2", $sid, "1449064371", "y", "0", "2"),
+            array("3", $sid, "1449258520", "y", "0", "2"),
+            array("4", $sid, "1452020444", "y", "0", "2"),
+            array("5", $sid, "1452804783", "y", "0", "2"),
+            array("6", $sid, "1452806547", "y", "0", "2"),
+            array("7", $sid, "1465415731", "n", "0", "2")
+        );
+
+        $this->add_data($responses, 'questionnaire_response', 'responsemap');
+
+        $attempts = array(
+            array("id", "qid", "userid", "rid", "timemodified"),
+            array("", $qid, "2", "1", "1419011935"),
+            array("", $qid, "2", "2", "1449064371"),
+            array("", $qid, "2", "3", "1449258520"),
+            array("", $qid, "2", "4", "1452020444"),
+            array("", $qid, "2", "5", "1452804783"),
+            array("", $qid, "2", "6", "1452806547")
+        );
+        $this->add_data($attempts, 'questionnaire_attempts', '', array('responsemap' => 'rid'));
+
+        $responsebool = array(
+            array("id", "response_id", "question_id", "choice_id"),
+            array("", "1", "1", "y"),
+            array("", "1", "4", "n"),
+            array("", "2", "1", "y"),
+            array("", "2", "4", "n"),
+            array("", "3", "1", "n"),
+            array("", "3", "4", "y"),
+            array("", "4", "1", "y"),
+            array("", "4", "4", "n"),
+            array("", "5", "1", "n"),
+            array("", "5", "4", "n"),
+            array("", "6", "1", "n"),
+            array("", "6", "4", "n"),
+            array("", "7", "1", "y"),
+            array("", "7", "4", "y")
+        );
+        $this->add_data($responsebool, 'questionnaire_response_bool', '',
+            array('responsemap' => 'response_id', 'questionmap' => 'question_id'));
+
+        $responsedate = array(
+            array("id", "response_id", "question_id", "response"),
+            array("", "1", "8", "2014-12-19"),
+            array("", "2", "8", "2015-12-02"),
+            array("", "3", "8", "2015-12-04"),
+            array("", "4", "8", "2016-01-06"),
+            array("", "5", "8", "2016-01-13"),
+            array("", "6", "8", "2016-01-13")
+        );
+        $this->add_data($responsedate, 'questionnaire_response_date', '',
+            array('responsemap' => 'response_id', 'questionmap' => 'question_id'));
+
+        $responseother = array(
+            array("id", "response_id", "question_id", "choice_id", "response"),
+            array("", "5", "7", "21", "Forty-four"),
+            array("", "6", "12", "22", "Green"),
+            array("", "7", "7", "21", "5")
+        );
+        $this->add_data($responseother, 'questionnaire_response_other', '',
+            array('responsemap' => 'response_id', 'questionmap' => 'question_id', 'choicemap' => 'choice_id'));
+
+        $responserank = array(
+            array("id", "response_id", "question_id", "choice_id", "rank"),
+            array("", "1", "13", "16", "0"),
+            array("", "1", "13", "17", "1"),
+            array("", "1", "13", "18", "2"),
+            array("", "1", "13", "19", "3"),
+            array("", "1", "13", "20", "4"),
+            array("", "2", "13", "16", "0"),
+            array("", "2", "13", "17", "1"),
+            array("", "2", "13", "18", "2"),
+            array("", "2", "13", "19", "3"),
+            array("", "2", "13", "20", "4"),
+            array("", "3", "13", "16", "4"),
+            array("", "3", "13", "17", "0"),
+            array("", "3", "13", "18", "3"),
+            array("", "3", "13", "19", "1"),
+            array("", "3", "13", "20", "2"),
+            array("", "4", "13", "16", "2"),
+            array("", "4", "13", "17", "2"),
+            array("", "4", "13", "18", "2"),
+            array("", "4", "13", "19", "2"),
+            array("", "4", "13", "20", "2"),
+            array("", "5", "13", "16", "1"),
+            array("", "5", "13", "17", "1"),
+            array("", "5", "13", "18", "1"),
+            array("", "5", "13", "19", "1"),
+            array("", "5", "13", "20", "-1"),
+            array("", "6", "13", "16", "2"),
+            array("", "6", "13", "17", "3"),
+            array("", "6", "13", "18", "-1"),
+            array("", "6", "13", "19", "1"),
+            array("", "6", "13", "20", "-1"),
+            array("", "7", "13", "16", "-999"),
+            array("", "7", "13", "17", "-999"),
+            array("", "7", "13", "18", "-999"),
+            array("", "7", "13", "19", "-999"),
+            array("", "7", "13", "20", "-999")
+        );
+        $this->add_data($responserank, 'questionnaire_response_rank', '',
+            array('responsemap' => 'response_id', 'questionmap' => 'question_id', 'choicemap' => 'choice_id'));
+
+        $respmultiple = array(
+            array("id", "response_id", "question_id", "choice_id"),
+            array("", "1", "7", "1"),
+            array("", "1", "7", "3"),
+            array("", "1", "7", "5"),
+            array("", "2", "7", "4"),
+            array("", "3", "7", "2"),
+            array("", "3", "7", "4"),
+            array("", "4", "7", "2"),
+            array("", "4", "7", "4"),
+            array("", "4", "7", "5"),
+            array("", "5", "7", "2"),
+            array("", "5", "7", "3"),
+            array("", "5", "7", "21"),
+            array("", "6", "7", "2"),
+            array("", "6", "7", "5"),
+            array("", "7", "7", "21")
+        );
+        $this->add_data($respmultiple, 'questionnaire_resp_multiple', '',
+            array('responsemap' => 'response_id', 'questionmap' => 'question_id', 'choicemap' => 'choice_id'));
+
+        $respsingle = array(
+            array("id", "response_id", "question_id", "choice_id"),
+            array("", "1", "9", "7"),
+            array("", "1", "12", "15"),
+            array("", "2", "9", "7"),
+            array("", "2", "12", "14"),
+            array("", "3", "9", "11"),
+            array("", "3", "12", "15"),
+            array("", "4", "9", "6"),
+            array("", "4", "12", "12"),
+            array("", "5", "9", "6"),
+            array("", "5", "12", "13"),
+            array("", "6", "9", "7"),
+            array("", "6", "12", "22")
+        );
+        $this->add_data($respsingle, 'questionnaire_resp_single', '',
+            array('responsemap' => 'response_id', 'questionmap' => 'question_id', 'choicemap' => 'choice_id'));
+    }
+
+    /**
+     * Helper function to insert record data, save mapping data and remap data where necessary.
+     *
+     * @param array $data Array of data record row arrays. The first row contains the field names.
+     * @param string $datatable The name of the data table to insert records into.
+     * @param string $mapvar The name of the object variable to store oldid / newid mappings (optional).
+     * @param string $replvars Array of key/value pairs where key is the mapvar and value is the record field
+     *                         to replace with mapped values.
+     * @return null
+     */
+    private function add_data(array $data, $datatable, $mapvar = '', array $replvars = null) {
+        global $DB;
+
+        if ($replvars === null) {
+            $replvars = array();
+        }
+        $fields = array_shift($data);
+        foreach ($data as $row) {
+            $record = new stdClass();
+            foreach ($row as $key => $fieldvalue) {
+                if ($fields[$key] == 'id') {
+                    if (!empty($mapvar)) {
+                        $oldid = $fieldvalue;
+                    }
+                } else if (($replvar = array_search($fields[$key], $replvars)) !== false) {
+                    $record->{$fields[$key]} = $this->{$replvar}[$fieldvalue];
+                } else {
+                    $record->{$fields[$key]} = $fieldvalue;
+                }
+            }
+            $newid = $DB->insert_record($datatable, $record);
+            if (!empty($mapvar)) {
+                $this->{$mapvar}[$oldid] = $newid;
+            }
+        }
+
+    }
+}
diff --git a/mod/questionnaire/tests/behat/check_responses.feature b/mod/questionnaire/tests/behat/check_responses.feature
new file mode 100644
index 0000000..240f1df
--- /dev/null
+++ b/mod/questionnaire/tests/behat/check_responses.feature
@@ -0,0 +1,83 @@
+@mod @mod_questionnaire
+Feature: Review responses
+  In order to review and manage questionnaire responses
+  As a teacher
+  I need to access the view responses features
+
+@javascript
+  Scenario: Add a questionnaire to a course without questions
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And "Test questionnaire" has questions and responses
+    And I log in as "admin"
+    And I navigate to "Location settings" node in "Site administration > Location"
+    And I set the field "id_s__timezone" to "Europe/London"
+    And I set the field "id_s__forcetimezone" to "Europe/London"
+    And I press "Save changes"
+    And I navigate to "Language settings" node in "Site administration > Language"
+    And I set the field "id_s__autolang" to "0"
+#    And I set the field "id_s__lang" to "en‎"
+    And I log out
+    And I log in as "teacher1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    Then I should see "View All Responses"
+    And I navigate to "View All Responses" in current page administration
+    Then I should see "View All Responses."
+    And I should see "All participants."
+    And I should see "View Default order"
+    And I should see "Responses: 6"
+    And I follow "Ascending order"
+    Then I should see "View All Responses."
+    And I should see "All participants."
+    And I should see "Ascending order"
+    And I should see "Responses: 6"
+    And I follow "Descending order"
+    Then I should see "View All Responses."
+    And I should see "All participants."
+    And I should see "Descending order"
+    And I should see "Responses: 6"
+    And I follow "List of responses"
+    Then I should see "Individual responses  : All participants"
+    And I follow "Admin User"
+    Then I should see "1 / 6"
+    And I should see "Respondent:"
+    And I should see "Admin User"
+    And I should see "Submitted on:"
+#    And I should see "Thursday, 14 January 2016, 9:22 pm"
+    And I should see "Test questionnaire"
+    And I follow "Next"
+    Then I should see "2 / 6"
+#    And I should see "Thursday, 14 January 2016, 8:53 pm"
+    And I follow "Last Respondent"
+    Then I should see "6 / 6"
+#    And I should see "Friday, 19 December 2014, 5:58 pm"
+    And I follow "Delete this Response"
+    Then I should see "Are you sure you want to delete the response"
+#    And I should see "Friday, 19 December 2014, 5:58 pm"
+    And I press "Delete"
+    Then I should see "Individual responses  : All participants"
+    And I follow "Admin User"
+    Then I should see "1 / 5"
+    And I follow "Summary"
+    Then I should see "View All Responses."
+    And I should see "All participants."
+    And I should see "View Default order"
+    And I should see "Responses: 5"
+    And I follow "Delete ALL Responses"
+    Then I should see "Are you sure you want to delete ALL the responses in this questionnaire?"
+    And I press "Delete"
+    Then I should see "You are not eligible to take this questionnaire."
+    And I should not see "View All Responses"
diff --git a/mod/questionnaire/tests/behat/checkbox_min_max_responses.feature b/mod/questionnaire/tests/behat/checkbox_min_max_responses.feature
new file mode 100644
index 0000000..f3d229e
--- /dev/null
+++ b/mod/questionnaire/tests/behat/checkbox_min_max_responses.feature
@@ -0,0 +1,52 @@
+@mod @mod_questionnaire
+Feature: Checkbox questions can have forced minimum and maximum numbers of boxes selected
+  In order to force minimum and maximum selections
+  As a teacher
+  I need to specify the minimum and maximum numbers in the question fields
+
+  Background: Add a checkbox question to a questionnaire with a min and max entered
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And I log in as "teacher1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Questions" in current page administration
+    And I add a "Check Boxes" question and I fill the form with:
+      | Question Name | Q1 |
+      | Yes | y |
+      | Min. forced responses | 1 |
+      | Max. forced responses | 2 |
+      | Question Text | Select one or two choices only |
+      | Possible answers | One,Two,Three,Four |
+    Then I should see "position 1"
+    And I should see "[Check Boxes] (Q1)"
+    And I should see "Select one or two choices only"
+    And I log out
+
+@javascript
+  Scenario: Student must select exactly one or two boxes to submit the question.
+    And I log in as "student1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Answer the questions..." in current page administration
+    Then I should see "Select one or two choices only"
+    And I press "Submit questionnaire"
+    Then I should see "Please answer Required question #1."
+    And I set the field "One" to "checked"
+    And I set the field "Two" to "checked"
+    And I set the field "Three" to "checked"
+    And I press "Submit questionnaire"
+#    Then I should see "There is something wrong with your answer to question: #1." -- Need to figure out why this isn't working.
+    Then I should see "For this question you must tick a maximum of 2 box(es)."
\ No newline at end of file
diff --git a/mod/questionnaire/tests/behat/numeric_question_digits.feature b/mod/questionnaire/tests/behat/numeric_question_digits.feature
new file mode 100644
index 0000000..feb5363
--- /dev/null
+++ b/mod/questionnaire/tests/behat/numeric_question_digits.feature
@@ -0,0 +1,51 @@
+@mod @mod_questionnaire
+Feature: Numeric questions can specify a maximum number of digits, and minimum number of decimal places
+  In order to force a limit on digits and require decimal places
+  As a teacher
+  I need to specify the max digits and number of decimal places in the numeric question fields
+
+  Background: Add a numeric question to a questionnaire with a max digits and nb decimals specified
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And I log in as "teacher1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Questions" in current page administration
+    And I add a "Numeric" question and I fill the form with:
+      | Question Name | Q1 |
+      | Yes | y |
+      | Max. digits allowed | 6 |
+      | Nb of decimal digits | 2 |
+      | Question Text | Enter no more than six digits including the decimal point |
+    Then I should see "position 1"
+    And I should see "[Numeric] (Q1)"
+    And I should see "Enter no more than six digits including the decimal point"
+    And I log out
+
+@javascript
+  Scenario: Student must enter no more than six digits and decimal points.
+    And I log in as "student1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Answer the questions..." in current page administration
+    Then I should see "Enter no more than six digits including the decimal point"
+    And I set the field "Enter no more than six digits including the decimal point" to "1.23456"
+    And I press "Submit questionnaire"
+    Then I should see "Thank you for completing this Questionnaire."
+    And I follow "Continue"
+    Then I should see "Your response"
+    And I should see "Test questionnaire"
+    And I should see "Enter no more than six digits including the decimal point"
+    And I should see "1.2345"
\ No newline at end of file
diff --git a/mod/questionnaire/tests/behat/radio_question_other.feature b/mod/questionnaire/tests/behat/radio_question_other.feature
new file mode 100644
index 0000000..bd20b82
--- /dev/null
+++ b/mod/questionnaire/tests/behat/radio_question_other.feature
@@ -0,0 +1,61 @@
+@mod @mod_questionnaire
+Feature: Radio questions allow optional "other" responses with optional labels
+  In order to allow users to enter "other" answers to a radio button question
+  As a teacher
+  I need to specify an "other" choice
+
+  Background: Add two radio button question to a questionnaire with both "other" choice options specified
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And I log in as "teacher1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Questions" in current page administration
+    And I add a "Radio Buttons" question and I fill the form with:
+      | Question Name | Q1 |
+      | Yes | y |
+      | Question Text | Select one |
+      | Possible answers | Red,Blue,Black,!other |
+    Then I should see "position 1"
+    And I should see "[Radio Buttons] (Q1)"
+    And I should see "Select one"
+    And I add a "Radio Buttons" question and I fill the form with:
+      | Question Name | Q2 |
+      | Yes | y |
+      | Question Text | Select another |
+      | Possible answers | Green,Orange,Yellow,!other=Another colour: |
+    Then I should see "position 2"
+    And I should see "[Radio Buttons] (Q2)"
+    And I should see "Select another"
+    And I log out
+
+@javascript
+  Scenario: Student selects other options and enters their own text.
+    And I log in as "student1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Answer the questions..." in current page administration
+    Then I should see "Test questionnaire"
+    And I click on "Other:" "radio"
+    And I set the field "Text for Other:" to "Yellow"
+    And I click on "Another colour:" "radio"
+    And I set the field "Text for Another colour:" to "Indigo"
+    And I press "Submit questionnaire"
+    Then I should see "Thank you for completing this Questionnaire."
+    And I follow "Continue"
+    Then I should see "Your response"
+    And I should see "Test questionnaire"
+    And I should see "Other: Yellow"
+    And I should see "Another colour: Indigo"
\ No newline at end of file
diff --git a/mod/questionnaire/tests/behat/rate_question_na.feature b/mod/questionnaire/tests/behat/rate_question_na.feature
new file mode 100644
index 0000000..c0ff592
--- /dev/null
+++ b/mod/questionnaire/tests/behat/rate_question_na.feature
@@ -0,0 +1,62 @@
+@mod @mod_questionnaire
+Feature: Rate scale questions have options for displaing "N/A"
+  In order to display an "N/A"
+  As a teacher
+  I need to enter a rate question with correct options
+
+@javascript
+  Scenario: Add a "N/A" option to an existing rate scale question
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And I log in as "teacher1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Questions" in current page administration
+    And I add a "Rate (scale 1..5)" question and I fill the form with:
+      | Question Name | Q1 |
+      | Yes | y |
+      | Question Text | Rate these movies from 1 to 5 |
+      | Possible answers | Star Wars,Casablanca,Airplane |
+    Then I should see "position 1"
+    And I should see "[Rate (scale 1..5)] (Q1)"
+    And I should see "Rate these movies from 1 to 5"
+    And I log out
+
+    And I log in as "student1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Answer the questions..." in current page administration
+    Then I should see "Test questionnaire"
+    And I should see "Rate these movies from 1 to 5"
+    And I should not see "N/A"
+    And I log out
+
+    And I log in as "teacher1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Questions" in current page administration
+    And I click on "input[title=Edit]" "css_element"
+    And I should see "Editing Rate (scale 1..5) question"
+    And I set the field "id_precise" to "1"
+    And I press "Save changes"
+    And I log out
+
+    And I log in as "student1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Answer the questions..." in current page administration
+    Then I should see "Test questionnaire"
+    And I should see "Rate these movies from 1 to 5"
+    And I should see "N/A"
diff --git a/mod/questionnaire/tests/behat/rate_question_named.feature b/mod/questionnaire/tests/behat/rate_question_named.feature
new file mode 100644
index 0000000..20667de
--- /dev/null
+++ b/mod/questionnaire/tests/behat/rate_question_named.feature
@@ -0,0 +1,51 @@
+@mod @mod_questionnaire @wip
+Feature: Rate scale questions can use names for degrees
+  In order to create questions with names for degrees
+  As a teacher
+  I need to enter a rate and specify specific named degrees
+
+@javascript
+  Scenario: Specify names for the degrees
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And I log in as "teacher1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Questions" in current page administration
+    And I add a "Rate (scale 1..5)" question and I fill the form with:
+      | Question Name | Q1 |
+      | Yes | y |
+      | Nb of scale items | 3 |
+      | Type of rate scale | Normal |
+      | Question Text | What did you think of these movies? |
+      | Possible answers | 1=I did not like,2=Ehhh,3=I liked,Star Wars,Casablanca,Airplane |
+    Then I should see "position 1"
+    And I should see "[Rate (scale 1..5)] (Q1)"
+    And I should see "What did you think of these movies?"
+    And I log out
+
+    And I log in as "student1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Answer the questions..." in current page administration
+    Then I should see "Test questionnaire"
+    And I should see "What did you think of these movies?"
+    And I should see "I did not like"
+    And I should see "Ehhh"
+    And I should see "I liked"
+    And I click on "Choice 3 for row 1" "radio"
+    And I click on "Choice 3 for row 2" "radio"
+    And I click on "Choice 3 for row 3" "radio"
+    And I press "Submit questionnaire"
diff --git a/mod/questionnaire/tests/behat/rate_question_ranking.feature b/mod/questionnaire/tests/behat/rate_question_ranking.feature
new file mode 100644
index 0000000..30da8d7
--- /dev/null
+++ b/mod/questionnaire/tests/behat/rate_question_ranking.feature
@@ -0,0 +1,48 @@
+@mod @mod_questionnaire
+Feature: Rate scale questions can be used to uniquely rank options
+  In order to create a ranking question
+  As a teacher
+  I need to enter a rate question with with "no duplicate choices" selected
+
+@javascript
+  Scenario: Add a rank the top three choices question
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And I log in as "teacher1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Questions" in current page administration
+    And I add a "Rate (scale 1..5)" question and I fill the form with:
+      | Question Name | Q1 |
+      | Yes | y |
+      | Nb of scale items | 3 |
+      | Type of rate scale | No duplicate choices |
+      | Question Text | What are your top three movies? |
+      | Possible answers | Star Wars,Casablanca,Airplane,Citizen Kane,Anchorman |
+    Then I should see "position 1"
+    And I should see "[Rate (scale 1..5)] (Q1)"
+    And I should see "What are your top three movies?"
+    And I log out
+
+    And I log in as "student1"
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Answer the questions..." in current page administration
+    Then I should see "Test questionnaire"
+    And I should see "What are your top three movies?"
+    And I click on "Choice 1 for row 1" "radio"
+    And I click on "Choice 2 for row 3" "radio"
+    And I click on "Choice 3 for row 2" "radio"
+    And I press "Submit questionnaire"
diff --git a/mod/questionnaire/tests/behat/view_questionnaire.feature b/mod/questionnaire/tests/behat/view_questionnaire.feature
new file mode 100644
index 0000000..1a3cd56
--- /dev/null
+++ b/mod/questionnaire/tests/behat/view_questionnaire.feature
@@ -0,0 +1,111 @@
+@mod @mod_questionnaire
+Feature: Questionnaires can be public, private or template
+  In order to view a questionnaire
+  As a user
+  The type of the questionnaire affects how it is displayed.
+
+@javascript
+  Scenario: Add a template questionnaire
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | manager1 | Manager | 1 | manager1@example.com |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+      | manager1 | C1 | manager |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And I log in as "manager1"
+    And I am on site homepage
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I navigate to "Advanced settings" in current page administration
+    And I should see "Content options"
+    And I set the field "id_realm" to "template"
+    And I press "Save and display"
+    Then I should see "Template questionnaires are not viewable"
+
+@javascript
+  Scenario: Add a questionnaire from a public questionnaire
+    Given the following "users" exist:
+      | username | firstname | lastname | email |
+      | manager1 | Manager | 1 | manager1@example.com |
+      | teacher1 | Teacher | 1 | teacher1@example.com |
+      | student1 | Student | 1 | student1@example.com |
+    And the following "courses" exist:
+      | fullname | shortname | category |
+      | Course 1 | C1 | 0 |
+      | Course 2 | C2 | 0 |
+    And the following "course enrolments" exist:
+      | user | course | role |
+      | teacher1 | C1 | editingteacher |
+      | student1 | C1 | student |
+      | manager1 | C1 | manager |
+      | manager1 | C2 | manager |
+      | student1 | C2 | student |
+    And the following "activities" exist:
+      | activity | name | description | course | idnumber |
+      | questionnaire | Test questionnaire | Test questionnaire description | C1 | questionnaire0 |
+    And the following config values are set as admin:
+      | coursebinenable | 0 | tool_recyclebin |
+    And I log in as "manager1"
+    And I am on site homepage
+    And I am on "Course 1" course homepage
+    And I follow "Test questionnaire"
+    And I follow "Test questionnaire"
+    And I navigate to "Questions" in current page administration
+    And I add a "Check Boxes" question and I fill the form with:
+      | Question Name | Q1 |
+      | Yes | y |
+      | Min. forced responses | 1 |
+      | Max. forced responses | 2 |
+      | Question Text | Select one or two choices only |
+      | Possible answers | One,Two,Three,Four |
+# Neither of the following steps work in 3.2, since the admin options are not available on any page but "view".
+    And I follow "Advanced settings"
+    And I should see "Content options"
+    And I set the field "id_realm" to "public"
+    And I press "Save and return to course"
+# Verify that a public questionnaire cannot be used in the same course.
+    And I turn editing mode on
+    And I add a "Questionnaire" to section "1"
+    And I expand all fieldsets
+    Then I should see "(No public questionnaires.)"
+    And I press "Cancel"
+# Verify that a public questionnaire can be used in a different course.
+    And I am on site homepage
+    And I am on "Course 2" course homepage
+    And I add a "Questionnaire" to section "1"
+    And I expand all fieldsets
+    And I set the field "name" to "Questionnaire from public"
+    And I click on "Test questionnaire [Course 1]" "radio"
+    And I press "Save and return to course"
+    And I log out
+    And I log in as "student1"
+    And I am on "Course 2" course homepage
+    And I follow "Questionnaire from public"
+    Then I should see "Answer the questions..."
+# Verify message for public questionnaire that has been deleted.
+    And I log out
+    And I log in as "manager1"
+    And I am on site homepage
+    And I am on "Course 1" course homepage
+    And I turn editing mode on
+    And I delete "Test questionnaire" activity
+    And I am on site homepage
+    And I am on "Course 2" course homepage
+    And I follow "Questionnaire from public"
+    Then I should see "This questionnaire used to depend on a Public questionnaire which has been deleted."
+    And I should see "It can no longer be used and should be deleted."
+    And I log out
+    And I log in as "student1"
+    And I am on "Course 2" course homepage
+    And I follow "Questionnaire from public"
+    Then I should see "This questionnaire is no longer available. Ask your teacher to delete it."
\ No newline at end of file
diff --git a/mod/questionnaire/tests/generator/lib.php b/mod/questionnaire/tests/generator/lib.php
new file mode 100644
index 0000000..a7eb2a4
--- /dev/null
+++ b/mod/questionnaire/tests/generator/lib.php
@@ -0,0 +1,750 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * mod_questionnaire data generator
+ *
+ * @package    mod_questionnaire
+ * @copyright  2015 Mike Churchward (mike@churchward.ca)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+
+defined('MOODLE_INTERNAL') || die();
+
+use mod_questionnaire\generator\question_response,
+    mod_questionnaire\generator\question_response_rank,
+    mod_questionnaire\question\base;
+
+global $CFG;
+require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+class mod_questionnaire_generator extends testing_module_generator {
+
+    /**
+     * @var int keep track of how many questions have been created.
+     */
+    protected $questioncount = 0;
+
+    /**
+     * @var int
+     */
+    protected $responsecount = 0;
+
+    /**
+     * @var questionnaire[]
+     */
+    protected $questionnaires = [];
+
+    /**
+     * To be called from data reset code only,
+     * do not use in tests.
+     * @return void
+     */
+    public function reset() {
+        $this->questioncount = 0;
+
+        $this->responsecount = 0;
+
+        $this->questionnaires = [];
+
+        parent::reset();
+    }
+
+    /**
+     * Acessor for questionnaires.
+     *
+     * @return array
+     */
+    public function questionnaires() {
+        return $this->questionnaires;
+    }
+
+    /**
+     * Create a questionnaire activity.
+     * @param array $record Will be changed in this function.
+     * @param array $options
+     * @return questionnaire
+     */
+    public function create_instance($record = array(), array $options = array()) {
+        if (is_array($record)) {
+            $record = (object)$record;
+        }
+
+        $defaultquestionnairesettings = array(
+            'qtype'                 => 0,
+            'respondenttype'        => 'fullname',
+            'resp_eligible'         => 'all',
+            'resp_view'             => 0,
+            'useopendate'           => true, // Used in form only to indicate opendate can be used.
+            'opendate'              => 0,
+            'useclosedate'          => true, // Used in form only to indicate closedate can be used.
+            'closedate'             => 0,
+            'resume'                => 0,
+            'navigate'              => 0,
+            'grade'                 => 0,
+            'sid'                   => 0,
+            'timemodified'          => time(),
+            'completionsubmit'      => 0,
+            'autonum'               => 3,
+            'create'                => 'new-0', // Used in form only to indicate a new, empty instance.
+        );
+
+        foreach ($defaultquestionnairesettings as $name => $value) {
+            if (!isset($record->{$name})) {
+                $record->{$name} = $value;
+            }
+        }
+
+        $instance = parent::create_instance($record, $options);
+        $cm = get_coursemodule_from_instance('questionnaire', $instance->id);
+        $course = get_course($cm->course);
+        $questionnaire = new questionnaire(0, $instance, $course, $cm, false);
+
+        $this->questionnaires[$instance->id] = $questionnaire;
+
+        return $questionnaire;
+    }
+
+    /**
+     * Create a survey instance with data from an existing questionnaire object.
+     * @param object $questionnaire
+     * @param array $options
+     * @return int
+     */
+    public function create_content($questionnaire, $record = array()) {
+        global $DB;
+
+        $survey = $DB->get_record('questionnaire_survey', array('id' => $questionnaire->sid), '*', MUST_EXIST);
+        foreach ($record as $name => $value) {
+            $survey->{$name} = $value;
+        }
+        return $questionnaire->survey_update($survey);
+    }
+
+    /**
+     * Function to create a question.
+     *
+     * @param questionnaire $questionnaire
+     * @param array|stdClass $record
+     * @param array|stdClass $data - accompanying data for question - e.g. choices
+     * @return \mod_questionnaire\question\base the question object
+     */
+    public function create_question(questionnaire $questionnaire, $record = null, $data = null) {
+        global $DB;
+
+        // Increment the question count.
+        $this->questioncount++;
+
+        $record = (array)$record;
+
+        $record['position'] = count($questionnaire->questions);
+
+        if (!isset($record['survey_id'])) {
+            throw new coding_exception('survey_id must be present in phpunit_util::create_question() $record');
+        }
+
+        if (!isset($record['name'])) {
+            throw new coding_exception('name must be present in phpunit_util::create_question() $record');
+        }
+
+        if (!isset($record['type_id'])) {
+            throw new coding_exception('typeid must be present in phpunit_util::create_question() $record');
+        }
+
+        if (!isset($record['content'])) {
+            $record['content'] = 'Random '.$this->type_str($record['type_id']).' '.uniqid();
+        }
+
+        // Get question type.
+        $typeid = $record['type_id'];
+
+        if ($typeid === QUESRATE && !isset($record['length'])) {
+            $record['length'] = 5;
+        }
+
+        if ($typeid !== QUESPAGEBREAK && $typeid !== QUESSECTIONTEXT) {
+            $qtype = $DB->get_record('questionnaire_question_type', ['id' => $typeid]);
+            if (!$qtype) {
+                throw new coding_exception('Could not find question type with id ' . $typeid);
+            }
+            // Throw an error if this requires choices and it hasn't got them.
+            $this->validate_question($qtype->typeid, $data);
+        }
+
+        $record = (object)$record;
+
+        // Add the question.
+        $record->id = $DB->insert_record('questionnaire_question', $record);
+
+        $question = \mod_questionnaire\question\base::question_builder($record->type_id, $record->id, $record);
+
+        // Add the question choices if required.
+        if ($typeid !== QUESPAGEBREAK && $typeid !== QUESSECTIONTEXT) {
+            if ($question->has_choices()) {
+                $this->add_question_choices($question, $data);
+                $record->opts = $data;
+            }
+        }
+
+        // Update questionnaire.
+        $questionnaire->add_questions();
+
+        return $question;
+    }
+
+    /**
+     * Create a questionnaire with questions and response data for use in other tests.
+     */
+    public function create_test_questionnaire($course, $qtype = null, $questiondata = array(), $choicedata = null) {
+        $questionnaire = $this->create_instance(array('course' => $course->id));
+        $cm = get_coursemodule_from_instance('questionnaire', $questionnaire->id);
+        if ($qtype !== null) {
+            $questiondata['type_id'] = $qtype;
+            $questiondata['survey_id'] = $questionnaire->sid;
+            $questiondata['name'] = isset($questiondata['name']) ? $questiondata['name'] : 'Q1';
+            $questiondata['content'] = isset($questiondata['content']) ? $questiondata['content'] : 'Test content';
+            $this->create_question($questionnaire, $questiondata, $choicedata);
+        }
+        $questionnaire = new questionnaire($questionnaire->id, null, $course, $cm, true);
+        return $questionnaire;
+    }
+
+    /**
+     * Create a reponse to the supplied question.
+     */
+    public function create_question_response($questionnaire, $question, $respval, $userid = 1, $section = 1) {
+        global $DB;
+        $currentrid = 0;
+        $_POST['q'.$question->id] = $respval;
+        $responseid = $questionnaire->response_insert($question->survey_id, $section, $currentrid, $userid);
+        $this->response_commit($questionnaire, $responseid);
+        questionnaire_record_submission($questionnaire, $userid, $responseid);
+        return $DB->get_record('questionnaire_response', array('id' => $responseid));
+        // TO DO - look at the implementing Guy's code below.
+        /* $responses[] = new question_response($question->id, 'Test answer');
+        return $this->create_response(['survey_id' => $questionnaire->sid, 'userid' => $userid], $responses); */
+    }
+
+    /**
+     * Need to create a method to access a private questionnaire method.
+     * TO DO - may not need this with above "TO DO".
+     */
+    private function response_commit($questionnaire, $responseid) {
+        $method = new ReflectionMethod('questionnaire', 'response_commit');
+        $method->setAccessible(true);
+        return $method->invoke($questionnaire, $responseid);
+    }
+
+    /**
+     * Validate choice question type
+     * @param $data
+     * @throws coding_exception
+     */
+    protected function validate_question_choice($data) {
+        if (empty($data)) {
+            throw new coding_exception('You must pass in an array of choices for the choice question type');
+        }
+    }
+
+    /**
+     * Validate radio question type
+     * @param $data
+     * @throws coding_exception
+     */
+    protected function validate_question_radio($data) {
+        if (empty($data)) {
+            throw new coding_exception('You must pass in an array of choices for the radio question type');
+        }
+    }
+
+    /**
+     * Validate checkbox question type
+     * @param $data
+     * @throws coding_exception
+     */
+    protected function validate_question_check($data) {
+        if (empty($data)) {
+            throw new coding_exception('You must pass in an array of choices for the checkbox question type');
+        }
+    }
+
+    /**
+     * Validate rating question type
+     * @param $data
+     * @throws coding_exception
+     */
+    protected function validate_question_rate($data) {
+        if (empty($data)) {
+            throw new coding_exception('You must pass in an array of choices for the rate question type');
+        }
+    }
+
+    /**
+     * Thrown an error if the question isn't receiving the data it should receive.
+     * @param string $typeid
+     * @param $data
+     * @throws coding_exception
+     */
+    protected function validate_question($typeid, $data) {
+        if ($typeid == QUESCHOOSE) {
+            $this->validate_question_choice($data);
+        } else if ($typeid === QUESRADIO) {
+            $this->validate_question_radio($data);
+        } else if ($typeid === QUESCHECK) {
+            $this->validate_question_check($data);
+        } else if ($typeid === QUESRATE) {
+            $this->validate_question_rate($data);
+        }
+    }
+
+    /**
+     * Add choices to question.
+     *
+     * @param \mod_questionnaire\question\base $question
+     * @param stdClass $data
+     */
+    protected function add_question_choices($question, $data) {
+        foreach ($data as $content) {
+            if (!is_object($content)) {
+                $content = (object)[
+                    'content' => $content,
+                    'value' => $content
+                ];
+            }
+            $record = (object)[
+                'question_id' => $question->id,
+                'content' => $content->content,
+                'value' => $content->value
+            ];
+            $question->add_choice($record);
+        }
+    }
+
+    /**
+     * TODO - use question object
+     * Does this question have choices.
+     * @param $typeid
+     * @return bool
+     */
+    public function question_has_choices($typeid) {
+        $choicequestions = [QUESCHOOSE, QUESRADIO, QUESCHECK, QUESDROP, QUESRATE];
+        return in_array($typeid, $choicequestions);
+    }
+
+    public function type_str($qtypeid) {
+        switch ($qtypeid) {
+            case QUESYESNO:
+                $qtype = 'yesno';
+                break;
+            case QUESTEXT:
+                $qtype = 'textbox';
+                break;
+            case QUESESSAY:
+                $qtype = 'essaybox';
+                break;
+            case QUESRADIO:
+                $qtype = 'radiobuttons';
+                break;
+            case QUESCHECK:
+                $qtype = 'checkboxes';
+                break;
+            case QUESDROP:
+                $qtype = 'dropdown';
+                break;
+            case QUESRATE:
+                $qtype = 'ratescale';
+                break;
+            case QUESDATE:
+                $qtype = 'date';
+                break;
+            case QUESNUMERIC:
+                $qtype = 'numeric';
+                break;
+            case QUESSECTIONTEXT:
+                $qtype = 'sectiontext';
+                break;
+            case QUESPAGEBREAK:
+                $qtype = 'sectionbreak';
+        }
+        return $qtype;
+    }
+
+    public function type_name($qtypeid) {
+        switch ($qtypeid) {
+            case QUESYESNO:
+                $qtype = 'Yes / No';
+                break;
+            case QUESTEXT:
+                $qtype = 'Text Box';
+                break;
+            case QUESESSAY:
+                $qtype = 'Essay Box';
+                break;
+            case QUESRADIO:
+                $qtype = 'Radio Buttons';
+                break;
+            case QUESCHECK:
+                $qtype = 'Check Boxes';
+                break;
+            case QUESDROP:
+                $qtype = 'Drop Down';
+                break;
+            case QUESRATE:
+                $qtype = 'Rate Scale';
+                break;
+            case QUESDATE:
+                $qtype = 'Date';
+                break;
+            case QUESNUMERIC:
+                $qtype = 'Numeric';
+                break;
+            case QUESSECTIONTEXT:
+                $qtype = 'Section Text';
+                break;
+            case QUESPAGEBREAK:
+                $qtype = 'Section Break';
+        }
+        return $qtype;
+    }
+
+    protected function add_response_choice($questionresponse, $responseid) {
+        global $DB;
+
+        $question = $DB->get_record('questionnaire_question', ['id' => $questionresponse->questionid]);
+        $qtype = intval($question->type_id);
+
+        if (is_array($questionresponse->response)) {
+            foreach ($questionresponse->response as $choice) {
+                $newresponse = clone($questionresponse);
+                $newresponse->response = $choice;
+                $this->add_response_choice($newresponse, $responseid);
+            }
+            return;
+        }
+
+        if ($qtype === QUESCHOOSE || $qtype === QUESRADIO || $qtype === QUESDROP || $qtype === QUESCHECK || $qtype === QUESRATE) {
+            if (is_int($questionresponse->response)) {
+                $choiceid = $questionresponse->response;
+            } else {
+                if ($qtype === QUESRATE) {
+                    if (!$questionresponse->response instanceof question_response_rank) {
+                        throw new coding_exception('Question response for ranked choice should be of type question_response_rank');
+                    }
+                    $choiceval = $questionresponse->response->choice->content;
+                } else {
+                    if (!is_object($questionresponse->response)) {
+                        $choiceval = $questionresponse->response;
+                    } else {
+                        if ($questionresponse->response->content.'' === '') {
+                            throw new coding_exception('Question response cannot be null for question type '.$qtype);
+                        }
+                        $choiceval = $questionresponse->response->content;
+                    }
+
+                }
+
+                // Lookup the choice id.
+                $comptext = $DB->sql_compare_text('content');
+                $select = 'WHERE question_id = ? AND '.$comptext.' = ?';
+
+                $params = [intval($question->id), $choiceval];
+                $rs = $DB->get_records_sql("SELECT * FROM {questionnaire_quest_choice} $select", $params, 0, 1);
+                $choice = reset($rs);
+                if (!$choice) {
+                    throw new coding_exception('Could not find choice for "'.$choiceval.
+                        '" (question_id = '.$question->id.')', var_export($choiceval, true));
+                }
+                $choiceid = $choice->id;
+
+            }
+            if ($qtype == QUESRATE) {
+                $DB->insert_record('questionnaire_response_rank', [
+                        'response_id' => $responseid,
+                        'question_id' => $questionresponse->questionid,
+                        'choice_id' => $choiceid,
+                        'rank' => $questionresponse->response->rank
+                    ]
+                );
+            } else {
+                if ($qtype === QUESCHOOSE || $qtype === QUESRADIO || $qtype === QUESDROP) {
+                    $instable = 'questionnaire_resp_single';
+                } else if ($qtype === QUESCHECK) {
+                    $instable = 'questionnaire_resp_multiple';
+                }
+                $DB->insert_record($instable, [
+                        'response_id' => $responseid,
+                        'question_id' => $questionresponse->questionid,
+                        'choice_id' => $choiceid
+                    ]
+                );
+            }
+        } else {
+            $DB->insert_record('questionnaire_response_text', [
+                    'response_id' => $responseid,
+                    'question_id' => $questionresponse->questionid,
+                    'response' => $questionresponse->response
+                ]
+            );
+        }
+    }
+
+    /**
+     * Create response to questionnaire.
+     *
+     * @param array|stdClass $record
+     * @param array $questionresponses
+     * @return stdClass the discussion object
+     */
+    public function create_response($record = null, $questionresponses) {
+        global $DB;
+
+        // Increment the response count.
+        $this->responsecount++;
+
+        $record = (array)$record;
+
+        if (!isset($record['survey_id'])) {
+            throw new coding_exception('survey_id must be present in phpunit_util::create_response() $record');
+        }
+
+        if (!isset($record['userid'])) {
+            throw new coding_exception('userid must be present in phpunit_util::create_response() $record');
+        }
+
+        $record['submitted'] = time() + $this->responsecount;
+
+        // Add the response.
+        $record['id'] = $DB->insert_record('questionnaire_response', $record);
+        $responseid = $record['id'];
+
+        foreach ($questionresponses as $questionresponse) {
+            if (!$questionresponse instanceof question_response) {
+                throw new coding_exception('Question responses must have an instance of question_response'.
+                    var_export($questionresponse, true));
+            }
+            $this->add_response_choice($questionresponse, $responseid);
+        }
+
+        // Mark response as complete.
+        $record['complete'] = 'y';
+        $DB->update_record('questionnaire_response', $record);
+
+        // Create attempt record.
+        $attempt = ['qid' => $record['survey_id'], 'userid' => $record['userid'], 'rid' => $record['id'],
+            'timemodified' => time()];
+        $DB->insert_record('questionnaire_attempts', $attempt);
+
+        return $record;
+    }
+
+
+    /**
+     * @param int $number
+     *
+     * Generate an array of assigned options;
+     */
+    public function assign_opts($number = 5) {
+        static $curpos = 0;
+
+        $opts = 'blue, red, yellow, orange, green, purple, white, black, earth, wind, fire, space, car, truck, train' .
+            ', van, tram, one, two, three, four, five, six, seven, eight, nine, ten, eleven, twelve, thirteen' .
+            ', fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty, happy, sad, jealous, angry';
+        $opts = explode (', ', $opts);
+        $numopts = count($opts);
+
+        if ($number > (count($opts) / 2)) {
+            throw new coding_exception('Maxiumum number of options is '.($opts / 2));
+        }
+
+        $retopts = [];
+        while (count($retopts) < $number) {
+            $retopts[] = $opts[$curpos];
+            $retopts = array_unique($retopts);
+            if (++$curpos == $numopts) {
+                $curpos = 0;
+            }
+        }
+        // Return re-indexed version of array (otherwise you can get a weird index of 1,2,5,9, etc).
+        return array_values($retopts);
+    }
+
+    /**
+     * @param questionnaire $questionnaire
+     * @param \mod_questionnaire\question\base[] $questions
+     * @param $userid
+     * @return stdClass
+     * @throws coding_exception
+     */
+    public function generate_response($questionnaire, $questions, $userid) {
+        $responses = [];
+        foreach ($questions as $question) {
+
+            $choices = [];
+            if ($question->has_choices()) {
+                $choices = array_values($question->choices);
+            }
+
+            switch ($question->type_id) {
+                case QUESTEXT :
+                    $responses[] = new question_response($question->id, 'Test answer');
+                    break;
+                case QUESESSAY :
+                    $resptext = '<h1>Some header text</h1><p>Some paragraph text</p>';
+                    $responses[] = new question_response($question->id, $resptext);
+                    break;
+                case QUESNUMERIC :
+                    $responses[] = new question_response($question->id, 83);
+                    break;
+                case QUESDATE :
+                    $date = mktime(0, 0, 0, 12, 28, date('Y'));
+                    $dateformat = get_string('strfdate', 'questionnaire');
+                    $datestr = userdate ($date, $dateformat, '1', false);
+                    $responses[] = new question_response($question->id, $datestr);
+                    break;
+                case QUESRADIO :
+                case QUESDROP :
+                    $optidx = count($choices) - 1;
+                    $responses[] = new question_response($question->id, $choices[$optidx]);
+                    break;
+                case QUESCHECK :
+                    $answers = [];
+                    for ($a = 0; $a < count($choices) - 1; $a++) {
+                        $optidx = count($choices) - 1;
+                        $answers[] = $choices[$optidx]->content;
+                    }
+
+                    $answers = array_unique($answers);
+
+                    $responses[] = new question_response($question->id, $answers);
+                    break;
+                case QUESRATE :
+                    $answers = [];
+                    for ($a = 0; $a < count($choices) - 1; $a++) {
+                        $answers[] = new question_response_rank($choices[$a], ($a % 5));
+                    }
+                    $responses[] = new question_response($question->id, $answers);
+                    break;
+            }
+
+        }
+        return $this->create_response(['survey_id' => $questionnaire->sid, 'userid' => $userid], $responses);
+    }
+
+    public function create_and_fully_populate($coursecount = 4, $studentcount = 20, $questionnairecount = 2,
+            $questionspertype = 5) {
+        global $DB;
+
+        $dg = $this->datagenerator;
+        $qdg = $this;
+
+        $questiontypes = [QUESTEXT, QUESESSAY, QUESNUMERIC, QUESDATE, QUESRADIO, QUESDROP, QUESCHECK, QUESRATE];
+
+        $totalquestions = $coursecount * $questionnairecount * ($questionspertype * count($questiontypes));
+        $totalquestionresponses = $studentcount * $totalquestions;
+        mtrace($coursecount.' courses * '.$questionnairecount.' questionnaires * '.($questionspertype * count($questiontypes)).
+            ' questions = '.$totalquestions.' total questions');
+        mtrace($totalquestions.' total questions * '.$studentcount.' resondees = '.$totalquestionresponses.
+            ' total question responses');
+
+        $questionsprocessed = 0;
+
+        $students = [];
+        $courses = [];
+
+        $questionnaires = [];
+
+        for ($u = 0; $u < $studentcount; $u++) {
+            $students[] = $dg->create_user();
+        }
+
+        $manplugin = enrol_get_plugin('manual');
+
+        // Create courses.
+        for ($c = 0; $c < $coursecount; $c++) {
+            $course = $dg->create_course();
+            $courses[] = $course;
+
+            // Enrol students on course.
+            $manualenrol = $DB->get_record('enrol', array('courseid' => $course->id, 'enrol' => 'manual'));
+            foreach ($students as $student) {
+                $studentrole = $DB->get_record('role', array('shortname' => 'student'));
+                $manplugin->enrol_user($manualenrol, $student->id, $studentrole->id);
+            }
+        }
+
+        // Create questionnaires in each course.
+        for ($q = 0; $q < $questionnairecount; $q++) {
+            $coursesprocessed = 0;
+            foreach ($courses as $course) {
+                $questionnaire = $qdg->create_instance(['course' => $course->id]);
+                $questionnaires[] = $questionnaire;
+                $questions = [];
+                foreach ($questiontypes as $questiontype) {
+                    // Add section text for this question.
+                    $qdg->create_question(
+                        $questionnaire,
+                        [
+                            'survey_id' => $questionnaire->sid,
+                            'name'      => $qdg->type_name($questiontype),
+                            'type_id'   => QUESSECTIONTEXT
+                        ]
+                    );
+                    // Create questions.
+                    for ($qpt = 0; $qpt < $questionspertype; $qpt++) {
+                        $opts = null;
+                        if ($qdg->question_has_choices($questiontype)) {
+                            $opts = $qdg->assign_opts(10);
+                        }
+                        $questions[] = $qdg->create_question(
+                            $questionnaire,
+                            [
+                                'survey_id' => $questionnaire->sid,
+                                'name'      => uniqid($qdg->type_name($questiontype).' '),
+                                'type_id'   => $questiontype
+                            ],
+                            $opts
+                        );
+                    }
+                    // Add page break.
+                    $qdg->create_question(
+                        $questionnaire,
+                        [
+                            'survey_id' => $questionnaire->sid,
+                            'name' => uniqid('pagebreak '),
+                            'type_id' => QUESPAGEBREAK
+                        ]
+                    );
+                    $questionsprocessed++;
+                    mtrace($questionsprocessed.' questions processed out of '.$totalquestions);
+                }
+
+                // Create responses.
+                mtrace('Creating responses');
+                foreach ($students as $student) {
+                    $qdg->generate_response($questionnaire, $questions, $student->id);
+                }
+                mtrace('Responses created');
+
+                $coursesprocessed++;
+                mtrace($coursesprocessed.' courses processed out of '.$coursecount);
+
+            }
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/tests/generator_test.php b/mod/questionnaire/tests/generator_test.php
new file mode 100644
index 0000000..ec221f9
--- /dev/null
+++ b/mod/questionnaire/tests/generator_test.php
@@ -0,0 +1,94 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * PHPUnit questionnaire generator tests
+ *
+ * @package    mod_questionnaire
+ * @copyright  2015 Mike Churchward (mike@churchward.ca)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+/**
+ * Unit tests for {@link questionnaire_generator_testcase}.
+ * @group mod_questionnaire
+ */
+class mod_questionnaire_generator_testcase extends advanced_testcase {
+    public function test_create_instance() {
+        global $DB;
+
+        $this->resetAfterTest(true);
+
+        $course = $this->getDataGenerator()->create_course();
+        $this->assertFalse($DB->record_exists('questionnaire', array('course' => $course->id)));
+
+        /** @var mod_questionnaire_generator $generator */
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $this->assertInstanceOf('mod_questionnaire_generator', $generator);
+        $this->assertEquals('questionnaire', $generator->get_modulename());
+
+        $questionnaire = $generator->create_instance(array('course' => $course->id));
+        $this->assertEquals(1, $DB->count_records('questionnaire'));
+
+        $cm = get_coursemodule_from_instance('questionnaire', $questionnaire->id);
+        $this->assertEquals($questionnaire->id, $cm->instance);
+        $this->assertEquals('questionnaire', $cm->modname);
+        $this->assertEquals($course->id, $cm->course);
+
+        $context = context_module::instance($cm->id);
+        $this->assertEquals($questionnaire->cmid, $context->instanceid);
+
+        $survey = $DB->get_record('questionnaire_survey', array('id' => $questionnaire->sid));
+        $this->assertEquals($survey->id, $questionnaire->sid);
+        $this->assertEquals($questionnaire->name, $survey->name);
+        $this->assertEquals($questionnaire->name, $survey->title);
+
+        // Should test creating a public questionnaire, template questionnaire and creating one from a template.
+
+        // Should test event creation if open dates and close dates are specified?
+    }
+
+    public function test_create_content() {
+        global $DB;
+
+        $this->resetAfterTest(true);
+
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questionnaire = $generator->create_instance(array('course' => $course->id));
+        $cm = get_coursemodule_from_instance('questionnaire', $questionnaire->id);
+        $questionnaire = new questionnaire($questionnaire->id, null, $course, $cm, false);
+
+        $newcontent = array(
+            'title'         => 'New title',
+            'email'         => 'test@email.com',
+            'subtitle'      => 'New subtitle',
+            'info'          => 'New info',
+            'thanks_page'   => 'http://thankurl.com',
+            'thank_head'    => 'New thank header',
+            'thank_body'    => 'New thank body',
+        );
+        $sid = $generator->create_content($questionnaire, $newcontent);
+        $this->assertEquals($sid, $questionnaire->sid);
+        $survey = $DB->get_record('questionnaire_survey', array('id' => $sid));
+        foreach ($newcontent as $name => $value) {
+            $this->assertEquals($survey->{$name}, $value);
+        }
+    }
+}
\ No newline at end of file
diff --git a/mod/questionnaire/tests/lib_test.php b/mod/questionnaire/tests/lib_test.php
new file mode 100644
index 0000000..c2b2bc9
--- /dev/null
+++ b/mod/questionnaire/tests/lib_test.php
@@ -0,0 +1,260 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * PHPUnit questionnaire generator tests
+ *
+ * @package    mod_questionnaire
+ * @copyright  2015 Mike Churchward (mike@churchward.ca)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+use mod_questionnaire\question\base;
+
+global $CFG;
+require_once($CFG->dirroot.'/mod/questionnaire/lib.php');
+require_once($CFG->dirroot.'/mod/questionnaire/classes/question/base.php');
+
+/**
+ * Unit tests for {@link questionnaire_lib_testcase}.
+ * @group mod_questionnaire
+ */
+class mod_questionnaire_lib_testcase extends advanced_testcase {
+    public function test_questionnaire_supports() {
+        $this->assertTrue(questionnaire_supports(FEATURE_BACKUP_MOODLE2));
+        $this->assertFalse(questionnaire_supports(FEATURE_COMPLETION_TRACKS_VIEWS));
+        $this->assertTrue(questionnaire_supports(FEATURE_COMPLETION_HAS_RULES));
+        $this->assertFalse(questionnaire_supports(FEATURE_GRADE_HAS_GRADE));
+        $this->assertFalse(questionnaire_supports(FEATURE_GRADE_OUTCOMES));
+        $this->assertTrue(questionnaire_supports(FEATURE_GROUPINGS));
+        $this->assertTrue(questionnaire_supports(FEATURE_GROUPMEMBERSONLY));
+        $this->assertTrue(questionnaire_supports(FEATURE_GROUPS));
+        $this->assertTrue(questionnaire_supports(FEATURE_MOD_INTRO));
+        $this->assertTrue(questionnaire_supports(FEATURE_SHOW_DESCRIPTION));
+        $this->assertNull(questionnaire_supports('unknown option'));
+    }
+
+    public function test_questionnaire_get_extra_capabilities() {
+        $caps = questionnaire_get_extra_capabilities();
+        $this->assertInternalType('array', $caps);
+        $this->assertEquals(1, count($caps));
+        $this->assertEquals('moodle/site:accessallgroups', reset($caps));
+    }
+
+    public function test_add_instance() {
+        global $DB;
+
+        $this->resetAfterTest();
+        $this->setAdminUser();
+        $course = $this->getDataGenerator()->create_course();
+
+        // Create test data as a record.
+        $questdata = new stdClass();
+        $questdata->course = $course->id;
+        $questdata->name = 'Test questionnaire';
+        $questdata->intro = 'Intro to test questionnaire.';
+        $questdata->introformat = FORMAT_HTML;
+        $questdata->qtype = 1;
+        $questdata->respondenttype = 'anonymous';
+        $questdata->resp_eligible = 'none';
+        $questdata->resp_view = 2;
+        $questdata->opendate = 99;
+        $questdata->closedate = 50;
+        $questdata->resume = 1;
+        $questdata->navigate = 1;
+        $questdata->grade = 100;
+        $questdata->sid = 1;
+        $questdata->timemodified = 3;
+        $questdata->completionsubmit = 1;
+        $questdata->autonum = 1;
+
+        // Call add_instance with the data.
+        $this->assertTrue(questionnaire_add_instance($questdata) > 0);
+    }
+
+    public function test_update_instance() {
+        global $DB;
+
+        $this->resetAfterTest();
+        $this->setAdminUser();
+        $course = $this->getDataGenerator()->create_course();
+        /** @var mod_questionnaire_generator $generator */
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        /** @var questionnaire $questionnaire */
+        $questionnaire = $generator->create_instance(array('course' => $course->id, 'sid' => 1));
+
+        $qid = $questionnaire->id;
+        $this->assertTrue($qid > 0);
+
+        // Change all the default values.
+        // Note, we need to get the actual db row to do an update to it.
+        $qrow = $DB->get_record('questionnaire', ['id' => $qid]);
+        $qrow->qtype = 1;
+        $qrow->respondenttype = 'anonymous';
+        $qrow->resp_eligible = 'none';
+        $qrow->resp_view = 2;
+        $qrow->useopendate = true;
+        $qrow->opendate = 99;
+        $qrow->useclosedate = true;
+        $qrow->closedate = 50;
+        $qrow->resume = 1;
+        $qrow->navigate = 1;
+        $qrow->grade = 100;
+        $qrow->timemodified = 3;
+        $qrow->completionsubmit = 1;
+        $qrow->autonum = 1;
+
+        // Moodle update form passes "instance" instead of "id" to [mod]_update_instance.
+        $qrow->instance = $qid;
+        // Grade function needs the "cm" "idnumber" field.
+        $qrow->cmidnumber = '';
+
+        $this->assertTrue(questionnaire_update_instance($qrow));
+
+        $questrecord = $DB->get_record('questionnaire', array('id' => $qid));
+        $this->assertNotEmpty($questrecord);
+        $this->assertEquals($qrow->qtype, $questrecord->qtype);
+        $this->assertEquals($qrow->respondenttype, $questrecord->respondenttype);
+        $this->assertEquals($qrow->resp_eligible, $questrecord->resp_eligible);
+        $this->assertEquals($qrow->resp_view, $questrecord->resp_view);
+        $this->assertEquals($qrow->opendate, $questrecord->opendate);
+        $this->assertEquals($qrow->closedate, $questrecord->closedate);
+        $this->assertEquals($qrow->resume, $questrecord->resume);
+        $this->assertEquals($qrow->navigate, $questrecord->navigate);
+        $this->assertEquals($qrow->grade, $questrecord->grade);
+        $this->assertEquals($qrow->sid, $questrecord->sid);
+        $this->assertEquals($qrow->timemodified, $questrecord->timemodified);
+        $this->assertEquals($qrow->completionsubmit, $questrecord->completionsubmit);
+        $this->assertEquals($qrow->autonum, $questrecord->autonum);
+    }
+
+    /*
+     * Need to verify that delete_instance deletes all data associated with a questionnaire.
+     *
+     */
+    public function test_delete_instance() {
+        global $DB;
+
+        $this->resetAfterTest();
+        $this->setAdminUser();
+
+        // Set up a new questionnaire.
+        $questiondata = array();
+        $questiondata['content'] = 'Enter yes or no';
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questionnaire = $generator->create_test_questionnaire($course, QUESYESNO, $questiondata);
+
+        $question = reset($questionnaire->questions);
+
+        // Add a response for the question.
+        $response = $generator->create_question_response($questionnaire, $question, 'y');
+
+        // Get records for database deletion confirmation.
+        $survey = $DB->get_record('questionnaire_survey', array('id' => $questionnaire->sid));
+
+        // Now delete it all.
+        $this->assertTrue(questionnaire_delete_instance($questionnaire->id));
+        $this->assertEmpty($DB->get_record('questionnaire', array('id' => $questionnaire->id)));
+        $this->assertEmpty($DB->get_record('questionnaire_survey', array('id' => $questionnaire->sid)));
+        $this->assertEmpty($DB->get_records('questionnaire_question', array('survey_id' => $survey->id)));
+        $this->assertEmpty($DB->get_records('questionnaire_response', array('survey_id' => $survey->id)));
+        $this->assertEmpty($DB->get_records('questionnaire_attempts', array('qid' => $questionnaire->id)));
+        $this->assertEmpty($DB->get_records('questionnaire_response_bool', array('response_id' => $response->id)));
+        $this->assertEmpty($DB->get_records('event', array("modulename" => 'questionnaire', "instance" => $questionnaire->id)));
+    }
+
+    public function test_questionnaire_user_outline() {
+        $this->resetAfterTest();
+        $this->setAdminUser();
+        $user = $this->getDataGenerator()->create_user();
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questiondata = array();
+        $questiondata['content'] = 'Enter yes or no';
+        $questionnaire = $generator->create_test_questionnaire($course, QUESYESNO, $questiondata);
+
+        // Test for correct "no response" values.
+        $outline = questionnaire_user_outline($course, $user, null, $questionnaire);
+        $this->assertEquals(get_string("noresponses", "questionnaire"), $outline->info);
+
+        // Test for a user with one response.
+        $response = $generator->create_question_response($questionnaire, reset($questionnaire->questions), 'y', $user->id);
+        $outline = questionnaire_user_outline($course, $user, null, $questionnaire);
+        $this->assertEquals('1 '.get_string("response", "questionnaire"), $outline->info);
+    }
+
+    public function test_questionnaire_user_complete() {
+        $this->resetAfterTest();
+        $this->setAdminUser();
+        $user = $this->getDataGenerator()->create_user();
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questionnaire = $generator->create_test_questionnaire($course, QUESYESNO);
+
+        $this->assertTrue(questionnaire_user_complete($course, $user, null, $questionnaire));
+        $this->expectOutputString(get_string('noresponses', 'questionnaire'));
+    }
+
+    public function test_questionnaire_print_recent_activity() {
+        $this->resetAfterTest();
+        $this->setAdminUser();
+        $this->assertFalse(questionnaire_print_recent_activity(null, null, null));
+    }
+
+    public function test_questionnaire_grades() {
+        $this->resetAfterTest();
+        $this->setAdminUser();
+        $this->assertNull(questionnaire_grades(null));
+    }
+
+    public function test_questionnaire_get_user_grades() {
+        $this->resetAfterTest();
+        $this->setAdminUser();
+
+        $user = $this->getDataGenerator()->create_user();
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questionnaire = $generator->create_test_questionnaire($course);
+
+        // Test for an array when user specified.
+        $grades = questionnaire_get_user_grades($questionnaire, $user->id);
+        $this->assertInternalType('array', $grades);
+
+        // Test for an array when no user specified.
+        $grades = questionnaire_get_user_grades($questionnaire);
+        $this->assertInternalType('array', $grades);
+    }
+
+    public function test_questionnaire_update_grades() {
+        // Don't know how to test this yet! It doesn't return anything.
+        $this->assertNull(questionnaire_update_grades());
+    }
+
+    public function test_questionnaire_grade_item_update() {
+        $this->resetAfterTest();
+        $this->setAdminUser();
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questionnaire = $generator->create_test_questionnaire($course);
+        $questionnaire->cmidnumber = $questionnaire->cm->idnumber;
+        $questionnaire->courseid = $questionnaire->course->id;
+        $this->assertEquals(GRADE_UPDATE_OK, questionnaire_grade_item_update($questionnaire));
+    }
+}
diff --git a/mod/questionnaire/tests/questiontypes_test.php b/mod/questionnaire/tests/questiontypes_test.php
new file mode 100644
index 0000000..bc398e7
--- /dev/null
+++ b/mod/questionnaire/tests/questiontypes_test.php
@@ -0,0 +1,151 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * PHPUnit questionnaire generator tests
+ *
+ * @package    mod_questionnaire
+ * @copyright  2015 Mike Churchward (mike@churchward.ca)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+use mod_questionnaire\question\base;
+
+global $CFG;
+require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+
+/**
+ * Unit tests for {@link questionnaire_questiontypes_testcase}.
+ * @group mod_questionnaire
+ */
+class mod_questionnaire_questiontypes_testcase extends advanced_testcase {
+    public function test_create_question_checkbox() {
+        $this->create_test_question_with_choices(QUESCHECK,
+            '\\mod_questionnaire\\question\\check', array('content' => 'Check one'));
+    }
+
+    public function test_create_question_date() {
+        $this->create_test_question(QUESDATE, '\\mod_questionnaire\\question\\date', array('content' => 'Enter a date'));
+    }
+
+    public function test_create_question_dropdown() {
+        $this->create_test_question_with_choices(QUESDROP, '\\mod_questionnaire\\question\\drop', array('content' => 'Select one'));
+    }
+
+    public function test_create_question_essay() {
+        $questiondata = array(
+            'content' => 'Enter an essay',
+            'length' => 0,
+            'precise' => 5);
+        $this->create_test_question(QUESESSAY, '\\mod_questionnaire\\question\\essay', $questiondata);
+    }
+
+    public function test_create_question_sectiontext() {
+        $this->create_test_question(QUESSECTIONTEXT, '\\mod_questionnaire\\question\\sectiontext',
+            array('name' => null, 'content' => 'This a section label.'));
+    }
+
+    public function test_create_question_numeric() {
+        $questiondata = array(
+            'content' => 'Enter a number',
+            'length' => 10,
+            'precise' => 0);
+        $this->create_test_question(QUESNUMERIC, '\\mod_questionnaire\\question\\numerical', $questiondata);
+    }
+
+    public function test_create_question_radiobuttons() {
+        $this->create_test_question_with_choices(QUESRADIO,
+            '\\mod_questionnaire\\question\\radio', array('content' => 'Choose one'));
+    }
+
+    public function test_create_question_ratescale() {
+        $this->create_test_question_with_choices(QUESRATE, '\\mod_questionnaire\\question\\rate', array('content' => 'Rate these'));
+    }
+
+    public function test_create_question_textbox() {
+        $questiondata = array(
+            'content' => 'Enter some text',
+            'length' => 20,
+            'precise' => 25);
+        $this->create_test_question(QUESTEXT, '\\mod_questionnaire\\question\\text', $questiondata);
+    }
+
+    public function test_create_question_yesno() {
+        $this->create_test_question(QUESYESNO, '\\mod_questionnaire\\question\\yesno', array('content' => 'Enter yes or no'));
+    }
+
+
+    // General tests to call from specific tests above.
+
+    private function create_test_question($qtype, $questionclass, $questiondata = array(), $choicedata = null) {
+        global $DB;
+
+        $this->resetAfterTest();
+
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questionnaire = $generator->create_instance(array('course' => $course->id));
+        $cm = get_coursemodule_from_instance('questionnaire', $questionnaire->id);
+
+        $questiondata['type_id'] = $qtype;
+        $questiondata['survey_id'] = $questionnaire->sid;
+        $questiondata['name'] = isset($questiondata['name']) ? $questiondata['name'] : 'Q1';
+        $questiondata['content'] = isset($questiondata['content']) ? $questiondata['content'] : 'Test content';
+        $question = $generator->create_question($questionnaire, $questiondata, $choicedata);
+        $this->assertInstanceOf($questionclass, $question);
+        $this->assertTrue($question->id > 0);
+
+        // Question object retrieved from the database should have correct data.
+        $this->assertEquals($question->type_id, $qtype);
+        foreach ($questiondata as $property => $value) {
+            $this->assertEquals($question->$property, $value);
+        }
+        if ($question->has_choices()) {
+            $this->assertEquals('array', gettype($question->choices));
+            $this->assertEquals(count($choicedata), count($question->choices));
+            $choicedatum = reset($choicedata);
+            foreach ($question->choices as $cid => $choice) {
+                $this->assertTrue($DB->record_exists('questionnaire_quest_choice', array('id' => $cid)));
+                $this->assertEquals($choice->content, $choicedatum->content);
+                $this->assertEquals($choice->value, $choicedatum->value);
+                $choicedatum = next($choicedata);
+            }
+        }
+
+        // Questionnaire object should now have question record(s).
+        $questionnaire = new questionnaire($questionnaire->id, null, $course, $cm, true);
+        $this->assertTrue($DB->record_exists('questionnaire_question', array('id' => $question->id)));
+        $this->assertEquals('array', gettype($questionnaire->questions));
+        $this->assertTrue(array_key_exists($question->id, $questionnaire->questions));
+        $this->assertEquals(1, count($questionnaire->questions));
+        if ($questionnaire->questions[$question->id]->has_choices()) {
+            $this->assertEquals(count($choicedata), count($questionnaire->questions[$question->id]->choices));
+        }
+    }
+
+    private function create_test_question_with_choices($qtype, $questionclass, $questiondata = array(), $choicedata = null) {
+        if ($choicedata === null) {
+            $choicedata = array(
+                (object)array('content' => 'One', 'value' => 1),
+                (object)array('content' => 'Two', 'value' => 2),
+                (object)array('content' => 'Three', 'value' => 3));
+        }
+        $this->create_test_question($qtype, $questionclass, $questiondata, $choicedata);
+    }
+}
diff --git a/mod/questionnaire/tests/responsetypes_test.php b/mod/questionnaire/tests/responsetypes_test.php
new file mode 100644
index 0000000..e40550d
--- /dev/null
+++ b/mod/questionnaire/tests/responsetypes_test.php
@@ -0,0 +1,320 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * PHPUnit questionnaire generator tests
+ *
+ * @package    mod_questionnaire
+ * @copyright  2015 Mike Churchward (mike@churchward.ca)
+ * @author     Mike Churchward
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+use mod_questionnaire\question\base;
+
+global $CFG;
+require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+require_once($CFG->dirroot . '/mod/questionnaire/tests/generator_test.php');
+require_once($CFG->dirroot . '/mod/questionnaire/tests/questiontypes_test.php');
+
+/**
+ * Unit tests for {@link questionnaire_responsetypes_testcase}.
+ * @group mod_questionnaire
+ */
+class mod_questionnaire_responsetypes_testcase extends advanced_testcase {
+    public function test_create_response_boolean() {
+        global $DB;
+
+        $this->resetAfterTest();
+
+        // Some common variables used below.
+        $userid = 1;
+
+        // Set up a questinnaire with one boolean response question.
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questionnaire = $generator->create_test_questionnaire($course, QUESYESNO, array('content' => 'Enter yes or no'));
+        $question = reset($questionnaire->questions);
+        $response = $generator->create_question_response($questionnaire, $question, 'y', $userid);
+
+        // Test the responses for this questionnaire.
+        $this->response_tests($questionnaire->id, $question->survey_id, $response->id, $userid);
+
+        // Retrieve the specific boolean response.
+        $booleanresponses = $DB->get_records('questionnaire_response_bool', array('response_id' => $response->id));
+        $this->assertEquals(1, count($booleanresponses));
+        $booleanresponse = reset($booleanresponses);
+        $this->assertEquals($question->id, $booleanresponse->question_id);
+        $this->assertEquals('y', $booleanresponse->choice_id);
+    }
+
+    public function test_create_response_text() {
+        global $DB;
+
+        $this->resetAfterTest();
+
+        // Some common variables used below.
+        $userid = 1;
+
+        // Set up a questionnaire with one text response question.
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questiondata = array(
+            'content' => 'Enter some text',
+            'length' => 0,
+            'precise' => 5);
+        $questionnaire = $generator->create_test_questionnaire($course, QUESESSAY, $questiondata);
+        $question = reset($questionnaire->questions);
+        $response = $generator->create_question_response($questionnaire, $question, 'This is my essay.', $userid);
+
+        // Test the responses for this questionnaire.
+        $this->response_tests($questionnaire->id, $question->survey_id, $response->id, $userid);
+
+        // Retrieve the specific text response.
+        $textresponses = $DB->get_records('questionnaire_response_text', array('response_id' => $response->id));
+        $this->assertEquals(1, count($textresponses));
+        $textresponse = reset($textresponses);
+        $this->assertEquals($question->id, $textresponse->question_id);
+        $this->assertEquals('This is my essay.', $textresponse->response);
+    }
+
+    public function test_create_response_date() {
+        global $DB;
+
+        $this->resetAfterTest();
+
+        // Some common variables used below.
+        $userid = 1;
+
+        // Set up a questionnaire with one text response question.
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questionnaire = $generator->create_test_questionnaire($course, QUESDATE, array('content' => 'Enter a date'));
+        $question = reset($questionnaire->questions);
+        // Date format is configured per site. This won't work unless it matches the configured format.
+        $response = $generator->create_question_response($questionnaire, $question, '27/1/2015', $userid);
+
+        // Test the responses for this questionnaire.
+        $this->response_tests($questionnaire->id, $question->survey_id, $response->id, $userid);
+
+        // Retrieve the specific date response.
+        $dateresponses = $DB->get_records('questionnaire_response_date', array('response_id' => $response->id));
+        $this->assertEquals(1, count($dateresponses));
+        $dateresponse = reset($dateresponses);
+        $this->assertEquals($question->id, $dateresponse->question_id);
+        // The date is always stored in the database in the same way.
+        $this->assertEquals('2015-01-27', $dateresponse->response);
+    }
+
+    public function test_create_response_single() {
+        global $DB;
+
+        $this->resetAfterTest();
+
+        // Some common variables used below.
+        $userid = 1;
+
+        // Set up a questinnaire with one question with choices including an "other" option.
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $choicedata = array(
+            (object)array('content' => 'One', 'value' => 1),
+            (object)array('content' => 'Two', 'value' => 2),
+            (object)array('content' => 'Three', 'value' => 3),
+            (object)array('content' => '!other=Something else', 'value' => 4));
+        $questionnaire = $generator->create_test_questionnaire($course, QUESRADIO, array('content' => 'Select one'), $choicedata);
+
+        // Create a response using one of the choices.
+        $question = reset($questionnaire->questions);
+        $val = 'unknown';
+        foreach ($question->choices as $cid => $choice) {
+            if ($choice->content == 'Two') {
+                $val = $cid;
+            }
+        }
+        $response = $generator->create_question_response($questionnaire, $question, $val, $userid);
+
+        // Test the responses for this questionnaire.
+        $this->response_tests($questionnaire->id, $question->survey_id, $response->id, $userid);
+
+        // Retrieve the specific single response.
+        $singresponses = $DB->get_records('questionnaire_resp_single', array('response_id' => $response->id));
+        $this->assertEquals(1, count($singresponses));
+        $singresponse = reset($singresponses);
+        $this->assertEquals($question->id, $singresponse->question_id);
+        $this->assertEquals($val, $singresponse->choice_id);
+
+        // Create another response using the '!other' choice.
+        foreach ($question->choices as $cid => $choice) {
+            if ($choice->content == '!other=Something else') {
+                $val = $cid;
+            }
+        }
+        // Need an extra $_POST variable for an "other" response.
+        $_POST['q'.$question->id.'_'.$val] = 'Forty-four';
+        $userid = 2;
+        $response = $generator->create_question_response($questionnaire, $question, $val, $userid);
+
+        // Test the responses for this questionnaire.
+        $this->response_tests($questionnaire->id, $question->survey_id, $response->id, $userid, 1, 2);
+
+        // Retrieve the specific single response.
+        $singresponses = $DB->get_records('questionnaire_resp_single', array('response_id' => $response->id));
+        $this->assertEquals(1, count($singresponses));
+        $singresponse = reset($singresponses);
+        $this->assertEquals($question->id, $singresponse->question_id);
+        $this->assertEquals($val, $singresponse->choice_id);
+
+        // Retrieve the 'other' response data.
+        $otherresponses = $DB->get_records('questionnaire_response_other',
+            array('response_id' => $response->id, 'question_id' => $question->id));
+        $this->assertEquals(1, count($otherresponses));
+        $otherresponse = reset($otherresponses);
+        $this->assertEquals($val, $otherresponse->choice_id);
+        $this->assertEquals('Forty-four', $otherresponse->response);
+    }
+
+    public function test_create_response_multiple() {
+        global $DB;
+
+        $this->resetAfterTest();
+
+        // Some common variables used below.
+        $userid = 1;
+
+        // Set up a questionnaire with one question with choices including an "other" option.
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $choicedata = array(
+            (object)array('content' => 'One', 'value' => 1),
+            (object)array('content' => 'Two', 'value' => 2),
+            (object)array('content' => 'Three', 'value' => 3),
+            (object)array('content' => '!other=Another number', 'value' => 4));
+        $questionnaire = $generator->create_test_questionnaire($course, QUESCHECK, array('content' => 'Select any'), $choicedata);
+
+        $question = reset($questionnaire->questions);
+        $val = array();
+        foreach ($question->choices as $cid => $choice) {
+            if (($choice->content == 'Two') || ($choice->content == 'Three')) {
+                $val[] = $cid;
+            } else if ($choice->content == '!other=Another number') {
+                $val2 = $cid;
+            }
+        }
+        $_POST['q'.$question->id.'_'.$val2] = 'Forty-four';
+        $response = $generator->create_question_response($questionnaire, $question, $val, $userid);
+
+        // Test the responses for this questionnaire.
+        $this->response_tests($questionnaire->id, $question->survey_id, $response->id, $userid);
+
+        // Retrieve the specific multiples responses.
+        $multresponses = $DB->get_records('questionnaire_resp_multiple', array('response_id' => $response->id));
+        $this->assertEquals(3, count($multresponses));
+        $multresponse = reset($multresponses);
+        $this->assertEquals($question->id, $multresponse->question_id);
+        $this->assertEquals(reset($val), $multresponse->choice_id);
+        $multresponse = next($multresponses);
+        $this->assertEquals($question->id, $multresponse->question_id);
+        $this->assertEquals(next($val), $multresponse->choice_id);
+
+        // Retrieve the specific other response.
+        $otherresponses = $DB->get_records('questionnaire_response_other',
+            array('response_id' => $response->id, 'question_id' => $question->id));
+        $this->assertEquals(1, count($otherresponses));
+        $otherresponse = reset($otherresponses);
+        $this->assertEquals($val2, $otherresponse->choice_id);
+        $this->assertEquals('Forty-four', $otherresponse->response);
+    }
+
+    public function test_create_response_rank() {
+        global $DB;
+
+        $this->resetAfterTest();
+
+        // Some common variables used below.
+        $userid = 1;
+
+        // Set up a questionnaire with one ranking question.
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $choicedata = array(
+            (object)array('content' => 'One', 'value' => 1),
+            (object)array('content' => 'Two', 'value' => 2),
+            (object)array('content' => 'Three', 'value' => 3));
+        $questiondata = array(
+            'content' => 'Rank these',
+            'length' => 5,
+            'precise' => 0);
+        $questionnaire = $generator->create_test_questionnaire($course, QUESRATE, $questiondata, $choicedata);
+
+        // Create a response for each choice.
+        $question = reset($questionnaire->questions);
+        $vals = array();
+        $i = 1;
+        foreach ($question->choices as $cid => $choice) {
+            $vals[$cid] = $i;
+            $_POST['q'.$question->id.'_'.$cid] = $i++;
+        }
+        $response = $generator->create_question_response($questionnaire, $question, null, $userid);
+
+        // Test the responses for this questionnaire.
+        $this->response_tests($questionnaire->id, $question->survey_id, $response->id, $userid);
+
+        // Retrieve the specific rank response.
+        $multresponses = $DB->get_records('questionnaire_response_rank', array('response_id' => $response->id));
+        $this->assertEquals(3, count($multresponses));
+        foreach ($multresponses as $multresponse) {
+            $this->assertEquals($question->id, $multresponse->question_id);
+            $this->assertEquals($vals[$multresponse->choice_id], $multresponse->rank);
+        }
+    }
+
+    // General tests to call from specific tests above.
+
+    public function create_test_questionnaire($qtype, $questiondata = array(), $choicedata = null) {
+        $this->resetAfterTest();
+
+        $course = $this->getDataGenerator()->create_course();
+        $generator = $this->getDataGenerator()->get_plugin_generator('mod_questionnaire');
+        $questionnaire = $generator->create_instance(array('course' => $course->id));
+        $cm = get_coursemodule_from_instance('questionnaire', $questionnaire->id);
+
+        $questiondata['type_id'] = $qtype;
+        $questiondata['survey_id'] = $questionnaire->sid;
+        $questiondata['name'] = isset($questiondata['name']) ? $questiondata['name'] : 'Q1';
+        $questiondata['content'] = isset($questiondata['content']) ? $questiondata['content'] : 'Test content';
+        $generator->create_question($questionnaire, $questiondata, $choicedata);
+
+        $questionnaire = new questionnaire($questionnaire->id, null, $course, $cm, true);
+
+        return $questionnaire;
+    }
+
+    private function response_tests($questionnaireid, $surveyid, $responseid, $userid,
+                                    $attemptcount = 1, $responsecount = 1) {
+        global $DB;
+
+        $attempts = $DB->get_records('questionnaire_attempts',
+                    array('qid' => $questionnaireid, 'userid' => $userid, 'rid' => $responseid));
+        $this->assertEquals($attemptcount, count($attempts));
+        $responses = $DB->get_records('questionnaire_response', array('survey_id' => $surveyid));
+        $this->assertEquals($responsecount, count($responses));
+        $this->assertArrayHasKey($responseid, $responses);
+        $this->assertEquals($responseid, $responses[$responseid]->id);
+    }
+}
diff --git a/mod/questionnaire/thirdpartylibs.xml b/mod/questionnaire/thirdpartylibs.xml
new file mode 100644
index 0000000..a8ee189
--- /dev/null
+++ b/mod/questionnaire/thirdpartylibs.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0"?>
+<libraries>
+    <library>
+        <location>javascript/RGraph</location>
+        <name>RGraph</name>
+        <version>?</version>
+        <license>MIT</license>
+        <licenseversion>?</licenseversion>
+    </library>
+</libraries>
\ No newline at end of file
diff --git a/mod/questionnaire/version.php b/mod/questionnaire/version.php
new file mode 100644
index 0000000..e951977
--- /dev/null
+++ b/mod/questionnaire/version.php
@@ -0,0 +1,34 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * Questionnaire version information.
+ *
+ * @package mod_questionnaire
+ * @author  Mike Churchward
+ * @author  Joseph Rézeau
+ * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+$plugin->version  = 2017050101;  // The current module version (Date: YYYYMMDDXX)
+$plugin->requires = 2017042800; // Moodle version.
+
+$plugin->component = 'mod_questionnaire';
+
+$plugin->release  = '3.3.1 (Build - 2017051800)';
+$plugin->maturity  = MATURITY_STABLE;
\ No newline at end of file
diff --git a/mod/questionnaire/view.php b/mod/questionnaire/view.php
new file mode 100644
index 0000000..928e119
--- /dev/null
+++ b/mod/questionnaire/view.php
@@ -0,0 +1,178 @@
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+require_once("../../config.php");
+require_once($CFG->dirroot.'/mod/questionnaire/locallib.php');
+require_once($CFG->libdir . '/completionlib.php');
+require_once($CFG->dirroot.'/mod/questionnaire/questionnaire.class.php');
+
+if (!isset($SESSION->questionnaire)) {
+    $SESSION->questionnaire = new stdClass();
+}
+$SESSION->questionnaire->current_tab = 'view';
+
+$id = optional_param('id', null, PARAM_INT);    // Course Module ID.
+$a = optional_param('a', null, PARAM_INT);      // Or questionnaire ID.
+
+$sid = optional_param('sid', null, PARAM_INT);  // Survey id.
+
+list($cm, $course, $questionnaire) = questionnaire_get_standard_page_items($id, $a);
+
+// Check login and get context.
+require_course_login($course, true, $cm);
+$context = context_module::instance($cm->id);
+
+$url = new moodle_url($CFG->wwwroot.'/mod/questionnaire/view.php');
+if (isset($id)) {
+    $url->param('id', $id);
+} else {
+    $url->param('a', $a);
+}
+if (isset($sid)) {
+    $url->param('sid', $sid);
+}
+
+$PAGE->set_url($url);
+$PAGE->set_context($context);
+$questionnaire = new questionnaire(0, $questionnaire, $course, $cm);
+// Add renderer and page objects to the questionnaire object for display use.
+$questionnaire->add_renderer($PAGE->get_renderer('mod_questionnaire'));
+$questionnaire->add_page(new \mod_questionnaire\output\viewpage());
+
+$PAGE->set_title(format_string($questionnaire->name));
+$PAGE->set_heading(format_string($course->fullname));
+
+echo $questionnaire->renderer->header();
+$questionnaire->page->add_to_page('questionnairename', clean_text($questionnaire->name));
+
+// Print the main part of the page.
+if ($questionnaire->intro) {
+    $questionnaire->page->add_to_page('intro', format_module_intro('questionnaire', $questionnaire, $cm->id));
+}
+
+$cm = $questionnaire->cm;
+$currentgroupid = groups_get_activity_group($cm);
+if (!groups_is_member($currentgroupid, $USER->id)) {
+    $currentgroupid = 0;
+}
+
+if (!$questionnaire->is_active()) {
+    if ($questionnaire->capabilities->manage) {
+        $msg = 'removenotinuse';
+    } else {
+        $msg = 'notavail';
+    }
+    $questionnaire->page->add_to_page('message', get_string($msg, 'questionnaire'));
+
+} else if ($questionnaire->survey->realm == 'template') {
+    // If this is a template survey, notify and exit.
+    $questionnaire->page->add_to_page('message', get_string('templatenotviewable', 'questionnaire'));
+    echo $questionnaire->renderer->render($questionnaire->page);
+    echo $questionnaire->renderer->footer($questionnaire->course);
+    exit();
+
+} else if (!$questionnaire->is_open()) {
+    $questionnaire->page->add_to_page('message', get_string('notopen', 'questionnaire', userdate($questionnaire->opendate)));
+
+} else if ($questionnaire->is_closed()) {
+    $questionnaire->page->add_to_page('message', get_string('closed', 'questionnaire', userdate($questionnaire->closedate)));
+
+} else if (!$questionnaire->user_is_eligible($USER->id)) {
+    if ($questionnaire->questions) {
+        $questionnaire->page->add_to_page('message', get_string('noteligible', 'questionnaire'));
+    }
+
+} else if (!$questionnaire->user_can_take($USER->id)) {
+    switch ($questionnaire->qtype) {
+        case QUESTIONNAIREDAILY:
+            $msgstring = ' '.get_string('today', 'questionnaire');
+            break;
+        case QUESTIONNAIREWEEKLY:
+            $msgstring = ' '.get_string('thisweek', 'questionnaire');
+            break;
+        case QUESTIONNAIREMONTHLY:
+            $msgstring = ' '.get_string('thismonth', 'questionnaire');
+            break;
+        default:
+            $msgstring = '';
+            break;
+    }
+    $questionnaire->page->add_to_page('message', get_string("alreadyfilled", "questionnaire", $msgstring));
+
+} else if ($questionnaire->user_can_take($USER->id)) {
+    if ($questionnaire->questions) { // Sanity check.
+        if (!$questionnaire->user_has_saved_response($USER->id)) {
+            $questionnaire->page->add_to_page('complete',
+                '<a href="'.$CFG->wwwroot.htmlspecialchars('/mod/questionnaire/complete.php?' .
+                'id='.$questionnaire->cm->id).'">'.get_string('answerquestions', 'questionnaire').'</a>');
+        } else {
+            $questionnaire->page->add_to_page('complete',
+                '<a href="'.$CFG->wwwroot.htmlspecialchars('/mod/questionnaire/complete.php?' .
+                'id='.$questionnaire->cm->id.'&resume=1').'">'.get_string('resumesurvey', 'questionnaire').'</a>');
+        }
+    } else {
+        $questionnaire->page->add_to_page('message', get_string('noneinuse', 'questionnaire'));
+    }
+}
+
+if ($questionnaire->capabilities->editquestions && !$questionnaire->questions && $questionnaire->is_active()) {
+    $questionnaire->page->add_to_page('complete',
+        '<a href="'.$CFG->wwwroot.htmlspecialchars('/mod/questionnaire/questions.php?'.
+        'id='.$questionnaire->cm->id).'">'.'<strong>'.get_string('addquestions', 'questionnaire').'</strong></a>');
+}
+
+if (isguestuser()) {
+    $guestno = html_writer::tag('p', get_string('noteligible', 'questionnaire'));
+    $liketologin = html_writer::tag('p', get_string('liketologin'));
+    $questionnaire->page->add_to_page('guestuser',
+        $questionnaire->renderer->confirm($guestno."\n\n".$liketologin."\n", get_login_url(), get_local_referer(false)));
+}
+
+// Log this course module view.
+// Needed for the event logging.
+$context = context_module::instance($questionnaire->cm->id);
+$anonymous = $questionnaire->respondenttype == 'anonymous';
+
+$event = \mod_questionnaire\event\course_module_viewed::create(array(
+                'objectid' => $questionnaire->id,
+                'anonymous' => $anonymous,
+                'context' => $context
+));
+$event->trigger();
+
+$usernumresp = $questionnaire->count_submissions($USER->id);
+
+if ($questionnaire->capabilities->readownresponses && ($usernumresp > 0)) {
+    $argstr = 'instance='.$questionnaire->id.'&user='.$USER->id;
+    if ($usernumresp > 1) {
+        $titletext = get_string('viewyourresponses', 'questionnaire', $usernumresp);
+    } else {
+        $titletext = get_string('yourresponse', 'questionnaire');
+        $argstr .= '&byresponse=1&action=vresp';
+    }
+    $questionnaire->page->add_to_page('yourresponse',
+        '<a href="'.$CFG->wwwroot.htmlspecialchars('/mod/questionnaire/myreport.php?'.$argstr).'">'.$titletext.'</a>');
+}
+
+if ($questionnaire->can_view_all_responses($usernumresp)) {
+    $argstr = 'instance='.$questionnaire->id.'&group='.$currentgroupid;
+    $questionnaire->page->add_to_page('allresponses',
+        '<a href="'.$CFG->wwwroot.htmlspecialchars('/mod/questionnaire/report.php?'.$argstr).'">'.
+        get_string('viewallresponses', 'questionnaire').'</a>');
+}
+
+echo $questionnaire->renderer->render($questionnaire->page);
+echo $questionnaire->renderer->footer();
-- 
1.8.3.1

